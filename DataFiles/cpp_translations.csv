cppex,patch_cpp,y
"#include <vector>
#include <algorithm>
#include <iterator>
#include <string>
#include <stdexcept>

class ComponentIdentifier {
public:
    static ComponentIdentifier builder() {
        return ComponentIdentifier();
    }
};

class MuleRuntimeException : public std::runtime_error {
public:
    explicit MuleRuntimeException(const std::string& msg)
        : std::runtime_error(msg) {}
};

class I18nMessageFactory {
};","#include <optional>
#include <vector>
#include <iterator>
#include <algorithm>
#include <stdexcept>
#include <string>",0
"&parserStateCacheSize, dwFlags);
END_TEMP_ALLOCATOR(tempAllocator, this);

if (FAILED(hr))
{
    OUTPUT_TRACE_DEBUGONLY(Js::DataCachePhase, _u("" Failed to serialize parser state cache (hr = 0x%08lx) for '%s'\n""), hr, url);
    return hr;
}

OUTPUT_TRACE_DEBUGONLY(Js::DataCachePhase, _u("" Successfully serialized parser state cache for '%s'\n""), url);
OUTPUT_TRACE_DEBUGONLY(Js::DataCachePhase, _u("" Trying to write parser state cache (%lu bytes) to stream for '%s'\n""), parserStateCacheSize, url);

hr = pDataCache->StartBlock(Js::SimpleDataCacheWrapper::BlockType_ParserState, parserStateCacheSize);

if (FAILED(hr))
{
    OUTPUT_TRACE_DEBUGONLY(Js::DataCachePhase, _u("" Failed to write a block to the parser state cache data stream (hr = 0x%08lx) for '%s'\n""), hr, url);
    return hr;
}

hr = pDataCache->WriteArray(parserStateCacheBuffer, parserStateCacheSize);

if (FAILED(hr))
{
    OUTPUT_TRACE_DEBUGONLY(Js::DataCachePhase, _u("" Failed to write parser state cache (hr = 0x%08lx) for '%s'\n""), hr, url);
    return hr;
}

OUTPUT_TRACE_DEBUGONLY(Js::DataCachePhase, _u("" Successfully wrote parser state cache for '%s'\n""), url);
#endif

return hr;","#if 0

    hr = SerializeParserStateCache(
        tempAllocator,
        &parserStateCacheBuffer,
        &parserStateCacheSize,
        dwFlags);
    END_TEMP_ALLOCATOR(tempAllocator, this);

    if (FAILED(hr))
    {
        OUTPUT_TRACE_DEBUGONLY(Js::DataCachePhase, _u("" Failed to serialize parser state cache (hr = 0x%08lx) for '%s'\n""), hr, url);
        return hr;
    }

    OUTPUT_TRACE_DEBUGONLY(Js::DataCachePhase, _u("" Successfully serialized parser state cache for '%s'\n""), url);
    OUTPUT_TRACE_DEBUGONLY(Js::DataCachePhase, _u("" Trying to write parser state cache (%lu bytes) to stream for '%s'\n""), parserStateCacheSize, url);

    hr = pDataCache->StartBlock(Js::SimpleDataCacheWrapper::BlockType_ParserState, parserStateCacheSize);

    if (FAILED(hr))
    {
        OUTPUT_TRACE_DEBUGONLY(Js::DataCachePhase, _u("" Failed to write a block to the parser state cache data stream (hr = 0x%08lx) for '%s'\n""), hr, url);
        return hr;
    }

    hr = pDataCache->WriteArray(parserStateCacheBuffer, parserStateCacheSize);

    if (FAILED(hr))
    {
        OUTPUT_TRACE_DEBUGONLY(Js::DataCachePhase, _u("" Failed to write parser state cache (hr = 0x%08lx) for '%s'\n""), hr, url);
        return hr;
    }

    OUTPUT_TRACE_DEBUGONLY(Js::DataCachePhase, _u("" Successfully wrote parser state cache for '%s'\n""), url);

    return hr;

#endif",1
"log_file = fs::path(packages_dir).parent_path() / log_file;
fs.install(phase_log, log_file);

// Archive the environment modifications for the build.
fs.install(pkg.env_mods_path, pkg.install_env_path);

if (fs::exists(pkg.configure_args_path)) {
    // Archive the args used for the build
}","fs.install(pkg.env_mods_path, pkg.install_env_path);

if (std::filesystem::exists(pkg.configure_args_path)) {
    // Archive the args used for the build
}",1
"```cpp
#include <string>
#include <vector>
#include <map>
#include <stdexcept>

class SchemaConversionException : public std::exception {
public:
    SchemaConversionException(const std::string& message) : msg(message) {}
    const char* what() const noexcept override { return msg.c_str(); }
private:
    std::string msg;
};

class WorkUnitState { /* ... */ };
class JsonArray; // Assume suitable implementation
class JsonElement;
class JsonObject;

class Schema {
public:
    class Field {
    public:
        // suitable constructors and members
    };
    // suitable constructors and members
};

class JsonElementConverter {
public:
    virtual Schema getSchema() = 0;
    virtual ~JsonElementConverter() = default;
};

class UnionConverter : public JsonElementConverter {
public:
    UnionConverter(const std::string&, const std::string&, const JsonObject&, WorkUnitState*) {}
    Schema getSchema() override { /* ... */ return Schema(); }
};

namespace JsonElementConversionFactory {
    JsonElementConverter* getConvertor(const std::string&, const std::string&, const std::string&, const JsonObject&, WorkUnitState*, bool) {
        // create and return appropriate converter
        return nullptr;
    }
}

std::string getPropOrBlankString(const JsonObject& map, const std::string& key);
bool getBooleanIfExists(const JsonObject& map, const std::string& key);
JsonArray getDataTypeTypeFromSchema(const JsonObject& map);
bool isUnionType(const JsonObject& map);
JsonElement getFirstType(const JsonArray& array);
std::string buildNamespace(const std::string& ns, const std::string& name);

class MyClass {
private:
    long numFailedConversion = 0;
    std::map<std::string, JsonElementConverter*> converters;

public:
    Schema convertSchema(const JsonArray& schema, WorkUnitState* workUnit) {
        std::vector<Schema::Field> fields;

        for (const auto& elem : schema) {
            JsonObject map = static_cast<const JsonObject&>(elem);

            std::string columnName = getPropOrBlankString(map, ""columnName"");
            std::string comment = getPropOrBlankString(map, ""comment"");
            std::string tempName = getPropOrBlankString(map, ""name"");
            std::string name = tempName.empty() ? """" : tempName;
            bool nullable = getBooleanIfExists","```cpp
class JsonIntermediateToAvroConverter : public ToAvroConverterBase<JsonArray> {
private:
    long numFailedConversion = 0;

public:
    Schema convertSchema(const JsonArray& schema, WorkUnitState& workUnit) override {
        std::vector<Schema::Field> fields;

        for (const auto& elem : schema) {
            const JsonObject& map = static_cast<const JsonObject&>(elem);

            std::string columnName = getPropOrBlankString(map, ""columnName"");
            std::string comment = getPropOrBlankString(map, ""comment"");
            std::string tempName = getPropOrBlankString(map, ""name"");
            std::optional<std::string> name = tempName.empty() ? std::nullopt : std::make_optional(tempName);
            bool nullable = getBooleanIfExists(map, ""isNullable"");
            Schema fldSchema;

            JsonArray dataTypeType = getDataTypeTypeFromSchema(map);
            std::shared_ptr<JsonElementConverter> converter;
            std::string sourceType;

            try {
                if (isUnionType(map)) {
                    converter = std::make_shared<UnionConverter>(columnName, ""UNION"", map, workUnit);
                    sourceType = ""union"";
                } else {
                    sourceType = getFirstType(dataTypeType).getAsString();
                    converter = JsonElementConversionFactory::getConvertor(
                        columnName,
                        buildNamespace(workUnit.getExtract().getNamespace(), name),
                        sourceType,
                        map,
                        workUnit,
                        nullable
                    );
                }
                this->converters[columnName] = converter;
                fldSchema = converter->getSchema();
            } catch (const UnsupportedDateTypeException& e) {
                // error handling logic here
            }

            // (rest of loop implementation as needed)
        }

        // (function's return logic as needed)
    }
};
```",1
"return UserList::create(resultUsers);
}

UserPageListResponse getPage(
    int page = 1,
    int perPage = 50,
    const std::string& query = """",
    const std::string& sort = StreamImpl::FIELD_TITLE,
    const std::string& order = ""asc"")
{
    SearchQuery searchQuery;
    auto sessions = sessionService.loadAll();
    auto lastSessionForUser = getLastSessionForUser(sessions);

    try {
        searchQuery = searchQueryParser.parse(query);
    } catch (const std::invalid_argument& e) {
        throw BadRequestException(std::string(""Invalid argument in search query: "") + e.what());
    }

    auto result = paginatedUserService.findPaginated(searchQuery, page, perPage, sort, order);

    std::set<std::string> allRoleIds;
    for (const auto& userDTO : result) {
        const auto& rolesOpt = userDTO.roles();
        if (rolesOpt) {
            allRoleIds.insert(rolesOpt->begin(), rolesOpt->end());
        }
    }

    std::map<std::string, std::string> roleNameMap;
    try {
        roleNameMap = getRoleNameMap(allRoleIds);
    } catch (const NotFoundException& e) {
        throw NotFoundException(std::string(""Couldn't find roles: "") + e.what());
    }

    auto adminUser = getAdminUserDTO(lastSessionForUser, roleNameMap);

    std::vector<UserDTO> users;
    users.reserve(result.size());
    for (const auto& userDTO : result) {
        UserDTO::Builder builder = userDTO.toBuilder()
            .fillSession(lastSessionForUser.count(userDTO.username()) 
                         ? lastSessionForUser.at(userDTO.username())
                         : std::nullopt);
        const auto& rolesOpt = userDTO.roles();
        if (rolesOpt) {
            std::set<std::string> mappedRoles;
            for (const auto& roleId : *rolesOpt) {
                auto it = roleNameMap.find(roleId);
                if (it != roleNameMap.end()) {
                    mappedRoles.insert(it->second);
                }
            }
            builder.roles(mappedRoles);
        }
        users.push_back(builder.build());
    }

    PaginatedList<UserDTO> userDTOS(users, result.pagination().total(),
                                    result.pagination().page(), result.pagination().perPage());

    return UserPageListResponse::","```cpp
#include <string>
#include <vector>
#include <set>
#include <map>
#include <optional>
#include <algorithm>

UserPageListResponse getPage(int page = 1,
                             int perPage = 50,
                             const std::string& query = """",
                             const std::string& sort = StreamImpl::FIELD_TITLE,
                             const std::string& order = ""asc"") {
    SearchQuery searchQuery;
    const auto sessions = sessionService.loadAll();
    const auto lastSessionForUser = getLastSessionForUser(sessions);

    try {
        searchQuery = searchQueryParser.parse(query);
    } catch (const std::invalid_argument& e) {
        throw BadRequestException(std::string(""Invalid argument in search query: "") + e.what());
    }

    PaginatedList<UserDTO> result = paginatedUserService.findPaginated(searchQuery, page, perPage, sort, order);

    std::set<std::string> allRoleIds;
    for (const auto& userDTO : result) {
        if (userDTO.roles().has_value()) {
            allRoleIds.insert(userDTO.roles()->begin(), userDTO.roles()->end());
        }
    }

    std::map<std::string, std::string> roleNameMap;
    try {
        roleNameMap = getRoleNameMap(allRoleIds);
    } catch (const org::graylog2::database::NotFoundException& e) {
        throw NotFoundException(std::string(""Couldn't find roles: "") + e.what());
    }

    UserDTO adminUser = getAdminUserDTO(lastSessionForUser, roleNameMap);

    std::vector<UserDTO> users;
    users.reserve(result.size());
    for (const auto& userDTO : result) {
        auto builder = userDTO.toBuilder()
            .fillSession(lastSessionForUser.count(userDTO.username()) ? lastSessionForUser.at(userDTO.username()) : std::optional<MongoDbSession>{});
        if (userDTO.roles().has_value()) {
            std::set<std::string> roleNames;
            for (const auto& roleId : userDTO.roles().value()) {
                auto it = roleNameMap.find(roleId);
                if (it != roleNameMap.end()) {
                    roleNames.insert(it->second);
                }
            }
            builder.roles(roleNames);
        }
        users.push_back(builder.build());
    }

    PaginatedList<UserDTO> userDTOS(users, result.pagination().total(),",1
"```cpp
void appendText(const std::string& text, const std::string& clazz, bool forceNewRange)
{
    auto last = class_.rbegin();
    if (last != class_.rend()) {
        ClassRange* range = last->second.get();
        if (!forceNewRange && StringUtil::equals(range->clazz, clazz))
        {
            range->appendRight(text, 0);
        }
        else
        {
            auto newRange = std::make_shared<ClassRange>(cursor_, clazz, text);
            appendChild(newRange->element);
            class_[cursor_] = newRange;
        }
    } else {
        auto newRange = std::make_shared<ClassRange>(cursor_, clazz, text);
        appendChild(newRange->element);
        class_[cursor_] = newRange;
    }
}

void insertText(std::shared_ptr<ClassRange> range)
{
    int start = range->start;
    int end = start + range->length;

    auto left = class_.empty() ? class_.end() : std::prev(class_.upper_bound(start));
    auto right = class_.empty() ? class_.end() : std::prev(class_.upper_bound(end));
}
```","```cpp
#include <map>
#include <string>

class VirtualConsole {
private:
    struct ClassRange {
        int start;
        int length;
        std::string clazz;
        std::string text;
        void* element;
        ClassRange(int start_, const std::string& clazz_, const std::string& text_)
            : start(start_), length(static_cast<int>(text_.size())), clazz(clazz_), text(text_), element(nullptr) {}
        void appendRight(const std::string& t, int) {
            text += t;
            length += static_cast<int>(t.size());
        }
    };

    int cursor_;
    std::map<int, ClassRange> class_;

    void appendChild(void* element) {
        // Assume implementation exists
    }

    static bool stringEquals(const std::string& a, const std::string& b) {
        return a == b;
    }

    void appendText(const std::string& text, const std::string& clazz, bool forceNewRange) {
        if (!class_.empty()) {
            auto last_it = std::prev(class_.end());
            ClassRange& range = last_it->second;
            if (!forceNewRange && stringEquals(range.clazz, clazz)) {
                range.appendRight(text, 0);
            } else {
                ClassRange newRange(cursor_, clazz, text);
                appendChild(newRange.element);
                class_.emplace(cursor_, newRange);
            }
        } else {
            // if map is empty, always create a new range
            ClassRange newRange(cursor_, clazz, text);
            appendChild(newRange.element);
            class_.emplace(cursor_, newRange);
        }
    }

    void insertText(const ClassRange& range) {
        int start = range.start;
        int end = start + range.length;

        auto left_it = class_.upper_bound(start);
        if (left_it != class_.begin()) --left_it;

        auto right_it = class_.upper_bound(end);
        if (right_it != class_.begin()) --right_it;

        // (Assume further logic is implemented here)
    }
};
```",1
"// [IGNORED: Requires database to be set up]
#include <gtest/gtest.h>

TEST(InjectedTest, TestInjected) {
}","#include <gtest/gtest.h>

TEST(FirewallManagerTest, DISABLED_testInjected) {
}",1
"#include <vector>
#include <string>

class UnusedPrivateMethodCheck : public SubscriptionBaseVisitor {
public:
  std::vector<Tree::Kind> nodesToVisit() override {
    return {Tree::Kind::METHOD, Tree::Kind::CONSTRUCTOR};
  }

  void visitNode(Tree* tree) override {
    MethodTree* node = static_cast<MethodTree*>(tree);
    Symbol* symbol = node->symbol();
    if (symbol->isPrivate() && symbol->usages().empty()) {
      if (node->is(Tree::Kind::CONSTRUCTOR)) {
        if (!node->parameters().empty()) {
          addIssue(node, ""Remove this unused private \"""" + node->simpleName().name() + ""\"" constructor."");
        }
      } else if (SerializableContract::SERIALIZABLE_CONTRACT_METHODS.find(symbol->name()) == SerializableContract::SERIALIZABLE_CONTRACT_METHODS.end()) {
        addIssue(node, ""Remove this unused private \"""" + symbol->name() + ""\"" method."");
      }
    }
  }
};","#include <vector>
#include <string>
#include <set>

class Tree {
public:
    enum class Kind { METHOD, CONSTRUCTOR };
    virtual Kind kind() const = 0;
};

class MethodTree : public Tree {
public:
    virtual const std::string& simpleName() const = 0;
    virtual std::vector<std::string> parameters() const = 0;
    virtual Symbol* symbol() const = 0;
    virtual bool is(Tree::Kind kind) const = 0;
};

class Symbol {
public:
    virtual bool isPrivate() const = 0;
    virtual std::vector<void*> usages() const = 0;
    virtual const std::string& name() const = 0;
};

class SerializableContract {
public:
    static const std::set<std::string> SERIALIZABLE_CONTRACT_METHODS;
};
const std::set<std::string> SerializableContract::SERIALIZABLE_CONTRACT_METHODS = {""readObject"", ""writeObject""};

class SubscriptionBaseVisitor {
public:
    virtual std::vector<Tree::Kind> nodesToVisit() = 0;
    virtual void visitNode(Tree* tree) = 0;
protected:
    void addIssue(const MethodTree* node, const std::string& message) {
        // Implementation to handle the issue detected
    }
};

class UnusedPrivateMethodCheck : public SubscriptionBaseVisitor {
public:
    std::vector<Tree::Kind> nodesToVisit() override {
        return {Tree::Kind::METHOD, Tree::Kind::CONSTRUCTOR};
    }

    void visitNode(Tree* tree) override {
        MethodTree* node = dynamic_cast<MethodTree*>(tree);
        Symbol* symbol = node->symbol();
        if (symbol->isPrivate() && symbol->usages().empty()) {
            if (node->is(Tree::Kind::CONSTRUCTOR)) {
                if (!node->parameters().empty()) {
                    addIssue(node, ""Remove this unused private \"""" + node->simpleName() + ""\"" constructor."");
                }
            } else if (SerializableContract::SERIALIZABLE_CONTRACT_METHODS.find(symbol->name()) == SerializableContract::SERIALIZABLE_CONTRACT_METHODS.end()) {
                addIssue(node, ""Remove this unused private \"""" + symbol->name() + ""\"" method."");
            }
        }
    }
};",1
"CCombo* wEncoding;
FormData fdlEncoding, fdEncoding;

Label* wlLength;
CCombo* wLength;
FormData fdlLength, fdLength;

Label* wlLimit;
Text* wLimit;
FormData fdlLimit, fdLimit;","Label* wlLength;
CCombo* wLength;
FormData fdlLength, fdLength;

Label* wlLimit;
Text* wLimit;
FormData fdlLimit, fdLimit;",0
"#include <memory>
#include <string>
#include <stdexcept>
#include <chrono>","#include ""lookup/LookupCachePurge.h""
#include ""lookup/LookupDataAdapter.h""
#include ""lookup/LookupDataAdapterConfiguration.h""
#include ""lookup/LookupResult.h""
#include ""system/urlwhitelist/UrlNotWhitelistedException.h""
#include ""system/urlwhitelist/UrlWhitelistNotificationService.h""
#include ""system/urlwhitelist/UrlWhitelistService.h""
#include <chrono>
#include <memory>
#include <string>",0
"protected:
    bool isExpectReply() const {
        return expectReply;
    }

public:
    void setPath(const std::string& path) {
        this->path = path;
    }

    std::string getPath() const {
        return path;
    }

    void setPayloadExpression(Expression* payloadExpression) {
        this->payloadExpression = payloadExpression;
    }

    void setHeaderExpressions(const std::map<std::string, Expression*>& headerExpressions) {
        this->headerExpressions = headerExpressions;
    }","protected:
    bool isExpectReply() const {
        return expectReply;
    }

public:
    void setPath(const std::string& path) {
        this->path = path;
    }

    std::string getPath() const {
        return path;
    }

    void setPayloadExpression(const Expression& payloadExpression) {
        this->payloadExpression = payloadExpression;
    }

    void setHeaderExpressions(const std::map<std::string, Expression>& headerExpressions) {
        this->headerExpressions = headerExpressions;
    }",0
"protected:
    int itemsPerPoll;

public:
    void onSuccess() {}","class WatermarkingPetAdoptionSource : public PollingSource<std::string, void> {
protected:
    int itemsPerPoll;

    void doStart() override {
        resetCounters();
        polls = (pets.size() / itemsPerPoll) + 1;
    }

    void doStop() override {
        resetCounters();
    }

    void onSuccess() {
        // Intentionally empty
    }
};",0
"JdbcOutboundGateway(JdbcOperations* jdbcOperations, const std::string& updateQuery, const std::string& selectQuery) {
    if (jdbcOperations == nullptr) {
        throw std::invalid_argument(""'jdbcOperations' must not be null."");
    }

    if (updateQuery.empty() && selectQuery.empty()) {
        throw std::invalid_argument(
            ""The 'updateQuery' and the 'selectQuery' must not both be null or empty."");
    }

    if (!selectQuery.empty()) {
        this->poller = new JdbcPollingChannelAdapter(jdbcOperations, selectQuery);
        this->poller->setMaxRows(1);
    } else {
        this->poller = nullptr;
    }
}","```cpp
JdbcOutboundGateway::JdbcOutboundGateway(JdbcOperations* jdbcOperations, const std::string& updateQuery, const std::string& selectQuery) {
    if (jdbcOperations == nullptr) {
        throw std::invalid_argument(""'jdbcOperations' must not be null."");
    }

    if (updateQuery.empty() && selectQuery.empty()) {
        throw std::invalid_argument(""The 'updateQuery' and the 'selectQuery' must not both be null or empty."");
    }

    if (!selectQuery.empty()) {
        this->poller = new JdbcPollingChannelAdapter(jdbcOperations, selectQuery);
        this->poller->setMaxRows(1);
    }
    else {
        this->poller = nullptr;
    }
}
```",0
"return;
}
LOG.info(""Processing input split : {}"", split);

format.open(split);
try {
    RowData* nextElement = nullptr;","if (!split) {
    return;
}

std::cout << ""Processing input split: "" << split << std::endl;

format.open(split);
try {
    RowData nextElement;",1
"#include <map>
#include <stdexcept>
#include <set>
#include <algorithm>
#include <iterator>
#include <cassert>","#include <locale>
#include <map>
#include <stdexcept>
#include <set>
#include <algorithm>
#include <iterator>

using namespace std;",0
"std::set<std::string> affectedIndices = determineAffectedIndices(range, filter);
HistogramResult result = searchesAdapter.histogram(query, filter, range, affectedIndices, interval);
recordEsMetrics(result.tookMs(), range);
return result;

HistogramResult histogram(const std::string& query, DateHistogramInterval interval, TimeRange range) {
    return histogram(query, interval, """", range);
}

HistogramResult histogram(const std::string& query, DateHistogramInterval interval, const std::string& filter, TimeRange range) {
    std::set<std::string> affectedIndices = determineAffectedIndices(range, filter);
    HistogramResult result = searchesAdapter.histogram(query, filter, range, affectedIndices, interval);
    recordEsMetrics(result.tookMs(), range);
    return result;
}

HistogramResult fieldHistogram(const std::string& query,
                              const std::string& field,
                              DateHistogramInterval interval,
                              const std::string& filter,
                              TimeRange range,
                              bool includeCardinality) {
    return fieldHistogram(query, field, interval, filter, range, true, includeCardinality);
}

HistogramResult fieldHistogram(const std::string& query,
                              const std::string& field,
                              DateHistogramInterval interval,
                              const std::string& filter,
                              TimeRange range,
                              bool includeStats,
                              bool includeCardinality) {
    std::set<std::string> affectedIndices = determineAffectedIndices(range, filter);
    HistogramResult result = searchesAdapter.fieldHistogram(query, filter, range, affectedIndices, field, interval, includeStats, includeCardinality);
    recordEsMetrics(result.tookMs(), range);
    return result;
}

void recordEsMetrics(long tookMs, TimeRange range) {
    esTotalSearchesCounter.inc();
}","HistogramResult histogram(const std::string& query, const DateHistogramInterval& interval, const TimeRange& range) {
    return histogram(query, interval, """", range);
}

HistogramResult histogram(const std::string& query, const DateHistogramInterval& interval, const std::string& filter, const TimeRange& range) {
    std::set<std::string> affectedIndices = determineAffectedIndices(range, filter);
    HistogramResult result = searchesAdapter.histogram(query, filter, range, affectedIndices, interval);
    recordEsMetrics(result.tookMs(), range);
    return result;
}

HistogramResult fieldHistogram(const std::string& query,
                              const std::string& field,
                              const DateHistogramInterval& interval,
                              const std::string& filter,
                              const TimeRange& range,
                              bool includeCardinality) {
    return fieldHistogram(query, field, interval, filter, range, true, includeCardinality);
}

HistogramResult fieldHistogram(const std::string& query,
                              const std::string& field,
                              const DateHistogramInterval& interval,
                              const std::string& filter,
                              const TimeRange& range,
                              bool includeStats,
                              bool includeCardinality) {
    std::set<std::string> affectedIndices = determineAffectedIndices(range, filter);
    HistogramResult result = searchesAdapter.fieldHistogram(query, filter, range, affectedIndices, field, interval, includeStats, includeCardinality);
    recordEsMetrics(result.tookMs(), range);
    return result;
}

void recordEsMetrics(long tookMs, const TimeRange& range) {
    esTotalSearchesCounter.inc();
}",0
"static constexpr size_t OLD_MAGIC_BUFFER_SIZE = 4;
static constexpr size_t MAGIC_BUFFER_SIZE = 6;
static std::array<std::uint8_t, OLD_MAGIC_BUFFER_SIZE> oldMagicBuffer{};
static std::array<std::uint8_t, MAGIC_BUFFER_SIZE> magicBuffer{};
const Schema readerSchema;
LogFormatVersion nextBlockVersion;
bool readBlockLazily;
std::int64_t reverseLogFilePosition;","static constexpr std::size_t OLD_MAGIC_BUFFER_SIZE = 4;
static constexpr std::size_t MAGIC_BUFFER_SIZE = 6;
static std::array<uint8_t, OLD_MAGIC_BUFFER_SIZE> oldMagicBuffer{};
static std::array<uint8_t, MAGIC_BUFFER_SIZE> magicBuffer{};
const Schema readerSchema;
LogFormatVersion nextBlockVersion;
bool readBlockLazily;
int64_t reverseLogFilePosition;",1
"#include <string>
#include <vector>
#include <map>

class Instrumenter {};

class AbstractAwsClientInstrumentation : public Instrumenter {
public:
    virtual std::vector<std::string> helperResourceNames() = 0;
    virtual bool classLoaderMatcher() = 0;
    virtual bool typeMatcher() = 0;
    virtual std::map<std::string, std::string> transformers() = 0;
};

class AwsClientInstrumentation : public AbstractAwsClientInstrumentation {
public:
    std::vector<std::string> helperResourceNames() override {
        return {
            ""software/amazon/awssdk/global/handlers/execution.interceptors""
        };
    }

    bool classLoaderMatcher() override {
        // Example placeholder for hasClassesNamed
        return hasClassesNamed(""software.amazon.awssdk.core.interceptor.ExecutionInterceptor"");
    }

    bool typeMatcher() override {
        // Example placeholder for named
        return named(""software.amazon.awssdk.core.SdkRequest"");
    }

    std::map<std::string, std::string> transformers() override {
        return {};
    }

private:
    bool hasClassesNamed(const std::string& className) {
        // Implementation-specific: check if the class is available
        return true;
    }

    bool named(const std::string& typeName) {
        // Implementation-specific: check if the type matches
        return true;
    }
};","#include <string>
#include <vector>
#include <map>

class Instrumenter {};

class AwsClientInstrumentation : public AbstractAwsClientInstrumentation {
public:
  std::vector<std::string> helperResourceNames() override {
    return {
      ""software/amazon/awssdk/global/handlers/execution.interceptors""
    };
  }

  ElementMatcher<ClassLoader> classLoaderMatcher() override {
    return hasClassesNamed(""software.amazon.awssdk.core.interceptor.ExecutionInterceptor"");
  }

  ElementMatcher<TypeDescription> typeMatcher() override {
    return named(""software.amazon.awssdk.core.SdkRequest"");
  }

  std::map<ElementMatcher<MethodDescription>, std::string> transformers() override {
    return {};
  }
};",1
"```cpp
#include <string>
#include <vector>
#include <stdexcept>

template<typename F>
class Session {
public:
    bool exists(const std::string& path);
    // ... other Session methods ...
};

class MyClass {
public:
    template<typename F>
    void makeDirectories(const std::string& path, Session<F>& session) {
        if (!session.exists(path)) {
            int nextSeparatorIndex = path.rfind(this->remoteFileSeparator);

            if (nextSeparatorIndex > -1) {
                std::vector<std::string> pathsToCreate;
                while (nextSeparatorIndex > -1) {
                    std::string pathSegment = path.substr(0, nextSeparatorIndex);
                    if (pathSegment.length() == 0 || session.exists(pathSegment)) {
                        break;
                    } else {
                        pathsToCreate.insert(pathsToCreate.begin(), pathSegment);
                        nextSeparatorIndex = pathSegment.rfind(this->remoteFileSeparator);
                    }
                }
                // ... (presumably, code to actually create the directories would go here) ...
            }
        }
    }

private:
    char remoteFileSeparator;
};
```","```cpp
template<typename F>
class FileTransferringMessageHandler : public AbstractMessageHandler {
private:
    void makeDirectories(const std::string& path, Session<F>& session) {
        if (!session.exists(path)) {
            int nextSeparatorIndex = path.rfind(this->remoteFileSeparator);

            if (nextSeparatorIndex > -1) {
                std::list<std::string> pathsToCreate;
                while (nextSeparatorIndex > -1) {
                    std::string pathSegment = path.substr(0, nextSeparatorIndex);
                    if (pathSegment.empty() || session.exists(pathSegment)) {
                        break;
                    } else {
                        pathsToCreate.push_front(pathSegment);
                        nextSeparatorIndex = pathSegment.rfind(this->remoteFileSeparator);
                    }
                }
                // further code for actually creating directories...
            }
        }
    }

    char remoteFileSeparator;
};
```",1
"Region* parseRegion(const Id& mdId, Element* extentObj) {
    MultiPolygon* geometry = parseElement(extentObj);

    std::string id;
    if (geometry != nullptr) {
        Element* element = extentObj->getChild(""element"", Geonet::Namespaces::GEONET);
        if (element != nullptr) {
            id = element->getAttributeValue(""ref"");
        }
        return new MetadataRegion(mdId, id, geometry);
    } else {
        return nullptr;
    }
}

MultiPolygon* parseElement(Element* extentObj) {
    GeonetContext* gc = static_cast<GeonetContext*>(context.getHandlerContext(Geonet::CONTEXT_NAME));
    gc->getBean<DataManager>()->getEditLib()->removeEditingInfo(extentObj);

    MultiPolygon* geometry = nullptr;
    if (extentObj->getName() == ""polygon"") {
        geometry = parsePolygon(extentObj);
    } else if (extentObj->getName() == ""EX_BoundingPolygon"") {
        Element* polygon = extentObj->getChild(""polygon"", Namespaces::GMD);
        geometry = parsePolygon(polygon);
    } else if (extentObj->getName() == ""EX_GeographicBoundingBox"") {
        double minx = std::stod(extentObj->getChild(""westBoundLongitude"", Geonet::Namespaces::GMD)->getChildText(""Decimal"", Geonet::Namespaces::GCO));
        double maxx = std::stod(extentObj->getChild(""eastBoundLongitude"", Geonet::Namespaces::GMD)->getChildText(""Decimal"", Geonet::Namespaces::GCO));
        double miny = std::stod(extentObj->getChild(""southBoundLatitude"", Geonet::Namespaces::GMD)->getChildText(""Decimal"", Geonet::Namespaces::GCO));
        double maxy = std::stod(extentObj->getChild(""northBoundLatitude"", Geonet::Namespaces::GMD)->getChildText(""Decimal"", Geonet::Namespaces::GCO));
        Polygon* polygon = static_cast<Polygon*>(factory->toGeometry(Envelope(minx, maxx, miny, maxy)));
        std::vector<Polygon*> polygons = {polygon};
        geometry = factory->createMultiPolygon(polygons);
    }
    return geometry;
}

MultiPolygon* parsePolygon(Element* extentObj) {
    auto children = extentObj->getChildren();
    if (children.empty())","Region* parseRegion(const Id& mdId, Element* extentObj) {
    MultiPolygon* geometry = parseElement(extentObj);

    std::string id;
    if (geometry != nullptr) {
        Element* element = extentObj->getChild(""element"", Geonet::Namespaces::GEONET);
        if (element != nullptr) {
            id = element->getAttributeValue(""ref"");
        }
        return new MetadataRegion(mdId, id, geometry);
    } else {
        return nullptr;
    }
}

MultiPolygon* parseElement(Element* extentObj) {
    GeonetContext* gc = static_cast<GeonetContext*>(context.getHandlerContext(Geonet::CONTEXT_NAME));
    gc->getBean<DataManager>()->getEditLib()->removeEditingInfo(extentObj);

    MultiPolygon* geometry = nullptr;
    if (extentObj->getName() == ""polygon"") {
        geometry = parsePolygon(extentObj);
    } else if (extentObj->getName() == ""EX_BoundingPolygon"") {
        Element* polygon = extentObj->getChild(""polygon"", Namespaces::GMD);
        geometry = parsePolygon(polygon);
    } else if (extentObj->getName() == ""EX_GeographicBoundingBox"") {
        double minx = std::stod(extentObj->getChild(""westBoundLongitude"", Geonet::Namespaces::GMD)
                                    ->getChildText(""Decimal"", Geonet::Namespaces::GCO));
        double maxx = std::stod(extentObj->getChild(""eastBoundLongitude"", Geonet::Namespaces::GMD)
                                    ->getChildText(""Decimal"", Geonet::Namespaces::GCO));
        double miny = std::stod(extentObj->getChild(""southBoundLatitude"", Geonet::Namespaces::GMD)
                                    ->getChildText(""Decimal"", Geonet::Namespaces::GCO));
        double maxy = std::stod(extentObj->getChild(""northBoundLatitude"", Geonet::Namespaces::GMD)
                                    ->getChildText(""Decimal"", Geonet::Namespaces::GCO));
        Polygon* poly = static_cast<Polygon*>(factory->toGeometry(Envelope(minx, maxx, miny, maxy)));
        std::vector<Polygon*> polygons = { poly };
        geometry = factory->createMultiPolygon(polygons);
    }
    return geometry;
}

MultiPolygon* parsePolygon(Element* extentObj) {
    std::vector<Element*> children =",1
"```cpp
if (s_logger.isInfoEnabled()) {
    s_logger.info(""Destroy template volume "" + vol.getPath());
}
vmMo.markAsVirtualMachine(hyperHost.getHyperHostOwnerResourcePool(), hyperHost.getMor());
vmMo.destroy();
} else {
    if (s_logger.isInfoEnabled()) {
```","if (s_logger.isInfoEnabled()) {
    s_logger.info(std::string(""Destroy template volume "") + vol.getPath());
}
vmMo.markAsVirtualMachine(hyperHost.getHyperHostOwnerResourcePool(), hyperHost.getMor());
vmMo.destroy();
} else {
    if (s_logger.isInfoEnabled()) {",1
"```cpp
auto parent_path = fs::path(file.getFilePath()).parent_path().string();
auto hiveSpecs = newSpecsMap[parent_path];
auto partition = getIcebergPartitionVal(hiveSpecs, file.getFilePath(), partitionSpec);

if (this->newPartitionTableWhitelistBlacklist.acceptTable(tableMetadata.dbName, tableMetadata.tableName)
    && gmce.getOperationType() == OperationType::add_files) {
    tableMetadata.prevCompletenessWatermark = std::stol(
        table.properties().count(COMPLETION_WATERMARK_KEY) ?
            table.properties().at(COMPLETION_WATERMARK_KEY) :
            std::to_string(DEFAULT_COMPLETION_WATERMARK)
    );
    // Assumes first partition value to be partitioned by date
}
```","```cpp
auto hiveSpecs = newSpecsMap[fs::path(file.filePath()).parent_path().string()];
auto partition = getIcebergPartitionVal(hiveSpecs, file.filePath(), partitionSpec);

if (this->newPartitionTableWhitelistBlacklist.acceptTable(tableMetadata.dbName, tableMetadata.tableName)
    && gmce.getOperationType() == OperationType::add_files) {
    tableMetadata.prevCompletenessWatermark = std::stoll(
        table.properties().value_or(COMPLETION_WATERMARK_KEY, std::to_string(DEFAULT_COMPLETION_WATERMARK))
    );
    // Assumes first partition value to be partitioned by date
}
```",1
"template <typename S>
class Factory : public FileSystemInstrumentationFactory<S> {
private:
    const std::string SERVICE_NAME_CONF_KEY = ""gobblin.broker.limiter.serviceName"";

public:
    FileSystem* instrumentFileSystem(FileSystem* fs, SharedResourcesBroker<S>* broker,
                                     ConfigView<S, FileSystemKey>* config) override {
        try {
            std::string serviceName = config->getConfig()->getString(SERVICE_NAME_CONF_KEY);
            Limiter* limiter;
            if (serviceName.empty()) {
                limiter = broker->getSharedResource(
                    std::make_shared<SharedLimiterFactory<S>>(),
                    std::make_shared<FileSystemLimiterKey>(config->getKey()->getUri())
                );
            } else {
                limiter = broker->getSharedResource(
                    std::make_shared<SharedLimiterFactory<S>>(),
                    std::make_shared<FileSystemLimiterKey>(config->getKey()->getUri(), serviceName)
                );
            }
            return new ThrottledFileSystem(fs, limiter, serviceName);
        } catch (const NotConfiguredException& nce) {
            throw std::runtime_error(nce.what());
        }
    }
};","```cpp
template <typename S>
class ThrottledFileSystem : public FileSystemInstrumentation {
public:
    class Factory : public FileSystemInstrumentationFactory<S> {
    private:
        const std::string SERVICE_NAME_CONF_KEY = ""gobblin.broker.limiter.serviceName"";
    public:
        FileSystem* instrumentFileSystem(FileSystem* fs, SharedResourcesBroker<S>* broker,
                                        ConfigView<S, FileSystemKey>* config) override {
            try {
                std::string serviceName = config->getConfig().getString(SERVICE_NAME_CONF_KEY);
                Limiter* limiter;
                if (serviceName.empty()) {
                    limiter = broker->getSharedResource(
                        std::make_shared<SharedLimiterFactory<S>>(),
                        std::make_shared<FileSystemLimiterKey>(config->getKey()->getUri()));
                } else {
                    limiter = broker->getSharedResource(
                        std::make_shared<SharedLimiterFactory<S>>(),
                        std::make_shared<FileSystemLimiterKey>(config->getKey()->getUri(), serviceName));
                }
                return new ThrottledFileSystem(fs, limiter, serviceName);
            } catch (const NotConfiguredException& nce) {
                throw std::runtime_error(nce.what());
            }
        }
    };
};
```",1
"#include <atomic>
#include <chrono>
#include <functional>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>","#include <thread>
#include <chrono>
#include <atomic>
#include <functional>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>",0
"protected:
    void SetItemsCore(const std::vector<ItemType>& value) override
    {
        if (value.empty())
        {
            throw std::invalid_argument(""value"");
        }

        BeginUpdate();
        Items.ClearInternal();
        Items.AddRangeInternal(value);
    }","```cpp
#include <stdexcept>
#include <vector>

protected:
void SetItemsCore(const std::vector<ItemType>& value) override
{
    if (&value == nullptr)
    {
        throw std::invalid_argument(""value"");
    }

    BeginUpdate();
    Items.ClearInternal();
    Items.AddRangeInternal(value);
}
```",1
"BaseClass::BaseClass(stepMeta, stepDataInterface, copyNr, transMeta, trans);
}

bool processRow(StepMetaInterface* smi, StepDataInterface* sdi) override {
    meta = static_cast<ExecProcessMeta*>(smi);
    data = static_cast<ExecProcessData*>(sdi);","ExecProcess::ExecProcess(const StepMeta& stepMeta, StepDataInterface* stepDataInterface, int copyNr, const TransMeta& transMeta, Trans* trans)
    : BaseStep(stepMeta, stepDataInterface, copyNr, transMeta, trans) {
}

bool ExecProcess::processRow(StepMetaInterface* smi, StepDataInterface* sdi) {
    meta = static_cast<ExecProcessMeta*>(smi);
    data = static_cast<ExecProcessData*>(sdi);
    // ...
}",0
"```cpp
#include <string>
#include <optional>

class GobblinServiceJobScheduler {
private:
    std::atomic<bool> isActive;
    std::string serviceName;

    // If current instance is nominated as a handler for DR traffic from down GaaS-Instance.
    // Note this is different from leadership change/fail-over handling.
    bool isNominatedDRHanlder;

public:
    // Use this to tag all DR-applicable FlowSpec entries 
    // so only they would be loaded during DR handling.
    static constexpr const char* DR_FILTER_TAG = ""dr"";

    GobblinServiceJobScheduler(
        const std::string& serviceName,
        const Config& config,
        std::optional<HelixManager> helixManager,
        std::optional<FlowCatalog> flowCatalog,
        std::optional<TopologyCatalog> topologyCatalog,
        Orchestrator orchestrator,
        SchedulerService schedulerService,
        std::optional<Logger> log
    )
    : isActive(false),
      serviceName(serviceName),
      isNominatedDRHanlder(false)
    {
        // constructor body (throw std::exception if needed)
    }
};
```","```cpp
class GobblinServiceJobScheduler : public JobScheduler, public SpecCatalogListener {
private:
    volatile bool isActive;
    std::string serviceName;

    // If current instance is nominated as a handler for DR traffic from down GaaS-Instance.
    bool isNominatedDRHanlder;

public:
    // Use this to tag all DR-applicable FlowSpec entries so only they would be loaded during DR handling.
    static constexpr const char* DR_FILTER_TAG = ""dr"";

    GobblinServiceJobScheduler(const std::string& serviceName, 
                              const Config& config, 
                              std::optional<HelixManager> helixManager,
                              std::optional<FlowCatalog> flowCatalog,
                              std::optional<TopologyCatalog> topologyCatalog,
                              Orchestrator orchestrator,
                              SchedulerService schedulerService,
                              std::optional<Logger> log) 
        : serviceName(serviceName)
    {
        // constructor body
    }
};
```",0
"MessageSourceBase* getMessageSource() const {
    return this->source;
}

void setOutputChannelName(const std::string& outputChannelName) {
    assert(!outputChannelName.empty());
    this->outputChannelName = outputChannelName;
}

std::string getOutputChannelName() const {
    if (this->outputChannel == nullptr) {
        return this->outputChannelName;
    } else {
        auto named = dynamic_cast<NamedComponent*>(this->outputChannel);
        return named ? named->getComponentName() : """";
    }
}","```cpp
class SourcePollingChannelAdapter : public AbstractPollingEndpoint {
public:
    void setOutputChannel(OutputChannel* outputChannel) {
        this->outputChannel = outputChannel;
    }

    MessageSourceBase* getMessageSource() {
        return this->source;
    }

    void setOutputChannelName(const std::string& outputChannelName) {
        if (outputChannelName.empty()) {
            throw std::invalid_argument(""'outputChannelName' must not be empty"");
        }
        this->outputChannelName = outputChannelName;
    }

    std::string getOutputChannelName() const {
        if (this->outputChannel == nullptr) {
            return this->outputChannelName;
        } else {
            auto named = dynamic_cast<const NamedComponent*>(this->outputChannel);
            if (named) {
                return named->getComponentName();
            } else {
                return {};
            }
        }
    }

    // ...
private:
    OutputChannel* outputChannel = nullptr;
    std::string outputChannelName;
    MessageSourceBase* source = nullptr;
};
```",1
"#include <optional>
#include <set>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <mutex>

std::optional<ExtensionModel> createTnsExtensionModel(const URL& resource, const std::set<ExtensionModel>& extensionModels) {
    std::ostringstream resultStream;
    Transformer* transformer = FOR_TNS_XSTL_TRANSFORMER_POOL.take();

    try {
        auto resourceStream = resource.openStream();
        BufferedInputStream resourceIS(std::move(resourceStream));

        Source moduleToTransform(resourceIS);

        {
            std::lock_guard<std::mutex> lock(transformer->getMutex());
            transformer->transform(moduleToTransform, StreamResult(resultStream));
        }
    } catch (const TransformerException& e) {
        throw MuleRuntimeException(
            createStaticMessage(
                format(
                    ""There was an issue transforming the stream for the resource %s while trying to remove the content of the <body> element to generate an XSD"",
                    resource.getFile()
                )
            ), 
            e
        );
    } 
    FOR_TNS_XSTL_TRANSFORMER_POOL.restore(transformer);

    ExtensionDeclarer extensionDeclarer;
    // ...
}","std::optional<ExtensionModel> createTnsExtensionModel(const URL& resource, std::set<ExtensionModel>& extensionModels) {
    std::ostringstream resultStream;
    Transformer* transformer = FOR_TNS_XSTL_TRANSFORMER_POOL.take();
    try {
        std::ifstream resourceIS(resource.openStream(), std::ios::in | std::ios::binary);
        if (!resourceIS) {
            throw std::runtime_error(""Failed to open resource stream"");
        }
        Source moduleToTransform(resourceIS);
        {
            std::lock_guard<std::mutex> lock(transformer->getMutex());
            transformer->transform(moduleToTransform, StreamResult(resultStream));
        }
    } catch (const TransformerException& e) {
        throw MuleRuntimeException(
            createStaticMessage(fmt::format(""There was an issue transforming the stream for the resource {} while trying to remove the content of the <body> element to generate an XSD"", resource.getFile())),
            e
        );
    } 
    FOR_TNS_XSTL_TRANSFORMER_POOL.restore(transformer);

    ExtensionDeclarer extensionDeclarer;

    // ... (rest of the function)
}",0
"PCollectionView<OutputT> expand(PCollection<InputT> input) override {
    if (
        hasExperiment(input.getPipeline()->getOptions(), ""beam_fn_api"") &&
        (hasExperiment(input.getPipeline()->getOptions(), ""use_runner_v2"") ||
         hasExperiment(input.getPipeline()->getOptions(), ""use_unified_worker""))
    ) {
        auto combined = input.apply(
            ""CombineValues"",
            Combine<InputT, OutputT>::globally(fn).withoutDefaults().withFanout(fanout)
        );
        Coder<OutputT>* outputCoder = combined.getCoder();
        auto view = PCollectionViews::singletonView(
            combined,
            static_cast<TypeDescriptorSupplier<OutputT>>(
                [outputCoder]() -> std::optional<TypeDescriptor> {
                    return outputCoder ? std::optional<TypeDescriptor>(outputCoder->getEncodedTypeDescriptor()) : std::nullopt;
                }
            ),
            input.getWindowingStrategy(),
            insertDefault,
            insertDefault ? fn.defaultValue() : OutputT{},
            combined.getCoder()
        );
        combined.apply(""CreatePCollectionView"", CreatePCollectionView::of(view));
        return view;
    }

    auto combined = input.apply(
        Combine<InputT, OutputT>::globally(fn).withoutDefaults().withFanout(fanout)
    );
    auto materializationInput = combined.apply(std::make_shared<VoidKeyToMultimapMaterialization<>>());
    Coder<OutputT>* outputCoder = combined.getCoder();
    auto view = PCollectionViews::singletonViewUsingVoidKey(
        materializationInput,
        static_cast<TypeDescriptorSupplier<OutputT>>(
            [outputCoder]() -> std::optional<TypeDescriptor> {
                return outputCoder ? std::optional<TypeDescriptor>(outputCoder->getEncodedTypeDescriptor()) : std::nullopt;
            }
        )
    );
    return view;
}","PCollectionView<OutputT> expand(PCollection<InputT> input) override {
    if (hasExperiment(input.getPipeline().getOptions(), ""beam_fn_api"") &&
        (hasExperiment(input.getPipeline().getOptions(), ""use_runner_v2"") ||
         hasExperiment(input.getPipeline().getOptions(), ""use_unified_worker""))) {
        auto combined = input.apply(
            ""CombineValues"",
            Combine<InputT, OutputT>::globally(fn).withoutDefaults().withFanout(fanout)
        );
        auto outputCoder = combined.getCoder();
        auto view = PCollectionViews::singletonView(
            combined,
            [&outputCoder]() -> std::optional<TypeDescriptor> {
                return outputCoder ? outputCoder->getEncodedTypeDescriptor() : std::nullopt;
            },
            input.getWindowingStrategy(),
            insertDefault,
            insertDefault ? fn.defaultValue() : OutputT(),
            combined.getCoder()
        );
        combined.apply(""CreatePCollectionView"", CreatePCollectionView::of(view));
        return view;
    }

    auto combined = input.apply(Combine<InputT, OutputT>::globally(fn).withoutDefaults().withFanout(fanout));
    auto materializationInput = combined.apply(VoidKeyToMultimapMaterialization<>());
    auto outputCoder = combined.getCoder();
    auto view = PCollectionViews::singletonViewUsingVoidKey(
        materializationInput,
        [&outputCoder]() -> std::optional<TypeDescriptor> {
            return outputCoder ? outputCoder->getEncodedTypeDescriptor() : std::nullopt;
        },
        input.getWindowingStrategy(),
        insertDefault,
        insertDefault ? fn.defaultValue() : OutputT(),
        combined.getCoder()
    );
    return view;
}",1
"class SourcePollingChannelAdapter : public AbstractPollingEndpoint, public TrackableComponent {
private:
    MessagingTemplate messagingTemplate;

    std::unordered_set<std::shared_ptr<Advice>> appliedAdvices;

    std::atomic<MessageSourceBase*> source{nullptr};

    std::atomic<MessageChannel*> outputChannel{nullptr};
};","#include <memory>
#include <unordered_set>
#include <atomic>

class MessagingTemplate {};

class Advice {};

class MessageSourceBase {};
template <typename T>
using MessageSource = MessageSourceBase;

class MessageChannel {};

class TrackableComponent {};

class AbstractPollingEndpoint {};

class SourcePollingChannelAdapter : public AbstractPollingEndpoint, public TrackableComponent {
private:
    MessagingTemplate messagingTemplate;
    std::unordered_set<std::shared_ptr<Advice>> appliedAdvices;

    std::atomic<MessageSource<void>*> source{nullptr};
    std::atomic<MessageChannel*> outputChannel{nullptr};
};",0
"/****
 * Login to salesforce
 * @return login status
 */
bool bulkApiLogin() {
    log.info(""Authenticating salesforce bulk api"");
    bool success = false;
    std::string hostName = workUnit.getProp(ConfigurationKeys::SOURCE_CONN_HOST_NAME);
    std::string apiVersion = workUnit.getProp(ConfigurationKeys::SOURCE_CONN_VERSION);","bool bulkApiLogin() {
    log.info(""Authenticating salesforce bulk api"");
    bool success = false;
    std::string hostName = workUnit.getProp(ConfigurationKeys::SOURCE_CONN_HOST_NAME);
    std::string apiVersion = workUnit.getProp(ConfigurationKeys::SOURCE_CONN_VERSION);
    // ...
    return success;
}",0
"std::map<std::string, std::any> toElasticSearchObject(ObjectMapper& objectMapper, Meter& invalidTimestampMeter) override {
    std::map<std::string, std::any> source = objectMapper.convertValue(this->toDto(), TypeReferences::MAP_STRING_OBJECT);

    source[EventDto::FIELD_EVENT_TIMESTAMP] = buildElasticSearchTimeFormat(requireNonNull(this->getEventTimestamp())->withZone(UTC));
    source[EventDto::FIELD_PROCESSING_TIMESTAMP] = buildElasticSearchTimeFormat(requireNonNull(this->getProcessingTimestamp())->withZone(UTC));
    if (this->getTimerangeStart() != nullptr) {
        source[EventDto::FIELD_TIMERANGE_START] = buildElasticSearchTimeFormat(this->getTimerangeStart()->withZone(UTC));
    }
    if (this->getTimerangeEnd() != nullptr) {
        source[EventDto::FIELD_TIMERANGE_END] = buildElasticSearchTimeFormat(this->getTimerangeEnd()->withZone(UTC));
    }

    if (this->getStreams().empty()) {
        throw std::logic_error(""Event streams cannot be empty"");
    }
    return source;
}","```cpp
#include <map>
#include <string>
#include <stdexcept>
#include <memory>

std::map<std::string, std::any> toElasticSearchObject(
    ObjectMapper& objectMapper,
    Meter& invalidTimestampMeter
) {
    auto source = objectMapper.convertValue(this->toDto());

    source[EventDto::FIELD_EVENT_TIMESTAMP] = buildElasticSearchTimeFormat(requireNonNull(this->getEventTimestamp())->withZone(UTC));
    source[EventDto::FIELD_PROCESSING_TIMESTAMP] = buildElasticSearchTimeFormat(requireNonNull(this->getProcessingTimestamp())->withZone(UTC));
    if (this->getTimerangeStart() != nullptr) {
        source[EventDto::FIELD_TIMERANGE_START] = buildElasticSearchTimeFormat(this->getTimerangeStart()->withZone(UTC));
    }
    if (this->getTimerangeEnd() != nullptr) {
        source[EventDto::FIELD_TIMERANGE_END] = buildElasticSearchTimeFormat(this->getTimerangeEnd()->withZone(UTC));
    }

    if (this->getStreams().empty()) {
        throw std::logic_error(""Event streams cannot be empty"");
    }
    return source;
}
```",1
"void unexport() override {
    if (unexported) {
        return;
    }

    std::string key = getCacheKey(this->originInvoker);
    bounds.erase(key);
}","```cpp
class RegistryProtocol : public Protocol {
public:
    // ...

    void unexport() override {
        if (unexported) {
            return;
        }

        std::string key = getCacheKey(this->originInvoker);
        bounds.erase(key);
    }

    // ...
};
```",1
"return evaluationContext;
}

virtual const std::type_info& getObjectType() const override {
    return typeid(StandardEvaluationContext);
}","std::type_index getObjectType() override {
    return typeid(StandardEvaluationContext);
}",0
"```cpp
#include <vector>
#include <string>
#include <sstream>

namespace JobStatusRetriever {
    const std::string NA_KEY = ""NA""; // placeholder
    const char STATE_STORE_KEY_SEPARATION_CHARACTER = ':'; // placeholder
}

// Utility to split string by a char
std::vector<std::string> split(const std::string& str, char delim) {
    std::vector<std::string> tokens;
    std::stringstream ss(str);
    std::string item;
    while (std::getline(ss, item, delim)) {
        tokens.push_back(item);
    }
    return tokens;
}

bool shouldFilterJobStatus(const std::vector<std::string>& tableNames, const std::string& tableName) {
    if (tableNames.size() <= 1) return false;
    auto tokens = split(tableName, JobStatusRetriever::STATE_STORE_KEY_SEPARATION_CHARACTER);
    return tokens.size() > 1 && tokens[1] == JobStatusRetriever::NA_KEY;
}
```","bool shouldFilterJobStatus(const std::vector<std::string>& tableNames, const std::string& tableName) {
    const char SEPARATION_CHARACTER = KafkaJobStatusMonitor::STATE_STORE_KEY_SEPARATION_CHARACTER;
    auto pos = tableName.find(SEPARATION_CHARACTER);
    std::string secondPart;
    if (pos != std::string::npos) {
        auto nextPos = tableName.find(SEPARATION_CHARACTER, pos + 1);
        secondPart = tableName.substr(pos + 1, nextPos - pos - 1);
    }
    return tableNames.size() > 1 && (secondPart == JobStatusRetriever::NA_KEY);
}",0
"if (keyCode == KEYCODE_BUTTON_Y || keyCode == KEYCODE_BUTTON_X
    || keyCode == KEYCODE_BUTTON_B || keyCode == KEYCODE_BUTTON_A)
{
    displayCardAnswer();
    return true;
}
if (keyPressed == 'e') {
    editCard();
    return true;
}","if (keyCode == KEYCODE_BUTTON_Y || keyCode == KEYCODE_BUTTON_X
    || keyCode == KEYCODE_BUTTON_B || keyCode == KEYCODE_BUTTON_A)
{
    displayCardAnswer();
    return true;
}
if (keyPressed == 'e') {
    editCard();
    return true;
}",1
"static constexpr const char* SEQUENCE_SIZE = ""sequenceSize"";

static constexpr const char* SEQUENCE_DETAILS = ""sequenceDetails"";

static constexpr const char* CONTENT_TYPE = ""content-type"";

std::map<std::string, std::any> headers;","```cpp
#include <string>
#include <map>

class MessageHeaders {
public:
    static const std::string SEQUENCE_SIZE;
    static const std::string SEQUENCE_DETAILS;
    static const std::string CONTENT_TYPE;

private:
    const std::map<std::string, std::any> headers;
};

const std::string MessageHeaders::SEQUENCE_SIZE = ""sequenceSize"";
const std::string MessageHeaders::SEQUENCE_DETAILS = ""sequenceDetails"";
const std::string MessageHeaders::CONTENT_TYPE = ""content-type"";
```",1
"virtual std::string CreationName() const { return this->Name; }

/// Returns all the upstream nodes for the given node
std::unordered_set<NodeModel*> Upstream;","std::string CreationName() const { return this->Name; }

std::unordered_set<NodeModel*> Upstream;",1
"#include <iostream>
#include <ostream>
#include <string>
#include <map>
#include <iomanip>
#include <sstream>
#include <chrono>
#include <ctime>
#include <memory>","#include <iostream>
#include <ostream>
#include <iomanip>
#include <string>
#include <ctime>
#include <map>",0
"auto method = &HeisenbergOperations::die;
ReflectiveMethodOperationExecutor executor(operationModel, method, operations);

assertThat(execute(), is(nullValue()));
assertThat(config.getEndingHealth(), is(DEAD));","auto method = ClassUtils::getMethod(HeisenbergOperations::class_type(), ""die"", {typeid(HeisenbergExtension)});
executor = std::make_unique<ReflectiveMethodOperationExecutor>(operationModel, method, operations);

EXPECT_EQ(execute(), nullptr);
EXPECT_EQ(config.getEndingHealth(), DEAD);",0
"virtual void write(const std::vector<RawMessageEvent>& entries) = 0;

virtual void preFlightCheck() { }

class Metrics {
public:
    class Provider {
    public:
        Metrics operator()();
    };
};","class MessageQueueWriter {
public:
    virtual ~MessageQueueWriter() = default;

    virtual void write(const std::vector<RawMessageEvent>& entries) = 0;

    virtual void preFlightCheck() {}

    class Metrics {
    public:
        class Provider {
        public:
            virtual Metrics* get() = 0;
            virtual ~Provider() = default;
        };
    };
};",1
"protected:
ResolverSet getParametersAsResolverSet(const EnrichableModel& model)
{
    ResolverSet resolverSet;
    for (const auto& [key, value] : getParameters())
    {
        resolverSet.add(key, toValueResolver(value));
    }
    checkParameterGroupExclusivenessForModel(model, getParameters().keySet());
    return resolverSet;
}","protected:
    ResolverSet getParametersAsResolverSet(const EnrichableModel& model)
    {
        ResolverSet resolverSet;
        for (const auto& [key, value] : getParameters())
        {
            resolverSet.add(key, toValueResolver(value));
        }
        checkParameterGroupExclusivenessForModel(model, getParameters().keySet());
        return resolverSet;
    }",0
"std::string excludedTypes = """";
std::vector<std::string> excludedTypesList;

std::unordered_set<TryStatementTree*> tryWithResourcesTrees;
std::unordered_set<Tree*> knownResources;
Type* visitedMethodOwnerType = nullptr;

constexpr const char* JAVA_IO_AUTO_CLOSEABLE = ""java.lang.AutoCloseable"";","```cpp
#include <string>
#include <vector>
#include <set>

class UnclosedResourcesCheck : public SECheck {
public:
    std::string excludedTypes = """";
private:
    std::vector<std::string> excludedTypesList;

    std::set<TryStatementTree*> tryWithResourcesTrees;
    std::set<Tree*> knownResources;
    Type* visitedMethodOwnerType;

    static constexpr const char* JAVA_IO_AUTO_CLOSEABLE = ""java.lang.AutoCloseable"";
};
```",1
"return typeCatalog.get();

private:
void findExtensionsInClasspath() {","TypeCatalog& getTypeCatalog() override {
    return *typeCatalog;
}",0
"#include <string>
#include <functional>

class MethodHandleAPI_foldArguments {
private:
    std::string MHClassName = ""java.lang.invoke.MethodHandles"";
    std::string internalFoldArgumentMethod;

public:
    MethodHandleAPI_foldArguments() {
        internalFoldArgumentMethod = (VersionCheck::major() > 11) ? ""foldArgumentsWithCombiner"" : ""foldArguments"";
    }
};","#include <string>

class MethodHandleAPI_foldArguments {
    const std::string MHClassName = ""java.lang.invoke.MethodHandles"";
    const std::string internalFoldArgumentMethod = (VersionCheck::major() > 11) ? ""foldArgumentsWithCombiner"" : ""foldArguments"";
};",1
"private:
    RedisClient primary;
    std::vector<RedisClient> shards;
    GlobalStateAccessor globalStateAccessor;

public:
    GcsClient(const std::string& redisAddress, const std::string& redisPassword)
        : primary(redisAddress, redisPassword) {
    }","class GcsClient {
private:
    RedisClient primary;
    std::vector<RedisClient> shards;
    GlobalStateAccessor globalStateAccessor;

public:
    GcsClient(const std::string& redisAddress, const std::string& redisPassword)
        : primary(redisAddress, redisPassword) {}
};",0
"void Lowerer::GenerateFastInlineIsIn(IR::Instr* instr)
{
    IR::Opnd* src1 = instr->GetSrc1();
    IR::Opnd* src2 = instr->GetSrc2();

    if (!src2->GetValueType().IsLikelyArray() || !src2->GetValueType().HasNoMissingValues())
    {
        return;
    }

    IR::LabelInstr* helperLabel = IR::LabelInstr::New(Js::OpCode::Label, m_func, true);
    IR::LabelInstr* doneFalseLabel = IR::LabelInstr::New(Js::OpCode::Label, m_func);
    IR::LabelInstr* doneLabel = IR::LabelInstr::New(Js::OpCode::Label, m_func);
    IR::LabelInstr* isArrayLabel = IR::LabelInstr::New(Js::OpCode::Label, m_func);

    IR::RegOpnd* src1Untagged = GenerateUntagVar(src1->AsRegOpnd(), helperLabel, instr);
    IR::RegOpnd* src2RegOpnd = IR::RegOpnd::New(TyMachPtr, m_func);
    InsertMove(src2RegOpnd, src2, instr);

    IR::AutoReuseOpnd autoReuseArrayOpnd;
    m_lowererMD.GenerateObjectTest(src2RegOpnd, instr, helperLabel);
    IR::RegOpnd* arrayOpnd = src2RegOpnd->Copy(instr->m_func)->AsRegOpnd();
    autoReuseArrayOpnd.Initialize(arrayOpnd, instr->m_func, false);

    IR::Opnd* vtableOpnd = LoadVTableValueOpnd(instr, VTableValue::VtableJavascriptArray);
    InsertCompareBranch(
        IR::IndirOpnd::New(arrayOpnd, 0, TyMachPtr, instr->m_func),
        vtableOpnd,
        Js::OpCode::BrEq_A,
        isArrayLabel,
        instr
    );

    vtableOpnd = LoadVTableValueOpnd(instr, VTableValue::VtableNativeIntArray);
    InsertCompareBranch(
        IR::IndirOpnd::New(arrayOpnd, 0, TyMachPtr, instr->m_func),
        vtableOpnd,
        Js::OpCode::BrEq_A,
        isArrayLabel,
        instr
    );

    vtableOpnd = LoadV","void Lowerer::GenerateFastInlineIsIn(IR::Instr* instr)
{
    IR::Opnd* src1 = instr->GetSrc1(); // foo
    IR::Opnd* src2 = instr->GetSrc2(); // bar

    if (!src2->GetValueType().IsLikelyArray() || !src2->GetValueType().HasNoMissingValues())
    {
        return;
    }

    IR::LabelInstr* helperLabel = IR::LabelInstr::New(Js::OpCode::Label, m_func, true);
    IR::LabelInstr* doneFalseLabel = IR::LabelInstr::New(Js::OpCode::Label, m_func);
    IR::LabelInstr* doneLabel = IR::LabelInstr::New(Js::OpCode::Label, m_func);
    IR::LabelInstr* isArrayLabel = IR::LabelInstr::New(Js::OpCode::Label, m_func);

    IR::RegOpnd* src1Untagged = GenerateUntagVar(src1->AsRegOpnd(), helperLabel, instr);
    IR::RegOpnd* src2RegOpnd = IR::RegOpnd::New(TyMachPtr, m_func);
    InsertMove(src2RegOpnd, src2, instr);

    IR::AutoReuseOpnd autoReuseArrayOpnd;
    m_lowererMD.GenerateObjectTest(src2RegOpnd, instr, helperLabel);
    IR::RegOpnd* arrayOpnd = src2RegOpnd->Copy(instr->m_func)->AsRegOpnd();
    autoReuseArrayOpnd.Initialize(arrayOpnd, instr->m_func, false);

    IR::Opnd* vtableOpnd = LoadVTableValueOpnd(instr, VTableValue::VtableJavascriptArray);
    InsertCompareBranch(
        IR::IndirOpnd::New(arrayOpnd, 0, TyMachPtr, instr->m_func),
        vtableOpnd,
        Js::OpCode::BrEq_A,
        isArrayLabel,
        instr);

    vtableOpnd = LoadVTableValueOpnd(instr, VTableValue::VtableNativeIntArray);
    InsertCompareBranch(
        IR::IndirOpnd::New(arrayOpnd, 0, TyMachPtr, instr->m_func),
        vtableOpnd,
        Js::OpCode::BrEq_A,
        isArrayLabel,
        instr);

    vtableOpnd =",1
"std::string nodeName = nodeName_(this->element);

if (nodeName == ""img"" && key == ""srcset"" && !value.empty()) {
    if (!isString(value)) {
        throw std::runtime_error(""$compileMinErr('srcset', \""Can't pass trusted values to `$set('srcset', value)`: \\\""\"" + value + ""\\\""\"", "" + value + "")"");
    }

    std::string result;

    // first check if there are spaces because it's not the same pattern

    // ... continue processing as needed
}","std::string nodeName = nodeName_(this->$$element);

if (nodeName == ""img"" && key == ""srcset"" && value) {
    if (!isString(value)) {
        throw $compileMinErr(""srcset"", ""Can't pass trusted values to `$set('srcset', value)`: \"""" + value.toString() + ""\"""");
    }

    std::string result = """";

    // first check if there are spaces because it's not the same pattern
}",1
"#include <functional>
#include <string>

enum class ArtifactClassificationType { MODULE, OTHER }; // Simplified example
const std::string PROVIDED = ""PROVIDED"";
const std::string COMPILE = ""COMPILE"";
const std::string MULE_PLUGIN_CLASSIFIER = ""mule-plugin"";

struct Artifact {
    std::string getClassifier() const;
};

struct Dependency {
    std::string getScope() const;
    Artifact getArtifact() const;
};

std::function<bool(const Dependency&)> getContainerDirectDependenciesFilter(ArtifactClassificationType rootArtifactType) {
    if (rootArtifactType == ArtifactClassificationType::MODULE) {
        return [](const Dependency& directDep) {
            return directDep.getScope() == PROVIDED || directDep.getScope() == COMPILE;
        };
    } else {
        return [](const Dependency& directDep) {
            return directDep.getScope() == PROVIDED
                || directDep.getArtifact().getClassifier() == MULE_PLUGIN_CLASSIFIER;
        };
    }
}","std::function<bool(const Dependency&)> getContainerDirectDependenciesFilter(ArtifactClassificationType rootArtifactType) {
    if (rootArtifactType == MODULE) {
        return [](const Dependency& directDep) {
            return directDep.getScope() == PROVIDED || directDep.getScope() == COMPILE;
        };
    } else {
        return [](const Dependency& directDep) {
            return directDep.getScope() == PROVIDED
                || directDep.getArtifact().getClassifier() == MULE_PLUGIN_CLASSIFIER;
        };
    }
}",0
"throw FetchError(fmt::format(""Will not fetch {}"", spec.format(""$_$@"")), ck_msg);

stage.create();
stage.fetch(mirror_only);

if (spack.do_checksum && versions.count(version)) {","stage.create();
stage.fetch(mirror_only);

_fetch_time = std::chrono::duration<double>(std::chrono::steady_clock::now() - start_time).count();

if (spack::do_checksum && versions.count(version)) {",1
"std::vector<std::string> items = {""ordered"", ""insert"", ""count"", ""find"", ""create""};

JsonWriterSettings* createJsonWriterSettings(int maxNormalizedQueryLength) {
    JsonWriterSettings* settings = nullptr;
    try {
        // The static JsonWriterSettings::builder() method was introduced in the 3.5 release
        std::optional<std::function<void()>> buildMethod;
        // ... (rest of logic)
    } catch (...) {
        // handle exception if necessary
    }
    return settings;
}","```cpp
#include <optional>
#include <vector>
#include <string>

std::vector<std::string> someList = {""ordered"", ""insert"", ""count"", ""find"", ""create""};

class JsonWriterSettings {
public:
    JsonWriterSettings(bool) {}
    // ... implementation
};

std::optional<JsonWriterSettings> createJsonWriterSettings(int maxNormalizedQueryLength) {
    std::optional<JsonWriterSettings> settings = std::nullopt;
    try {
        // The rest of the logic would go here
    } catch (...) {
        // Handle exceptions if needed
    }
    return settings;
}
```",0
"auto unlistenPromise = nullptr;
if (!selector || selector == "":root"" || selector == "":host"") {
    unlistenPromise = visibilityManagerPromise.then(
        [=](auto visibilityManager) {
            return visibilityManager->listenRoot(
                visibilitySpec,
                this->getReadyPromise(waitForSpec, selector),
                createReportReadyPromiseFunc,
                std::bind(&ClassName::onEvent_, this, eventType, listener, this->root.getRootElement())
            );
        },
        [](){}
    );
} else {
    std::string selectionMethod = config.count(""selectionMethod"") ? config[""selectionMethod""] : visibilitySpec[""selectionMethod""];
    unlistenPromise = this->root.getAmpElement(
        context.parentElement ? context.parentElement : context,
        selector,
        selectionMethod
    ).then([=](auto element) {
        return visibilityManagerPromise.then(
            [=](auto visibilityManager) {
                return visibilityManager->listenElement(
                    element,
                    visibilitySpec,
                    this->getReadyPromise(waitForSpec, selector, element),
                    createReportReadyPromiseFunc,
                    std::bind(&ClassName::onEvent_, this, eventType, listener, element)
                );
            },
            [](){}
        );
    });
}
return [=]() {
    unlistenPromise.then([](auto unlisten) {
        unlisten();
    });
};","```cpp
std::function<void()> func = [=]() {
    std::shared_ptr<std::future<void>> unlistenPromise;

    if (!selector || selector == "":root"" || selector == "":host"") {
        // Return a promise resolved when visibilityManagerPromise completes
        unlistenPromise = std::make_shared<std::future<void>>(std::async(std::launch::async, [=]() {
            visibilityManagerPromise.then([=](auto visibilityManager) {
                return visibilityManager->listenRoot(
                    visibilitySpec,
                    getReadyPromise(waitForSpec, selector),
                    createReportReadyPromiseFunc,
                    std::bind(&VisibilityTracker::onEvent_, this, eventType, listener, root->getRootElement())
                );
            }).get();
        }));
    } else {
        std::string selectionMethod = config.count(""selectionMethod"") ? config[""selectionMethod""] : visibilitySpec[""selectionMethod""];
        unlistenPromise = std::make_shared<std::future<void>>(std::async(std::launch::async, [=]() {
            root->getAmpElement(
                (context->parentElement ? context->parentElement : context),
                selector,
                selectionMethod
            ).then([=](auto element) {
                visibilityManagerPromise.then([=](auto visibilityManager) {
                    return visibilityManager->listenElement(
                        element,
                        visibilitySpec,
                        getReadyPromise(waitForSpec, selector, element),
                        createReportReadyPromiseFunc,
                        std::bind(&VisibilityTracker::onEvent_, this, eventType, listener, element)
                    );
                }).get();
            }).get();
        }));
    }
    return [=]() {
        unlistenPromise->wait();
        // If unlisten() returns a callable/future, call/wait it here
    };
};
```",1
"constexpr const char* COMPACTION_PRIORITIZER_ALIAS = ""compaction_prioritization_prioritizerAlias"";
constexpr const char* COMPACTION_ESTIMATOR = ""compaction_prioritization_estimator"";

/***
 * Configuration properties related to Re-compaction
 */
inline std::string COMPACTION_DIRECTORY_FORMAT = ""compaction_%s"";
inline std::string RECOMPACTION_WRITE_TO_NEW_FOLDER = ""recompaction.write.to.new.folder"";


/**
 * Configuration related to ConfigStore based copy/retention
 */","```cpp
#include <string>

class ConfigurationKeys {
public:
    static const std::string COMPACTION_PRIORITIZER_ALIAS;
    static const std::string COMPACTION_ESTIMATOR;

    // Configuration properties related to Re-compaction
    static std::string COMPACTION_DIRECTORY_FORMAT;
    static std::string RECOMPACTION_WRITE_TO_NEW_FOLDER;
};

const std::string ConfigurationKeys::COMPACTION_PRIORITIZER_ALIAS = ConfigurationKeys::COMPACTION_PRIORITIZATION_PREFIX + ""prioritizerAlias"";
const std::string ConfigurationKeys::COMPACTION_ESTIMATOR = ConfigurationKeys::COMPACTION_PRIORITIZATION_PREFIX + ""estimator"";

std::string ConfigurationKeys::COMPACTION_DIRECTORY_FORMAT = ""compaction_%s"";
std::string ConfigurationKeys::RECOMPACTION_WRITE_TO_NEW_FOLDER = ""recompaction.write.to.new.folder"";
```",1
"if (!cidr.empty() && ntwkOff.getGuestType() == Network::GuestType::Isolated && ntwkOff.getTrafficType() == TrafficType::Guest) {
    Vpc vpc = _vpcMgr.getActiveVpc(vpcId);
    if (_vpcOffServiceDao.areServicesSupportedByNetworkOffering(vpc.getVpcOfferingId(), Service::VPCDynamicRouting)) {
        _dcDao.loadDetails(zone);
        try {
            std::vector<CIDR> superCidr = _vpcMgr.getZoneSuperCidrList(zoneId);
            CIDR ncidr = CIDRFactory::getCIDR(cidr);
            if (!NetUtils::validateGuestCidrForOSPF(ncidr, superCidr)) {
                throw InvalidParameterValueException(""Virtual Guest Cidr "" + cidr + "" is not compliant for this dynamically routed network."");
            }
        } catch (const BadCIDRException& ex) {
            throw InvalidParameterValueException(""Virtual Guest Cidr "" + cidr + "" is not compliant for this dynamically routed network."");
        }
    } else {
        if (!NetUtils::validateGuestCidr(cidr)) {
            throw InvalidParameterValueException(""Virtual Guest Cidr "" + cidr + "" is not RFC1918 compliant"");
        }
    }
}","if (!cidr.empty() && ntwkOff.getGuestType() == Network::GuestType::Isolated && ntwkOff.getTrafficType() == TrafficType::Guest) {
    Vpc vpc = _vpcMgr.getActiveVpc(vpcId);
    if (_vpcOffServiceDao.areServicesSupportedByNetworkOffering(vpc.getVpcOfferingId(), Service::VPCDynamicRouting)) {
        _dcDao.loadDetails(zone);
        try {
            std::vector<CIDR> superCidr = _vpcMgr.getZoneSuperCidrList(zoneId);
            CIDR ncidr = CIDRFactory::getCIDR(cidr);
            if (!NetUtils::validateGuestCidrForOSPF(ncidr, superCidr)) {
                throw InvalidParameterValueException(""Virtual Guest Cidr "" + cidr + "" is not compliant for this dynamically routed network."");
            }
        }
        catch (const BadCIDRException&) {
            throw InvalidParameterValueException(""Virtual Guest Cidr "" + cidr + "" is not compliant for this dynamically routed network."");
        }
    } else {
        if (!NetUtils::validateGuestCidr(cidr)) {
            throw InvalidParameterValueException(""Virtual Guest Cidr "" + cidr + "" is not RFC1918 compliant"");
        }
    }
}",1
"#include <string>
#include <vector>
#include <memory>

class TemporaryFolder {};
class TestRule {};
class AbstractFtpTestHarness {};
class FtpTestHarness {};
class FileAttributes {};
class FtpFileAttributes {};
class SftpFileAttributes {};
class SftpClient {};
class SftpClientFactory {};
class SftpServer {};
class DynamicPort {};

#include <sstream>
#include <iostream>","#include <string>
#include <vector>
#include <memory>

class AbstractFtpTestHarness;
class FtpTestHarness;
class FileAttributes;
class FtpFileAttributes;
class SftpFileAttributes;
class SftpClient;
class SftpClientFactory;
class SftpServer;

class TemporaryFolder {};
class TestRule {};
class DynamicPort {};

#include <sstream>
#include <iostream>
#include <fstream>",0
"// No equivalent C++ code, as these are specific to the Android Java SDK and AndroidX.
// The libraries and classes (Color, ColorDrawable, Drawable, ContextCompat, RecyclerView, LayoutInflater) do not have direct counterparts in standard C++.","#include <string>
#include <vector>
#include <memory>
#include <optional>
#include <cstdint>

#include <QColor>
#include <QPixmap>
#include <QWidget>
#include <QLayout>",0
"```cpp
class SingleRequestAdvice {
public:
    static void methodEnter(HttpRequest& request, Span& span, Scope& scope) {
        // Versions 10.0 and 10.1 have slightly different structure that is hard to distinguish so here
        // we cast 'wider net' and avoid instrumenting twice.
    }
};
```","struct SingleRequestAdvice {
  static void methodEnter(HttpRequest& request, Span& span, Scope& scope) {
    /*
    Versions 10.0 and 10.1 have slightly different structure that is hard to distinguish so here
    we cast 'wider net' and avoid instrumenting twice.
    */
  }
};",1
"template <typename Option, typename HoodieTableMetadataWriter>
Option getMetadataWriter(const std::string& inFlightInstantTimestamp) {
    return getMetadataWriter(inFlightInstantTimestamp, Option{});
}","virtual std::optional<HoodieTableMetadataWriter> getMetadataWriter(const std::string& inFlightInstantTimestamp) final {
    return getMetadataWriter(inFlightInstantTimestamp, std::nullopt);
}",1
"#include <vector>
#include <map>
#include <set>
#include <string>
#include <algorithm>","#include <vector>
#include <array>
#include <unordered_map>
#include <unordered_set>
#include <list>",0
"#include <vector>
#include <string>
#include <map>
#include <set>
#include <mutex>
#include <algorithm>
#include <memory>

template<typename T>
class HoodieColumnRangeMetadata {
public:
    HoodieColumnRangeMetadata(
        const std::string& parquetFileName,
        const std::string& columnName,
        const T& min,
        const T& max,
        int64_t numNulls,
        const std::string& minAsString,
        const std::string& maxAsString)
        : parquetFileName_(parquetFileName),
          columnName_(columnName),
          min_(min),
          max_(max),
          numNulls_(numNulls),
          minAsString_(minAsString),
          maxAsString_(maxAsString) {}

    const std::string& getColumnName() const { return columnName_; }

private:
    std::string parquetFileName_;
    std::string columnName_;
    T min_;
    T max_;
    int64_t numNulls_;
    std::string minAsString_;
    std::string maxAsString_;
};

class Configuration {};
class Path {
public:
    Path(const std::string& name) : name_(name) {}
    std::string getName() const { return name_; }
private:
    std::string name_;
};

enum class OriginalType {
    NONE,
    DATE
};

class Statistics {
public:
    template<typename T>
    T genericGetMin() const;
    template<typename T>
    T genericGetMax() const;
    int64_t getNumNulls() const;
    std::string minAsString() const;
    std::string maxAsString() const;
};

class PrimitiveType {
public:
    OriginalType getOriginalType() const;
    std::string stringifier() const;
};

class ColumnPath {
public:
    std::string toDotString() const;
};

class ColumnChunkMetaData {
public:
    const ColumnPath& getPath() const;
    const Statistics& getStatistics() const;
    const PrimitiveType& getPrimitiveType() const;
};

class BlockMetaData {
public:
    const std::vector<ColumnChunkMetaData>& getColumns() const;
};

class ParquetMetadata {
public:
    const std::vector<BlockMetaData>& getBlocks() const;
};

ParquetMetadata readMetadata(Configuration& conf, const Path& parquetFilePath);

std::mutex lock;

std::vector<std::shared_ptr<HoodieColumnRangeMetadata<std::string","#include <vector>
#include <string>
#include <map>
#include <mutex>
#include <algorithm>

template<typename T>
class HoodieColumnRangeMetadata {
public:
    HoodieColumnRangeMetadata(
        const std::string& fileName,
        const std::string& columnName,
        const T& min,
        const T& max,
        int64_t numNulls,
        const std::string& minAsString,
        const std::string& maxAsString
    ) :
        fileName_(fileName),
        columnName_(columnName),
        min_(min),
        max_(max),
        numNulls_(numNulls),
        minAsString_(minAsString),
        maxAsString_(maxAsString)
    {}

    const std::string& getColumnName() const { return columnName_; }

private:
    std::string fileName_;
    std::string columnName_;
    T min_;
    T max_;
    int64_t numNulls_;
    std::string minAsString_;
    std::string maxAsString_;
};

enum class OriginalType {
    OTHER,
    DATE
};

class PrimitiveType {
public:
    OriginalType getOriginalType() const;
};

class Statistics {
public:
    template<typename T>
    T genericGetMin() const;

    template<typename T>
    T genericGetMax() const;

    int64_t getNumNulls() const;

    std::string minAsString() const;
    std::string maxAsString() const;
};

class ColumnPath {
public:
    std::string toDotString() const;
};

class ColumnChunkMetaData {
public:
    ColumnPath getPath() const;
    const Statistics& getStatistics() const;
    const PrimitiveType& getPrimitiveType() const;
};

class BlockMetaData {
public:
    const std::vector<ColumnChunkMetaData>& getColumns() const;
};

class ParquetMetadata {
public:
    const std::vector<BlockMetaData>& getBlocks() const;
};

class Configuration {};
class Path {
public:
    std::string getName() const;
};

ParquetMetadata readMetadata(const Configuration& conf, const Path& parquetFilePath);

std::mutex lock;

std::vector<HoodieColumnRangeMetadata<std::string>> readRangeFromParquetMetadata(
    const Configuration& conf,
    const Path& parquetFilePath,
    const std::vector<std::string>& cols
) {
    ParquetMetadata metadata = readMetadata(conf, parquetFilePath);

    std",1
"}
CardBrowserContextMenu::ensureConsistentStateWithSharedPreferences(this);

setLanguage(preferences.getString(Preferences::LANGUAGE, """"));

NotificationChannels::setup(getApplicationContext());","CardBrowserContextMenu::ensureConsistentStateWithSharedPreferences(this);
NotificationChannels::setup(getApplicationContext());",0
"#include ""Invoker.h""
#include ""RpcContext.h""
#include ""RpcException.h""
#include ""cluster/router/AbstractRouter.h""

#include <script/Bindings.h>
#include <script/Compilable.h>","#include <string>
#include <map>
#include <memory>

#include ""Invocation.h""
#include ""Invoker.h""
#include ""RpcContext.h""
#include ""RpcException.h""
#include ""cluster/router/AbstractRouter.h""

#include <script/Bindings.h>
#include <script/Compilable.h>",0
"```cpp
#include ""Cleanable.h""
#include ""ObjectOutput.h""
#include ""Hessian2FactoryInitializer.h""
```","#include ""org/apache/dubbo/common/serialize/Cleanable.h""
#include ""org/apache/dubbo/common/serialize/ObjectOutput.h""
#include ""org/apache/dubbo/common/serialize/hessian2/dubbo/Hessian2FactoryInitializer.h""",0
"auto element = nullptr;
try {
    if (selectionMethod == ""closest"") {
        element = closest(
            requireTarget_(),
            [selector](auto* element) { return matches(element, selector); },
            scope_
        );
    } else {
        element = scopedQuerySelector_(selector);
    }
} catch (const std::exception& e) {
    throw user().createError(""Bad query selector: \"""" + selector + ""\"""", e);
}","```cpp
Element* CssContextImpl::findElement(const std::string& selectionMethod, const std::string& selector) {
    Element* element = nullptr;
    try {
        if (selectionMethod == ""closest"") {
            element = closest(
                requireTarget_(),
                [&](Element* el) { return matches(el, selector); },
                scope_
            );
        } else {
            element = scopedQuerySelector_(selector);
        }
    } catch (const std::exception& e) {
        throw user().createError(""Bad query selector: \"""" + selector + ""\"""", e);
    }
    return element;
}
```",1
"#include <stdexcept>
#include <functional>
#include <memory>","#include <gtest/gtest.h>
#include <stdexcept>
#include <memory>
#include <functional>
#include <any>
#include <string>",0
"return SearchResult(r.getHits(), indices, config.query(), request.source(), r.getTook());
}

std::optional<std::string> getIndexPrefixForFilter(const std::string& filter) {
    auto streamId = extractStreamId(filter);
    std::optional<std::string> indexPrefix = std::nullopt;
    if (streamId.has_value()) {
        try {
            Stream stream = streamService.load(streamId.value());
            indexPrefix = stream.getIndexSet().getIndexPrefix();
        } catch (const NotFoundException&) {
        }
    }
    return indexPrefix;
}

TermsResult terms(const std::string& field, int size, const std::string& query, const std::string& filter, const TimeRange& range) {
    if (size == 0) {
        size = 50;
    }

    auto indexPrefixOpt = getIndexPrefixForFilter(filter);
    std::string indexPrefix = indexPrefixOpt.has_value() ? indexPrefixOpt.value() : """";

    SearchRequestBuilder srb;
    if (filter.empty()) {
        srb = standardSearchRequest(query, IndexHelper::determineAffectedIndices(indexRangeService, range, indexPrefix), range);
    } else {
        srb = filteredSearchRequest(query, filter, IndexHelper::determineAffectedIndices(indexRangeService, range, indexPrefix), range);
    }

    FilterAggregationBuilder builder = AggregationBuilders::filter(AGG_FILTER);
    // ... (rest of the method)
}","#include <optional>
#include <string>

class Searches {
private:
    std::optional<std::string> extractStreamId(const std::string& filter);
    StreamService streamService;
    IndexRangeService indexRangeService;
    static constexpr int DEFAULT_SIZE = 50;

    std::optional<std::string> getIndexPrefixForFilter(const std::string& filter) {
        auto streamId = extractStreamId(filter);
        std::optional<std::string> indexPrefix;
        if (streamId) {
            try {
                Stream stream = streamService.load(*streamId);
                indexPrefix = stream.getIndexSet().getIndexPrefix();
            } catch (const NotFoundException&) {
                // ignored
            }
        }
        return indexPrefix;
    }

public:
    TermsResult terms(const std::string& field, int size, const std::string& query, const std::string& filter, const TimeRange& range) {
        int effectiveSize = size == 0 ? DEFAULT_SIZE : size;

        auto indexPrefix = getIndexPrefixForFilter(filter);
        SearchRequestBuilder srb;
        if (filter.empty()) {
            srb = standardSearchRequest(query, IndexHelper::determineAffectedIndices(indexRangeService, range, indexPrefix), range);
        } else {
            srb = filteredSearchRequest(query, filter, IndexHelper::determineAffectedIndices(indexRangeService, range, indexPrefix), range);
        }

        FilterAggregationBuilder builder = AggregationBuilders::filter(AGG_FILTER);
        // ... rest of implementation
    }
};",0
"#include <string>
#include <memory>
#include <cassert>
#include <optional>
#include <uuid/uuid.h>

static const std::string MESSAGE_GROUP_KEY_PREFIX = ""MESSAGE_GROUP_"";

/**
 * Represents the time when the message has been added to the store.
 * @deprecated since 5.0. This constant isn't used any more.
 */
[[deprecated(""since 5.0. This constant isn't used any more."")]]
static const std::string CREATED_DATE = ""CREATED_DATE"";

class Message {
    // ...
};

class MessageStore {
public:
    virtual std::shared_ptr<Message> getMessage(const std::string& messageId) {
        assert(!messageId.empty() && ""'messageId' must not be null"");
        std::shared_ptr<Message> message = std::dynamic_pointer_cast<Message>(doRetrieve(MESSAGE_KEY_PREFIX + messageId));
        if (message) {
            // Optionally: assert(dynamic_cast<Message*>(message.get()) != nullptr);
        }
        return message;
    }
protected:
    static const std::string MESSAGE_KEY_PREFIX;
    virtual std::shared_ptr<void> doRetrieve(const std::string& key) = 0;
};

const std::string MessageStore::MESSAGE_KEY_PREFIX = ""MESSAGE_"";","```cpp
#include <string>
#include <memory>
#include <cassert>
#include <uuid/uuid.h>

class Message {
    // Message class definition here
};

class AbstractKeyValueMessageStore {
protected:
    static constexpr const char* MESSAGE_GROUP_KEY_PREFIX = ""MESSAGE_GROUP_"";

    [[deprecated(""since 5.0. This constant isn't used any more."")]]
    static constexpr const char* CREATED_DATE = ""CREATED_DATE"";

public:
    std::shared_ptr<Message> getMessage(const uuid_t& messageId) {
        assert(messageId != nullptr && ""'messageId' must not be null"");
        std::string key = MESSAGE_KEY_PREFIX + uuidToString(messageId);
        std::shared_ptr<void> raw = doRetrieve(key);
        if (raw) {
            std::shared_ptr<Message> message = std::dynamic_pointer_cast<Message>(raw);
            assert(message && ""Retrieved object is not of type Message"");
            return message;
        }
        return nullptr;
    }

protected:
    static constexpr const char* MESSAGE_KEY_PREFIX = ""MESSAGE_"";

    virtual std::shared_ptr<void> doRetrieve(const std::string& key) = 0;

private:
    static std::string uuidToString(const uuid_t& uuid) {
        char buffer[37];
        uuid_unparse_lower(uuid, buffer);
        return std::string(buffer);
    }
};
```",1
"```cpp
capabilities[Service::SourceNat] = sourceNatCapabilities;

capabilities[Service::StaticNat] = nullptr;

std::map<Capability, std::string>* portForwardingCapabilities = new std::map<Capability, std::string>();
(*portForwardingCapabilities)[Capability::SupportedProtocols] = NetUtils::TCP_PROTO + std::string("","") + NetUtils::UDP_PROTO;
capabilities[Service::PortForwarding] = portForwardingCapabilities;

return capabilities;
}
```","std::map<Service, std::map<Capability, std::string>*> capabilities;

capabilities[Service::SourceNat] = &sourceNatCapabilities;

capabilities[Service::StaticNat] = nullptr;

auto portForwardingCapabilities = new std::map<Capability, std::string>();
(*portForwardingCapabilities)[Capability::SupportedProtocols] = NetUtils::TCP_PROTO + "","" + NetUtils::UDP_PROTO;
capabilities[Service::PortForwarding] = portForwardingCapabilities;

return capabilities;",1
"private:
ErrorType getErrorType(const ErrorModel& errorModel) {
    ComponentIdentifier identifier = createIdentifier(errorModel.getType(), errorModel.getNamespace());
    std::optional<ErrorType> optionalError = errorTypeRepository.getErrorType(identifier);
    if (optionalError.has_value()) {
        return optionalError.value();
    } else {
        return createErrorType(errorModel, identifier);
    }
}","ErrorType getErrorType(const ErrorModel& errorModel) {
    ComponentIdentifier identifier = createIdentifier(errorModel.getType(), errorModel.getNamespace());
    std::optional<ErrorType> optionalError = errorTypeRepository.getErrorType(identifier);
    if (optionalError.has_value()) {
        return optionalError.value();
    } else {
        return createErrorType(errorModel, identifier);
    }
}",1
"```cpp
HoodieLogBlock readBlock() {
    int blocksize = -1;
    int ordinal = -1;
    HoodieLogBlockType blockType;
    std::map<HeaderMetadataType, std::string> header;

    try {
        if (isOldMagic()) {
            ordinal = inputStream.readInt();
            if (ordinal >= HoodieLogBlockType::values().size()) {
                throw std::invalid_argument(""Invalid block byte ordinal found "" + std::to_string(ordinal));
            }
            blockType = HoodieLogBlockType::values().at(ordinal);
            blocksize = inputStream.readInt();
        } else {
            blocksize = inputStream.readInt();
        }
    } catch (const std::exception& e) {
        return createCorruptBlock();
    }

    // We may have had a crash which could have written this block partially
    // Skip blocksize in the stream and we should either find a sync marker (start of the next block) or EOF
}
```","```cpp
HoodieLogBlock readBlock() {
    int blocksize = -1;
    int ordinal = -1;
    HoodieLogBlockType blockType;
    std::map<HeaderMetadataType, std::string> header;

    try {
        if (isOldMagic()) {
            ordinal = inputStream.readInt();
            if (!(ordinal < HoodieLogBlockType::values().size())) {
                throw std::invalid_argument(""Invalid block byte ordinal found "" + std::to_string(ordinal));
            }
            blockType = HoodieLogBlockType::values().at(ordinal);
            blocksize = inputStream.readInt();
        } else {
            blocksize = inputStream.readInt();
        }
    } catch (const std::exception& e) {
        return createCorruptBlock();
    }

    // ... rest of function
}
```",1
"if (key.empty())
{
    logger.warn(
        createStaticMessage(""Detected a lookup attempt with an empty or null key""),
        std::make_exception_ptr(std::runtime_error(""Stack trace""))
    );
    return nullptr;
}","if (key.empty())
{
    logger.warn(
        createStaticMessage(""Detected a lookup attempt with an empty or null key""),
        std::make_exception_ptr(std::runtime_error("""")));
    return nullptr;
}",0
"#include <typeinfo>
#include <cstddef>
#include <cstdint>","#include <typeinfo>
#include <type_traits>
#include <cstddef>

class VM {};
class JITHelpers {};

// PrimitiveHandle is a subclass of MethodHandle used for grouping MethodHandles that directly refer a C++-level function.",0
"ProxyConfig getProxyConfig() const {
    return proxyConfig;
}

void setProxyConfig(const ProxyConfig& proxyConfig) {
    this->proxyConfig = proxyConfig;
}","public:
    ProxyConfig getProxyConfig() const
    {
        return proxyConfig;
    }

    void setProxyConfig(const ProxyConfig& proxyConfig)
    {
        this->proxyConfig = proxyConfig;
    }",1
"#include <regex>
#include <fstream>
#include <string>
#include <set>

class FlagProcessor {
public:
    std::set<std::string> setFlags;
    std::set<std::string> seenFlags;

    void processCacheInfo(const std::string& cacheInfo) {
        std::regex cacheVarPattern(R""((\w+):BOOL=(.*)$)"");
        std::ifstream infile(cacheInfo);
        std::string line;
        while (std::getline(infile, line)) {
            std::smatch matcher;
            if (std::regex_match(line, matcher, cacheVarPattern)) {
                std::string flagName = matcher[1];
                bool flagValue = strToBool(matcher[2]);
                if (flagName.rfind(""J9VM_"", 0) == 0) {
                    flagName = Util::transformFlag(flagName);
                    if (flagValue) {
                        setFlags.insert(flagName);
                    }
                    seenFlags.insert(flagName);
                }
            }
        }
    }

    std::set<std::string> getAllSetFlags() const {
        return setFlags;
    }

    bool isFlagValid(const std::string& flagName) const {
        // TODO: We need to properly define all the flags from cmake before we turn this on
        // return seenFlags.find(Util::transformFlag(flagName)) != seenFlags.end();
        return true;
    }

private:
    static bool strToBool(const std::string& value) {
        return value == ""ON"" || value == ""TRUE"" || value == ""1"";
    }

    struct Util {
        static std::string transformFlag(const std::string& flag) {
            // Implement as needed
            return flag;
        }
    };
};","#include <fstream>
#include <regex>
#include <string>
#include <set>

class CmakeFlagInfo /* : public IFlagInfo */ {
private:
    std::set<std::string> setFlags;
    std::set<std::string> seenFlags;

    bool strToBool(const std::string& s) {
        return s == ""ON"" || s == ""TRUE"" || s == ""1"";
    }

    std::string transformFlag(const std::string& flagName) {
        // Assuming Util.transformFlag is similar to identity for now
        // Replace with actual transformation logic if necessary
        return flagName;
    }

public:
    CmakeFlagInfo(const std::string& cacheInfo) {
        std::regex cacheVarPattern(R""(([a-zA-Z0-9_]+):BOOL=(.*)$)"");
        std::ifstream file(cacheInfo);
        std::string line;

        while (std::getline(file, line)) {
            std::smatch matcher;
            if (std::regex_match(line, matcher, cacheVarPattern)) {
                std::string flagName = matcher[1].str();
                bool flagValue = strToBool(matcher[2].str());

                if (flagName.rfind(""J9VM_"", 0) == 0) {
                    flagName = transformFlag(flagName);
                    if (flagValue) {
                        setFlags.insert(flagName);
                    }
                    seenFlags.insert(flagName);
                }
            }
        }
    }

    std::set<std::string> getAllSetFlags() const {
        return setFlags;
    }

    bool isFlagValid(const std::string& flagName) const {
        // TODO: properly define all flags from cmake before enabling this check
        // return seenFlags.count(transformFlag(flagName)) > 0;
        return true;
    }
};",1
"#include <fstream>
#include <vector>
#include <array>
#include <unordered_map>
#include <unordered_set>
#include <iterator>
#include <list>
#include <set>
#include <algorithm>
#include <numeric>","#include <fstream>
#include <iostream>
#include <vector>
#include <array>
#include <unordered_map>
#include <unordered_set>
#include <iterator>
#include <algorithm>
#include <numeric>
#include <string>",0
"template <typename Option, typename Pair, typename HoodieInstant, typename HoodieClusteringPlan, typename HoodieTableMetaClient, typename HoodieRequestedReplaceMetadata, typename WriteOperationType, typename HoodieTimeline, typename TimelineMetadataUtils, typename HoodieIOException, typename LOG>
Option<Pair<HoodieInstant, HoodieClusteringPlan>> getClusteringPlan(HoodieTableMetaClient& metaClient, const HoodieInstant& pendingReplaceInstant) {
    try {
        HoodieInstant requestedInstant;
        if (!pendingReplaceInstant.isRequested()) {
            requestedInstant = HoodieTimeline::getReplaceCommitRequestedInstant(pendingReplaceInstant.getTimestamp());
        } else {
            requestedInstant = pendingReplaceInstant;
        }
        Option<std::vector<uint8_t>> content = metaClient.getActiveTimeline().getInstantDetails(requestedInstant);
        if (!content.isPresent() || content.get().empty()) {
            LOG::warn(""No content found in requested file for instant "" + pendingReplaceInstant.toString());
            return Option<Pair<HoodieInstant, HoodieClusteringPlan>>::empty();
        }
        HoodieRequestedReplaceMetadata requestedReplaceMetadata = TimelineMetadataUtils::deserializeRequestedReplaceMetadta(content.get());
        if (WriteOperationType::CLUSTER.name() == requestedReplaceMetadata.getOperationType()) {
            return Option<Pair<HoodieInstant, HoodieClusteringPlan>>::of(Pair<HoodieInstant, HoodieClusteringPlan>(pendingReplaceInstant, requestedReplaceMetadata.getClusteringPlan()));
        }
        return Option<Pair<HoodieInstant, HoodieClusteringPlan>>::empty();
    } catch (const std::ios_base::failure& e) {
        throw HoodieIOException(""Error reading clustering plan "" + pendingReplaceInstant.getTimestamp(), e);
    }
}","```cpp
#include <optional>
#include <utility>
#include <string>
#include <stdexcept>

class ClusteringUtils {
public:
    static std::optional<std::pair<HoodieInstant, HoodieClusteringPlan>>
    getClusteringPlan(HoodieTableMetaClient& metaClient, const HoodieInstant& pendingReplaceInstant) {
        try {
            HoodieInstant requestedInstant;
            if (!pendingReplaceInstant.isRequested()) {
                // inflight replacecommit files don't have clustering plan.
                // This is because replacecommit inflight can have workload profile for 'insert_overwrite'.
                // Get the plan from corresponding requested instant.
                requestedInstant = HoodieTimeline::getReplaceCommitRequestedInstant(pendingReplaceInstant.getTimestamp());
            } else {
                requestedInstant = pendingReplaceInstant;
            }
            auto content = metaClient.getActiveTimeline().getInstantDetails(requestedInstant);
            if (!content.has_value() || content.value().empty()) {
                LOG::warn(""No content found in requested file for instant "" + pendingReplaceInstant.toString());
                return std::nullopt;
            }
            HoodieRequestedReplaceMetadata requestedReplaceMetadata = TimelineMetadataUtils::deserializeRequestedReplaceMetadta(content.value());
            if (requestedReplaceMetadata.getOperationType() == WriteOperationType::CLUSTER.name()) {
                return std::make_optional(std::make_pair(pendingReplaceInstant, requestedReplaceMetadata.getClusteringPlan()));
            }
            return std::nullopt;
        } catch (const std::ios_base::failure& e) {
            throw HoodieIOException(""Error reading clustering plan "" + pendingReplaceInstant.getTimestamp(), e);
        }
    }
};
```",1
"try {
    context = muleContextFactory.createMuleContext(""log4j2-test.xml"");
} catch (const ConfigurationException& e) {
    assert(std::string(e.what()) == ""No suitable configuration builder for resource \""[ConfigResource{resourceName='log4j2-test.xml'}]\"" found.  Check you have configuration module on your classpath and are using correct file extension."");
}
assert(context == nullptr);","std::unique_ptr<MuleContext> context;
try {
    context = muleContextFactory.createMuleContext(""log4j2-test.xml"");
} catch (const ConfigurationException& e) {
    EXPECT_EQ(
        ""No suitable configuration builder for resource \""[ConfigResource{resourceName='log4j2-test.xml'}]\"" found.  ""
        ""Check you have configuration module on your classpath and are using correct file extension."", 
        std::string(e.what())
    );
}
EXPECT_EQ(context, nullptr);",1
"#include <atomic>
#include <cstdint>
#include <future>

class YourClass {
private:
    std::atomic<bool> requiresReply;
    long lastSend;
    std::atomic<long> idleReplyContainerTimeout;
    std::future<void> idleTask;
};","```cpp
#include <atomic>
#include <future>
#include <cstdint>

class JmsOutboundGateway : public AbstractReplyProducingMessageHandler, public /* appropriate interfaces */ {
private:
    std::atomic<bool> requiresReply;

    int64_t lastSend = 0;

    std::atomic<int64_t> idleReplyContainerTimeout;

    std::future<void> idleTask;

    // ...
};
```",1
"UpdateT value = cell.getValue();
if (value != nullptr) {
    MetricKey key = MetricKey::create(stepName, cell.getName());
    auto update = MetricUpdates::MetricUpdate<UpdateT>::create(key, value, nullptr);
    updates.push_back(update);
}","if (auto value = cell.getValue()) {
    auto key = MetricKey::create(stepName, cell.getName());
    auto update = MetricUpdates::MetricUpdate<UpdateT>::create(key, value, nullptr);
    updates.push_back(update);
}",1
"#include <stdexcept>

class ExpressionFilterTestCase : public AbstractMuleContextTestCase {","#include <gtest/gtest.h>

class ExpressionFilterTestCase : public ::testing::Test {",0
"void start() override {
    this->running = true;
    this->fileSource.start();
}

void stop() override {
    this->running = false;
    try {
        this->fileSource.stop();
        this->synchronizer.close();
    } catch (const std::ios_base::failure& e) {
    }
}","void start() override {
    this->running = true;
    this->fileSource.start();
}

void stop() override {
    this->running = false;
    try {
        this->fileSource.stop();
        this->synchronizer.close();
    } catch (const std::ios_base::failure& e) {
    }
}",0
"auto timeline = metaClient.reloadActiveTimeline();
assert(timeline.getTimelineOfActions(
    CollectionUtils::createSet(HoodieTimeline::ROLLBACK_ACTION)).filterCompletedInstants().countInstants() == 3);

auto rollBackInstantForFailedCommit = timeline.getTimelineOfActions(
    CollectionUtils::createSet(HoodieTimeline::ROLLBACK_ACTION)).filterCompletedInstants().lastInstant();

auto rollbackMetadata = TimelineMetadataUtils::deserializeAvroMetadata(
    timeline.getInstantDetails(rollBackInstantForFailedCommit.get()).get(), HoodieRollbackMetadata::class_type());

assert(rollbackMetadata.getTotalFilesDeleted() == 3);","auto timeline = metaClient.reloadActiveTimeline();
assert(timeline.getTimelineOfActions(
    CollectionUtils::createSet(HoodieTimeline::ROLLBACK_ACTION)).filterCompletedInstants().countInstants() == 3);
auto rollBackInstantForFailedCommit = timeline.getTimelineOfActions(
    CollectionUtils::createSet(HoodieTimeline::ROLLBACK_ACTION)).filterCompletedInstants().lastInstant();
auto rollbackMetadata = TimelineMetadataUtils::deserializeAvroMetadata(
    timeline.getInstantDetails(rollBackInstantForFailedCommit.get()).value(), HoodieRollbackMetadata::classType());
assert(rollbackMetadata.getTotalFilesDeleted() == 3);",0
"static std::vector<Message> toMessageCollection(
    const std::vector<Result>& results,
    const CursorProviderFactory& cursorProviderFactory,
    const BaseEventContext& eventContext,
    const ComponentLocation& originatingLocation)
{
    return ResultsToMessageList(results, cursorProviderFactory, eventContext, originatingLocation);
}","static std::vector<Message> toMessageCollection(
    const std::vector<Result>& results,
    const CursorProviderFactory& cursorProviderFactory,
    const BaseEventContext& eventContext,
    const ComponentLocation& originatingLocation) {
    return ResultsToMessageList(results, cursorProviderFactory, eventContext, originatingLocation);
}",0
"#include <iomanip>
#include <sstream>
#include <algorithm>
#include <chrono>
#include <ctime>
#include <iterator>
#include <list>
#include <map>
#include <utility>
#include <random>
#include <thread>
#include <future>","#include <string>
#include <map>
#include <iterator>
#include <utility>
#include <chrono>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <random>
#include <thread>
#include <future>
#include <vector>",0
"template <typename T>
class Builder {
public:
    virtual Builder<T>& setParseFn(std::function<T(const GenericRecord&)> parseFn) = 0;

    virtual Builder<T>& setConfiguration(const SerializableConfiguration& configuration) = 0;

    Builder<T>& setHadoopConfigurationFlags(const std::map<std::string, std::string>& flags) {
        return setConfiguration(makeHadoopConfigurationUsingFlags(flags));
    }

    virtual Builder<T>& setSplittable(bool splittable) = 0;

    virtual Parse<T> build() = 0;

    virtual ~Builder() = default;
};","```cpp
template <typename T>
class ParquetIO {
public:
    class Builder {
    public:
        virtual Builder& setParseFn(std::function<T(const GenericRecord&)> parseFn) = 0;

        virtual Builder& setConfiguration(const SerializableConfiguration& configuration) = 0;

        Builder& setHadoopConfigurationFlags(const std::map<std::string, std::string>& flags) {
            return setConfiguration(makeHadoopConfigurationUsingFlags(flags));
        }

        virtual Builder& setSplittable(bool splittable) = 0;

        virtual std::unique_ptr<Parse<T>> build() = 0;
    };
};
```",1
".withOptionalParameter(""defaultErrorHandler-ref"")
.ofType(typeLoader.load(typeid(std::string)))
.withExpressionSupport(NOT_SUPPORTED)
.withAllowedStereotypes({ERROR_HANDLER})
.describedAs(""The default error handler for every flow. This must be a reference to a global error handler."");

configuration.onDefaultParameterGroup();","parameterBuilder
    .withOptionalParameter(""defaultErrorHandler-ref"")
    .ofType(typeLoader.load(typeid(std::string)))
    .withExpressionSupport(NOT_SUPPORTED)
    .withAllowedStereotypes(std::vector<std::string>{ERROR_HANDLER})
    .describedAs(""The default error handler for every flow. This must be a reference to a global error handler."");

configuration.onDefaultParameterGroup();",1
"std::function<void()> RequestPresetsWarningPrompt;

void OnRequestPresetWarningPrompt() {
    if (RequestPresetsWarningPrompt)
        RequestPresetsWarningPrompt();
}","#include <functional>
#include <vector>

class SomeClass {
public:
    using Action = std::function<void()>;

    std::vector<Action> RequestPresetsWarningPromptHandlers;

    void addRequestPresetsWarningPromptHandler(const Action& handler) {
        RequestPresetsWarningPromptHandlers.push_back(handler);
    }

    void OnRequestPresetWarningPrompt() {
        for (const auto& handler : RequestPresetsWarningPromptHandlers) {
            if (handler) handler();
        }
    }
};",1
"// No direct equivalent required for static imports in C++
#include ""TestsLogConfigurationHelper.h""
#include ""LoggerFactory.h""

#include ""DefaultMuleEvent.h""
#include ""DefaultMuleMessage.h""
#include ""MessageExchangePattern.h""","#include ""mule/util/TestsLogConfigurationHelper.h""

#include ""slf4j/LoggerFactory.h""

#include ""mule/DefaultMuleEvent.h""
#include ""mule/DefaultMuleMessage.h""
#include ""mule/MessageExchangePattern.h""",0
"EmptyApplicationDescriptor(const std::filesystem::path& appLocation)
    : SuperClass(appLocation.filename().string())
{
    std::string configLocation = ""mule"" + std::string(1, std::filesystem::path::preferred_separator) + DEFAULT_CONFIGURATION_RESOURCE;
    setConfigResources({configLocation});
    std::filesystem::path configPathFile = appLocation / configLocation;
    setArtifactLocation(appLocation);
    setRootFolder(appLocation.parent_path());
    std::string configPath = configPathFile.string();
}","#include <string>
#include <filesystem>
#include <vector>

class ApplicationDescriptor {
public:
    ApplicationDescriptor(const std::string& name) {}
    void setConfigResources(const std::vector<std::string>& resources) {}
    void setArtifactLocation(const std::filesystem::path& location) {}
    void setRootFolder(const std::filesystem::path& folder) {}
};

class EmptyApplicationDescriptor : public ApplicationDescriptor {
public:
    static constexpr const char* DEFAULT_CONFIGURATION_RESOURCE = ""default-config.xml"";

    EmptyApplicationDescriptor(const std::filesystem::path& appLocation)
        : ApplicationDescriptor(appLocation.filename().string())
    {
        std::string configLocation = ""mule"" + std::string(1, std::filesystem::path::preferred_separator) + DEFAULT_CONFIGURATION_RESOURCE;
        setConfigResources({configLocation});
        std::filesystem::path configPathFile = appLocation / configLocation;
        setArtifactLocation(appLocation);
        setRootFolder(appLocation.parent_path());
        std::string configPath = configPathFile.string();
    }
};",1
"}
bind<SystemJobManager>().toProvider<SystemJobManagerProvider>();
bind<LdapConnector>().in(Scope::Singleton);
bind<LdapUserAuthenticator>().in(Scope::Singleton);
bind<DefaultSecurityManager>().toProvider<DefaultSecurityManagerProvider>().asEagerSingleton();","bind<SystemJobManager>().toProvider<SystemJobManagerProvider>();
bind<LdapConnector>().in(SingletonScope);
bind<LdapUserAuthenticator>().in(SingletonScope);
bind<DefaultSecurityManager>().toProvider<DefaultSecurityManagerProvider>().asEagerSingleton();",0
"assert(stateAddressWindows != nullptr && ""Cannot ensure window is active since it is neither ACTIVE nor NEW"");
if (stateAddressWindows != nullptr && stateAddressWindows->empty()) {
    stateAddressWindows->insert(window);
}","assert(stateAddressWindows != nullptr && ""Cannot ensure window is active since it is neither ACTIVE nor NEW"");
if (stateAddressWindows != nullptr && stateAddressWindows->empty()) {
    stateAddressWindows->insert(window);
}",1
"std::vector<ChannelInterceptor> getInterceptors() const override {
    return interceptors.getInterceptors();
}","std::vector<ChannelInterceptor*> getInterceptors() const override {
    return interceptors.getInterceptors();
}",1
"setKettleInit(kettleInit);
}

Result execute(const JobParams& iParams) {
    getLog().logMinimal(BaseMessages::getString(getPkgClazz(), ""Kitchen.Log.Starting""));
}","Result execute(const JobParams& iParams) {
    getLog().logMinimal(BaseMessages::getString(getPkgClazz(), ""Kitchen.Log.Starting""));
}",1
"#include <cassert>
#include <atomic>
#include <map>
#include <string>
#include <thread>
#include <vector>
#include <algorithm>
#include <condition_variable>
#include <memory>

class Message {
public:
    explicit Message(const std::string& payload) : payload_(payload) {}
    std::string toString() const { return payload_; }
private:
    std::string payload_;
};

class ScriptVariableGenerator {
public:
    virtual std::map<std::string, void*> generateScriptVariables(const Message& message) = 0;
    virtual ~ScriptVariableGenerator() = default;
};

class MessageProcessor {
public:
    virtual void processMessage(const Message& message) = 0;
    virtual ~MessageProcessor() = default;
};

// Dummy ScriptSource/Script for C++
using ScriptSource = std::string;

class GroovyScriptExecutingMessageProcessor : public MessageProcessor {
public:
    GroovyScriptExecutingMessageProcessor(const ScriptSource& script,
                                          std::shared_ptr<ScriptVariableGenerator> varGen)
        : script_(script), varGen_(std::move(varGen)) {}

    void processMessage(const Message& message) override {
        auto vars = varGen_->generateScriptVariables(message);
        auto* var1 = static_cast<std::atomic<int>*>(vars[""var1""]);
        auto* var2 = static_cast<std::atomic<int>*>(vars[""var2""]);
        var1->fetch_add(1);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        int maxVal = std::max(var1->load(), var2->load());
        var2->store(maxVal);
        var1->fetch_sub(1);
    }
private:
    ScriptSource script_;
    std::shared_ptr<ScriptVariableGenerator> varGen_;
};

class MyScriptVariableGenerator : public ScriptVariableGenerator {
public:
    MyScriptVariableGenerator(std::atomic<int>* v1, std::atomic<int>* v2)
        : var1_(v1), var2_(v2) {}
    std::map<std::string, void*> generateScriptVariables(const Message& message) override {
        return {
            { ""var1"", var1_ },
            { ""var2"", var2_ }
        };
    }
private:
    std::atomic<int>* var1_;
    std::atomic<int>* var2_;
};

void testInt3166GroovyScriptExecutingMessageProcessorPerformance() {
    Message message(""test"");

    std::atomic<int> var1","#include <gtest/gtest.h>
#include <atomic>
#include <map>
#include <memory>
#include <string>
#include <thread>
#include <vector>
#include <algorithm>
#include <condition_variable>
#include <future>
#include <chrono>

class Message {
public:
    explicit Message(const std::string& payload) : payload_(payload) {}
    const std::string& getPayload() const { return payload_; }
private:
    std::string payload_;
};

class ScriptVariableGenerator {
public:
    virtual ~ScriptVariableGenerator() = default;
    virtual std::map<std::string, void*> generateScriptVariables(const Message& message) = 0;
};

class ScriptSource {
public:
    ScriptSource(const std::string& script, const std::string& scriptClass) : script_(script), scriptClass_(scriptClass) {}
    const std::string& getScript() const { return script_; }
private:
    std::string script_;
    std::string scriptClass_;
};

class MessageProcessor {
public:
    virtual ~MessageProcessor() = default;
    virtual void processMessage(const Message& message) = 0;
};

class GroovyScriptExecutingMessageProcessor : public MessageProcessor {
public:
    GroovyScriptExecutingMessageProcessor(std::shared_ptr<ScriptSource> scriptSource,
                                          std::shared_ptr<ScriptVariableGenerator> variableGenerator)
        : scriptSource_(std::move(scriptSource)), variableGenerator_(std::move(variableGenerator)) {}

    void processMessage(const Message& message) override {
        auto variables = variableGenerator_->generateScriptVariables(message);
        auto* var1 = static_cast<std::atomic<int>*>(variables[""var1""]);
        auto* var2 = static_cast<std::atomic<int>*>(variables[""var2""]);
        var1->fetch_add(1);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        int v1 = var1->load();
        int v2 = var2->load();
        var2->store(std::max(v1, v2));
        var1->fetch_sub(1);
    }

private:
    std::shared_ptr<ScriptSource> scriptSource_;
    std::shared_ptr<ScriptVariableGenerator> variableGenerator_;
};

TEST(GroovyScriptExecutingMessageProcessorTests, testInt3166GroovyScriptExecutingMessageProcessorPerformance) {
    Message message(""test"");

    auto var1 = std::make_shared<std::atomic<int>>(0);
    auto var2 = std::make_shared<std::",1
"void setUserName(const std::string& userName) {
    this->userName = userName;
}","void setUserName(const std::string& userName) {
    this->userName = userName;
}",0
"protected:
    HiveDatasetFinder(FileSystem* fs, Properties properties, HiveMetastoreClientPool* clientPool,
                      EventSubmitter* eventSubmitter)
        : HiveDatasetFinder(fs, properties, clientPool, eventSubmitter,
                           ConfigClientCache::getClient(VersionStabilityPolicy::STRONG_LOCAL_STABILITY)) {}

    HiveDatasetFinder(FileSystem* fs, Properties properties, HiveMetastoreClientPool* clientPool,
                      EventSubmitter* eventSubmitter, ConfigClient* configClient)
        : properties(properties), clientPool(clientPool), fs(fs) {
    }","protected:
  HiveDatasetFinder(FileSystem* fs, Properties properties, HiveMetastoreClientPool* clientPool,
                    EventSubmitter* eventSubmitter)
    : HiveDatasetFinder(fs, properties, clientPool, eventSubmitter, ConfigClientCache::getClient(VersionStabilityPolicy::STRONG_LOCAL_STABILITY)) {}

  HiveDatasetFinder(FileSystem* fs, Properties properties, HiveMetastoreClientPool* clientPool,
                    EventSubmitter* eventSubmitter, ConfigClient* configClient)
    : properties(properties),
      clientPool(clientPool),
      fs(fs) {}",1
"std::string format;

protected:
std::string hypervisor;

private:
std::optional<bool> featured;","class RegisterTemplateCmd : public BaseCmd {
private:
    std::string format;

protected:
    std::string hypervisor;

private:
    bool featured;
};",1
"auto nextBlockVersion = readVersion();

HoodieLogBlockType blockType = tryReadBlockType(nextBlockVersion);

std::map<HeaderMetadataType, std::string> header =
    nextBlockVersion.hasHeader() ? HoodieLogBlock::getLogMetadata(inputStream) : std::map<HeaderMetadataType, std::string>();

int contentLength =
    nextBlockVersion.getVersion() != HoodieLogFormatVersion::DEFAULT_VERSION ? static_cast<int>(inputStream.readLong()) : blockSize;

bool shouldReadLazily = readBlockLazily && nextBlockVersion.getVersion() != HoodieLogFormatVersion::DEFAULT_VERSION;
std::optional<std::vector<uint8_t>> content = HoodieLogBlock::tryReadContent(inputStream, contentLength, shouldReadLazily);

std::map<HeaderMetadataType, std::string> footer =
    nextBlockVersion.hasFooter() ? HoodieLogBlock::getLogMetadata(inputStream) : std::map<HeaderMetadataType, std::string>();

if (nextBlockVersion.hasLogBlockLength()) {
    inputStream.readLong();
}

long blockEndPos = inputStream.getPos();

switch (blockType) {
    case HoodieLogBlockType::AVRO_DATA_BLOCK:
        if (nextBlockVersion.getVersion() == HoodieLogFormatVersion::DEFAULT_VERSION) {
            return HoodieAvroDataBlock::getBlock(*content, readerSchema);
        } else {
            return HoodieAvroDataBlock(logFile, inputStream, content, readBlockLazily,
                                      contentPosition, contentLength, blockEndPos,
                                      readerSchema ? std::make_optional(readerSchema) : std::nullopt,
                                      header, footer, keyField);
        }
    case HoodieLogBlockType::HFILE_DATA_BLOCK:
        checkState(nextBlockVersion.getVersion() != HoodieLogFormatVersion::DEFAULT_VERSION,
            ""HFile block could not be of version ("" + std::to_string(HoodieLogFormatVersion::DEFAULT_VERSION) + "")"");
        return HoodieHFileDataBlock(logFile, inputStream, content, readBlockLazily,
                                    contentPosition, contentLength, blockEndPos,
                                    readerSchema ? std::make_optional(readerSchema) : std::nullopt,
                                    header, footer, keyField, enableRecordLookups);
    case HoodieLogBlockType::PARQUET_DATA_BLOCK:
        checkState(nextBlockVersion.getVersion() != HoodieLogFormatVersion::DEFAULT_VERSION,
            ""Parquet block could not be of version","```cpp
HoodieLogBlockType tryReadBlockType(const HoodieLogFormat::LogFormatVersion& blockVersion) {
    if (blockVersion.getVersion() == HoodieLogFormatVersion::DEFAULT_VERSION) {
        return HoodieLogBlockType::INVALID;
    }
    int type = inputStream.readInt();
    checkArgument(type < static_cast<int>(HoodieLogBlockType::MAX_TYPE), ""Invalid block byte type found "" + std::to_string(type));
    return static_cast<HoodieLogBlockType>(type);
}

std::optional<HoodieLogBlock> HoodieLogFileReader::readNextBlock() {
    HoodieLogFormat::LogFormatVersion nextBlockVersion = readVersion();

    HoodieLogBlockType blockType = tryReadBlockType(nextBlockVersion);

    std::map<HeaderMetadataType, std::string> header =
        nextBlockVersion.hasHeader() ? HoodieLogBlock::getLogMetadata(inputStream) : std::map<HeaderMetadataType, std::string>();

    int contentLength =
        nextBlockVersion.getVersion() != HoodieLogFormatVersion::DEFAULT_VERSION ?
            static_cast<int>(inputStream.readLong()) : blockSize;

    int64_t contentPosition = inputStream.getPos();

    bool shouldReadLazily = readBlockLazily && nextBlockVersion.getVersion() != HoodieLogFormatVersion::DEFAULT_VERSION;

    std::optional<std::vector<uint8_t>> content = HoodieLogBlock::tryReadContent(inputStream, contentLength, shouldReadLazily);

    std::map<HeaderMetadataType, std::string> footer =
        nextBlockVersion.hasFooter() ? HoodieLogBlock::getLogMetadata(inputStream) : std::map<HeaderMetadataType, std::string>();

    if (nextBlockVersion.hasLogBlockLength()) {
        inputStream.readLong();
    }

    int64_t blockEndPos = inputStream.getPos();

    switch (blockType) {
        case HoodieLogBlockType::AVRO_DATA_BLOCK:
            if (nextBlockVersion.getVersion() == HoodieLogFormatVersion::DEFAULT_VERSION) {
                return HoodieAvroDataBlock::getBlock(content.value(), readerSchema);
            } else {
                return HoodieAvroDataBlock(
                    logFile, inputStream, content, readBlockLazily,
                    contentPosition, contentLength, blockEndPos,
                    to_optional(readerSchema), header, footer, keyField
                );
            }
        case HoodieLogBlockType::HFILE",1
"private:
std::string getReplyDestinationName(const Destination& destination, const ConsumerType& replyConsumerType) {
    return replyConsumerType.isTopic() ? static_cast<const Topic&>(destination).getTopicName()
                                       : static_cast<const Queue&>(destination).getQueueName();
}","std::string getReplyDestinationName(const Destination& destination, ConsumerType replyConsumerType) {
    return replyConsumerType.isTopic() ? static_cast<const Topic&>(destination).getTopicName()
                                       : static_cast<const Queue&>(destination).getQueueName();
}",0
"#include <stdexcept>
#include <typeinfo>
#include <typeindex>
#include <unordered_map>
#include <string>

class HighAvailabilityManagerImpl;
class Inject {};

class Field {
public:
    std::string name;
    bool isInject;
    bool accessible;
    std::type_index type;
    void* ptr;

    Field(const std::string& n, bool inject, std::type_index t, void* p)
        : name(n), isInject(inject), accessible(false), type(t), ptr(p) {}

    void setAccessible(bool b) { accessible = b; }

    bool isAnnotationPresent(const std::type_info& anno) const {
        return isInject && (anno == typeid(Inject));
    }

    const std::string& getName() const { return name; }

    void set(void* instance, void* value) {
        // In practice, more checks/casting are needed
        *(void**)ptr = value;
    }
};

class HighAvailabilityManagerImpl {
public:
    // placeholder for fields & ""WorkerThread""
};

class Array {
public:
    static void* newInstance(const std::type_info&, size_t n) {
        // This would be specialized for actual classes; for now, nullptr
        return nullptr;
    }
};

class SomeClass {
protected:
    HighAvailabilityManagerImpl* highAvailabilityManager;

    std::unordered_map<std::string, Field> getFields() {
        // Should return Field-s for `highAvailabilityManager` and other members, with pointers to actual members
        return {};
    }

    std::unordered_map<std::string, Field> getClassFields(const std::type_info&) {
        // Should return fields for the given type
        return {};
    }

    std::vector<const std::type_info*> getDeclaredClasses(const std::type_info&) {
        // Return vector of nested classes (type_info objects)
        return {};
    }

    std::string getClassName(const std::type_info&) {
        // Return demangled name or something equivalent
        return """";
    }

public:
    void setup() {
        highAvailabilityManager = new HighAvailabilityManagerImpl();
        auto fields = getClassFields(typeid(HighAvailabilityManagerImpl));
        for (auto& [fieldName, injectField] : fields) {
            if (injectField.isAnnotationPresent(typeid(Inject))) {
                injectField.setAccessible(true);
                auto myFields = getFields();
                injectField.set(highAvailabilityManager, myFields[field","```cpp
#include <typeinfo>
#include <vector>
#include <string>
#include <cstring>

class HighAvailabilityManagerImplTest {
public:
    void setup() {
        highAvailabilityManager = HighAvailabilityManagerImpl();

        auto& fields = HighAvailabilityManagerImpl::getDeclaredFields();
        for (auto& injectField : fields) {
            if (injectField.isAnnotatedWith<Inject>()) {
                injectField.setAccessible(true);
                auto& sourceField = getDeclaredField(injectField.getName());
                injectField.set(&highAvailabilityManager, sourceField.get(this));
            } else if (injectField.getName() == ""_workers"") {
                injectField.setAccessible(true);
                for (auto& clz : HighAvailabilityManagerImpl::getDeclaredClasses()) {
                    if (clz.getName() == ""com.cloud.ha.HighAvailabilityManagerImpl$WorkerThread"") {
                        auto obj = clz.createArray(0);
                        injectField.set(&highAvailabilityManager, obj);
                    }
                }
            }
        }
    }

private:
    HighAvailabilityManagerImpl highAvailabilityManager;

    class Field {
    public:
        template<typename T>
        bool isAnnotatedWith() const;
        void setAccessible(bool);
        std::string getName() const;
        void set(void* instance, void* value);
        void* get(void* instance) const;
    };

    static std::vector<Field>& getDeclaredFields();
    static std::vector<Class>& getDeclaredClasses();
    Field& getDeclaredField(const std::string& name);

    class Inject {};

    class HighAvailabilityManagerImpl {
    public:
        static std::vector<Field>& getDeclaredFields();
        static std::vector<Class>& getDeclaredClasses();
    };

    class Class {
    public:
        std::string getName() const;
        void* createArray(int size) const;
    };
};
```",1
"std::map<std::string, std::set<DagNode<JobExecutionPlan>>> onJobFinish(DagNode<JobExecutionPlan> dagNode) {
    Dag<JobExecutionPlan> dag = this->jobToDag[dagNode];
    std::string dagId = DagManagerUtils::generateDagId(dag);
    // ...
}","```cpp
std::map<std::string, std::set<DagNode<JobExecutionPlan>*>> onJobFinish(DagNode<JobExecutionPlan>* dagNode) {
    Dag<JobExecutionPlan>* dag = this->jobToDag[dagNode];
    std::string dagId = DagManagerUtils::generateDagId(dag);
}
```",0
"return false;
}

[[deprecated(""use registerHelperResources(HelperResources&) instead"")]]
virtual std::vector<std::string> helperResourceNames() {
    return {};
}

virtual void registerHelperResources(const HelperResources& helperResources) {}","#include <vector>
#include <string>

class HelperResources {};

class InstrumentationModule {
public:
    virtual ~InstrumentationModule() = default;

    [[deprecated(""use registerHelperResources instead"")]]
    virtual std::vector<std::string> helperResourceNames() {
        return {};
    }

    virtual void registerHelperResources(HelperResources& helperResources) {}
};",1
"#include <unordered_set>
#include <map>
#include <set>
#include <future>
#include <atomic>
#include <functional>","#include <unordered_map>
#include <unordered_set>
#include <future>
#include <atomic>
#include <functional>",0
"#include <unordered_map>
#include <memory>
#include <mutex>

template <typename T>
class ServiceFactory {
protected:
    std::unordered_map<int, std::shared_ptr<T>> cache_;
    std::mutex mutex_;
};","#include <unordered_map>

template<typename T>
class ServiceFactory {
    // Cache ExchangeClient
};",1
"```cpp
#include <string>
#include <unordered_map>
#include <vector>
#include <stdexcept>
#include <any>

class Expression {};

class ExpressionEvaluatingSqlParameterSource {
private:
    const std::any input;
    std::unordered_map<std::string, std::any> values;
    const std::unordered_map<std::string, std::vector<Expression*>> parameterExpressions;
    const bool cache;

public:
    ExpressionEvaluatingSqlParameterSource(
        std::any input,
        const std::unordered_map<std::string, std::any>& staticParameters,
        const std::unordered_map<std::string, std::vector<Expression*>>& parameterExpressions,
        bool cache
    )
        : input(std::move(input))
        , values(staticParameters)
        , parameterExpressions(parameterExpressions)
        , cache(cache)
    {
    }

    std::any getValue(const std::string& paramName) {
        return this->doGetValue(paramName, false);
    }

    std::any doGetValue(const std::string& paramName, bool calledFromHasValue) {
        auto it = values.find(paramName);
        if (it != values.end()) {
            std::any cachedByHasValue = it->second;
            if (!this->cache) {
                values.erase(it);
            }
            return cachedByHasValue;
        }

        if (parameterExpressions.find(paramName) == parameterExpressions.end()) {
            throw std::invalid_argument(""Parameter not found: "" + paramName);
        }

        // Additional logic should be here (not provided in the original code)
        return std::any();
    }
};
```","```cpp
#include <string>
#include <unordered_map>
#include <stdexcept>
#include <any>

class Expression {};

class ExpressionEvaluatingSqlParameterSource {
private:
    const std::any input;
    std::unordered_map<std::string, std::any> values;
    const std::unordered_map<std::string, std::vector<Expression*>> parameterExpressions;
    const bool cache;

public:
    ExpressionEvaluatingSqlParameterSource(
        const std::any& input,
        const std::unordered_map<std::string, std::any>& staticParameters,
        const std::unordered_map<std::string, std::vector<Expression*>>& parameterExpressions,
        bool cache
    )
        : input(input), parameterExpressions(parameterExpressions), cache(cache)
    {
        values.insert(staticParameters.begin(), staticParameters.end());
    }

    std::any getValue(const std::string& paramName) {
        return doGetValue(paramName, false);
    }

    std::any doGetValue(const std::string& paramName, bool calledFromHasValue) {
        auto it = values.find(paramName);
        if (it != values.end()) {
            std::any cachedByHasValue = it->second;
            if (!cache) {
                values.erase(it);
            }
            return cachedByHasValue;
        }

        if (parameterExpressions.find(paramName) == parameterExpressions.end()) {
            throw std::invalid_argument(""Parameter not found: "" + paramName);
        }

        // Expression evaluation logic would be here (not shown in original snippet)
        return std::any{};
    }
};
```",0
"#include <string>
#include <memory>

class URL {};
class StringUtils {};
class ChannelHandler {};
class Request {};
class Response {};

class NettyClientHandler /* : public some_base_handler */ {
public:
    NettyClientHandler(std::shared_ptr<URL> url,
                       std::shared_ptr<ChannelHandler> handler)
        : url_(std::move(url)), handler_(std::move(handler)) {}

private:
    std::shared_ptr<URL> url_;
    std::shared_ptr<ChannelHandler> handler_;
};","#include <string>
#include <memory>

class URL {};
class ChannelHandler {};
class Request {};
class Response {};

class NettyClientHandler {
public:
    NettyClientHandler(std::shared_ptr<ChannelHandler> handler, std::shared_ptr<URL> url)
        : handler_(handler), url_(url) {}

private:
    std::shared_ptr<ChannelHandler> handler_;
    std::shared_ptr<URL> url_;
};",0
"}

PortablePipelineResult runPortablePipeline(const RunnerApi::Pipeline& pipeline, const JobInfo& jobInfo) {
    std::string jsonGraph = PipelineJsonRenderer::toJsonString(pipeline).toString();
    LOG::info(""Portable pipeline to run json graph:\n{}"", jsonGraph);

    ConfigBuilder configBuilder(options);
    SamzaPortablePipelineTranslator::createConfig(pipeline, configBuilder, options);
    configBuilder.put(BEAM_JSON_GRAPH, jsonGraph);

    Config config = configBuilder.build();
    options.setConfigOverride(config);
}","std::string jsonGraph = PipelineJsonRenderer::toJsonString(pipeline).toString();
LOG.info(""Portable pipeline to run json graph:\n{}"", jsonGraph);

ConfigBuilder configBuilder(options);
SamzaPortablePipelineTranslator::createConfig(pipeline, configBuilder, options);
configBuilder.put(BEAM_JSON_GRAPH, jsonGraph);

Config config = configBuilder.build();
options.setConfigOverride(config);",1
"}
}

void start() override {
    std::unique_lock<std::mutex> lock(mutex_);
    if (!started) {","void start() override {
    std::lock_guard<std::mutex> lock(mutex_);
    if (!started) {",0
"void close() {
    if (this->closed) {
        return;
    }","void close() {
    if (this->closed) {
        return;
    }
}",0
"}
    return entry;
}

ClassInfo scanClassFile(std::istream& file, const std::string& url) {
    ClassScanner scanner(url, listeners);","```cpp
private:
    ClassInfo scanClassFile(std::istream& file, const std::string& url) {
        ClassScanner scanner(url, listeners);
```",0
"handler = this->getApplicationContext()->getBean(static_cast<std::string>(handler));
}
auto mapping = this->getMappingForEndpoint(static_cast<HttpRequestHandlingEndpointSupport*>(handler));
if (mapping != nullptr) {
    this->registerHandlerMethod(handler, HANDLE_REQUEST_METHOD, mapping);
}
}","if (std::is_same_v<decltype(handler), std::string>) {
    handler = this->getApplicationContext()->getBean(static_cast<std::string>(handler));
}
RequestMappingInfo* mapping = this->getMappingForEndpoint(static_cast<HttpRequestHandlingEndpointSupport*>(handler));
if (mapping != nullptr) {
    this->registerHandlerMethod(handler, HANDLE_REQUEST_METHOD, mapping);
}",0
"```cpp
#include <vector>
#include <map>
#include <typeinfo>

class Type {};
class TypeDefinition {};
class TypeBuilder {
public:
    virtual TypeDefinition build(const Type& type, const std::type_info& clazz, std::map<const std::type_info*, TypeDefinition>& typeCache) = 0;
    virtual ~TypeBuilder() = default;
};

class ArrayTypeBuilder : public TypeBuilder {
    // ... implementation
};
class CollectionTypeBuilder : public TypeBuilder {
    // ... implementation
};
class MapTypeBuilder : public TypeBuilder {
    // ... implementation
};
class EnumTypeBuilder : public TypeBuilder {
    // ... implementation
};

class TypeDefinitionBuilder {
private:
    static ArrayTypeBuilder ARRAY_BUILDER;
    static CollectionTypeBuilder COLLECTION_BUILDER;
    static MapTypeBuilder MAP_BUILDER;
    static EnumTypeBuilder ENUM_BUILDER;
    static std::vector<TypeBuilder*> BUILDERS;

public:
    static TypeDefinition build(const Type& type, const std::type_info& clazz, std::map<const std::type_info*, TypeDefinition>& typeCache) {
        TypeBuilder* builder = getGenericTypeBuilder(type, clazz);
        TypeDefinition td;
        if (builder != nullptr) {
            td = builder->build(type, clazz, typeCache);
        } else {
            // ...
        }
        return td;
    }

    static TypeBuilder* getGenericTypeBuilder(const Type& type, const std::type_info& clazz) {
        // ... implementation
        return nullptr;
    }
};

ArrayTypeBuilder TypeDefinitionBuilder::ARRAY_BUILDER;
CollectionTypeBuilder TypeDefinitionBuilder::COLLECTION_BUILDER;
MapTypeBuilder TypeDefinitionBuilder::MAP_BUILDER;
EnumTypeBuilder TypeDefinitionBuilder::ENUM_BUILDER;
std::vector<TypeBuilder*> TypeDefinitionBuilder::BUILDERS = {
    &TypeDefinitionBuilder::ARRAY_BUILDER,
    &TypeDefinitionBuilder::COLLECTION_BUILDER,
    &TypeDefinitionBuilder::MAP_BUILDER,
    &TypeDefinitionBuilder::ENUM_BUILDER
};
```","#include <vector>
#include <map>
#include <typeinfo>
#include <typeindex>

class Type {};
class TypeDefinition {};
class TypeBuilder {
public:
    virtual TypeDefinition build(const Type& type, const std::type_info& clazz, std::map<std::type_index, TypeDefinition>& typeCache) = 0;
    virtual ~TypeBuilder() {}
};

class ArrayTypeBuilder : public TypeBuilder {
public:
    TypeDefinition build(const Type& type, const std::type_info& clazz, std::map<std::type_index, TypeDefinition>& typeCache) override;
};

class CollectionTypeBuilder : public TypeBuilder {
public:
    TypeDefinition build(const Type& type, const std::type_info& clazz, std::map<std::type_index, TypeDefinition>& typeCache) override;
};

class MapTypeBuilder : public TypeBuilder {
public:
    TypeDefinition build(const Type& type, const std::type_info& clazz, std::map<std::type_index, TypeDefinition>& typeCache) override;
};

class EnumTypeBuilder : public TypeBuilder {
public:
    TypeDefinition build(const Type& type, const std::type_info& clazz, std::map<std::type_index, TypeDefinition>& typeCache) override;
};

class TypeDefinitionBuilder {
private:
    static ArrayTypeBuilder ARRAY_BUILDER;
    static CollectionTypeBuilder COLLECTION_BUILDER;
    static MapTypeBuilder MAP_BUILDER;
    static EnumTypeBuilder ENUM_BUILDER;
    static std::vector<TypeBuilder*> BUILDERS;
public:
    static TypeDefinition build(const Type& type, const std::type_info& clazz, std::map<std::type_index, TypeDefinition>& typeCache) {
        TypeBuilder* builder = getGenericTypeBuilder(type, clazz);
        TypeDefinition td;
        if (builder != nullptr) {
            td = builder->build(type, clazz, typeCache);
        } else {
            // ...
        }
        return td;
    }

    static TypeBuilder* getGenericTypeBuilder(const Type& type, const std::type_info& clazz) {
        for (TypeBuilder* builder : BUILDERS) {
            // ... logic to select correct builder
        }
        return nullptr;
    }
};

ArrayTypeBuilder TypeDefinitionBuilder::ARRAY_BUILDER;
CollectionTypeBuilder TypeDefinitionBuilder::COLLECTION_BUILDER;
MapTypeBuilder TypeDefinitionBuilder::MAP_BUILDER;
EnumTypeBuilder TypeDefinitionBuilder::ENUM_BUILDER;
std::vector<TypeBuilder*> Type",1
"```cpp
private:
    std::filesystem::path loadProperties(Builder& builder) {
        std::unordered_map<std::string, Xpp3Dom> tracker;

        loadParentProjectProperties(builder, project, tracker);

        Xpp3Dom configuration = 
            project.getBuildPlugins() 
                ? getConfiguration(*project.getBuildPlugins()).value_or(defaultConfiguration())
                : defaultConfiguration();

        return loadProjectProperties(builder, project, project, configuration, tracker);
    }

    void loadParentProjectProperties(Builder& builder, MavenProject* currentProject,
                                    std::unordered_map<std::string, Xpp3Dom>& tracker) {
        MavenProject* parentProject = currentProject->getParent();
        if (parentProject == nullptr) {
            return;
        }
        loadParentProjectProperties(builder, parentProject, tracker);

        Xpp3Dom configuration =
            parentProject->getBuildPlugins()
                ? getConfiguration(*parentProject->getBuildPlugins()).value_or(defaultConfiguration())
                : defaultConfiguration();
        // ...
    }
```","```cpp
#include <map>
#include <memory>
#include <optional>
#include <string>

File loadProperties(Builder& builder) {
	std::map<std::string, std::shared_ptr<Xpp3Dom>> tracker;
	// Load parent project properties first
	loadParentProjectProperties(builder, project, tracker);

	// Load current project properties
	auto configuration = project.getBuildPlugins()
		? getConfiguration(*project.getBuildPlugins())
		: std::optional<std::shared_ptr<Xpp3Dom>>(defaultConfiguration());

	return loadProjectProperties(builder, project, project,
		configuration.value_or(defaultConfiguration()), tracker);
}

void loadParentProjectProperties(Builder& builder, MavenProject& currentProject,
	std::map<std::string, std::shared_ptr<Xpp3Dom>>& tracker)
{
	MavenProject* parentProject = currentProject.getParent();
	if (parentProject == nullptr) {
		return;
	}
	loadParentProjectProperties(builder, *parentProject, tracker);

	// Get configuration from parent project
	auto configuration = parentProject->getBuildPlugins()
		? getConfiguration(*parentProject->getBuildPlugins())
		: std::optional<std::shared_ptr<Xpp3Dom>>(defaultConfiguration());
}
```",0
"auto connectionHandler = static_cast<ConnectionHandler*>(operationContext.getVariable(CONNECTION_PARAM));
if (connectionHandler != nullptr && supportsStreaming(operationContext.getComponentModel())) {
    value = componentDecoratorFactory.decorateOutput(
        new ConnectedInputStreamWrapper(static_cast<InputStream*>(value), connectionHandler,
            getIncrementActiveComponent(operationContext),
            getDecrementActiveComponent(operationContext)),
        correlationId);
}","```cpp
ConnectionHandler* connectionHandler = static_cast<ConnectionHandler*>(operationContext.getVariable(CONNECTION_PARAM));
if (connectionHandler != nullptr && supportsStreaming(operationContext.getComponentModel())) {
    value = componentDecoratorFactory->decorateOutput(
        new ConnectedInputStreamWrapper(
            static_cast<InputStream*>(value),
            connectionHandler,
            getIncrementActiveComponent(operationContext),
            getDecrementActiveComponent(operationContext)
        ),
        correlationId
    );
}
```",1
"```cpp
if (updateLocationToBucket.contains(location.getFileId())) {
    return updateLocationToBucket.at(location.getFileId());
} else {
    const std::string& partitionPath = keyLocation.first->getPartitionPath();
    const auto& targetBuckets = partitionPathToInsertBucketInfos.at(partitionPath);
    const long totalInserts = std::max(1L, profile.getWorkloadStat(partitionPath).getNumInserts());
    const long hashOfKey = NumericUtils::getMessageDigestHash(""MD5"", keyLocation.first->getRecordKey());
    const double r = 1.0 * (hashOfKey % totalInserts) / totalInserts;

    auto comp = [](const InsertBucketCumulativeWeightPair& a, const InsertBucketCumulativeWeightPair& b) {
        return a.cumulativeWeight < b.cumulativeWeight;
    };

    InsertBucketCumulativeWeightPair probe(InsertBucket(), r);

    auto it = std::lower_bound(targetBuckets.begin(), targetBuckets.end(), probe, comp);

    if (it != targetBuckets.end() && it->cumulativeWeight == r) {
        return it->getKey().bucketNumber;
    }

    if (it != targetBuckets.end()) {
        return it->getKey().bucketNumber;
    }

    return targetBuckets.front().getKey().bucketNumber;
}
```","```cpp
if (updateLocationToBucket.find(location.getFileId()) != updateLocationToBucket.end()) {
    return updateLocationToBucket[location.getFileId()];
} else {
    std::string partitionPath = keyLocation.first.getPartitionPath();
    auto& targetBuckets = partitionPathToInsertBucketInfos[partitionPath];
    const long totalInserts = std::max<int64_t>(1, profile.getWorkloadStat(partitionPath).getNumInserts());
    const long hashOfKey = NumericUtils::getMessageDigestHash(""MD5"", keyLocation.first.getRecordKey());
    const double r = 1.0 * static_cast<double>(std::abs(hashOfKey % totalInserts)) / totalInserts;

    auto comp = [](const InsertBucketCumulativeWeightPair& lhs, const InsertBucketCumulativeWeightPair& rhs) {
        return lhs.getValue() < rhs.getValue();
    };
    InsertBucketCumulativeWeightPair probe(InsertBucket(), r);
    auto it = std::lower_bound(targetBuckets.begin(), targetBuckets.end(), probe, comp);

    if (it != targetBuckets.end() && it->getValue() == r) {
        return it->getKey().bucketNumber;
    }

    if (it != targetBuckets.end()) {
        return it->getKey().bucketNumber;
    }

    return targetBuckets[0].getKey().bucketNumber;
}
```",1
"#include ""ExtensionsTypeLoaderFactory.h""
#include ""DslElementSyntax.h""
#include ""DslSyntaxResolver.h""
#include ""Literal.h""
#include ""ExtensionMetadataTypeUtils.h""
#include ""InfrastructureParameterModelProperty.h""
#include ""RouteComponentParser.h""","#include ""org/mule/runtime/extension/api/declaration/type/ExtensionsTypeLoaderFactory.h""
#include ""org/mule/runtime/extension/api/dsl/syntax/DslElementSyntax.h""
#include ""org/mule/runtime/extension/api/dsl/syntax/resolver/DslSyntaxResolver.h""
#include ""org/mule/runtime/extension/api/runtime/parameter/Literal.h""
#include ""org/mule/runtime/extension/api/util/ExtensionMetadataTypeUtils.h""
#include ""org/mule/runtime/extension/internal/property/InfrastructureParameterModelProperty.h""
#include ""org/mule/runtime/module/extension/internal/config/dsl/construct/RouteComponentParser.h""",0
"if (!cfg.filterDupes || cfg.operation != Operation::UPSERT) {
    // proceed
} else {
    throw std::invalid_argument(""'--filter-dupes' needs to be disabled when '--op' is 'UPSERT' to ensure updates are not missed."");
}

this->props = properties;
LOG.info(""Creating delta streamer with configs : "" + props.toString());
this->schemaProvider = UtilHelpers::createSchemaProvider(cfg.schemaProviderClassName, props, jssc);","this->props = properties;
LOG.info(""Creating delta streamer with configs : "" + props.toString());
this->schemaProvider = UtilHelpers::createSchemaProvider(cfg.schemaProviderClassName, props, jssc);",0
"cr.addField(TextField(
    CK_CUSTOM_PROPERTIES,
    ""Custom Kafka properties"",
    """",
    ""A newline separated list of Kafka properties. (e.g.: \""ssl.keystore.location=/etc/graylog/server/kafka.keystore.jks\"")."",
    ConfigurationField::Optional::OPTIONAL,
    110,
    TextField::Attribute::TEXTAREA
));

return cr;","```cpp
class KafkaTransport : public ThrottleableTransport {
public:
    static ConfigurationRequest getConfigRequest() {
        ConfigurationRequest cr;
        cr.addField(TextField(
            DEFAULT_GROUP_ID,
            ""Name of the consumer group the Kafka input belongs to"",
            ConfigurationField::Optional::OPTIONAL
        ));
        cr.addField(TextField(
            CK_CUSTOM_PROPERTIES,
            ""Custom Kafka properties"",
            """",
            ""A newline separated list of Kafka properties. (e.g.: \""ssl.keystore.location=/etc/graylog/server/kafka.keystore.jks\"")."",
            ConfigurationField::Optional::OPTIONAL,
            110,
            TextField::Attribute::TEXTAREA
        ));
        return cr;
    }
};
```",1
"class EventhubDataWriter : public SyncDataWriter<std::vector<uint8_t>>, public BatchAsyncDataWriter<std::vector<uint8_t>> {
};","#include <vector>
#include <string>

class EventhubDataWriter : public SyncDataWriter<std::vector<uint8_t>>, public BatchAsyncDataWriter<std::vector<uint8_t>> {",1
"version = Version(version);

const auto& cls = typeid(*this);

// if (hasattr(cls, 'url') || self.version_urls())
if (cls_has_attr_url(cls) || this->version_urls()) {
    // If we have a specific URL for this version, don't extrapolate.
    auto version_urls = this->version_urls();
    if (version_urls.count(version) > 0) {
        return version_urls.at(version);
    }

    // If we have no idea, try to substitute the version.
    return spack::url::substitute_version(
        this->nearest_url(version), this->url_version(version));
}
else if (cls_has_attr_pypi(cls) || this_has_attr_pypi(*this)) {
    xmlrpc_client client(""https://pypi.python.org/pypi"");
    auto releases = client.release_urls(get_pypi(cls, *this), to_string(version));

    // Tarballs have the highest preference
    for (const auto& release : releases) {
        if (ends_with(release.at(""filename""), "".tar.gz"")) {
            return release.at(""url"");
        }
    }

    // Zipballs have a lower preference
    for (const auto& release : releases) {
        if (ends_with(release.at(""filename""), "".zip"")) {
            return release.at(""url"");
        }
    }

    // Are there any source distributions at all?
    for (const auto& release : releases) {
        if ((release.at(""packagetype"") == ""sdist"") ||
            (release.at(""python_version"") == ""source"")) {
            return release.at(""url"");
        }
    }
}
else {
    throw NoURLError(cls);
}","```cpp
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

class NoURLError : public std::runtime_error {
public:
    explicit NoURLError(const std::string& cls_name)
        : std::runtime_error(""No URL for class: "" + cls_name) {}
};

// Mocked place-holders for Version, spack, etc.
class Version {
public:
    explicit Version(const std::string& v) : value(v) {}
    bool operator==(const Version& other) const { return value == other.value; }
    bool operator!=(const Version& other) const { return value != other.value; }
    bool operator<(const Version& other) const { return value < other.value; }
    std::string toString() const { return value; }
private:
    std::string value;
};

namespace spack {
    namespace url {
        std::string substitute_version(const std::string& url, const std::string& version) {
            // Simplified stub
            return url;
        }
    }
}

// Simulating a PyPI server client (stub)
struct Release {
    std::string filename;
    std::string url;
    std::string packagetype;
    std::string python_version;
};

class PyPIClient {
public:
    std::vector<Release> release_urls(const std::string& pypi, const std::string& version) {
        // Stub return
        return {};
    }
};

class PackageBase {
public:
    virtual ~PackageBase() = default;
    // '.url' or '.pypi' or '.version_urls' should be set in derived classes where relevant
    virtual std::string url() const { return """"; }
    virtual std::string pypi() const { return """"; }
    virtual std::unordered_map<Version, std::string> version_urls() const { return {}; }
    virtual std::string nearest_url(const Version& version) const { return """"; }
    virtual std::string url_version(const Version& version) const { return """"; }
    virtual std::string class_name() const { return ""PackageBase""; }

    std::string get_url(const std::string& version_str) {
        Version version(version_str);

        bool has_url = !url().empty();
        bool has_pypi = !pypi().empty();
        auto v_urls = version_urls();

        if (has_url || !v_urls.empty()) {
            if (!v_urls.empty",1
"for (;;) {
    JobMetrics metrics = getJobMetrics(job);
    std::optional<bool> success = checkForPAssertSuccess(job, metrics);
    if (messageHandler.hasSeenError()) {
        return std::optional<bool>(false);
    }

    if (success.has_value() && (!success.value() || atMaxWatermark(job, metrics))) {
        // It's possible that the streaming pipeline doesn't use PAssert.
        // So checkForSuccess() will return true before job is finished.
    }
}","for (;;) {
    JobMetrics metrics = getJobMetrics(job);
    auto success = checkForPAssertSuccess(job, metrics);
    if (messageHandler.hasSeenError()) {
        return std::optional<bool>(false);
    }
    if (success.has_value() && (!success.value() || atMaxWatermark(job, metrics))) {
        // It's possible that the streaming pipeline doesn't use PAssert.
        // So checkForSuccess() will return true before job is finished.
    }
}",1
"void releaseNetworkResourcesOnExpunge(long id) {
    VMInstanceVO* vmInstance = _vmDao.findById(id);
    VirtualMachineProfileImpl profile(vmInstance);
    _networkMgr.release(profile, false);
}

bool cleanupVmResources(long vmId) {
    bool success = true;
    // Remove vm from security groups","void releaseNetworkResourcesOnExpunge(long id) {
    VMInstanceVO vmInstance = _vmDao.findById(id);
    VirtualMachineProfileImpl profile(vmInstance);
    _networkMgr.release(profile, false);
}",1
"std::vector<std::any> expected = {
    1.1f,
    3.4,
    static_cast<int>(std::chrono::sys_days{std::chrono::year{2021}/3/30}.time_since_epoch().count()),
    std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::parse<std::chrono::system_clock::time_point>(""%H:%M:%S"", ""15:44:29"") - 
        std::chrono::floor<std::chrono::days>(
            std::chrono::parse<std::chrono::system_clock::time_point>(""%H:%M:%S"", ""15:44:29"")
        )
    ).count(),
    stringToTimestampData(""2021-03-30T15:44:29""),
    stringToTimestampData(""2021-03-30T15:44:29.666111""),
    DecimalData::fromBigDecimal(BigDecimal(""12345.67""), 7, 2)
};
assert(expected == converted);","#include <array>
#include <chrono>
#include <string>
#include <cassert>
#include <iomanip>
#include <sstream>

struct TimestampData {
    std::chrono::system_clock::time_point tp;
    static TimestampData fromEpochMillis(int64_t millis) {
        TimestampData t;
        t.tp = std::chrono::system_clock::time_point(std::chrono::milliseconds(millis));
        return t;
    }
};

TimestampData stringToTimestampData(const std::string& ts) {
    std::istringstream ss(ts);
    std::tm tm = {};
    char dot = 0;
    int micro{0};
    if (ts.find('.') != std::string::npos) {
        ss >> std::get_time(&tm, ""%Y-%m-%dT%H:%M:%S"");
        ss >> dot >> micro;
    } else {
        ss >> std::get_time(&tm, ""%Y-%m-%dT%H:%M:%S"");
    }
    auto tp = std::chrono::system_clock::from_time_t(std::mktime(&tm));
    if (dot == '.') {
        int64_t us = micro;
        int64_t ns = us * 1000;
        tp += std::chrono::nanoseconds(ns);
    }
    TimestampData t;
    t.tp = tp;
    return t;
}

struct DecimalData {
    std::string value;
    int precision, scale;
    static DecimalData fromBigDecimal(const std::string& v, int p, int s) {
        return DecimalData{v, p, s};
    }
};

auto converted = std::array<std::any, 6>{ 
    1.1f, 
    3.4, 
    static_cast<int>((std::chrono::sys_days(std::chrono::year{2021}/3/30) - std::chrono::sys_days(std::chrono::year{1970}/1/1)).count()),
    std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::hours{15} + std::chrono::minutes{44} + std::chrono::seconds{29}
    ).count(),
    stringToTimestampData(""2021-03-30T15:44:29""),
    stringToTimestampData(""2021-03-30T15:44:29.666111""),
    DecimalData::fromBigDecimal(""12345.67"", 7, 2)
};",0
"auto componentModel = componentModelReader.extractComponentDefinitionModel(
    configFile.getConfigLines().at(0), configFile.getFilename()
);
if (isMuleConfigFile(configFile)) {
    if (muleComponentModels.empty()) {
        muleComponentModels.push_back(componentModel);
    } else {
        auto& rootComponentModel = muleComponentModels.front();
        auto& innerComponents = rootComponentModel.getInnerComponents();
        const auto& newInnerComponents = componentModel.getInnerComponents();
        innerComponents.insert(innerComponents.end(), newInnerComponents.begin(), newInnerComponents.end());
    }
} else {
    springComponentModels.push_back(componentModel);
}","ComponentModel componentModel =
    componentModelReader.extractComponentDefinitionModel(configFile.getConfigLines()[0], configFile.getFilename());
if (isMuleConfigFile(configFile)) {
    if (muleComponentModels.empty()) {
        muleComponentModels.push_back(componentModel);
    } else {
        // Only one componentModel as Root should be set, therefore componentModel from other configFiles are added as innerComponents
        auto& innerComponents = muleComponentModels[0].getInnerComponents();
        const auto& otherInnerComponents = componentModel.getInnerComponents();
        innerComponents.insert(innerComponents.end(), otherInnerComponents.begin(), otherInnerComponents.end());
    }
} else {
    springComponentModels.push_back(componentModel);
}",1
"}
}

#include <string>
#include <vector>
#include <stdexcept>
#include <memory>
#include <optional>
#include <chrono>
#include <thread>

void runWorkUnits(
    const std::string& jobId,
    const std::string& containerId,
    const std::vector<std::shared_ptr<WorkUnit>>& workUnits,
    TaskStateTracker& taskStateTracker,
    TaskExecutor& taskExecutor,
    StateStore<TaskState>& taskStateStore,
    Logger& logger
) {
    if (workUnits.empty()) {
        logger.warn(""No work units to run in container "" + containerId);
        return;
    }

    for (const auto& workUnit : workUnits) {
        std::string taskId = workUnit->getProp(ConfigurationKeys::TASK_ID_KEY);
        if (taskStateStore.exists(jobId, taskId + AbstractJobLauncher::TASK_STATE_STORE_TABLE_SUFFIX)) {
            taskStateStore.deleteKey(jobId, taskId + AbstractJobLauncher::TASK_STATE_STORE_TABLE_SUFFIX);
        }
    }

    std::shared_ptr<CountDownLatch> countDownLatch = std::make_shared<CountDownLatch>(workUnits.size());
    auto tasks = runWorkUnits(jobId, workUnits, taskStateTracker, taskExecutor, countDownLatch);

    logger.info(""Waiting for submitted tasks of job "" + jobId + "" to complete in container "" + containerId + ""..."");
    while (countDownLatch->getCount() > 0) {
        logger.info(std::to_string(countDownLatch->getCount()) + "" out of "" +
                    std::to_string(workUnits.size()) + "" tasks of job "" + jobId +
                    "" are running in container "" + containerId);

        if (countDownLatch->await(std::chrono::seconds(10))) {
            break;
        }
    }
    logger.info(""All assigned tasks of job "" + jobId + "" have completed in container "" + containerId);

    bool hasTaskFailure = false;
    for (const auto& task : tasks) {
        logger.info(""Writing task state for task "" + task->getTaskId());
        taskStateStore.put(task->getJobId(), task->getTaskId() + AbstractJobLauncher::TASK_STATE_STORE_TABLE_SUFFIX,
                           task->getTaskState());

        if (task->getTaskState().getWorkingState() == WorkUnitState::WorkingState::FAILED) {
            hasTaskFailure = true;
        }
    }","#include <string>
#include <vector>
#include <memory>
#include <stdexcept>
#include <chrono>
#include <thread>

void runWorkUnits(
    const std::string& jobId, const std::string& containerId,
    const std::vector<std::shared_ptr<WorkUnit>>& workUnits,
    TaskStateTracker& taskStateTracker, TaskExecutor& taskExecutor,
    StateStore<TaskState>& taskStateStore, Logger& logger) {

    if (workUnits.empty()) {
        logger.warn(""No work units to run in container "" + containerId);
        return;
    }

    for (const auto& workUnit : workUnits) {
        std::string taskId = workUnit->getProp(ConfigurationKeys::TASK_ID_KEY);
        if (taskStateStore.exists(jobId, taskId + AbstractJobLauncher::TASK_STATE_STORE_TABLE_SUFFIX)) {
            taskStateStore.deleteEntry(jobId, taskId + AbstractJobLauncher::TASK_STATE_STORE_TABLE_SUFFIX);
        }
    }

    std::shared_ptr<CountDownLatch> countDownLatch = std::make_shared<CountDownLatch>(static_cast<int>(workUnits.size()));
    std::vector<std::shared_ptr<Task>> tasks = runWorkUnits(jobId, workUnits, taskStateTracker, taskExecutor, countDownLatch);

    logger.info(""Waiting for submitted tasks of job "" + jobId + "" to complete in container "" + containerId + ""..."");
    while (countDownLatch->getCount() > 0) {
        logger.info(std::to_string(countDownLatch->getCount()) + "" out of "" +
                    std::to_string(workUnits.size()) + "" tasks of job "" +
                    jobId + "" are running in container "" + containerId);
        if (countDownLatch->await(std::chrono::seconds(10))) {
            break;
        }
    }
    logger.info(""All assigned tasks of job "" + jobId + "" have completed in container "" + containerId);

    bool hasTaskFailure = false;
    for (const auto& task : tasks) {
        logger.info(""Writing task state for task "" + task->getTaskId());
        taskStateStore.put(
            task->getJobId(),
            task->getTaskId() + AbstractJobLauncher::TASK_STATE_STORE_TABLE_SUFFIX,
            task->getTaskState()
        );
        if (task->getTaskState().getWorkingState() == WorkUnitState::WorkingState::FAILED) {
            hasTaskFailure =",1
"TEST_F(MyTestClass, testProcessRequestResponse)
{
    MuleEvent event = getTestEvent(TEST_MESSAGE);

    try
    {","```cpp
TEST(AsyncInterceptingMessageProcessorTestCase, testProcessRequestResponse)
{
    auto event = getTestEvent(TEST_MESSAGE);

    try
    {
```",0
"}
LOG.warn(""Classes not found during the analysis : [{}{}]"", 
          std::accumulate(classesNotFound.begin(), 
                          std::next(classesNotFound.begin(), std::min<size_t>(50, classesNotFound.size())),
                          std::string(),
                          [](const std::string& a, const std::string& b) { return a.empty() ? b : a + "", "" + b; }),
          message);
classLoader.close();
}
}","```cpp
#include <iostream>
#include <set>
#include <string>
#include <sstream>
#include <iterator>
#include <algorithm>
#include <fstream>

class Logger {
public:
    void warn(const std::string& msg) {
        std::cerr << ""WARN: "" << msg << std::endl;
    }
};

class ClassLoader {
public:
    void close() {
        // Close resources if any
    }
};

void analysisFunction(std::set<std::string>& classesNotFound, const std::string& message, ClassLoader& classLoader, Logger& LOG) {
    if (!classesNotFound.empty()) {
        std::ostringstream oss;
        auto it = classesNotFound.begin();
        int count = 0;
        while (it != classesNotFound.end() && count < 50) {
            if (count > 0) oss << "", "";
            oss << *it;
            ++it;
            ++count;
        }
        LOG.warn(""Classes not found during the analysis : ["" + oss.str() + message + ""]"");
    }
    classLoader.close();
}
```",0
"long blockSize, Progressable *progress) {
    Path p = convertToDefaultPath(f);
    return wrapOutputStream(p,
        fileSystem.createNonRecursive(p, overwrite, bufferSize, replication, blockSize, progress), bufferSize);
}","virtual std::unique_ptr<OutputStream> createNonRecursive(const Path& f, bool overwrite, int bufferSize,
                                                        short replication, long blockSize, Progressable* progress) override {
    Path p = convertToDefaultPath(f);
    return wrapOutputStream(p,
        fileSystem->createNonRecursive(p, overwrite, bufferSize, replication, blockSize, progress), bufferSize);
}",0
"params
    .withOptionalParameter(""dynamicConfigExpiration"")
    .describedAs(DYNAMIC_CONFIG_EXPIRATION_DESCRIPTION)
    .ofType(DynamicConfigExpirationTypeBuilder().buildDynamicConfigExpirationType());","params
    .withOptionalParameter(""dynamicConfigExpiration"")
    .describedAs(DYNAMIC_CONFIG_EXPIRATION_DESCRIPTION)
    .ofType(DynamicConfigExpirationTypeBuilder().buildDynamicConfigExpirationType());",0
"class Builder {
public:
    virtual Builder& creationDate(const std::chrono::system_clock::time_point& creationDate) = 0;
    virtual Builder& indexAnalyzer(const std::string& analyzer) = 0;
    virtual Builder& indexTemplateName(const std::string& templateName) = 0;
    virtual Builder& indexOptimizationMaxNumSegments(std::optional<int> indexOptimizationMaxNumSegments) = 0;
    virtual Builder& indexOptimizationDisabled(std::optional<bool> indexOptimizationDisabled) = 0;
    virtual std::unique_ptr<IndexSetConfig> build() = 0;
    virtual ~Builder() = default;
};","class IndexSetConfig : public Comparable<IndexSetConfig> {
public:
    class Builder {
    public:
        virtual Builder& creationDate(const std::chrono::system_clock::time_point& creationDate) = 0;
        virtual Builder& indexAnalyzer(const std::string& analyzer) = 0;
        virtual Builder& indexTemplateName(const std::string& templateName) = 0;
        virtual Builder& indexOptimizationMaxNumSegments(std::optional<int> indexOptimizationMaxNumSegments) = 0;
        virtual Builder& indexOptimizationDisabled(std::optional<bool> indexOptimizationDisabled) = 0;
        virtual std::unique_ptr<IndexSetConfig> build() = 0;
        virtual ~Builder() = default;
    };
    virtual ~IndexSetConfig() = default;
};",0
"// FIXME: this potentially catches too many things...

// [ADD] Archive the whole stdout + stderr for the package
install(log_path, log_install_path);
// [ADD] Archive the environment used for the build
install(env_path, env_install_path);
// [ADD] Finally, archive files that are specific to each package
{
    WorkingDir wd(stage.source_path);
    for (const auto& glob_expr : archive_files) {
        std::vector<std::string> files = glob(glob_expr);
        for (const auto& file : files) {
            try {
                std::string target = spack::store::layout::metadata_path(spec) +
                                     ""/archived-files/"" + file;
                mkdirp(dirname(target));
                install(file, target);
            } catch (const std::exception&) {
                tty::warn(""FAILED ARCHIVE: "" + file);
            }
        }
    }
}
dump_packages(spec, packages_dir);","```cpp
install(log_path, log_install_path);
install(env_path, env_install_path);

{
    WorkingDir working_dir(stage.source_path);

    for (const auto& glob_expr : archive_files) {
        auto files = glob(glob_expr);
        for (const auto& file : files) {
            try {
                auto target = spack::store::layout::metadata_path(spec) + ""/archived-files/"" + file;
                mkdirp(fs::path(target).parent_path().string());
                install(file, target);
            } catch (const std::exception&) {
                tty::warn(""FAILED ARCHIVE: "" + file);
            }
        }
    }
}

dump_packages(spec, packages_dir);
```",1
"#include <string>
#include <vector>
#include <map>
#include <set>

class FixtureImporter {
    // Interface definition
};

class FixtureImporterES6 : public FixtureImporter {
private:
    static inline Logger LOG = LoggerFactory::getLogger(typeid(FixtureImporter).name());
};","#include <string>
#include <vector>
#include <map>
#include <set>

class FixtureImporterES6 : public FixtureImporter {
private:
    static Logger LOG;
};",0
"#include ""constants/Geonet.h""
#include ""constants/Namespaces.h""
#include ""constants/Params.h""
#include ""domain/Constants.h""
#include ""domain/Group.h""
#include ""domain/ISODate.h""
#include ""domain/InspireAtomFeed.h""
#include ""domain/Metadata.h""
#include ""domain/MetadataCategory.h""
#include ""domain/MetadataDataInfo.h""
#include ""domain/MetadataDataInfo_.h""
#include ""domain/MetadataFileUpload.h""
#include ""domain/MetadataFileUpload_.h""
#include ""domain/MetadataHarvestInfo.h""
#include ""domain/MetadataRatingByIp.h""
#include ""domain/MetadataRatingByIpId.h""
#include ""domain/MetadataSourceInfo.h""
#include ""domain/MetadataStatus.h""
#include ""domain/MetadataStatusId.h""
#include ""domain/MetadataStatusId_.h""
#include ""domain/MetadataStatus_.h""
#include ""domain/MetadataType.h""
#include ""domain/MetadataValidation.h""
#include ""domain/MetadataValidationId.h""
#include ""domain/MetadataValidationStatus.h""
#include ""domain/Metadata_.h""
#include ""domain/OperationAllowed.h""
#include ""domain/OperationAllowedId.h""
#include ""domain/OperationAllowedId_.h""
#include ""domain/Pair.h""
#include ""domain/Profile.h""
#include ""domain/ReservedGroup.h""
#include ""domain/ReservedOperation.h""
#include ""domain/SchematronRequirement.h""
#include ""domain/User.h""
#include ""domain/UserGroup.h""
#include ""domain/UserGroupId.h""
#include ""domain/userfeedback/UserFeedback.h""
#include ""events/md/MetadataIndexCompleted.h""
#include ""exceptions/JeevesException.h""
#include ""exceptions/NoSchemaMatchesException.h""","#include ""constants/Edit.h""
#include ""constants/Geonet.h""
#include ""constants/Namespaces.h""
#include ""constants/Params.h""
#include ""domain/Constants.h""
#include ""domain/Group.h""
#include ""domain/ISODate.h""
#include ""domain/InspireAtomFeed.h""
#include ""domain/Metadata.h""
#include ""domain/MetadataCategory.h""
#include ""domain/MetadataDataInfo.h""
#include ""domain/MetadataDataInfo_.h""
#include ""domain/MetadataFileUpload.h""
#include ""domain/MetadataFileUpload_.h""
#include ""domain/MetadataHarvestInfo.h""
#include ""domain/MetadataRatingByIp.h""
#include ""domain/MetadataRatingByIpId.h""
#include ""domain/MetadataSourceInfo.h""
#include ""domain/MetadataStatus.h""
#include ""domain/MetadataStatusId.h""
#include ""domain/MetadataStatusId_.h""
#include ""domain/MetadataStatus_.h""
#include ""domain/MetadataType.h""
#include ""domain/MetadataValidation.h""
#include ""domain/MetadataValidationId.h""
#include ""domain/MetadataValidationStatus.h""
#include ""domain/Metadata_.h""
#include ""domain/OperationAllowed.h""
#include ""domain/OperationAllowedId.h""
#include ""domain/OperationAllowedId_.h""
#include ""domain/Pair.h""
#include ""domain/Profile.h""
#include ""domain/ReservedGroup.h""
#include ""domain/ReservedOperation.h""
#include ""domain/SchematronRequirement.h""
#include ""domain/User.h""
#include ""domain/UserGroup.h""
#include ""domain/UserGroupId.h""
#include ""domain/userfeedback/UserFeedback.h""
#include ""events/md/MetadataIndexCompleted.h""
#include ""exceptions/JeevesException.h""
#include ""exceptions/NoSchemaMatchesException.h""",0
"#include <regex>
#include <memory>
#include <optional>

static const std::regex sUriPattern(R""(^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$)"");

class MediaPlayer {};
class Uri {};

class MyClass {
private:
    std::unique_ptr<MediaPlayer> mMediaPlayer = nullptr;

    std::unique_ptr<Uri> mCurrentAudioUri = nullptr;

    // AudioManager to request/release audio focus
};","#include <regex>
#include <memory>

class MediaPlayer {};
class Uri {};

class Sound {
private:
    static const std::regex sUriPattern;
    std::unique_ptr<MediaPlayer> mMediaPlayer = nullptr;
    std::unique_ptr<Uri> mCurrentAudioUri = nullptr;
};

const std::regex Sound::sUriPattern(""^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"");",0
"class RocksDbBasedFileSystemView : public IncrementalTimelineSyncFileSystemView {
private:
    static Logger LOG;
    const FileSystemViewStorageConfig config;
};

Logger RocksDbBasedFileSystemView::LOG = LoggerFactory::getLogger(""RocksDbBasedFileSystemView"");","#include <memory>

class Logger {
public:
    static std::shared_ptr<Logger> getLogger(const char* className);
};

class FileSystemViewStorageConfig {};

class RocksDbBasedFileSystemView : public IncrementalTimelineSyncFileSystemView {
private:
    static std::shared_ptr<Logger> LOG;
    const FileSystemViewStorageConfig config;

public:
    // ...
};

std::shared_ptr<Logger> RocksDbBasedFileSystemView::LOG = Logger::getLogger(""RocksDbBasedFileSystemView"");",0
"} else {
    currentBlock = createUnconditionalJump(tree, body);
}
updateBlock.addSuccessor(currentBlock);

// process init
currentBlock = createBlock(currentBlock);
for (auto it = tree.initializer().rbegin(); it != tree.initializer().rend(); ++it) {
    auto init = *it;","```cpp
} else {
    currentBlock = createUnconditionalJump(tree, body);
}
updateBlock.addSuccessor(currentBlock);
// process init
currentBlock = createBlock(currentBlock);
for (auto it = tree.initializer().rbegin(); it != tree.initializer().rend(); ++it) {
    StatementTree* init = *it;
```",0
"auto schemaWithoutMetaCols = HoodieAvroUtils::removeMetadataFields(schemaWithMetaCols);
assert(schemaWithoutMetaCols->fields().size() == NUM_FIELDS_IN_EXAMPLE_SCHEMA);

void testRewriteToEvolvedNestedRecord() {
    // schema definition for inner record
    auto nestedSchema = avro::NodePtr(new avro::NodeRecord(""inner_rec""));
    nestedSchema->addField(avro::NodePtr(new avro::NodePrimitive(avro::AVRO_DOUBLE)), ""color_id"");

    auto evolvedNestedSchema = avro::NodePtr(new avro::NodeRecord(""inner_rec""));
    evolvedNestedSchema->addField(avro::NodePtr(new avro::NodePrimitive(avro::AVRO_DOUBLE)), ""color_id"");
    evolvedNestedSchema->addOptionalField(avro::NodePtr(new avro::NodePrimitive(avro::AVRO_STRING)), ""color_name"");

    // schema definition for outer record
    auto recordSchema = avro::NodePtr(new avro::NodeRecord(""outer_rec""));
    recordSchema->addField(avro::NodePtr(new avro::NodePrimitive(avro::AVRO_DOUBLE)), ""timestamp"");
    recordSchema->addField(avro::NodePtr(new avro::NodePrimitive(avro::AVRO_STRING)), ""_row_key"");
    recordSchema->addField(avro::NodePtr(new avro::NodePrimitive(avro::AVRO_STRING)), ""non_pii_col"");
    recordSchema->addField(nestedSchema, ""color_rec"");
    recordSchema->addField(avro::NodePtr(new avro::NodePrimitive(avro::AVRO_STRING)), ""pii_col"");

    auto evolvedRecordSchema = avro::NodePtr(new avro::NodeRecord(""outer_rec""));
    evolvedRecordSchema->addField(avro::NodePtr(new avro::NodePrimitive(avro::AVRO_DOUBLE)), ""timestamp"");
    evolvedRecordSchema->addField(avro::NodePtr(new avro::NodePrimitive(avro::AVRO_STRING)), ""_row_key"");
    evolvedRecordSchema->addField(avro::NodePtr(new avro::NodePrimitive(avro::AVRO_STRING)), ""non_pii_col"");
    evolvedRecordSchema->addField(evolvedNestedSchema, ""color_rec"");
    evolvedRecordSchema->addField(avro::NodePtr(new avro::NodePrimitive(avro::AVRO_STRING)), ""pii_col"");

    // populate inner record, with fewer fields
    avro::GenericRecord nestedRec","#include <gtest/gtest.h>
#include ""SchemaBuilder.h""
#include ""GenericData.h""
#include ""HoodieAvroUtils.h""

TEST(TestHoodieAvroUtils, testRewriteToEvolvedNestedRecord) {
    // schema definition for inner record
    Schema nestedSchema = SchemaBuilder::record(""inner_rec"").fields().requiredDouble(""color_id"").endRecord();
    Schema evolvedNestedSchema = SchemaBuilder::record(""inner_rec"").fields()
        .requiredDouble(""color_id"")
        .optionalString(""color_name"")
        .endRecord();

    // schema definition for outer record
    Schema recordSchema = SchemaBuilder::record(""outer_rec"").fields()
        .requiredDouble(""timestamp"")
        .requiredString(""_row_key"")
        .requiredString(""non_pii_col"")
        .name(""color_rec"").type(nestedSchema).noDefault()
        .requiredString(""pii_col"")
        .endRecord();
    Schema evolvedRecordSchema = SchemaBuilder::record(""outer_rec"").fields()
        .requiredDouble(""timestamp"")
        .requiredString(""_row_key"")
        .requiredString(""non_pii_col"")
        .name(""color_rec"").type(evolvedNestedSchema).noDefault()
        .requiredString(""pii_col"")
        .endRecord();

    // populate inner record, with fewer fields
    GenericRecord nestedRec(nestedSchema);
    nestedRec.put(""color_id"", 55.5);

    // populate outer record
    GenericRecord rec(recordSchema);
    rec.put(""timestamp"", 3.5);
    rec.put(""_row_key"", ""key1"");
    rec.put(""non_pii_col"", ""val1"");
    rec.put(""color_rec"", nestedRec);
    rec.put(""pii_col"", ""val2"");

    // rewrite record with less number of fields into an evolved record (with optional fields added).
    try {
        GenericRecord newRecord = HoodieAvroUtils::rewriteRecordWithOnlyNewSchemaFields(rec, evolvedRecordSchema);
        ASSERT_EQ(""val2"", newRecord.get(""pii_col""));
        ASSERT_EQ(nullptr, std::dynamic_pointer_cast<GenericRecord>(newRecord.get(""color_rec""))->get(""color_name""));
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
        ASSERT_TRUE(false) << ""Failed to rewrite Record"";
    }
}

TEST(TestHoodieAvroUtils, testRewriteToShorterRecord) {",1
"return executeFuncWithTimeMetrics(MetricName::create.name(), f, [&]() {
    return wrapOutputStream(f, fileSystem.create(convertToDefaultPath(f), permission, flags, bufferSize, replication,
        blockSize, progress, checksumOpt), bufferSize);
});","return executeFuncWithTimeMetrics(MetricName::create.name(), f, [&]() {
    return wrapOutputStream(f, fileSystem.create(convertToDefaultPath(f), permission, flags, bufferSize, replication,
        blockSize, progress, checksumOpt), bufferSize);
});",0
"}
return std::nullopt;
}

#include <optional>
#include <set>
#include <map>
#include <string>
#include <vector>
#include <algorithm>
#include <stdexcept>
#include <iterator>
#include <sstream>

class ConfigurationException : public std::runtime_error {
public:
    explicit ConfigurationException(const std::string& msg) : std::runtime_error(msg) {}
};

class ParameterValueResolver {
public:
    virtual std::map<std::string, std::string> getParameters() const = 0;
    virtual ~ParameterValueResolver() = default;
};

class ValueResolvingException : public std::exception {
public:
    explicit ValueResolvingException(const std::string& msg) : std::exception() {}
};

class MuleRuntimeException : public std::runtime_error {
public:
    explicit MuleRuntimeException(const std::exception& e) : std::runtime_error(e.what()) {}
};

template<typename T>
std::set<T> intersection(const std::set<T>& a, const std::set<T>& b) {
    std::set<T> result;
    std::set_intersection(a.begin(), a.end(), b.begin(), b.end(), std::inserter(result, result.begin()));
    return result;
}

std::string join(const std::set<std::string>& items, const std::string& delimiter) {
    std::ostringstream oss;
    for (auto it = items.begin(); it != items.end(); ++it) {
        if (it != items.begin()) oss << delimiter;
        oss << *it;
    }
    return oss.str();
}

std::string format(const std::string& fmt, const std::string& a1, const std::string& a2, const std::string& a3) {
    std::ostringstream oss;
    size_t s = 0, idx = 0, cnt = 0;
    std::vector<std::string> args = {a1, a2, a3};
    for (size_t i = 0; i < fmt.size(); ++i) {
        if (fmt[i] == '%' && i + 1 < fmt.size() && fmt[i+1] == 's' && cnt < args.size()) {
            oss << fmt.substr(s, i - s) << args[cnt++];
            i++;
            s = i + 1;
        }
    }
    oss << fmt.substr(s);
    return oss.str();
}

std::string format(const std::string& fmt, const","#include <optional>
#include <vector>
#include <map>
#include <set>
#include <string>
#include <algorithm>
#include <stdexcept>
#include <iterator>

// Forward declarations for types used in function signature and code.
class ParameterizedModel;
class ParameterGroupModel;
class ExclusiveParametersModel;
class ParameterValueResolver;
class ValueResolvingException : public std::exception {};
class ConfigurationException : public std::runtime_error {
public:
    explicit ConfigurationException(const std::string& msg) : std::runtime_error(msg) {}
};
class MuleRuntimeException : public std::runtime_error {
public:
    explicit MuleRuntimeException(const std::exception& e) : std::runtime_error(e.what()) {}
};

std::string createStaticMessage(const std::string& msg) { return msg; }

std::string format(const char* format_str, const std::string& a, const std::string& b)
{
    char buffer[1024];
    snprintf(buffer, sizeof(buffer), format_str, a.c_str(), b.c_str());
    return buffer;
}

std::string format(const char* format_str, const std::string& a, const std::string& b, const std::string& c)
{
    char buffer[1024];
    snprintf(buffer, sizeof(buffer), format_str, a.c_str(), b.c_str(), c.c_str());
    return buffer;
}

std::string getComponentModelTypeName(const ParameterizedModel& model);
std::string getModelName(const ParameterizedModel& model);

template <typename Container>
std::string join(const Container& container, const std::string& separator)
{
    std::string result;
    auto it = container.begin();
    if (it != container.end())
    {
        result += *it;
        ++it;
    }
    for (; it != container.end(); ++it)
    {
        result += separator;
        result += *it;
    }
    return result;
}

template <typename T>
std::set<T> intersection(const std::set<T>& a, const std::set<T>& b)
{
    std::set<T> result;
    std::set_intersection(a.begin(), a.end(), b.begin(), b.end(), std::inserter(result, result.begin()));
    return result;
}

void checkParameterGroupExclusiveness(
    const std::optional<ParameterizedModel>& model,
    const std::vector<ParameterGroupModel>& groups,
    const std::map<std::string, std::any>& parameters,",1
"private:
    bool isPathDedupeEnabled;

public:
    std::unordered_map<std::string, long> pathToRecordCount;
    static constexpr const char* PARTITION_RECORD_COUNT = ""recordCount"";","```cpp
#include <string>
#include <unordered_map>

class HiveRegistrationPublisher : public DataPublisher {
private:
    bool isPathDedupeEnabled;

    // This map serves two purposes:
    // 1. Path deduplication at the publisher level.
    // 2. Stores metadata such as numRecords for each partition.
    std::unordered_map<std::string, long> pathToRecordCount;

public:
    static constexpr const char* PARTITION_RECORD_COUNT = ""recordCount"";

    // constructor, other methods...
};
```",0
"#include ""org/apache/hudi/common/model/HoodieArchivedLogFile.h""
#include ""org/apache/hudi/common/model/HoodieAvroPayload.h""
#include ""org/apache/hudi/common/model/HoodieFailedWritesCleaningPolicy.h""
#include ""org/apache/hudi/common/model/HoodieLogFile.h""
#include ""org/apache/hudi/common/table/HoodieTableMetaClient.h""
#include ""org/apache/hudi/common/table/log/HoodieLogFormat.h""
#include ""org/apache/hudi/common/table/log/HoodieLogFormat_Writer.h""","#include ""FSUtils.h""
#include ""HoodieArchivedLogFile.h""
#include ""HoodieAvroPayload.h""
#include ""HoodieFailedWritesCleaningPolicy.h""
#include ""HoodieLogFile.h""
#include ""HoodieTableMetaClient.h""
#include ""HoodieLogFormat.h""
using Writer = HoodieLogFormat::Writer;",0
"if (dataFile.has_value()) {
    this->dataFileName = dataFile.value()->getFileName();
    this->id = HoodieFileGroupId(partitionPath, dataFile.value()->getFileId());
    this->dataFileCommitTime = dataFile.value()->getCommitTime();
    if (auto externalBaseFile = dataFile.value()->getExternalBaseFile()) {
        this->externalFilePath = externalBaseFile->getPath();
    } else {
        this->externalFilePath = std::nullopt;
    }
} else {
    assert(!logFiles.empty());
    this->dataFileName = std::nullopt;
    this->baseInstantTime = FSUtils::getBaseCommitTimeFromLogPath(logFiles[0].getPath());
    this->id = HoodieFileGroupId(partitionPath, FSUtils::getFileIdFromLogPath(logFiles[0].getPath()));
    this->dataFileCommitTime = std::nullopt;
    this->externalFilePath = std::nullopt;
}","```cpp
if (dataFile.has_value()) {
    this->dataFileName = Option::of(dataFile.value()->getFileName());
    this->id = HoodieFileGroupId(partitionPath, dataFile.value()->getFileId());
    this->dataFileCommitTime = Option::of(dataFile.value()->getCommitTime());
    this->externalFilePath = dataFile.value()->getExternalBaseFile().map([](const BaseFile& b) { return b.getPath(); });
} else {
    assert(!logFiles.empty());
    this->dataFileName = Option::empty();
    this->baseInstantTime = FSUtils::getBaseCommitTimeFromLogPath(logFiles[0].getPath());
    this->id = HoodieFileGroupId(partitionPath, FSUtils::getFileIdFromLogPath(logFiles[0].getPath()));
    this->dataFileCommitTime = Option::empty();
    this->externalFilePath = Option::empty();
}
this->deltaFileNames.clear();
for (const auto& s : logFiles) {
    this->deltaFileNames.push_back(s.getPath().getName());
}
this->metrics = metrics;
```",0
"#include <string>

class StaticFlowTemplate { 
public:
    static constexpr long long serialVersionUID = 84641624233978LL;

    static const std::string INPUT_DATASET_DESCRIPTOR_PREFIX;
    static const std::string OUTPUT_DATASET_DESCRIPTOR_PREFIX;
    static const std::string DATASET_DESCRIPTOR_CLASS_KEY;
};

const std::string StaticFlowTemplate::INPUT_DATASET_DESCRIPTOR_PREFIX = ""gobblin.flow.dataset.descriptor.input"";
const std::string StaticFlowTemplate::OUTPUT_DATASET_DESCRIPTOR_PREFIX = ""gobblin.flow.dataset.descriptor.output"";
const std::string StaticFlowTemplate::DATASET_DESCRIPTOR_CLASS_KEY = ""class"";","#include <string>

class StaticFlowTemplate {
public:
    static constexpr long long serialVersionUID = 84641624233978LL;
    static const std::string INPUT_DATASET_DESCRIPTOR_PREFIX;
    static const std::string OUTPUT_DATASET_DESCRIPTOR_PREFIX;
    static const std::string DATASET_DESCRIPTOR_CLASS_KEY;
};

const std::string StaticFlowTemplate::INPUT_DATASET_DESCRIPTOR_PREFIX = ""gobblin.flow.dataset.descriptor.input"";
const std::string StaticFlowTemplate::OUTPUT_DATASET_DESCRIPTOR_PREFIX = ""gobblin.flow.dataset.descriptor.output"";
const std::string StaticFlowTemplate::DATASET_DESCRIPTOR_CLASS_KEY = ""class"";",1
"#include <string>
#include <unordered_map>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

WorkflowDag convertYamlToDag(const std::string& yaml) {
    int dagRounds = DEFAULT_DAG_ROUNDS;
    int intermittentDelayMins = DEFAULT_INTERMITTENT_DELAY_MINS;
    std::string dagName = DEFAULT_DAG_NAME;
    std::unordered_map<std::string, DagNode> allNodes;
    json jsonNode = yaml::parse(yaml); // Assuming a yaml-to-json parse function
    for (auto it = jsonNode.begin(); it != jsonNode.end(); ++it) {
        std::string key = it.key();
        if (key == DAG_NAME) {
            dagName = it.value().get<std::string>();
        } else if (key == DAG_ROUNDS) {
            dagRounds = it.value().get<int>();
        } else if (key == DAG_INTERMITTENT_DELAY_MINS) {
            intermittentDelayMins = it.value().get<int>();
        } else if (key == DAG_CONTENT) {
            auto& dagContent = it.value();
            for (auto contentIt = dagContent.begin(); contentIt != dagContent.end(); ++contentIt) {
                allNodes[contentIt.key()] = convertJsonToDagNode(allNodes, contentIt.key(), contentIt.value());
            }
        } else {
            // do nothing
        }
    }
    return WorkflowDag(dagName, dagRounds, intermittentDelayMins, findRootNodes(allNodes));
}","WorkflowDag convertYamlToDag(const std::string& yaml) {
    int dagRounds = DEFAULT_DAG_ROUNDS;
    int intermittentDelayMins = DEFAULT_INTERMITTENT_DELAY_MINS;
    std::string dagName = DEFAULT_DAG_NAME;
    std::unordered_map<std::string, DagNode> allNodes;
    YAML::Node root = YAML::Load(yaml);

    for (auto it = root.begin(); it != root.end(); ++it) {
        std::string key = it->first.as<std::string>();
        if (key == DAG_NAME) {
            dagName = it->second.as<std::string>();
        } else if (key == DAG_ROUNDS) {
            dagRounds = it->second.as<int>();
        } else if (key == DAG_INTERMITTENT_DELAY_MINS) {
            intermittentDelayMins = it->second.as<int>();
        } else if (key == DAG_CONTENT) {
            YAML::Node dagContent = it->second;
            for (auto contentIt = dagContent.begin(); contentIt != dagContent.end(); ++contentIt) {
                std::string contentKey = contentIt->first.as<std::string>();
                allNodes[contentKey] = convertJsonToDagNode(
                    allNodes, 
                    contentKey, 
                    contentIt->second
                );
            }
        }
    }
    return WorkflowDag(dagName, dagRounds, intermittentDelayMins, findRootNodes(allNodes));
}",1
"auto builder = MaterialDialog::Builder(requireActivity())
    .neutralText(R::string::dialog_cancel)
    .customView(dialogView, false)
    .onNeutral([](Dialog* dialog, int which) {});","```cpp
QDialog dialog(parent);
QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Cancel | QDialogButtonBox::RestoreDefaults);
dialog.setLayout(new QVBoxLayout);
dialog.layout()->addWidget(dialogView);
dialog.layout()->addWidget(buttonBox);
QObject::connect(buttonBox, &QDialogButtonBox::rejected, &dialog, [&]() { onDeckSelected(nullptr); });
QObject::connect(buttonBox->button(QDialogButtonBox::Cancel), &QPushButton::clicked, &dialog, [&]() { /* do nothing */ });
```",1
"conf.setInteger(FlinkOptions::COMPACTION_DELTA_COMMITS, config.compactionDeltaCommits);
conf.setInteger(FlinkOptions::COMPACTION_DELTA_SECONDS, config.compactionDeltaSeconds);
conf.setInteger(FlinkOptions::COMPACTION_MAX_MEMORY, config.compactionMaxMemory);
conf.setLong(FlinkOptions::COMPACTION_TARGET_IO, config.compactionTargetIo);
conf.setInteger(FlinkOptions::COMPACTION_TASKS, config.compactionTasks);
conf.setBoolean(FlinkOptions::CLEAN_ASYNC_ENABLED, config.cleanAsyncEnable);
conf.setBoolean(FlinkOptions::COMPACTION_ASYNC_ENABLED, false);","conf.setInteger(FlinkOptions::COMPACTION_DELTA_COMMITS, config.compactionDeltaCommits);
conf.setInteger(FlinkOptions::COMPACTION_DELTA_SECONDS, config.compactionDeltaSeconds);
conf.setInteger(FlinkOptions::COMPACTION_MAX_MEMORY, config.compactionMaxMemory);
conf.setLong(FlinkOptions::COMPACTION_TARGET_IO, config.compactionTargetIo);
conf.setInteger(FlinkOptions::COMPACTION_TASKS, config.compactionTasks);
conf.setBoolean(FlinkOptions::CLEAN_ASYNC_ENABLED, config.cleanAsyncEnable);
// use synchronous compaction always
conf.setBoolean(FlinkOptions::COMPACTION_ASYNC_ENABLED, false);",0
"EXPECT_CALL(*networkModel, getNextAvailableMacAddressInNetwork(::testing::A<long>())).Times(times);
EXPECT_EQ(expectedMacAddress, returnedMacAddress);

TEST(YourTestSuite, validateRemoveTagsWhenExists) {
    std::vector<ResourceTag> resourceTags = { ResourceTagVO(""test"", ""test"", 1L, 2L, 123L, ResourceTag::ResourceObjectType::UserVm, """", ""test"") };
    std::vector<std::string> resourceIds = { ""123"" };

    EXPECT_CALL(*taggedResourceManagerMock, getUuid(""123"", ResourceTag::ResourceObjectType::UserVm)).WillOnce(::testing::Return(""123""));
    EXPECT_CALL(*taggedResourceManagerMock, getResourceId(""123"", ResourceTag::ResourceObjectType::UserVm)).WillOnce(::testing::Return(123L));
    EXPECT_CALL(*taggedResourceManagerMock, listByResourceTypeAndId(ResourceTag::ResourceObjectType::UserVm, 123L)).WillOnce(::testing::Return(resourceTags));
    EXPECT_CALL(*taggedResourceManagerMock, deleteTags(resourceIds, ResourceTag::ResourceObjectType::UserVm, nullptr)).WillOnce(::testing::Return(true));
    EXPECT_CALL(*userVmDao, findById(123L)).WillOnce(::testing::Return(userVmVoMock));
    EXPECT_CALL(*userVmVoMock, getUuid()).WillOnce(::testing::Return(""123""));

    userVmManagerImpl.removeTagsFromVm(123L);
    EXPECT_TRUE(taggedResourceManagerMock->deleteTags(resourceIds, ResourceTag::ResourceObjectType::UserVm, nullptr));
}

TEST(YourTestSuite, validateWhenRemoveTagsNoExists) {
    std::vector<ResourceTag> resourceTags;
    
    EXPECT_CALL(*taggedResourceManagerMock, getResourceId(""1L"", ResourceTag::ResourceObjectType::UserVm)).WillOnce(::testing::Return(1L));
    EXPECT_CALL(*taggedResourceManagerMock, listByResourceTypeAndId(ResourceTag::ResourceObjectType::UserVm, 1L)).WillOnce(::testing::Return(resourceTags));
    EXPECT_CALL(*userVmVoMock, getUuid()).WillOnce(::testing::Return(""1L""));
    EXPECT_CALL(*userVmDao, findById(::testing::Eq(vmId))).WillOnce(::testing::Return(userVmVoMock));

    userVmManagerImpl.removeTagsFromVm(1L);
    EXPECT_EQ(0, tagged","#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <vector>
#include <string>
#include <memory>

using namespace testing;

class ResourceTag {
public:
    enum class ResourceObjectType { UserVm };
    virtual ~ResourceTag() = default;
};

class ResourceTagVO : public ResourceTag {
public:
    ResourceTagVO(const std::string&, const std::string&, long, long, long, ResourceObjectType, const std::string&, const std::string&) {}
};

class TaggedResourceManagerMock {
public:
    MOCK_METHOD(std::string, getUuid, (const std::string&, ResourceTag::ResourceObjectType), ());
    MOCK_METHOD(long, getResourceId, (const std::string&, ResourceTag::ResourceObjectType), ());
    MOCK_METHOD(std::vector<std::shared_ptr<ResourceTag>>, listByResourceTypeAndId, (ResourceTag::ResourceObjectType, long), ());
    MOCK_METHOD(bool, deleteTags, (const std::vector<std::string>&, ResourceTag::ResourceObjectType, void*), ());
};

class UserVmVoMock {
public:
    MOCK_METHOD(std::string, getUuid, (), ());
};

class UserVmDaoMock {
public:
    MOCK_METHOD(UserVmVoMock*, findById, (long), ());
};

class UserVmManagerImpl {
public:
    UserVmManagerImpl(TaggedResourceManagerMock* tagMgr, UserVmDaoMock* dao) : tagMgr_(tagMgr), dao_(dao) {}
    void removeTagsFromVm(long id) {
        UserVmVoMock* vm = dao_->findById(id);
        if (!vm) return;
        std::string uuid = vm->getUuid();
        long resourceId = tagMgr_->getResourceId(uuid, ResourceTag::ResourceObjectType::UserVm);
        auto tags = tagMgr_->listByResourceTypeAndId(ResourceTag::ResourceObjectType::UserVm, resourceId);
        if (!tags.empty()) {
            std::vector<std::string> resourceIds{uuid};
            tagMgr_->deleteTags(resourceIds, ResourceTag::ResourceObjectType::UserVm, nullptr);
        }
    }
private:
    TaggedResourceManagerMock* tagMgr_;
    UserVmDaoMock* dao_;
};

class UserVmManagerImplTest : public Test {
protected:
    TaggedResourceManagerMock taggedResourceManagerMock;
    UserVmDaoMock userVmDao;
    UserVmVoMock userVmVoMock;
    UserVmManagerImpl userVm",1
"}
}

Var IntlEngineInterfaceExtensionObject::EntryIntl_FormatDateTime(RecyclableObject* function, CallInfo callInfo, ...)
{
    EngineInterfaceObject_CommonFunctionProlog(function, callInfo);

#ifdef INTL_WINGLOB
    if (args.Info.Count < 3 || !(TaggedInt::Is(args.Values[1]) || JavascriptNumber::Is(args.Values[1])) || !DynamicObject::Is(args.Values[2]))
    {
        return scriptContext->GetLibrary()->GetUndefined();
    }

#endif
}","```cpp
Var IntlEngineInterfaceExtensionObject::EntryIntl_FormatDateTime(RecyclableObject* function, CallInfo callInfo, ...)
{
    EngineInterfaceObject_CommonFunctionProlog(function, callInfo);

#ifdef INTL_WINGLOB
    if (args.Info.Count < 3 ||
        !(TaggedInt::Is(args.Values[1]) || JavascriptNumber::Is(args.Values[1])) ||
        !DynamicObject::Is(args.Values[2]))
    {
        return scriptContext->GetLibrary()->GetUndefined();
    }

    Windows::Foundation::DateTime winDate;
    HRESULT hr;
    if (TaggedInt::Is(args.Values[1]))
    {
        // ... implementation continues
    }
#endif
}
```",1
"/ Copyright 2002-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.","/ Copyright 2002-2015 the original author or authors.
 / 
 / Licensed under the Apache License, Version 2.0 (the ""License"");
 / you may not use this file except in compliance with the License.",0
"virtual BundleSpecExportPackage& include(const std::vector<std::string>& classNames) {
    if (classNames.empty()) {
        throw std::invalid_argument(""'classNames' cannot be null or empty"");
    }
    directive(""include"", x().join(classNames));
    return *this;
}","virtual BundleSpecExportPackage& include(const std::vector<std::string>& classNames) {
    if (classNames.empty()) {
        throw std::invalid_argument(""'classNames' cannot be null or empty"");
    }
    directive(""include"", x().join(classNames));
    return *this;
}",0
"/ *
[DEL] * Copyright (c) 2016 Uber Technologies, Inc. (hoodie-dev-group@uber.com)
[ADD] * Copyright (c) 2016,2017 Uber Technologies, Inc. (hoodie-dev-group@uber.com)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
*/","/*
 * Copyright (c) 2016,2017 Uber Technologies, Inc. (hoodie-dev-group@uber.com)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
*/",0
"```cpp
baseUrl = state.getProp(KAFKA_AUDIT_REST_BASE_URL);
maxNumTries = state.getPropAsInt(KAFKA_AUDIT_REST_MAX_TRIES, 5);
retryBackOffSecs = state.getPropAsInt(KAFKA_AUDIT_REST_BACKOFF_INTERVAL_SECONDS, KAFKA_AUDIT_REST_BACKOFF_INTERVAL_SECONDS_DEFAULT);
topicQueryString = state.getProp(KAFKA_AUDIT_REST_TOPIC_QUERYSTRING_KEY, KAFKA_AUDIT_REST_TOPIC_QUERYSTRING_DEFAULT);
startQueryString = state.getProp(KAFKA_AUDIT_REST_START_QUERYSTRING_KEY, KAFKA_AUDIT_REST_START_QUERYSTRING_DEFAULT);
endQueryString = state.getProp(KAFKA_AUDIT_REST_END_QUERYSTRING_KEY, KAFKA_AUDIT_REST_END_QUERYSTRING_DEFAULT);
}


std::map<std::string, long> fetch(const std::string& topic, long start, long end) {
    std::string actualBaseUrl = (baseUrl.size() > 0 && baseUrl.back() == '/') ? baseUrl.substr(0, baseUrl.size() - 1) : baseUrl;
    std::string fullUrl = actualBaseUrl + ""?"" + topicQueryString + ""="" + topic
        + ""&"" + startQueryString + ""="" + std::to_string(start)
        + ""&"" + endQueryString + ""="" + std::to_string(end);
    log.info(""Full URL is "" + fullUrl);
    std::string response = getHttpResponse(fullUrl);
    return parseResponse(fullUrl, response, topic);
}
```","std::string baseUrl = state.getProp(KAFKA_AUDIT_REST_BASE_URL);
int maxNumTries = state.getPropAsInt(KAFKA_AUDIT_REST_MAX_TRIES, 5);
int retryBackOffSecs = state.getPropAsInt(KAFKA_AUDIT_REST_BACKOFF_INTERVAL_SECONDS, KAFKA_AUDIT_REST_BACKOFF_INTERVAL_SECONDS_DEFAULT);
std::string topicQueryString = state.getProp(KAFKA_AUDIT_REST_TOPIC_QUERYSTRING_KEY, KAFKA_AUDIT_REST_TOPIC_QUERYSTRING_DEFAULT);
std::string startQueryString = state.getProp(KAFKA_AUDIT_REST_START_QUERYSTRING_KEY, KAFKA_AUDIT_REST_START_QUERYSTRING_DEFAULT);
std::string endQueryString = state.getProp(KAFKA_AUDIT_REST_END_QUERYSTRING_KEY, KAFKA_AUDIT_REST_END_QUERYSTRING_DEFAULT);

std::map<std::string, long> fetch(const std::string& topic, long start, long end) {
    std::string fullUrl = (baseUrl.back() == '/' ? baseUrl.substr(0, baseUrl.size() - 1) : baseUrl)
        + ""?"" + topicQueryString + ""="" + topic
        + ""&"" + startQueryString + ""="" + std::to_string(start)
        + ""&"" + endQueryString + ""="" + std::to_string(end);
    log.info(""Full URL is "" + fullUrl);
    std::string response = getHttpResponse(fullUrl);
    return parseResponse(fullUrl, response, topic);
}",0
"virtual std::unique_ptr<Builder<K, V>> toBuilder() = 0;

template <typename K, typename V>
class Builder : public ExternalTransformBuilder<External::Configuration, PCollection<KV<K, V>>, PDone> {
public:
    virtual Builder<K, V>& setTopic(const std::string& topic) = 0;

    virtual Builder<K, V>& setWriteRecordsTransform(const WriteRecords<K, V>& transform) = 0;

    virtual Write<K, V> build() = 0;

    std::unique_ptr<PTransform<PCollection<KV<K, V>>, PDone>>
    buildExternal(const External::Configuration& configuration) override {
        std::string topic = utf8String(configuration.topic);

        setTopic(topic);

        std::map<std::string, std::string> producerConfig;
        for (const auto& kv : configuration.producerConfig) {
            std::string key = utf8String(kv.first);
            std::string value = utf8String(kv.second);
            producerConfig[key] = value;
        }
        auto keySerializer = resolveClass(utf8String(configuration.keySerializer));
        auto valSerializer = resolveClass(utf8String(configuration.valueSerializer));

        auto writeRecords =
            KafkaIO<K, V>::writeRecords()
                .updateProducerProperties(producerConfig)
                .withKeySerializer(keySerializer)
                .withValueSerializer(valSerializer)
                .withTopic(topic);

        setWriteRecordsTransform(writeRecords);

        return std::make_unique<Write<K, V>>(build());
    }
};

class External : public ExternalTransformRegistrar {
public:
    static constexpr const char* URN = ""beam:external:java:kafka:write:v1"";

    std::map<std::string, std::function<std::unique_ptr<ExternalTransformBuilderBase>()>>
    knownBuilders() override {
        return {
            {URN, []() { return std::make_unique<AutoValue_KafkaIO_Write_Builder>(); }}
        };
    }

    class Configuration {
    public:
        std::vector<std::pair<std::vector<uint8_t>, std::vector<uint8_t>>> producerConfig;
        std::vector<uint8_t> topic;
        std::vector<uint8_t> keySerializer;
        std::vector<uint8_t> valueSerializer;

        void setProducerConfig(const std::vector<std::pair<std::vector<uint8_t>, std::vector<uint8_t>>>& pc) {
            producerConfig = pc;","template <typename K, typename V>
class Builder : public ExternalTransformBuilder<External::Configuration, PCollection<KV<K, V>>, PDone> {
public:
    virtual Builder<K, V>& setTopic(const std::string& topic) = 0;
    virtual Builder<K, V>& setWriteRecordsTransform(const WriteRecords<K, V>& transform) = 0;
    virtual Write<K, V> build() = 0;

    PTransform<PCollection<KV<K, V>>, PDone> buildExternal(const External::Configuration& configuration) override {
        std::string topic = utf8String(configuration.topic);
        setTopic(topic);

        std::map<std::string, std::string> producerConfig;
        for (const auto& kv : configuration.producerConfig) {
            std::string key = utf8String(kv.first);
            std::string value = utf8String(kv.second);
            producerConfig[key] = value;
        }
        auto keySerializer = resolveClass<K>(utf8String(configuration.keySerializer));
        auto valSerializer = resolveClass<V>(utf8String(configuration.valueSerializer));

        auto writeRecords =
            KafkaIO<K, V>::writeRecords()
                .updateProducerProperties(producerConfig)
                .withKeySerializer(keySerializer)
                .withValueSerializer(valSerializer)
                .withTopic(topic);

        setWriteRecordsTransform(writeRecords);
        return build();
    }
};

class External : public ExternalTransformRegistrar {
public:
    static constexpr const char* URN = ""beam:external:java:kafka:write:v1"";

    std::map<std::string, std::function<std::unique_ptr<ExternalTransformBuilderBase>()>> knownBuilders() override {
        return {
            {URN, [](){ return std::make_unique<AutoValue_KafkaIO_Write_Builder>(); }}
        };
    }

    struct Configuration {
        std::vector<std::pair<std::vector<uint8_t>, std::vector<uint8_t>>> producerConfig;
        std::vector<uint8_t> topic;
        std::vector<uint8_t> keySerializer;
        std::vector<uint8_t> valueSerializer;

        void setProducerConfig(const std::vector<std::pair<std::vector<uint8_t>, std::vector<uint8_t>>>& pc) {
            producerConfig = pc;
        }

        void setTopic(const std::vector<uint8_t>& t) {
            topic = t;
        }

        void setKeySerializer(const std::vector<uint8_t>&",1
"ResourceProvider* externalResourceProvider)
    : ClassName(artifactConfig, artifactDeclaration, std::set<>(), std::map<>(), std::nullopt, std::make_optional(ComponentBuildingDefinitionRegistry()), externalResourceProvider, true) {}","ApplicationModel(
    ArtifactConfig artifactConfig,
    ArtifactDeclaration artifactDeclaration,
    ResourceProvider externalResourceProvider
) : ApplicationModel(
        artifactConfig,
        artifactDeclaration,
        std::set<>(),
        std::map<>(),
        std::nullopt,
        std::make_optional(ComponentBuildingDefinitionRegistry()),
        externalResourceProvider,
        true
    ) {}",0
"case NOTES_V2: {
    std::vector<std::string> proj = sanitizeNoteProjection(projection);
    std::string sql = SQLiteQueryBuilder::buildQueryString(false, ""notes"", proj, selection, nullptr, nullptr, order, nullptr);
    return col.getDb().getDatabase().query(sql, selectionArgs);
}
case NOTES: {
    // Search for notes using the libanki browser syntax","switch (uriType) {
    case NOTES_V2: {
        std::vector<std::string> proj = sanitizeNoteProjection(projection);
        std::string sql = SQLiteQueryBuilder::buildQueryString(false, ""notes"", proj, selection, nullptr, nullptr, order, nullptr);
        return col.getDb()->getDatabase()->query(sql, selectionArgs);
    }
    case NOTES: {
        // ...
    }
}",1
"for (auto& allocator : _storagePoolAllocators) {
    std::vector<StoragePool> suitablePools = allocator.allocateToPool(diskProfile, vmProfile, plan, avoid, returnUpTo);
    if (!suitablePools.empty()) {
        std::vector<StoragePool> pools;
        auto storagePool = getPreferredStoragePool(suitablePools, vmProfile.getVirtualMachine());
        if (storagePool.has_value()) {
            pools.push_back(storagePool.value());
        }

        pools.insert(pools.end(), suitablePools.begin(), suitablePools.end());
        suitableVolumeStoragePools[toBeCreated] = pools;
        foundPotentialPools = true;
        break;
    }
}","```cpp
for (auto& allocator : _storagePoolAllocators) {
    std::vector<StoragePool> suitablePools = allocator.allocateToPool(diskProfile, vmProfile, plan, avoid, returnUpTo);
    if (!suitablePools.empty()) {
        std::vector<StoragePool> pools;
        auto storagePool = getPreferredStoragePool(suitablePools, vmProfile.getVirtualMachine());
        if (storagePool) {
            pools.push_back(*storagePool);
        }
        pools.insert(pools.end(), suitablePools.begin(), suitablePools.end());
        suitableVolumeStoragePools[toBeCreated] = pools;
        foundPotentialPools = true;
        break;
    }
}
```",1
"#include <string>

struct ConverterConfigProperties {
    static constexpr const char* CONVERTER_AVRO_INCLUDE_SCHEMA_CREATION_TIME = ""converter.avro.include.schema.creation.time"";
    static constexpr bool DEFAULT_CONVERTER_AVRO_INCLUDE_SCHEMA_CREATION_TIME = true;
    static constexpr const char* CONVERTER_AVRO_DATE_FORMAT = ""converter.avro.date.format"";
    static constexpr const char* CONVERTER_AVRO_DATE_TIMEZONE = ""converter.avro.date.timezone"";
    static constexpr const char* CONVERTER_AVRO_TIME_FORMAT = ""converter.avro.time.format"";
};","#include <string>

struct ConfigurationKeys {
    static constexpr const char* CONVERTER_AVRO_INCLUDE_SCHEMA_CREATION_TIME = ""converter.avro.include.schema.creation.time"";
    static constexpr bool DEFAULT_CONVERTER_AVRO_INCLUDE_SCHEMA_CREATION_TIME = true;
    static constexpr const char* CONVERTER_AVRO_DATE_FORMAT = ""converter.avro.date.format"";
    static constexpr const char* CONVERTER_AVRO_DATE_TIMEZONE = ""converter.avro.date.timezone"";
    static constexpr const char* CONVERTER_AVRO_TIME_FORMAT = ""converter.avro.time.format"";
};",1
"if (delay.has_value()) {
    nextTime = self.defer.now + delay.value();
} else if (!self.deferredFns.empty()) {
    nextTime = self.deferredFns.back().time;
} else {
    throw std::runtime_error(""No deferred tasks to be flushed"");
}

while (!self.deferredFns.empty() && self.deferredFns.front().time <= nextTime) {
    self.defer.now = self.deferredFns.front().time;
    auto task = self.deferredFns.front();
    self.deferredFns.pop_front();
    completeOutstandingRequest(task.fn, task.type);
}

self.defer.now = nextTime;

class Defer {
public:
    void verifyNoPendingTasks(const std::optional<std::string>& taskType = std::nullopt) {
        std::vector<Task> pendingTasks;
        if (!taskType.has_value()) {
            pendingTasks.assign(self.deferredFns.begin(), self.deferredFns.end());
        } else {
            std::copy_if(
                self.deferredFns.begin(), self.deferredFns.end(), std::back_inserter(pendingTasks),
                [&](const Task& t) { return t.type == taskType.value(); }
            );
        }

        if (!pendingTasks.empty()) {
            std::ostringstream os;
            os << ""Deferred tasks to flush ("" << pendingTasks.size() << ""):\n  "";
            for (size_t i = 0; i < pendingTasks.size(); ++i) {
                os << ""{id: "" << pendingTasks[i].id
                   << "", type: "" << pendingTasks[i].type
                   << "", time: "" << pendingTasks[i].time << '}';
                if (i + 1 < pendingTasks.size())
                    os << '\n' << ""  "";
            }
            throw std::runtime_error(os.str());
        }
    }
};

// ...

self.$$baseHref = ""/"";
self.baseHref = [&]() -> std::string {
    return self.$$baseHref;
};","```cpp
#include <vector>
#include <stdexcept>
#include <string>
#include <algorithm>
#include <sstream>

struct DeferredTask {
    int id;
    std::string type;
    int time;
    void (*fn)();
};

struct Defer {
    int now = 0;
    std::vector<DeferredTask> deferredFns;

    void flush(std::optional<int> delay = std::nullopt) {
        int nextTime;
        if (delay.has_value()) {
            nextTime = now + delay.value();
        } else if (!deferredFns.empty()) {
            nextTime = deferredFns.back().time;
        } else {
            throw std::runtime_error(""No deferred tasks to be flushed"");
        }

        while (!deferredFns.empty() && deferredFns.front().time <= nextTime) {
            now = deferredFns.front().time;
            DeferredTask task = deferredFns.front();
            deferredFns.erase(deferredFns.begin());
            completeOutstandingRequest(task.fn, task.type);
        }
        now = nextTime;
    }

    void verifyNoPendingTasks(const std::string& taskType = """") {
        std::vector<DeferredTask> pendingTasks;
        if (taskType.empty()) {
            pendingTasks = deferredFns;
        } else {
            std::copy_if(
                deferredFns.begin(),
                deferredFns.end(),
                std::back_inserter(pendingTasks),
                [&taskType](const DeferredTask& task) {
                    return task.type == taskType;
                }
            );
        }

        if (!pendingTasks.empty()) {
            std::ostringstream oss;
            for (const auto& task : pendingTasks) {
                oss << ""{id: "" << task.id << "", type: "" << task.type << "", time: "" << task.time << ""}\n  "";
            }
            std::string tasksStr = oss.str();
            if (!tasksStr.empty() && tasksStr.size() >= 2) {
                tasksStr.erase(tasksStr.end() - 2, tasksStr.end()); // Remove extra ""\n  ""
            }
            throw std::runtime_error(
                ""Deferred tasks to flush ("" + std::to_string(pendingTasks.size()) + ""):\n  "" + tasksStr
            );
        }
    }
};

struct Browser {
    Defer defer;
    std::string $$baseHref = ""/"";

    std::string baseHref() const {
        return $$baseHref;
    }
};

// Placeholder for completeOutstandingRequest; in",1
"std::optional<MetadataCacheId> getIdForComponentAttributesMetadata(const ComponentAst& component) override {
    assert(&component != nullptr && ""Cannot generate a Cache Key for a 'null' component"");
    return delegate.getIdForComponentAttributesMetadata(component);
}","std::optional<MetadataCacheId> getIdForComponentAttributesMetadata(const ComponentAst& component) override {
    assert(&component != nullptr && ""Cannot generate a Cache Key for a 'null' component"");
    return delegate.getIdForComponentAttributesMetadata(component);
}",0
"return dynamic_cast<Topic*>(destination) != nullptr;
}

JmsListenerLock* createJmsLock() {
    return synchronous ? new DefaultJmsListenerLock() : new NullJmsListenerLock();
}

int getValidNumberOfConsumers(int numberOfConsumers) {
    if (numberOfConsumers > 1 && consumerType.isTopic()) {
        TopicConsumer* topicConsumer = static_cast<TopicConsumer*>(&consumerType);

        if (!isCapableOfMultiConsumersOnTopic(*topicConsumer)) {
            LOGGER.warn(""Destination ["" + destination + ""] is a topic, but "" +
                        std::to_string(numberOfConsumers) +
                        "" receivers have been requested. Will configure only 1"");
            return 1;
        }
    }
    return numberOfConsumers;
}

bool isCapableOfMultiConsumersOnTopic(const TopicConsumer& topicConsumer) {
    return jmsSupport.getSpecification() == JMS_2_0 && topicConsumer.isShared();
}","```cpp
class JmsListener : public Source<Object, JmsAttributes> {
public:
    bool isTopic() const {
        return dynamic_cast<Topic*>(destination) != nullptr;
    }

private:
    std::unique_ptr<JmsListenerLock> createJmsLock() {
        return synchronous ? std::make_unique<DefaultJmsListenerLock>() : std::make_unique<NullJmsListenerLock>();
    }

    int getValidNumberOfConsumers(int numberOfConsumers) {
        if (numberOfConsumers > 1 && consumerType.isTopic()) {
            TopicConsumer* topicConsumer = static_cast<TopicConsumer*>(&consumerType);

            if (!isCapableOfMultiConsumersOnTopic(*topicConsumer)) {
                LOGGER.warn(""Destination ["" + to_string(destination) + ""] is a topic, but "" +
                            std::to_string(numberOfConsumers) +
                            "" receivers have been requested. Will configure only 1"");
                return 1;
            }
        }
        return numberOfConsumers;
    }

    bool isCapableOfMultiConsumersOnTopic(const TopicConsumer& topicConsumer) const {
        return jmsSupport.getSpecification() == JMS_2_0 && topicConsumer.isShared();
    }
};
```",1
"setPendingQuit(DesktopFrame::PENDING_QUIT_AND_RESTART);

auto progress = TimedProgressIndicator(
    globalDisplay_.getProgressIndicator(constants_.progressErrorCaption()));
progress.onTimedProgress(constants_.restartingRMessage(), 1000);

auto onRestartComplete = [&]() {
    suspendingAndRestarting_ = false;
};","setPendingQuit(DesktopFrame::PENDING_QUIT_AND_RESTART);

TimedProgressIndicator progress(
    globalDisplay_->getProgressIndicator(constants_->progressErrorCaption()));
progress.onTimedProgress(constants_->restartingRMessage(), 1000);

auto onRestartComplete = [&]() {
    suspendingAndRestarting_ = false;
};",0
"protected:
bool isSourceAndDestinationPoolTypeOfNfs(const std::map<VolumeInfo, DataStore*>& volumeDataStoreMap) {
    for (const auto& entry : volumeDataStoreMap) {
        const VolumeInfo& srcVolumeInfo = entry.first;
        DataStore* destDataStore = entry.second;

        StoragePoolVO* destStoragePool = _storagePoolDao->findById(destDataStore->getId());
        StoragePoolVO* sourceStoragePool = _storagePoolDao->findById(srcVolumeInfo.getPoolId());
        if (sourceStoragePool->getPoolType() == StoragePoolType::NetworkFilesystem &&
            destStoragePool->getPoolType() == StoragePoolType::NetworkFilesystem) {
            return true;
        }
    }
    return false;
}","```cpp
bool isSourceAndDestinationPoolTypeOfNfs(const std::map<VolumeInfo, DataStore*>& volumeDataStoreMap) {
    for (const auto& entry : volumeDataStoreMap) {
        const VolumeInfo& srcVolumeInfo = entry.first;
        DataStore* destDataStore = entry.second;

        StoragePoolVO* destStoragePool = _storagePoolDao->findById(destDataStore->getId());
        StoragePoolVO* sourceStoragePool = _storagePoolDao->findById(srcVolumeInfo.getPoolId());
        if (sourceStoragePool->getPoolType() == StoragePoolType::NetworkFilesystem &&
            destStoragePool->getPoolType() == StoragePoolType::NetworkFilesystem) {
            return true;
        }
    }
    return false;
}
```",1
"virtual Builder& base64UniqueId(const std::string& base64UniqueId) = 0;
virtual Builder& userAccountControl(const ADUserAccountControl& adUserAccountControl) = 0;
virtual Builder& username(const std::string& username) = 0;
virtual Builder& fullName(const std::string& fullName) = 0;","virtual Builder& base64UniqueId(const std::string& base64UniqueId) = 0;

virtual Builder& userAccountControl(const ADUserAccountControl& adUserAccountControl) = 0;

virtual Builder& username(const std::string& username) = 0;

virtual Builder& fullName(const std::string& fullName) = 0;",0
"```cpp
template<typename T>
class Checkpoint {
public:
    std::optional<std::vector<TimestampedValue<T>>> residualElements;
    std::optional<std::deque<std::shared_ptr<BoundedSource<T>>>> residualSources;

    Checkpoint(
        std::optional<std::vector<TimestampedValue<T>>> residualElements_,
        std::optional<std::deque<std::shared_ptr<BoundedSource<T>>>> residualSources_)
        : residualElements(std::move(residualElements_)),
          residualSources(std::move(residualSources_)) {}

    void finalizeCheckpoint() {}

    std::optional<const std::vector<TimestampedValue<T>>&> getResidualElements() const {
        if (residualElements) return *residualElements;
        return std::nullopt;
    }

    std::optional<const std::deque<std::shared_ptr<BoundedSource<T>>>&> getResidualSources() const {
        if (residualSources) return *residualSources;
        return std::nullopt;
    }
};

template<typename T>
class ResidualSources {
private:
    std::deque<std::shared_ptr<BoundedSource<T>>> residualSources;
    PipelineOptions options;
    std::unique_ptr<BoundedReader<T>> reader;
    bool closed;
    bool readerDone;
    bool currentResidualSourceDone;
    std::shared_ptr<BoundedSource<T>> currentResidualSource;

    bool helper(bool onlyFinishReadingCurrentSource) {
        if (closed) {
            throw std::logic_error(""advance() call on closed ResidualSources"");
        }
        if (readerDone) {
            return false;
        }

        if (!reader && !residualSources.empty()) {
            currentResidualSource = residualSources.front();
            residualSources.pop_front();
            reader = currentResidualSource->createReader(options);
            currentResidualSourceDone = !reader->start();
        } else {
            if (!reader || !currentResidualSource) {
                return false;
            }
            currentResidualSourceDone = !reader->advance();
        }

        if (currentResidualSourceDone
            && !residualSources.empty()
            && !onlyFinishReadingCurrentSource) {
            reader->close();
            reader.reset();
            currentResidualSource = residualSources.front();
            residualSources.pop_front();
            reader = currentResidualSource->createReader(options);
            currentResidualSourceDone = !reader->start();
        }

        if (residualSources.empty() && currentResidualSourceDone) {
            readerDone =","#include <vector>
#include <deque>
#include <optional>
#include <stdexcept>
#include <memory>
#include <utility>

template <typename T>
class TimestampedValue {
public:
    // Implement according to actual logic
    T getValue() const;
    // Implement according to actual logic
    // SomeTimestampType getTimestamp() const;
};

template <typename T>
class Checkpoint {
private:
    std::optional<std::vector<TimestampedValue<T>>> residualElements;
    std::optional<std::deque<std::shared_ptr<BoundedSource<T>>>> residualSources;

public:
    Checkpoint(
        std::optional<std::vector<TimestampedValue<T>>> residualElements,
        std::deque<std::shared_ptr<BoundedSource<T>>> residualSources)
        : residualElements(std::move(residualElements)),
          residualSources(std::move(residualSources)) {}

    void finalizeCheckpoint() {}

    std::optional<std::vector<TimestampedValue<T>>> getResidualElements() const {
        return residualElements;
    }

    std::optional<std::deque<std::shared_ptr<BoundedSource<T>>>> getResidualSources() const {
        return residualSources;
    }
};

template <typename T>
class ResidualSources {
private:
    std::deque<std::shared_ptr<BoundedSource<T>>> residualSources;
    std::shared_ptr<PipelineOptions> options;
    std::unique_ptr<BoundedReader<T>> reader;
    bool closed;
    bool readerDone;
    bool currentResidualSourceDone;
    std::shared_ptr<BoundedSource<T>> currentResidualSource;

    bool helper(bool onlyFinishReadingCurrentSource) {
        if (closed) {
            throw std::invalid_argument(""advance() call on closed ResidualSources"");
        }
        if (readerDone) {
            return false;
        }
        if (!reader && !residualSources.empty()) {
            currentResidualSource = residualSources.front();
            residualSources.pop_front();
            reader.reset(currentResidualSource->createReader(options));
            currentResidualSourceDone = !reader->start();
        } else {
            if (!reader || residualSources.empty()) {
                return false;
            }
            currentResidualSourceDone = !reader->advance();
        }
        if (currentResidualSourceDone && !residualSources.empty() && !onlyFinishReadingCurrentSource) {
            reader->close();
            reader = nullptr;
            currentResidualSource = residualSources.front();
            residualSources.pop_front();
            reader.reset(currentResidualSource->create",1
"#include ""core/privileged/extension/SingletonModelProperty.h""
#include ""extension/api/declaration/type/DynamicConfigExpirationTypeBuilder.h""
#include ""extension/api/model/deprecated/ImmutableDeprecationModel.h""
#include ""extension/api/property/NoWrapperModelProperty.h""
#include ""extension/api/property/SinceMuleVersionModelProperty.h""
#include ""extension/api/stereotype/MuleStereotypes.h""
#include ""extension/internal/property/NoErrorMappingModelProperty.h""","#include ""CustomBuildingDefinitionProvider.h""
#include ""SingletonModelProperty.h""
#include ""DynamicConfigExpirationTypeBuilder.h""
#include ""ImmutableDeprecationModel.h""
#include ""NoWrapperModelProperty.h""
#include ""SinceMuleVersionModelProperty.h""
#include ""MuleStereotypes.h""
#include ""NoErrorMappingModelProperty.h""",0
"auto tableSource = BigQueryStorageTableSource::create(
    ValueProvider::StaticValueProvider::of(tableRef),
    readOptions,
    nullptr,
    nullptr,
    std::make_shared<TableRowParser>(),
    TableRowJsonCoder::of(),
    std::make_shared<FakeBigQueryServices>()
        ->withDatasetService(fakeDatasetService)
        ->withStorageClient(fakeStorageClient)
);

std::vector<std::shared_ptr<BoundedSource<TableRow>>> sources = tableSource->split(10L, options);
assert(sources.size() == 10);

void testTableSourceInitialSplit_WithSelectedFieldsAndRowRestriction() {
    fakeDatasetService->createDataset(""foo.com:project"", ""dataset"", """", """", nullptr);
    auto tableRef = BigQueryHelpers::parseTableSpec(""foo.com:project:dataset.table"");

    auto table = std::make_shared<Table>();
    table->setTableReference(tableRef);
    table->setNumBytes(100L);
    table->setSchema(
        std::make_shared<TableSchema>(
            ImmutableList<TableFieldSchema>({
                TableFieldSchema().setName(""name"").setType(""STRING""),
                TableFieldSchema().setName(""number"").setType(""INTEGER"")
            })
        )
    );

    fakeDatasetService->createTable(table);

    auto readOptions = TableReadOptions::newBuilder()
        ->addSelectedFields(""name"")
        ->addSelectedFields(""number"")
        ->setRowRestriction(""number > 5"")
        ->build();

    auto expectedRequest = CreateReadSessionRequest::newBuilder()
        ->setParent(""projects/project-id"")
        ->setTableReference(BigQueryHelpers::toTableRefProto(tableRef))
        ->setRequestedStreams(10)
        ->setReadOptions(readOptions)
        ->setUnknownFields(
            UnknownFieldSet::newBuilder()
                ->addField(7, UnknownFieldSet::Field::newBuilder()->addVarint(2)->build())
                ->build()
        )
        ->build();

    auto builder = ReadSession::newBuilder();
    for (int i = 0; i < 10; ++i) {
        builder->addStreams(Stream::newBuilder()->setName(""stream-"" + std::to_string(i)));
    }

    auto fakeStorageClient = std::make_shared<StorageClientMock>();
    EXPECT_CALL(*fakeStorageClient, createReadSession(expectedRequest))
        .WillOnce(::testing::Return(builder->build()));

    auto tableSource = BigQueryStorage","```cpp
#include <gtest/gtest.h>
#include <memory>
#include <vector>
#include <string>

TEST(BigQueryIOStorageReadTest, testTableSourceInitialSplit_WithSelectedFieldsAndRowRestriction) {
    fakeDatasetService.createDataset(""foo.com:project"", ""dataset"", """", """", nullptr);
    TableReference tableRef = BigQueryHelpers::parseTableSpec(""foo.com:project:dataset.table"");

    Table table;
    table.setTableReference(tableRef);
    table.setNumBytes(100L);

    TableSchema schema;
    schema.setFields({
        TableFieldSchema().setName(""name"").setType(""STRING""),
        TableFieldSchema().setName(""number"").setType(""INTEGER"")
    });
    table.setSchema(schema);

    fakeDatasetService.createTable(table);

    TableReadOptions readOptions = TableReadOptions::builder()
        .addSelectedFields(""name"")
        .addSelectedFields(""number"")
        .setRowRestriction(""number > 5"")
        .build();

    CreateReadSessionRequest expectedRequest = CreateReadSessionRequest::builder()
        .setParent(""projects/project-id"")
        .setTableReference(BigQueryHelpers::toTableRefProto(tableRef))
        .setRequestedStreams(10)
        .setReadOptions(readOptions)
        .setUnknownFields(
            UnknownFieldSet::builder()
                .addField(7, UnknownFieldSet::Field::builder().addVarint(2).build())
                .build())
        .build();

    ReadSession::Builder builder;
    for (int i = 0; i < 10; ++i) {
        builder.addStreams(Stream::builder().setName(""stream-"" + std::to_string(i)));
    }

    auto fakeStorageClient = std::make_shared<NiceMock<MockStorageClient>>();
    ON_CALL(*fakeStorageClient, createReadSession(expectedRequest))
        .WillByDefault(Return(builder.build()));

    auto tableSource =
        BigQueryStorageTableSource<TableRow>::create(
            ValueProvider::StaticValueProvider::of(tableRef),
            nullptr,
            StaticValueProvider::of(std::vector<std::string>{""name"", ""number""}),
            StaticValueProvider::of(std::string(""number > 5"")),
            std::make_shared<TableRowParser>(),
            TableRowJsonCoder::of(),
            std::make_shared<FakeBigQueryServices>()
                ->withDatasetService(fakeDatasetService)
                ->withStorageClient(fakeStorageClient)
        );

    auto sources = tableSource->",1
"}

/// <summary>
///     Produce a random number in the range (lower_number, higher_number).
/// </summary>
/// <param name=""value1"">Lower range for the random number.</param>
/// <param name=""value2"">Higher range for the random number.</param>
/// <returns name=""number"">Random number in the range (lower_number, higher_number).</returns>
/// <search>random,numberrange</search>
static double Random(double value1, double value2)
{
    if (value2 <= value1)
        throw std::invalid_argument(""value2 must be greater than value1"");
    static thread_local std::mt19937 rng(std::random_device{}());
    std::uniform_real_distribution<double> dist(value1, value2);
    double val;
    do {
        val = dist(rng);
    } while (val <= value1 || val >= value2);
    return val;
}","#include <random>
#include <algorithm>

double Random(double value1, double value2)
{
    double low = std::min(value1, value2);
    double high = std::max(value1, value2);
    static std::random_device rd;
    static std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dis(std::nextafter(low, high), high);
    double result;
    do {
        result = dis(gen);
    } while (result <= low || result >= high);
    return result;
}",1
"#include <filesystem>
#include <vector>
#include <atomic>

using namespace std;
namespace fs = std::filesystem;","#include <filesystem>
#include <vector>
#include <atomic>
#include ""BrokerController.h""
#include ""BrokerConfig.h""",0
"#include ""gobblin/configuration/ConfigurationKeys.h""
#include ""gobblin/configuration/WorkUnitState.h""
#include ""gobblin/crypto/EncryptionConfigParser.h""
#include ""gobblin/crypto/GPGFileDecryptor.h""
#include ""gobblin/data/management/copy/CopyConfiguration.h""
#include ""gobblin/data/management/copy/CopySource.h""
#include ""gobblin/data/management/copy/CopyableDatasetMetadata.h""","#include <fstream>
#include <string>
#include ""ConfigurationKeys.h""
#include ""WorkUnitState.h""
#include ""EncryptionConfigParser.h""
#include ""GPGFileDecryptor.h""
#include ""CopyConfiguration.h""
#include ""CopySource.h""
#include ""CopyableDatasetMetadata.h""",0
"std::vector<std::any> lookupValues(const RowMetaInterface& inputRowMeta, const std::vector<std::any>& row) {
    std::vector<std::any> outputRow = RowDataUtil::resizeArray(row, data.outputRowMeta.size());

    std::vector<std::any> lookupRow(data.lookupMeta.size());","Object* lookupValues(RowMetaInterface* inputRowMeta, Object* row) {
    std::lock_guard<std::mutex> lock(mutex_);
    Object* outputRow = RowDataUtil::resizeArray(row, data.outputRowMeta.size());
    std::vector<Object> lookupRow(data.lookupMeta.size());
    // ...
    return outputRow;
}",0
"class S3330 {
private:
    static constexpr bool FALSE_CONSTANT = false;
    static constexpr const char* XSRF_TOKEN = ""XSRF-TOKEN"";

    // Using a simple Cookie struct as a placeholder for Java's Cookie
    struct Cookie {
        std::string name;
        std::string value;
        Cookie(const std::string& n, const std::string& v) : name(n), value(v) {}
    };

    // Using a simple HttpCookie struct as a placeholder for Java's HttpCookie
    struct HttpCookie {
        std::string name;
        std::string value;
        HttpCookie(const std::string& n, const std::string& v) : name(n), value(v) {}
    };

    Cookie field1 = Cookie(""name"", ""value"");
    HttpCookie field2 = HttpCookie(""name"", ""value"");
};","#include <string>
#include <http_cookie.h>

class S3330 {
private:
    static constexpr bool FALSE_CONSTANT = false;
    static const std::string XSRF_TOKEN;

    Cookie field1 = Cookie(""name"", ""value"");
    HttpCookie field2 = HttpCookie(""name"", ""value"");
};

const std::string S3330::XSRF_TOKEN = ""XSRF-TOKEN"";",0
"#include ""ray/runtime/function_manager.h""
#include ""ray/runtime/object_store_proxy.h""
#include ""ray/runtime/raylet/raylet_client.h""
#include ""ray/runtime/task/arguments_builder.h""
#include ""ray/runtime/task/task_spec.h""","#include ""ray/runtime/config/RayConfig.h""
#include ""ray/runtime/functionmanager/FunctionManager.h""
#include ""ray/runtime/functionmanager/RayFunction.h""
#include ""ray/runtime/objectstore/ObjectStoreProxy.h""
#include ""ray/runtime/objectstore/ObjectStoreProxy.GetResult.h""
#include ""ray/runtime/raylet/RayletClient.h""
#include ""ray/runtime/task/ArgumentsBuilder.h""
#include ""ray/runtime/task/TaskSpec.h""",0
"#include ""org/mule/runtime/core/api/registry/TransformerResolver.h""
#include ""org/mule/runtime/api/metadata/DataType.h""
#include ""org/mule/runtime/core/api/MuleContext.h""
#include ""org/mule/runtime/core/api/MuleException.h""

using org::mule::runtime::core::api::registry::TransformerResolver::RegistryAction::ADDED;","#include ""org/mule/runtime/api/metadata/DataType.h""
#include ""org/mule/runtime/core/api/MuleContext.h""
#include ""org/mule/runtime/core/api/MuleException.h""
#include ""org/mule/runtime/core/api/registry/TransformerResolver.h""
using org::mule::runtime::core::api::registry::TransformerResolver::RegistryAction::ADDED;",0
"}
}

#include <gtest/gtest.h>

TEST(KafkaTest, testRecordsSink) {
    int numElements = 1000;

    MockProducerWrapper producerWrapper;

    auto completionThread = ProducerSendCompletionThread(producerWrapper.mockProducer).start();

    std::string topic = ""test"";

    p.apply(mkKafkaReadTransform(numElements, ValueAsTimestampFn()).withoutMetadata())
     .apply(ParDo::of(KV2ProducerRecord(topic)))
     .setCoder(ProducerRecordCoder::of(VarIntCoder::of(), VarLongCoder::of()))
     .apply(
         KafkaIO<int, long>::writeRecords()
         .withBootstrapServers(""none"")
         .withTopic(topic)
         .withKeySerializer(IntegerSerializer::class_type())
         .withValueSerializer(LongSerializer::class_type())
         .withInputTimestamp()
         .withProducerFactoryFn(ProducerFactoryFn(producerWrapper.producerKey))
     );

    p.run();

    completionThread.shutdown();

    verifyProducerRecords(producerWrapper.mockProducer, topic, numElements, false, true);
}

class KV2ProducerRecord : public DoFn<KV<int, long>, ProducerRecord<int, long>> {
public:
    std::string topic;

    explicit KV2ProducerRecord(const std::string& topic) : topic(topic) {}

    void processElement(ProcessContext& ctx) override {
        auto kv = ctx.element();
        ctx.output(ProducerRecord<int, long>(topic, kv.getKey(), kv.getValue()));
    }
};","```cpp
#include <gtest/gtest.h>
#include <string>
#include <memory>

TEST(KafkaIOTest, testRecordsSink) {
    int numElements = 1000;

    {
        MockProducerWrapper producerWrapper;

        auto completionThread = ProducerSendCompletionThread(producerWrapper.mockProducer).start();

        std::string topic = ""test"";

        p.apply(mkKafkaReadTransform(numElements, ValueAsTimestampFn()).withoutMetadata())
         .apply(KV2ProducerRecord(topic))
         .setCoder(ProducerRecordCoder::of(VarIntCoder::of(), VarLongCoder::of()))
         .apply(
             KafkaIO<int, long>::writeRecords()
                 .withBootstrapServers(""none"")
                 .withTopic(topic)
                 .withKeySerializer(IntegerSerializer::classType())
                 .withValueSerializer(LongSerializer::classType())
                 .withInputTimestamp()
                 .withProducerFactoryFn(ProducerFactoryFn(producerWrapper.producerKey))
             );

        p.run();

        completionThread.shutdown();

        verifyProducerRecords(producerWrapper.mockProducer, topic, numElements, false, true);
    }
}

class KV2ProducerRecord : public DoFn<KV<int, long>, ProducerRecord<int, long>> {
public:
    std::string topic;

    explicit KV2ProducerRecord(const std::string& topic) : topic(topic) {}

    void processElement(ProcessContext& ctx) override {
        auto kv = ctx.element();
        ctx.output(ProducerRecord<int, long>(topic, kv.getKey(), kv.getValue()));
    }
};
```",1
"printUsage(parser);
return;
//// TODO: Expose the fileSystem related options.
// Register standard file systems.
// FileSystems::setDefaultPipelineOptions(
//     PipelineOptionsTranslation::fromProto(google::protobuf::Struct()));
auto driver = fromConfig(configuration);
driver.run();","if (shouldPrintUsage) {
    printUsage(parser);
    return;
}
// TODO: Expose the fileSystem related options.
// Register standard file systems.
FileSystems::setDefaultPipelineOptions(
    PipelineOptionsTranslation::fromProto(Struct())
);
FlinkJobServerDriver driver = fromConfig(configuration);
driver.run();",1
"class IntrospectionUtils {
protected:
    IntrospectionUtils() = default;
public:
    virtual ~IntrospectionUtils() = default;
};","```cpp
class IntrospectionUtils
{
protected:
    IntrospectionUtils() = default;
    virtual ~IntrospectionUtils() = default;
};
```",1
"fdStepname.right = FormAttachment(100, 0);
wStepname->setLayoutData(fdStepname);

wlInputField = new QLabel(BaseMessages::getString(PKG, ""PentahoReportingOutputDialog.InputFilenameField.Label""), shell);
props.setLook(wlInputField);
FormData fdlInputField;
fdlInputField.left = FormAttachment(0, 0);
fdlInputField.top = FormAttachment(wStepname, margin + 5);
fdlInputField.right = FormAttachment(middle, -margin);
wlInputField->setLayoutData(fdlInputField);

wInputField = new QComboBox(shell);
props.setLook(wInputField);
// Assuming wInputField emits an appropriate signal for ""addModifyListener""
QObject::connect(wInputField, SIGNAL(editTextChanged(const QString&)), lsMod, SLOT(onTextChanged(const QString&)));
FormData fdInputField;
fdInputField.left = FormAttachment(middle, 0);
fdInputField.top = FormAttachment(wStepname, margin + 5);
fdInputField.right = FormAttachment(100, 0);
wInputField->setLayoutData(fdInputField);

std::vector<QString> fieldNames;
try {
    fieldNames = Const::sortStrings(transMeta.getPrevStepFields(stepMeta).getFieldNames());
} catch (const KettleException& e) {
    log.logError(""Unexpected error getting fields from previous steps..."", e);
}

QStringList fieldNamesList;
for (const auto& name : fieldNames) fieldNamesList << name;
wInputField->addItems(fieldNamesList);

wlOutputField = new QLabel(BaseMessages::getString(PKG, ""PentahoReportingOutputDialog.OutputFilenameField.Label""), shell);
props.setLook(wlOutputField);
FormData fdlOutputField;
fdlOutputField.left = FormAttachment(0, 0);
fdlOutputField.top = FormAttachment(wInputField, margin + 5);
fdlOutputField.right = FormAttachment(middle, -margin);
wlOutputField->setLayoutData(fdlOutputField);

wOutputField = new QComboBox(shell);
props.setLook(wOutputField);
QObject::connect(wOutputField, SIGNAL(editTextChanged(const QString&)), lsMod, SLOT(onTextChanged(const QString&)));
FormData fdOutputField;
fdOutputField.left = FormAttachment(middle, 0);
fdOutputField.top = FormAttachment(wInputField, margin + 5);
fdOutputField.right = Form","fdStepname.right = FormAttachment(100, 0);
wStepname->setLayoutData(fdStepname);

// input file field line (report definition)
wlInputField = new Label(shell, SWT_RIGHT);
wlInputField->setText(BaseMessages::getString(PKG, ""PentahoReportingOutputDialog.InputFilenameField.Label""));
props.setLook(wlInputField);
FormData fdlInputField;
fdlInputField.left = FormAttachment(0, 0);
fdlInputField.top = FormAttachment(wStepname, margin + 5);
fdlInputField.right = FormAttachment(middle, -margin);
wlInputField->setLayoutData(fdlInputField);
wInputField = new Combo(shell, SWT_SINGLE | SWT_LEFT | SWT_BORDER);
props.setLook(wInputField);
wInputField->addModifyListener(lsMod);
FormData fdInputField;
fdInputField.left = FormAttachment(middle, 0);
fdInputField.top = FormAttachment(wStepname, margin + 5);
fdInputField.right = FormAttachment(100, 0);
wInputField->setLayoutData(fdInputField);

std::vector<std::string> fieldNames;
try {
    fieldNames = Const::sortStrings(transMeta.getPrevStepFields(stepMeta).getFieldNames());
} catch (KettleException &e) {
    log.logError(""Unexpected error getting fields from previous steps..."", e);
}

wInputField->setItems(fieldNames);

// output file field line
wlOutputField = new Label(shell, SWT_RIGHT);
wlOutputField->setText(BaseMessages::getString(PKG, ""PentahoReportingOutputDialog.OutputFilenameField.Label""));
props.setLook(wlOutputField);
FormData fdlOutputField;
fdlOutputField.left = FormAttachment(0, 0);
fdlOutputField.top = FormAttachment(wInputField, margin + 5);
fdlOutputField.right = FormAttachment(middle, -margin);
wlOutputField->setLayoutData(fdlOutputField);
wOutputField = new Combo(shell, SWT_SINGLE | SWT_LEFT | SWT_BORDER);
props.setLook(wOutputField);
wOutputField->addModifyListener(lsMod);
FormData fdOutputField;
fdOutputField.left = FormAttachment(middle, 0);
fdOutputField.top = FormAttachment(wInputField, margin + 5);
fdOutputField.right = FormAttachment(100, 0);
wOutputField->setLayoutData(fdOutputField);
wOutputField->set",1
"#include <unordered_map>
#include <string>
#include <memory>
#include <mutex>

class JedisPool {};
class Notifier {};

class YourClass {
private:
    std::unordered_map<std::string, std::shared_ptr<JedisPool>> jedisPools;
    std::unordered_map<std::string, std::shared_ptr<Notifier>> notifiers;
    mutable std::mutex jedisPoolsMutex;
    mutable std::mutex notifiersMutex;
    const int reconnectPeriod;

public:
    YourClass(int reconnectPeriod_)
        : reconnectPeriod(reconnectPeriod_) {}
};","#include <map>
#include <string>
#include <memory>
#include <mutex>
#include <shared_mutex>

class JedisPool {};
class Notifier {};

class RedisRegistry : public FailbackRegistry {
private:
    std::map<std::string, std::shared_ptr<JedisPool>> jedisPools;
    std::map<std::string, std::shared_ptr<Notifier>> notifiers;
    mutable std::shared_mutex notifiers_mutex;
    const int reconnectPeriod;
};",0
"std::string line = ""\""\\\\valueA\""|\""valueB\\\\\""|\""val\\\\ueC\"""";

auto strings = TextFileInputUtils::guessStringsFromLine(
    std::make_shared<VariableSpace>(),
    std::make_shared<LogChannelInterface>(),
    line, inputMeta, ""|"", ""\"""", ""\\""
);

assert(strings != nullptr);
assert(strings[0] == ""\\valueA"");
assert(strings[1] == ""valueB\\"");","```cpp
std::string line = ""\""\\\\valueA\""|\""valueB\\\\\""|\""val\\\\ueC\""""; // ""\\valueA""|""valueB\\""|""val\\ueC""

std::vector<std::string> strings = TextFileInputUtils::guessStringsFromLine(
    mock<VariableSpace>(), mock<LogChannelInterface>(), line, inputMeta, ""|"", ""\"""", ""\\""
);

assert(!strings.empty());
assert(strings[0] == ""\\valueA"");
assert(strings[1] == ""valueB\\"");
```",0
"return compactionInstantTimeOpt;
}

//
// Schedules a new clustering instant.
//
std::optional<std::string> scheduleClustering(const std::optional<std::map<std::string, std::string>>& extraMetadata) {
    std::string instantTime = HoodieActiveTimeline::createNewInstantTime();
    return scheduleClusteringAtInstant(instantTime, extraMetadata) ? std::make_optional(instantTime) : std::nullopt;
}

//
// Schedules a new clustering instant with passed-in instant time.
//
bool scheduleClusteringAtInstant(const std::string& instantTime, const std::optional<std::map<std::string, std::string>>& extraMetadata) {
    LOG.info(""Scheduling clustering at instant time :"" + instantTime);
    auto plan = createTable(config, hadoopConf)
        .scheduleClustering(context, instantTime, extraMetadata);
    return plan.has_value();
}

//
// Ensures clustering instant is in expected state and performs clustering for the plan stored in metadata.
//
virtual HoodieWriteMetadata<O> cluster(const std::string& clusteringInstant, bool shouldComplete) = 0;

//
// Executes a clustering plan on a table, serially before or after an insert/upsert action.
//
std::optional<std::string> inlineCluster(const std::optional<std::map<std::string, std::string>>& extraMetadata) {
    auto clusteringInstantOpt = scheduleClustering(extraMetadata);
    if (clusteringInstantOpt) {
        // inline cluster should auto commit as the user is never given control
        cluster(*clusteringInstantOpt, true);
    }
    return clusteringInstantOpt;
}

void rollbackInflightClustering(const HoodieInstant& inflightInstant, HoodieTable<T, I, K, O>& table) {
    table.rollback(context, HoodieActiveTimeline::createNewInstantTime(), inflightInstant, false);
    table.getActiveTimeline().revertReplaceCommitInflightToRequested(inflightInstant);
}","```cpp
#include <string>
#include <map>
#include <optional>
#include <memory>

template <typename T>
using Option = std::optional<T>;

class HoodieIOException : public std::exception {
public:
    const char* what() const noexcept override { return ""Hoodie IO Exception""; }
};

class HoodieActiveTimeline {
public:
    static std::string createNewInstantTime();
};

class HoodieClusteringPlan {};

class Context {};
class LOG_class {
public:
    template <typename T>
    void info(const T& msg);
};
static LOG_class LOG;

template <typename Config, typename HadoopConf, typename ContextT, typename HoodieTableT, typename O>
class AbstractHoodieWriteClient {
public:
    Option<std::string> scheduleClustering(Option<std::map<std::string, std::string>> extraMetadata) {
        std::string instantTime = HoodieActiveTimeline::createNewInstantTime();
        return scheduleClusteringAtInstant(instantTime, extraMetadata) ? Option<std::string>(instantTime) : std::nullopt;
    }

    bool scheduleClusteringAtInstant(const std::string& instantTime, Option<std::map<std::string, std::string>> extraMetadata) {
        LOG.info(""Scheduling clustering at instant time :"" + instantTime);
        Option<HoodieClusteringPlan> plan = createTable(config, hadoopConf)
            ->scheduleClustering(context, instantTime, extraMetadata);
        return plan.has_value();
    }

    virtual HoodieWriteMetadata<O> cluster(const std::string& clusteringInstant, bool shouldComplete) = 0;

protected:
    Option<std::string> inlineCluster(Option<std::map<std::string, std::string>> extraMetadata) {
        Option<std::string> clusteringInstantOpt = scheduleClustering(extraMetadata);
        if (clusteringInstantOpt) {
            cluster(*clusteringInstantOpt, true);
        }
        return clusteringInstantOpt;
    }

    void rollbackInflightClustering(const HoodieInstant& inflightInstant, std::shared_ptr<HoodieTableT> table) {
        table->rollback(context, HoodieActiveTimeline::createNewInstantTime(), inflightInstant, false);
        table->getActiveTimeline()->revertReplaceCommitInflightToRequested(inflightInstant);
    }

    Config config;
    HadoopConf hadoopConf;
    ContextT context;

    // The following functions and types are assumed to be defined elsewhere
    std::shared_ptr<HoodieTableT>",1
"#include <string>

static const std::string METAFOLDER_NAME = "".hoodie"";
static const std::string TEMPFOLDER_NAME = METAFOLDER_NAME + ""/"" + "".temp"";
static const std::string AUXILIARYFOLDER_NAME = METAFOLDER_NAME + ""/"" + "".aux"";
static const std::string BOOTSTRAP_INDEX_ROOT_FOLDER_PATH = AUXILIARYFOLDER_NAME + ""/"" + "".bootstrap"";
static const std::string BOOTSTRAP_INDEX_BY_PARTITION_FOLDER_PATH = BOOTSTRAP_INDEX_ROOT_FOLDER_PATH + ""/"" + "".partitions"";
static const std::string BOOTSTRAP_INDEX_BY_FILE_ID_FOLDER_PATH = BOOTSTRAP_INDEX_ROOT_FOLDER_PATH + ""/"" + "".fileids"";
static const std::string MARKER_EXTN = "".marker"";

std::string basePath;","```cpp
#include <string>

class HoodieTableMetaClient {
public:
    static const std::string METAFOLDER_NAME;
    static const std::string TEMPFOLDER_NAME;
    static const std::string AUXILIARYFOLDER_NAME;
    static const std::string BOOTSTRAP_INDEX_ROOT_FOLDER_PATH;
    static const std::string BOOTSTRAP_INDEX_BY_PARTITION_FOLDER_PATH;
    static const std::string BOOTSTRAP_INDEX_BY_FILE_ID_FOLDER_PATH;
    static const std::string MARKER_EXTN;

private:
    std::string basePath;
};

const std::string HoodieTableMetaClient::METAFOLDER_NAME = "".hoodie"";
const std::string HoodieTableMetaClient::TEMPFOLDER_NAME = HoodieTableMetaClient::METAFOLDER_NAME + ""/"" + "".temp"";
const std::string HoodieTableMetaClient::AUXILIARYFOLDER_NAME = HoodieTableMetaClient::METAFOLDER_NAME + ""/"" + "".aux"";
const std::string HoodieTableMetaClient::BOOTSTRAP_INDEX_ROOT_FOLDER_PATH = HoodieTableMetaClient::AUXILIARYFOLDER_NAME + ""/"" + "".bootstrap"";
const std::string HoodieTableMetaClient::BOOTSTRAP_INDEX_BY_PARTITION_FOLDER_PATH = HoodieTableMetaClient::BOOTSTRAP_INDEX_ROOT_FOLDER_PATH + ""/"" + "".partitions"";
const std::string HoodieTableMetaClient::BOOTSTRAP_INDEX_BY_FILE_ID_FOLDER_PATH = HoodieTableMetaClient::BOOTSTRAP_INDEX_ROOT_FOLDER_PATH + ""/"" + "".fileids"";
const std::string HoodieTableMetaClient::MARKER_EXTN = "".marker"";
```",1
"return basePath + std::string(1, std::filesystem::path::preferred_separator) + AUXILIARYFOLDER_NAME;
}

std::string getBootstrapIndexByPartitionFolderName() {
    return getMetaAuxiliaryPath() + std::string(1, std::filesystem::path::preferred_separator) + BOOTSTRAP_INDEX_BY_PARTITION_FOLDER_NAME;
}

std::string getBootstrapIndexByFileIdFolderNameFolderName() {
    return getMetaAuxiliaryPath() + std::string(1, std::filesystem::path::preferred_separator) + BOOTSTRAP_INDEX_BY_FILE_ID_FOLDER_NAME;
}","std::string getBootstrapIndexByPartitionFolderName() const {
    return getMetaAuxiliaryPath() + std::string(1, std::filesystem::path::preferred_separator) + BOOTSTRAP_INDEX_BY_PARTITION_FOLDER_NAME;
}

std::string getBootstrapIndexByFileIdFolderName() const {
    return getMetaAuxiliaryPath() + std::string(1, std::filesystem::path::preferred_separator) + BOOTSTRAP_INDEX_BY_FILE_ID_FOLDER_NAME;
}",1
"template <typename T>
requires std::is_base_of<Persisted, T>::value
std::string save(const T& model);

template <typename T>
requires std::is_base_of<Persisted, T>::value
std::string saveWithoutEvents(const T& model);

template <typename T>
requires std::is_base_of<Persisted, T>::value
std::optional<std::string> saveWithoutValidation(const T& model);","template <typename T>
requires std::is_base_of<Persisted, T>::value
std::string save(const T& model); // may throw ValidationException

template <typename T>
requires std::is_base_of<Persisted, T>::value
std::string saveWithoutEvents(const T& model); // may throw ValidationException

template <typename T>
requires std::is_base_of<Persisted, T>::value
std::optional<std::string> saveWithoutValidation(const T& model);",1
"#include ""AnalyticsDialogFragment.h""
#include ""BundleUtils.h""

class ExportDialog : public AnalyticsDialogFragment {
public:
    class ExportDialogListener {
    public:
        virtual ~ExportDialogListener() = default;
    };
};","#include ""AnalyticsDialogFragment.h""

class ExportDialog : public AnalyticsDialogFragment {
public:
    class ExportDialogListener {
    public:
        virtual ~ExportDialogListener() = default;
    };
};",1
"```cpp
i++;

errorMessage << format("" which alias name is '%s'. Names should be unique"", entry.getKey());
throw IllegalModelDefinitionException(errorMessage.str());
}

void validateSingularizeNameClashesWithTopLevels() {
    std::map<std::string, std::vector<TopLevelParameter>> singularClashes;

    for (const auto& kv : topLevelParameters) {
        const auto& k = kv.first;
        if (singularizedObjects.count(k) && !kv.second.empty()) {
            singularClashes[k] = kv.second;
        }
    }

    if (!singularClashes.empty()) {
        std::vector<std::string> errorMessages;
        for (const auto& e : singularClashes) {
            DescribedParameter& reference = singularizedObjects.at(e.first);
            for (const auto& tp : e.second) {
                errorMessages.push_back(format(
                    ""%s '%s' contains parameter '%s' that clash when singularized with parameter '%s' from '%s'"",
                    reference.parent->getDescription(),
                    reference.parent->getName(),
                    reference.getName(),
                    tp.getName(),
                    tp.ownerType
                ));
            }
        }
        throw IllegalModelDefinitionException(format(
            ""Extension '%s' contains %zu parameters that clash when singularized. %s"",
            extensionModel.getName(),
            singularClashes.size(),
            join(errorMessages, "", "")
        ));
    }
}

void validateClash(const std::string& existingNamingModel,
                   const std::string& newNamingModel,
                   const std::string& typeOfExistingNamingModel,
                   const std::string& typeOfNewNamingModel) {
    if (StringUtils::equalsIgnoreCase(existingNamingModel, newNamingModel)) {
```","```cpp
private:
    void validateSingularizeNameClashesWithTopLevels() {
        std::map<std::string, std::vector<TopLevelParameter*>> singularClashes;
        for (const auto& kv : topLevelParameters) {
            const std::string& k = kv.first;
            if (singularizedObjects.count(k) && !kv.second.empty()) {
                singularClashes[k] = kv.second;
            }
        }

        if (!singularClashes.empty()) {
            std::vector<std::string> errorMessages;
            for (const auto& e : singularClashes) {
                DescribedParameter* reference = singularizedObjects[e.first];
                for (auto* tp : e.second) {
                    errorMessages.push_back(format(
                        ""%s '%s' contains parameter '%s' that clash when singularized with parameter '%s' from '%s'"",
                        reference->parent->getDescription(), reference->parent->getName(),
                        reference->getName(),
                        tp->getName(), tp->ownerType
                    ));
                }
            }

            throw IllegalModelDefinitionException(format(
                ""Extension '%s' contains %zu parameters that clash when singularized. %s"",
                extensionModel.getName(), singularClashes.size(),
                join(errorMessages, "", "").c_str()
            ));
        }
    }

    void validateClash(const std::string& existingNamingModel, const std::string& newNamingModel,
                       const std::string& typeOfExistingNamingModel, const std::string& typeOfNewNamingModel) {
        if (StringUtils::equalsIgnoreCase(existingNamingModel, newNamingModel)) {
            // body omitted
        }
    }
```",1
"Option<WriteOperationType> getWriteOperationType(const HoodieInstant& instant) override {
    try {
        HoodieCommitMetadata commitMetadata = HoodieCommitMetadata::fromBytes(getInstantDetails(instant).value(), HoodieCommitMetadata::type());
        return Option<WriteOperationType>::of(commitMetadata.getOperationType());
    } catch (...) {
        return Option<WriteOperationType>::empty();
    }
}

bool isDeletePartitionType(const HoodieInstant& instant) override {
    Option<WriteOperationType> operationType = getWriteOperationType(instant);
    return operationType.isPresent() && WriteOperationType::DELETE_PARTITION == operationType.get();
}

bool isNotDeletePartitionType(const HoodieInstant& instant) override {
    return !isDeletePartitionType(instant);
}

std::string toString() const override {
    std::ostringstream oss;
    for (auto it = instants.begin(); it != instants.end(); ++it) {
        if (it != instants.begin()) oss << "","";
        oss << it->toString();
    }
    return typeid(*this).name() + std::string("": "") + oss.str();
}","```cpp
Option<WriteOperationType> getWriteOperationType(const HoodieInstant& instant) override {
    try {
        auto commitMetadata = HoodieCommitMetadata::fromBytes(getInstantDetails(instant).value(), HoodieCommitMetadata::typeid_);
        return Option<WriteOperationType>::of(commitMetadata.getOperationType());
    } catch (const std::exception&) {
        return Option<WriteOperationType>::empty();
    }
}

bool isDeletePartitionType(const HoodieInstant& instant) override {
    auto operationType = getWriteOperationType(instant);
    return operationType.isPresent() && (operationType.get() == WriteOperationType::DELETE_PARTITION);
}

bool isNotDeletePartitionType(const HoodieInstant& instant) override {
    return !isDeletePartitionType(instant);
}

std::string toString() const override {
    std::ostringstream oss;
    oss << typeid(*this).name() << "": "";
    bool first = true;
    for (const auto& instant : instants) {
        if (!first) oss << "","";
        oss << instant.toString();
        first = false;
    }
    return oss.str();
}
```",1
"const auto searchQuery = searchQueryParser.parse(query);
const auto result = dbService.searchPaginated(
    searchQuery,
    [&](const auto& event) {
        return isPermitted(RestPermissions::EVENT_DEFINITIONS_READ, event.id());
    },
    ""title"",
    page,
    perPage
);
const auto context = contextService.contextFor(result.delegate());
return PaginatedResponse::create(""event_definitions"", result, query, context);","auto searchQuery = searchQueryParser.parse(query);
auto result = dbService.searchPaginated(searchQuery, [&](const EventDefinitionDto& event) {
    return isPermitted(RestPermissions::EVENT_DEFINITIONS_READ, event.id());
}, ""title"", page, perPage);
auto context = contextService.contextFor(result.delegate());
return PaginatedResponse::create(""event_definitions"", result, query, context);",0
"#include <algorithm>
#include <functional>
#include <chrono>
#include <list>
#include <vector>
#include <map>
#include <set>","#include <algorithm>
#include <chrono>
#include <list>
#include <map>
#include <set>
#include <vector>",0
"int getLastReleasedMessageSequenceNumber() const {
    return lastReleasedMessageSequenceNumber;
}
};","class MessageGroupMetadata {
public:
    int getLastReleasedMessageSequenceNumber() const {
        return lastReleasedMessageSequenceNumber;
    }
private:
    int lastReleasedMessageSequenceNumber;
};",0
"#include <animation/Animation.h>
#include <aria/DialogRole.h>
#include <aria/Id.h>
#include <core/Scheduler.h>
#include <dom/Document.h>
#include <dom/Element.h>
#include <dom/NativeEvent.h>","#include <string>
#include <functional>",0
"assert(sym->GetScopeSlot() != Js::Constants::NoProperty && sym->GetScopeSlot() > slot);
propIds->elements[slot] = Js::Constants::NoProperty;
}
else
{
    // This is for patterns
    propIds->elements[slot] = Js::Constants::NoProperty;
}
slot++;
};
MapFormalsWithoutRest(pnodeFnc, initArg);

// If the rest is in the slot - we need to keep that slot.
if (pnodeFnc->sxFnc.pnodeRest != nullptr && pnodeFnc->sxFnc.pnodeRest->sxVar.sym->IsInSlot(funcInfo))
{
    Symbol::SaveToPropIdArray(pnodeFnc->sxFnc.pnodeRest->sxVar.sym, propIds, this);
}","@@ -1577,15 +1577,20 @@
void ByteCodeGenerator::EmitScopeObjectInit(FuncInfo* funcInfo)
{
    Assert(sym->GetScopeSlot() != Js::Constants::NoProperty && sym->GetScopeSlot() > slot);
    propIds->elements[slot] = Js::Constants::NoProperty;
    // slot++;
}
else
{
    propIds->elements[slot] = Js::Constants::NoProperty;
}
++slot;

auto initArg = [&](ParseNode* node)
{
    // ... assume logic for initArg same as Java code context ...
};
MapFormalsWithoutRest(pnodeFnc, initArg);

// If the rest is in the slot - we need to keep that slot.
if (pnodeFnc->sxFnc.pnodeRest != nullptr && pnodeFnc->sxFnc.pnodeRest->sxVar.sym->IsInSlot(funcInfo))
{
    Symbol::SaveToPropIdArray(pnodeFnc->sxFnc.pnodeRest->sxVar.sym, propIds, this);
}
}",1
"if (this->next == nullptr && !this->eof) {
    if (!scanner.isSeeked() && scanner.seekTo()) {
        this->next = getRecordFromCell(scanner.getCell(), getSchema(), readerSchema);
    }
}
return this->next != nullptr;","if (this->next == nullptr && !this->eof) {
    if (!scanner.isSeeked() && scanner.seekTo()) {
        this->next = getRecordFromCell(scanner.getCell(), getSchema(), readerSchema);
    }
}
return this->next != nullptr;",0
"protected:
void finishRollback(const HoodieRollbackMetadata& rollbackMetadata) {
    try {
        // TODO: Potential error here - rollbacks have already completed here so if the syncTableMetadata fails,
        // metadata table will be left in an inconsistent state. This is because we do not use the inflight
        // state for rollback.
        syncTableMetadata(rollbackMetadata);

        table.getActiveTimeline().createNewInstant(
            HoodieInstant(HoodieInstant::State::INFLIGHT, HoodieTimeline::ROLLBACK_ACTION, instantTime)
        );
        table.getActiveTimeline().saveAsComplete(
            /* arguments to saveAsComplete go here */
        );
    } catch (const HoodieIOException& e) {
        throw;
    }
}","```cpp
protected:
  void finishRollback(const HoodieRollbackMetadata& rollbackMetadata) {
    try {
      syncTableMetadata(rollbackMetadata);

      table.getActiveTimeline().createNewInstant(
        HoodieInstant(HoodieInstant::State::INFLIGHT, HoodieTimeline::ROLLBACK_ACTION, instantTime)
      );
      table.getActiveTimeline().saveAsComplete(
        // Remaining arguments as per your original code...
      );
    } catch (const HoodieIOException& e) {
      throw;
    }
  }
```",1
"#if ENABLE_TTD
    Js::ScriptContext* scriptContext = JsrtContext::GetCurrent()->GetScriptContext();
    if (PERFORM_JSRT_TTD_RECORD_ACTION_CHECK(scriptContext))
    {
        if (arrayBuffer != nullptr)
        {
            BEGIN_JS_RUNTIME_CALLROOT_EX(scriptContext, false)
            {
                PERFORM_JSRT_TTD_RECORD_ACTION_WRESULT(
                    scriptContext, 
                    scriptContext->GetThreadContext()->TTDLog->RecordJsRTGetTypedArrayInfo(scriptContext, typedArray, &__ttd_resultPtr)
                );
                PERFORM_JSRT_TTD_RECORD_ACTION_PROCESS_RESULT(arrayBuffer);
            }
            END_JS_RUNTIME_CALL(scriptContext);
        }
    }
#endif","@@ -1332,6 +1332,23 @@ CHAKRA_API JsGetTypedArrayInfo(_In_ JsValueRef typedArray, _Out_opt_ JsTypedArray
             *byteLength = typedArrayBase->GetByteLength();
         }
     }
+
+#if ENABLE_TTD
+    Js::ScriptContext* scriptContext = JsrtContext::GetCurrent()->GetScriptContext();
+    if (PERFORM_JSRT_TTD_RECORD_ACTION_CHECK(scriptContext))
+    {
+        if (arrayBuffer != nullptr)
+        {
+            BEGIN_JS_RUNTIME_CALLROOT_EX(scriptContext, false)
+            {
+                PERFORM_JSRT_TTD_RECORD_ACTION_WRESULT(
+                    scriptContext,
+                    scriptContext->GetThreadContext()->TTDLog->RecordJsRTGetTypedArrayInfo(
+                        scriptContext, typedArray, &__ttd_resultPtr));
+                PERFORM_JSRT_TTD_RECORD_ACTION_PROCESS_RESULT(arrayBuffer);
+            }
+            END_JS_RUNTIME_CALL(scriptContext);
+        }
+    }
+#endif
+
     END_JSRT_NO_EXCEPTION
 }",1
"#include <string>

constexpr auto DEFAULT_CHARSET_ENCODING = ""UTF-8"";
constexpr const char* TEST_HARNESS_LAUNCHER_IMPL = ""gobblin.testharness.launcher.impl"";
constexpr int PERMISSION_PARSING_RADIX = 8;","#include <string>

class ConfigurationKeys {
public:
    static constexpr int PERMISSION_PARSING_RADIX = 8;
    static const std::string TEST_HARNESS_LAUNCHER_IMPL;
};

const std::string ConfigurationKeys::TEST_HARNESS_LAUNCHER_IMPL = ""gobblin.testharness.launcher.impl"";",0
"Answer execute(const MigrateWithStorageReceiveCommand& command, const XenServer610Resource& xenServer610Resource) {
    Connection connection = xenServer610Resource.getConnection();
    const VirtualMachineTO& vmSpec = command.getVirtualMachine();
    const std::vector<std::pair<VolumeTO, std::string>>& volumeToStorageUuid = command.getVolumeToStorageUuid();

    try {
        // In a cluster management server setup, the migrate with storage receive and send
    } catch (const std::exception& e) {
        // handle exception if needed
    }
}","Answer execute(const MigrateWithStorageReceiveCommand& command, const XenServer610Resource& xenServer610Resource) {
    Connection connection = xenServer610Resource.getConnection();
    const VirtualMachineTO& vmSpec = command.getVirtualMachine();
    const std::vector<std::pair<VolumeTO, std::string>>& volumeToStorageUuid = command.getVolumeToStorageUuid();

    try {
        // In a cluster management server setup, the migrate with storage receive and send",1
"#include <string>
#include <unordered_map>
#include <vector>
#include <sstream>

class ConsoleProxyHttpHandlerHelper {
private:
    static constexpr const char* EQUALS = ""="";
public:
    static std::unordered_map<std::string, std::string> getQueryMap(const std::string& query) {
        std::unordered_map<std::string, std::string> map;
        std::stringstream ss(query);
        std::string param;

        while (std::getline(ss, param, '&')) {
            std::vector<std::string> paramTokens;
            std::stringstream pss(param);
            std::string token;
            int splits = 0;
            size_t start = 0;
            size_t pos = 0;
            // Limit split to 3 tokens for ugly Xen case
            while ((pos = param.find(EQUALS, start)) != std::string::npos && splits < 2) {
                paramTokens.push_back(param.substr(start, pos - start));
                start = pos + 1;
                ++splits;
            }
            paramTokens.push_back(param.substr(start));

            if (paramTokens.size() == 2) {
                const std::string& name = paramTokens[0];
                const std::string& value = paramTokens[1];
                map[name] = value;
            } else if (paramTokens.size() == 3) {
                const std::string& name = paramTokens[0];
                std::string value = paramTokens[1] + EQUALS + paramTokens[2];
                map[name] = value;
            }
        }
        return map;
    }
};","#include <string>
#include <unordered_map>
#include <vector>
#include <sstream>

class ConsoleProxyHttpHandlerHelper {
public:
    static std::unordered_map<std::string, std::string> getQueryMap(const std::string& query) {
        constexpr char EQUALS = '=';
        std::unordered_map<std::string, std::string> map;
        std::vector<std::string> params;
        std::string param;
        std::istringstream queryStream(query);

        while (std::getline(queryStream, param, '&')) {
            std::vector<std::string> paramTokens;
            std::string token;
            std::istringstream paramStream(param);
            while (std::getline(paramStream, token, EQUALS)) {
                paramTokens.push_back(token);
            }
            if (paramTokens.size() == 2) {
                map[paramTokens[0]] = paramTokens[1];
            } else if (paramTokens.size() == 3) {
                map[paramTokens[0]] = paramTokens[1] + std::string(1, EQUALS) + paramTokens[2];
            } 
        }
        return map;
    }
};",1
"#include ""opentelemetry/context/Context.h""
#include ""opentelemetry/context/Scope.h""
#include ""opentelemetry/context/propagation/TextMapPropagator.h""
#include ""opentelemetry/instrumentation/api/tracer/HttpServerTracer.h""
#include ""opentelemetry/trace/Span.h""","#include <opentelemetry/context/context.h>
#include <opentelemetry/context/scope.h>
#include <opentelemetry/context/propagation/text_map_propagator.h>
#include <opentelemetry/instrumentation/api/tracer/http_server_tracer.h>
#include <opentelemetry/trace/span.h>",0
"Config loadPullFile(const std::filesystem::path& path, const Config& sysProps, bool loadGlobalProperties, bool resolve) {
    Config fallback = loadGlobalProperties ? loadAncestorGlobalConfigs(path, sysProps) : sysProps;
    Config loadedConfig;
    if (this->javaPropsPullFileFilter.accept(path)) {
        loadedConfig = loadJavaPropsWithFallback(path, fallback);
    } else if (this->hoconPullFileFilter.accept(path)) {","Config loadPullFile(const std::filesystem::path& path, const Config& sysProps, bool loadGlobalProperties, bool resolve) {
    Config fallback = loadGlobalProperties ? loadAncestorGlobalConfigs(path, sysProps) : sysProps;
    Config loadedConfig;

    if (this->javaPropsPullFileFilter.accept(path)) {
        loadedConfig = loadJavaPropsWithFallback(path, fallback);
    } else if (this->hoconPullFileFilter.accept(path)) {",0
"public:
    void setHeaderMapper(HeaderMapper<MimeMessage>* headerMapper) {
        this->headerMapper = headerMapper;
    }

    void setMultipartAsBytes(bool multipartAsBytes) {
        this->multipartAsBytes = multipartAsBytes;
    }

protected:
    Folder* getFolder() {
        return this->folder;
    }","public:
    void setHeaderMapper(HeaderMapper<MimeMessage>* headerMapper) {
        this->headerMapper = headerMapper;
    }

    void setMultipartAsBytes(bool multipartAsBytes) {
        this->multipartAsBytes = multipartAsBytes;
    }

protected:
    Folder* getFolder() {
        return this->folder;
    }",1
"#include <climits>
#include <thread>
#include <vector>
#include <algorithm>
#include <gtest/gtest.h>

using namespace std;","#include <climits>
#include <thread>
#include <vector>
#include <algorithm>
#include <gtest/gtest.h>",0
"HoodieTestTable& addReplaceCommit(
    const std::string& instantTime,
    const HoodieRequestedReplaceMetadata& requestedReplaceMetadata,
    const HoodieReplaceCommitMetadata& completeReplaceMetadata,
    const HoodieCommitMetadata& inflightReplaceMetadata) 
{
    createRequestedReplaceCommit(basePath, instantTime, requestedReplaceMetadata);
    createInflightReplaceCommit(basePath, instantTime, inflightReplaceMetadata);
    createReplaceCommit(basePath, instantTime, completeReplaceMetadata);
    currentInstantTime = instantTime;
    metaClient = HoodieTableMetaClient::reload(metaClient);
    return *this;
}","HoodieTestTable& addReplaceCommit(
    const std::string& instantTime,
    const HoodieRequestedReplaceMetadata& requestedReplaceMetadata,
    const HoodieReplaceCommitMetadata& completeReplaceMetadata,
    const HoodieCommitMetadata& inflightReplaceMetadata) 
{
    createRequestedReplaceCommit(basePath, instantTime, requestedReplaceMetadata);
    createInflightReplaceCommit(basePath, instantTime, inflightReplaceMetadata);
    createReplaceCommit(basePath, instantTime, completeReplaceMetadata);
    currentInstantTime = instantTime;
    metaClient = HoodieTableMetaClient::reload(metaClient);
    return *this;
}",1
"return attrs;
}

ComponentLocation getLocation() override {
    return getComponentLocation();
}","public:
    const std::type_info& getType() const {
        return *type;
    }

    void setType(const std::type_info& t) {
        type = &t;
    }

    ComponentLocation getLocation() override {
        return getComponentLocation();
    }

private:
    const std::type_info* type;",0
"dateHistogramBuilder.subAggregation(AggregationBuilders::cardinality(AGG_CARDINALITY).field(field));
    }

const auto filterBuilder = AggregationBuilders::filter(AGG_FILTER)
    .subAggregation(dateHistogramBuilder)
    .filter(standardAggregationFilters(range, filter));

const auto qs = queryStringQuery(query)
    .allowLeadingWildcard(configuration.isAllowLeadingWildcardSearches());

auto searchSourceBuilder = SearchSourceBuilder();
searchSourceBuilder.query(qs)
    .aggregation(filterBuilder);

const auto affectedIndices = determineAffectedIndices(range, filter);

auto searchBuilder = Search::Builder(searchSourceBuilder.toString())
    .addType(IndexMapping::TYPE_MESSAGE)
    .addIndex(affectedIndices);

const auto searchResult = execute(searchBuilder.build());

const auto tookMs = tookMsFromSearchResult(searchResult);
recordEsMetrics(tookMs, range);

const auto filterAggregation = searchResult.getAggregations().getFilterAggregation(AGG_FILTER);
const auto histogramAggregation = filterAggregation.getHistogramAggregation(AGG_HISTOGRAM);

return FieldHistogramResult(
    histogramAggregation,
    query,
    searchSourceBuilder.buildAsBytes(),
    interval,
    TimeValue(tookMs)
);","```cpp
FieldHistogramResult Searches::fieldHistogram(const std::string& query,
                                              const Range& range,
                                              const Filter& filter,
                                              const std::string& field,
                                              int interval,
                                              const Configuration& configuration) {
    auto dateHistogramBuilder = AggregationBuilders::dateHistogram(AGG_HISTOGRAM)
                               .field(field)
                               .interval(interval);

    if (!field.empty()) {
        dateHistogramBuilder.subAggregation(
            AggregationBuilders::cardinality(AGG_CARDINALITY).field(field)
        );
    }

    const auto filterBuilder = AggregationBuilders::filter(AGG_FILTER)
                              .subAggregation(dateHistogramBuilder)
                              .filter(standardAggregationFilters(range, filter));

    auto qs = queryStringQuery(query)
              .allowLeadingWildcard(configuration.allowLeadingWildcardSearches());

    SearchSourceBuilder searchSourceBuilder;
    searchSourceBuilder.query(qs)
                      .aggregation(filterBuilder);

    const auto affectedIndices = determineAffectedIndices(range, filter);

    Search searchBuilder(searchSourceBuilder.toString());
    searchBuilder.addType(IndexMapping::TYPE_MESSAGE)
                 .addIndex(affectedIndices);

    const auto searchResult = execute(searchBuilder.build());

    const auto tookMs = tookMsFromSearchResult(searchResult);
    recordEsMetrics(tookMs, range);

    const auto& filterAggregation = searchResult.getAggregations().getFilterAggregation(AGG_FILTER);
    const auto& histogramAggregation = filterAggregation.getHistogramAggregation(AGG_HISTOGRAM);

    return FieldHistogramResult{
        histogramAggregation,
        query,
        searchSourceBuilder.buildAsBytes(),
        interval,
        TimeValue(tookMs)
    };
}
```",0
"FilebasedSchemaProvider* schemaProvider;
KafkaTestUtils* testUtils;
HoodieDeltaStreamerMetrics* metrics = nullptr;

static void initClass() {
}","@@ -56,6 +56,7 @@
 
   FilebasedSchemaProvider schemaProvider;
   KafkaTestUtils testUtils;
+  std::shared_ptr<HoodieDeltaStreamerMetrics> metrics = std::make_shared<MockHoodieDeltaStreamerMetrics>();
 
   static void initClass() {",0
"```cpp
#include <vector>
#include <string>

enum class SqlTypeName {
    INTEGER
};

class BeamSqlExpression {
protected:
    std::vector<BeamSqlExpression*> operands;
    SqlTypeName typeName;
public:
    BeamSqlExpression(const std::vector<BeamSqlExpression*>& operands, SqlTypeName typeName)
        : operands(operands), typeName(typeName) {}
    virtual ~BeamSqlExpression() = default;
    virtual bool accept() = 0;
};

class BeamSqlPositionExpression : public BeamSqlExpression {
public:
    BeamSqlPositionExpression(const std::vector<BeamSqlExpression*>& operands)
        : BeamSqlExpression(operands, SqlTypeName::INTEGER) {}

    bool accept() override {
        if (operands.size() < 2 || operands.size() > 3) {
            return false;
        }
        return true;
    }
};
```","#include <vector>
#include <memory>

class BeamSqlExpression {
public:
    using Ptr = std::shared_ptr<BeamSqlExpression>;
    std::vector<Ptr> operands;
    enum SqlTypeName { INTEGER };

    BeamSqlExpression(const std::vector<Ptr>& ops, SqlTypeName) : operands(ops) {}
    virtual bool accept() = 0;
};

class BeamSqlPositionExpression : public BeamSqlExpression {
public:
    BeamSqlPositionExpression(const std::vector<Ptr>& operands)
        : BeamSqlExpression(operands, SqlTypeName::INTEGER) {}

    bool accept() override {
        if (operands.size() < 2 || operands.size() > 3) {
            return false;
        }
        return true;
    }
};",1
"{
    std::unique_ptr<Scope> scope(withScopedContext(context));
    try {
        response = chain.proceed(requestBuilder.build());
    } catch (const std::exception& e) {
        TRACER.endExceptionally(span, e);
        throw;
    }
    TRACER.end(span, response);
    return response;
}","```cpp
try {
    auto scope = withScopedContext(context);
    response = chain.proceed(requestBuilder.build());
} catch (const std::exception& e) {
    TRACER.endExceptionally(span, e);
    throw;
}
TRACER.end(span, response);
return response;
```",1
"private:
    JobLauncher* jobLauncher;
    JobListener* jobListener = new EmailNotificationJobListener();
    Properties* props;
    ApplicationLauncher* applicationLauncher;

public:
    AzkabanJobLauncher(const std::string& jobId, Properties* props) {
        // constructor body
    }","```cpp
class AzkabanJobLauncher : public AbstractJob {
private:
    JobLauncher jobLauncher;
    EmailNotificationJobListener jobListener;
    Properties props;
    ApplicationLauncher applicationLauncher;

public:
    AzkabanJobLauncher(const std::string& jobId, const Properties& props)
        : AbstractJob(jobId),
          jobLauncher(),
          jobListener(),
          props(props),
          applicationLauncher() {
    }
};
```",0
"auto adapter = std::make_shared<ApplicationEventListeningMessageProducer>();
adapter->setPayloadExpression(""'received: ' + source"");
adapter->setOutputChannel(channel);

auto ctx = TestUtils::createTestApplicationContext();
auto beanFactory = ctx->getBeanFactory();
beanFactory->registerSingleton(AbstractApplicationContext::APPLICATION_EVENT_MULTICASTER_BEAN_NAME,
    std::make_shared<SimpleApplicationEventMulticaster>(beanFactory));

adapter->setBeanFactory(beanFactory);
beanFactory->registerSingleton(""testListenerMessageProducer"", adapter);
adapter->afterPropertiesSet();

ctx->refresh();

auto message1 = channel->receive(0);
// ContextRefreshedEvent
assert(message1 != nullptr);
assert(message1->getPayload().toString().find(""org.springframework.integration.test.util.TestUtils$TestApplicationContext"") != std::string::npos);

adapter->onApplicationEvent(std::make_shared<TestApplicationEvent1>());
adapter->onApplicationEvent(std::make_shared<TestApplicationEvent2>());
auto message2 = channel->receive(20);
assert(message2 != nullptr);

auto message3 = channel->receive(20);
assert(message3 != nullptr);
assert(message3->getPayload() == ""received: event2"");","```cpp
ApplicationEventListeningMessageProducer adapter;
adapter.setPayloadExpression(""'received: ' + source"");
adapter.setOutputChannel(channel);

auto ctx = TestUtils::createTestApplicationContext();
auto beanFactory = ctx->getBeanFactory();
beanFactory->registerSingleton(AbstractApplicationContext::APPLICATION_EVENT_MULTICASTER_BEAN_NAME,
    std::make_shared<SimpleApplicationEventMulticaster>(beanFactory));

adapter.setBeanFactory(beanFactory);
beanFactory->registerSingleton(""testListenerMessageProducer"", std::make_shared<ApplicationEventListeningMessageProducer>(adapter));
adapter.afterPropertiesSet();

ctx->refresh();

auto message1 = channel->receive(0);
// ContextRefreshedEvent
assert(message1 != nullptr);
assert(message1->getPayload().toString().find(""TestUtils::TestApplicationContext"") != std::string::npos);

adapter.onApplicationEvent(TestApplicationEvent1());
adapter.onApplicationEvent(TestApplicationEvent2());

auto message2 = channel->receive(20);
assert(message2 != nullptr);

auto message3 = channel->receive(20);
assert(message3 != nullptr);
assert(message3->getPayload() == ""received: event2"");
```",1
"#include <vector>
#include <string>
#include <filesystem>

class ArtifactPluginDescriptor {};

std::filesystem::path getContainerAppPluginsFolder();
std::vector<ArtifactPluginDescriptor> createApplicationPluginDescriptors();
const std::vector<ArtifactPluginDescriptor> EMPTY_LIST;

std::vector<ArtifactPluginDescriptor> collectContainerApplicationPluginDescriptors() {
    auto containerPlugins = std::filesystem::directory_iterator(getContainerAppPluginsFolder());
    if (std::filesystem::exists(getContainerAppPluginsFolder())) {
        return createApplicationPluginDescriptors();
    } else {
        return EMPTY_LIST;
    }
}","std::vector<ArtifactPluginDescriptor> collectContainerApplicationPluginDescriptors() {
    std::filesystem::path pluginsFolder = getContainerAppPluginsFolder();
    std::vector<ArtifactPluginDescriptor> descriptors;
    if (std::filesystem::is_directory(pluginsFolder)) {
        // unzipPluginsIfNeeded(); // This call removed
        return createApplicationPluginDescriptors();
    } else {
        return EMPTY_LIST;
    }
}",0
"#include <memory>
#include <typeinfo>

class DoFn {
public:
    virtual ~DoFn() = default;
};

class ParDoBound : public DoFn {
public:
    virtual DoFn* getFn() = 0;
};

class ParDoBoundMulti : public DoFn {
public:
    virtual DoFn* getFn() = 0;
};

class PTransform {
public:
    virtual ~PTransform() = default;
};

class FlattenPCollectionList : public PTransform {
};

class AppliedPTransform {
public:
    virtual PTransform* getTransform() = 0;
    virtual bool getInputsEmpty() const = 0;
};

class PTransformMatcher {
public:
    virtual bool matches(AppliedPTransform* application) = 0;
    virtual ~PTransformMatcher() = default;
};

std::unique_ptr<PTransformMatcher> parDoWithFnType(const std::type_info& fnType) {
    class Matcher : public PTransformMatcher {
        const std::type_info& fnType_;
    public:
        Matcher(const std::type_info& ft) : fnType_(ft) {}
        bool matches(AppliedPTransform* application) override {
            DoFn* fn = nullptr;
            if (auto* bound = dynamic_cast<ParDoBound*>(application->getTransform())) {
                fn = bound->getFn();
            } else if (auto* boundMulti = dynamic_cast<ParDoBoundMulti*>(application->getTransform())) {
                fn = boundMulti->getFn();
            } else {
                return false;
            }
            return typeid(*fn) == fnType_;
        }
    };
    return std::make_unique<Matcher>(fnType);
}

std::unique_ptr<PTransformMatcher> emptyFlatten() {
    class Matcher : public PTransformMatcher {
    public:
        bool matches(AppliedPTransform* application) override {
            return dynamic_cast<FlattenPCollectionList*>(application->getTransform())
                && application->getInputsEmpty();
        }
    };
    return std::make_unique<Matcher>();
}","#include <typeinfo>
#include <memory>

class DoFn {
public:
    virtual ~DoFn() = default;
};

class ParDoBound {
public:
    virtual ~ParDoBound() = default;
    virtual DoFn* getFn() const = 0;
};

class ParDoBoundMulti {
public:
    virtual ~ParDoBoundMulti() = default;
    virtual DoFn* getFn() const = 0;
};

class FlattenPCollectionList {
public:
    virtual ~FlattenPCollectionList() = default;
};

class PTransform {
public:
    virtual ~PTransform() = default;
};

class AppliedPTransform {
public:
    virtual ~AppliedPTransform() = default;
    virtual PTransform* getTransform() const = 0;
    virtual bool inputsEmpty() const = 0;
};

class PTransformMatcher {
public:
    virtual ~PTransformMatcher() = default;
    virtual bool matches(const AppliedPTransform* application) const = 0;
};

template <typename FnType>
class ParDoWithFnTypeMatcher : public PTransformMatcher {
public:
    bool matches(const AppliedPTransform* application) const override {
        DoFn* fn = nullptr;
        if (auto bound = dynamic_cast<ParDoBound*>(application->getTransform())) {
            fn = bound->getFn();
        } else if (auto boundMulti = dynamic_cast<ParDoBoundMulti*>(application->getTransform())) {
            fn = boundMulti->getFn();
        } else {
            return false;
        }
        return typeid(FnType) == typeid(*fn);
    }
};

inline std::unique_ptr<PTransformMatcher> parDoWithFnType(const std::type_info& fnType) {
    class Matcher : public PTransformMatcher {
        const std::type_info& fnType;
    public:
        Matcher(const std::type_info& type) : fnType(type) {}
        bool matches(const AppliedPTransform* application) const override {
            DoFn* fn = nullptr;
            if (auto bound = dynamic_cast<ParDoBound*>(application->getTransform())) {
                fn = bound->getFn();
            } else if (auto boundMulti = dynamic_cast<ParDoBoundMulti*>(application->getTransform())) {
                fn = boundMulti->getFn();
            } else {
                return false;
            }
            return fn && typeid(*fn) == fnType;
        }
    };
    return std::unique_ptr<PTransformMatcher>(new Matcher(fnType",1
"#include ""org/apache/hudi/common/config/SerializableConfiguration.h""
#include ""org/apache/hudi/common/model/HoodieRecord.h""
#include ""org/apache/hudi/common/model/WriteOperationType.h""
#include ""org/apache/hudi/common/util/ObjectSizeCalculator.h""
#include ""org/apache/hudi/index/HoodieIndex.h""
#include ""org/apache/hudi/operator/event/BatchWriteSuccessEvent.h""
#include ""org/apache/hudi/table/action/commit/FlinkWriteHelper.h""","#include ""HoodieFlinkEngineContext.h""
#include ""SerializableConfiguration.h""
#include ""HoodieRecord.h""
#include ""WriteOperationType.h""
#include ""ObjectSizeCalculator.h""
#include ""HoodieIndex.h""
#include ""BatchWriteSuccessEvent.h""
#include ""FlinkWriteHelper.h""",0
"// [DEL] import org.mule.runtime.extension.api.annotation.Parameter;
// [ADD] import org.mule.runtime.extension.api.annotation.param.NullSafe;
// [ADD] import org.mule.runtime.extension.api.annotation.param.Parameter;
// [ADD] import org.mule.runtime.extension.api.annotation.param.ParameterGroup;
// [ADD] import org.mule.runtime.extension.api.annotation.source.EmitsResponse;

#include <stdexcept>
#include <string>

class Extension {};
class ExtensionOf {};
class Operations {};
class RestrictedTo {};
class XmlHints {};
class MetadataKeyId {};
class Connection {};
class NullSafe {};
class Parameter {};
class ParameterGroup {};
class UseConfig {};
class EmitsResponse {};
class IllegalModelDefinitionException : public std::logic_error {
public:
    using std::logic_error::logic_error;
};
class DescribingContext {};
class Describer {};",#include <stdexcept>,0
"this->objectStore = objectStore;
normalTaskExecutorService = std::make_shared<std::thread::id>();
actorConcurrencyGroupManager = std::make_unique<ActorConcurrencyGroupManager>();
}

void onObjectPut(const ObjectId& id) {","LocalModeTaskSubmitter::LocalModeTaskSubmitter(ObjectStore& objectStore)
    : objectStore(objectStore),
      normalTaskExecutorService(std::make_unique<ThreadPool>()),
      actorConcurrencyGroupManager(std::make_unique<ActorConcurrencyGroupManager>()) {
}

void LocalModeTaskSubmitter::onObjectPut(const ObjectId& id) {",0
"}

void setSoapVersion(const std::string& soapVersion)
{
    for (auto serviceConfiguration : getServiceConfigurations())
    {
        if (auto proxyServiceConfiguration = dynamic_cast<ProxyServiceConfiguration*>(serviceConfiguration))
        {
            proxyServiceConfiguration->setSoapVersion(soapVersion);
            return;
        }
    }
}","void setSoapVersion(const std::string& soapVersion)
{
    for (auto* serviceConfiguration : getServiceConfigurations())
    {
        if (auto* proxyServiceConfiguration = dynamic_cast<ProxyServiceConfiguration*>(serviceConfiguration))
        {
            proxyServiceConfiguration->setSoapVersion(soapVersion);
            return;
        }
    }
}",1
"#include <string>
#include <vector>
#include <algorithm>

class MyClass : public SuperClass {
public:

    [[Description(""When the ReactorProcessingStrategy is configured any async processing will be returned to CPU_LIGHT thread. ""
                  ""This helps avoid deadlocks when there are reduced number of threads used by async processor."")]]
    void asyncCpuLight() override {
        SuperClass::asyncCpuLight();
        assertThat(threads.size(), between(1, 2));
        auto cpuLightCount = std::count_if(threads.begin(), threads.end(),
            [](const std::string& name) { return name.starts_with(CPU_LIGHT); });
        assertThat(static_cast<long>(cpuLightCount), between(1l, 2l));
        auto ioCount = std::count_if(threads.begin(), threads.end(),
            [](const std::string& name) { return name.starts_with(IO); });
        assertThat(static_cast<long>(ioCount), equalTo(0l));
        auto cpuIntensiveCount = std::count_if(threads.begin(), threads.end(),
            [](const std::string& name) { return name.starts_with(CPU_INTENSIVE); });
        assertThat(static_cast<long>(cpuIntensiveCount), equalTo(0l));
        auto customCount = std::count_if(threads.begin(), threads.end(),
            [](const std::string& name) { return name.starts_with(CUSTOM); });
        assertThat(static_cast<long>(customCount), equalTo(0l));
    }

    [[Description(""When the ReactorProcessingStrategy is configured any async processing will be returned to CPU_LIGHT thread. ""
                  ""This helps avoid deadlocks when there are reduced number of threads used by async processor."")]]
    void asyncCpuLightConcurrent() override {
        SuperClass::asyncCpuLightConcurrent();
        assertThat(threads.size(), between(2, 3));
        auto cpuLightCount = std::count_if(threads.begin(), threads.end(),
            [](const std::string& name) { return name.starts_with(CPU_LIGHT); });
        assertThat(static_cast<long>(cpuLightCount), between(2l, 3l));
        auto ioCount = std::count_if(threads.begin(), threads.end(),
            [](const std::string& name) { return name.starts_with(IO); });
        assertThat(static_cast<long>(ioCount), equalTo(0l));
        auto cpuIntensiveCount = std::count_if(threads.begin(), threads.end(),
            [](const std::","void asyncCpuLight() override {
    AbstractProcessingStrategyTestCase::asyncCpuLight();
    assertThat(threads.size(), between(1, 2));
    assertThat(std::count_if(threads.begin(), threads.end(), [](const std::string& name){ return name.rfind(CPU_LIGHT, 0) == 0; }), between(1l, 2l));
    assertThat(std::count_if(threads.begin(), threads.end(), [](const std::string& name){ return name.rfind(IO, 0) == 0; }), equalTo(0l));
    assertThat(std::count_if(threads.begin(), threads.end(), [](const std::string& name){ return name.rfind(CPU_INTENSIVE, 0) == 0; }), equalTo(0l));
    assertThat(std::count_if(threads.begin(), threads.end(), [](const std::string& name){ return name.rfind(CUSTOM, 0) == 0; }), equalTo(0l));
}

void asyncCpuLightConcurrent() override {
    AbstractProcessingStrategyTestCase::asyncCpuLightConcurrent();
    assertThat(threads.size(), between(2, 3));
    assertThat(std::count_if(threads.begin(), threads.end(), [](const std::string& name){ return name.rfind(CPU_LIGHT, 0) == 0; }), between(2l, 3l));
    assertThat(std::count_if(threads.begin(), threads.end(), [](const std::string& name){ return name.rfind(IO, 0) == 0; }), equalTo(0l));
    assertThat(std::count_if(threads.begin(), threads.end(), [](const std::string& name){ return name.rfind(CPU_INTENSIVE, 0) == 0; }), equalTo(0l));
    assertThat(std::count_if(threads.begin(), threads.end(), [](const std::string& name){ return name.rfind(CUSTOM, 0) == 0; }), equalTo(0l));
}",1
"EXPECT_EQ(pullFile.entrySet().size(), 7);
}

TEST(MyTestSuite, testJsonPropertyReuseJobLoading) {
    std::filesystem::path path;
    Config pullFile;
    path = std::filesystem::path(this->basePath) / ""bjob.pull"";
    Config cfg = ConfigFactory::parseMap({
        {PullFileLoader::PROPERTY_DELIMITER_PARSING_ENABLED_KEY, true}
    });
    pullFile = loader.loadPullFile(path, cfg, false);
    std::cout << pullFile.getString(""json.property.key"") << std::endl;
    std::cout << pullFile.getString(""json.property.key1"") << std::endl;
    EXPECT_EQ(pullFile.getString(""json.property.key""), pullFile.getString(""json.property.key1""));
}

Config pullFileFromPath(const std::vector<Config>& configs, const std::filesystem::path& path) {
    for (const auto& config : configs) {
        if (config.getString(ConfigurationKeys::JOB_CONFIG_FILE_PATH_KEY) == path.string()) {","```cpp
#include <gtest/gtest.h>
#include <filesystem>
#include <map>
#include <string>
#include <iostream>

using namespace std;

TEST(PullFileLoaderTest, testJsonPropertyReuseJobLoading) {
    filesystem::path path;
    Config pullFile;
    path = filesystem::path(this->basePath) / ""bjob.pull"";
    map<string, any> cfgMap = {
        {PullFileLoader::PROPERTY_DELIMITER_PARSING_ENABLED_KEY, true}
    };
    Config cfg = ConfigFactory::parseMap(cfgMap);
    pullFile = loader.loadPullFile(path, cfg, false);
    cout << pullFile.getString(""json.property.key"") << endl;
    cout << pullFile.getString(""json.property.key1"") << endl;
    ASSERT_EQ(pullFile.getString(""json.property.key""), pullFile.getString(""json.property.key1""));
}

Config pullFileFromPath(const vector<Config>& configs, const filesystem::path& path) {
    for (const Config& config : configs) {
        if (config.getString(ConfigurationKeys::JOB_CONFIG_FILE_PATH_KEY) == path.string()) {
            return config;
        }
    }
    throw std::ios_base::failure(""File not found"");
}
```",1
"assertFieldOfType(record, ""ID"", testDatabase.getIdFieldMetaDataType());
assertFieldOfType(record, ""POSITION"", testDatabase.getPositionFieldMetaDataType());
assertFieldOfType(record, ""NAME"", typeBuilder.stringType().build());
assertFieldOfType(record, ""PICTURE"", typeLoader.load(typeid(Blob)));","assertFieldOfType(record, ""ID"", testDatabase.getIdFieldMetaDataType());
assertFieldOfType(record, ""POSITION"", testDatabase.getPositionFieldMetaDataType());
assertFieldOfType(record, ""NAME"", typeBuilder.stringType().build());
// The following assertion will fail in MySQL because Blob is communicated as a std::vector<uint8_t>
assertFieldOfType(record, ""PICTURE"", typeLoader.load(Blob::classType()));",1
"auto beginLsTs = std::chrono::steady_clock::now();
auto statuses = listPartition(partitionPath);
auto endLsTs = std::chrono::steady_clock::now();
LOG.debug(""#files found in partition ("" + partitionPathStr + "") =""
          + std::to_string(statuses.size()) + "", Time taken =""
          + std::to_string(std::chrono::duration_cast<std::chrono::milliseconds>(endLsTs - beginLsTs).count()));
auto groups = addFilesToView(statuses);","auto beginLsTs = std::chrono::system_clock::now();
auto statuses = listPartition(partitionPath);
auto endLsTs = std::chrono::system_clock::now();
LOG.debug(""#files found in partition ("" + partitionPathStr + "") ="" +
          std::to_string(statuses.size()) + "", Time taken ="" +
          std::to_string(std::chrono::duration_cast<std::chrono::milliseconds>(endLsTs - beginLsTs).count()));
auto groups = addFilesToView(statuses);",0
"#include <string>

const std::string CLUSTERING_STRATEGY_PARAM_PREFIX = ""hoodie.clustering.plan.strategy."";

class ConfigProperty {
public:
    using value_type = std::string;
    ConfigProperty& key(const std::string& k) {
        key_ = k;
        return *this;
    }
    ConfigProperty& defaultValue(const value_type& v) {
        default_ = v;
        return *this;
    }
    ConfigProperty& sinceVersion(const std::string& ver) {
        version_ = ver;
        return *this;
    }
    ConfigProperty& withDocumentation(const std::string& doc) {
        doc_ = doc;
        return *this;
    }
    std::string key() const { return key_; }
private:
    std::string key_;
    value_type default_;
    std::string version_;
    std::string doc_;
};

const ConfigProperty CLUSTERING_DAYBASED_LOOKBACK_PARTITIONS = ConfigProperty()
    .key(CLUSTERING_STRATEGY_PARAM_PREFIX + ""daybased.lookback.partitions"")
    .defaultValue(""2"")
    .sinceVersion(""0.7.0"")
    .withDocumentation(""Number of partitions to list to create ClusteringPlan"");

const ConfigProperty CLUSTERING_PLAN_STRATEGY_CLASS_NAME = ConfigProperty()
    .key(""hoodie.clustering.plan.strategy.class"")
    .defaultValue(""org.apache.hudi.client.clustering.plan.strategy.SparkRecentDaysClusteringPlanStrategy"")
    .sinceVersion(""0.7.0"")
    .withDocumentation(
        ""Config to provide a strategy class (subclass of ClusteringPlanStrategy) to create clustering plan ""
        ""i.e select what file groups are being clustered. Default strategy, looks at the last N (determined by ""
        + CLUSTERING_DAYBASED_LOOKBACK_PARTITIONS.key() + "") day based partitions picks the small file slices within those partitions.""
    );

const ConfigProperty CLUSTERING_EXECUTION_STRATEGY_CLASS_NAME = ConfigProperty()
    .key(""hoodie.clustering.execution.strategy.class"")
    .defaultValue(""org.apache.hudi.client.clustering.run.strategy.SparkSortAndSizeExecutionStrategy"")
    .sinceVersion(""0.7.0"");","#include <string>

class HoodieClusteringConfig : public HoodieConfig {
public:
    static constexpr const char* CLUSTERING_STRATEGY_PARAM_PREFIX = ""hoodie.clustering.plan.strategy."";

    static const ConfigProperty<std::string> CLUSTERING_DAYBASED_LOOKBACK_PARTITIONS;
    static const ConfigProperty<std::string> CLUSTERING_PLAN_STRATEGY_CLASS_NAME;
    static const ConfigProperty<std::string> CLUSTERING_EXECUTION_STRATEGY_CLASS_NAME;
};

const ConfigProperty<std::string> HoodieClusteringConfig::CLUSTERING_DAYBASED_LOOKBACK_PARTITIONS = ConfigProperty<std::string>()
    .key(std::string(CLUSTERING_STRATEGY_PARAM_PREFIX) + ""daybased.lookback.partitions"")
    .defaultValue(""2"")
    .sinceVersion(""0.7.0"")
    .withDocumentation(""Number of partitions to list to create ClusteringPlan"");

const ConfigProperty<std::string> HoodieClusteringConfig::CLUSTERING_PLAN_STRATEGY_CLASS_NAME = ConfigProperty<std::string>()
    .key(""hoodie.clustering.plan.strategy.class"")
    .defaultValue(""org.apache.hudi.client.clustering.plan.strategy.SparkRecentDaysClusteringPlanStrategy"")
    .sinceVersion(""0.7.0"")
    .withDocumentation(
        std::string(""Config to provide a strategy class (subclass of ClusteringPlanStrategy) to create clustering plan "")
        + ""i.e select what file groups are being clustered. Default strategy, looks at the last N (determined by ""
        + HoodieClusteringConfig::CLUSTERING_DAYBASED_LOOKBACK_PARTITIONS.key()
        + "") day based partitions picks the small file slices within those partitions.""
    );

const ConfigProperty<std::string> HoodieClusteringConfig::CLUSTERING_EXECUTION_STRATEGY_CLASS_NAME = ConfigProperty<std::string>()
    .key(""hoodie.clustering.execution.strategy.class"")
    .defaultValue(""org.apache.hudi.client.clustering.run.strategy.SparkSortAndSizeExecutionStrategy"")
    .sinceVersion(""0.7.0"");",0
"#include ""graylog2/dashboards/widgets/DashboardWidget.h""
#include ""graylog2/dashboards/widgets/DashboardWidgetCreator.h""
#include ""graylog2/dashboards/widgets/InvalidWidgetConfigurationException.h""
#include ""graylog2/dashboards/widgets/WidgetPosition.h""
#include ""graylog2/database/MongoConnection.h""
#include ""graylog2/database/NotFoundException.h""
#include ""graylog2/database/PersistedServiceImpl.h""","#include <string>
#include <stdexcept>
#include <memory>
#include ""ObjectId.h""
#include ""DashboardWidget.h""
#include ""DashboardWidgetCreator.h""
#include ""InvalidWidgetConfigurationException.h""
#include ""WidgetPosition.h""
#include ""MongoConnection.h""
#include ""NotFoundException.h""
#include ""PersistedServiceImpl.h""",0
"class DefaultExtensionsClient : public ExtensionsClient {
private:
    TemplateParser parser = TemplateParser::createMuleStyleParser();

public:
    MuleContext* muleContext;
};","class DefaultExtensionsClient : public ExtensionsClient {
private:
    TemplateParser parser = TemplateParser::createMuleStyleParser();

public:
    MuleContext* muleContext;
};",0
"```cpp
void initialise() {
    std::vector<Properties> bootstraps;
    try {
        bootstraps = discoverer.discover();
    } catch (const std::exception& e1) {
        throw InitialisationException(e1, this);
    }

    int objectCounter = 1;
    int transformerCounter = 1;
    std::vector<ParsedProperty> transformers;
    std::vector<ParsedProperty> namedObjects;
    std::vector<ParsedProperty> unnamedObjects;
    std::vector<ParsedProperty> singleTransactionFactories;

    for (const auto& bootstrap : bootstraps) {
        for (const auto& entry : bootstrap) {
            ParsedProperty pp = parsePropertyEntry(entry.first, entry.second);

            if (pp.keyContains(OBJECT_KEY)) {
                pp.disambiguateKey(objectCounter++);
                unnamedObjects.push_back(pp);
            }
            else if (pp.keyContains(TRANSFORMER_KEY) || pp.isOfType<Transformer>()) {
                if (pp.keyContains(TRANSFORMER_KEY)) {
                    pp.disambiguateKey(transformerCounter++);
                }
                transformers.push_back(pp);
            }
            else if (pp.keyContains(SINGLE_TX)) {
                if (!pp.keyContains("".transaction.resource"")) {
                    std::string transactionResourceKey = replaceAll(pp.key, "".transaction.factory"", "".transaction.resource"");
                    std::string transactionResource = bootstrap.getProperty(transactionResourceKey);
                    if (transactionResource.empty()) {
                        throw InitialisationException(CoreMessages::createStaticMessage(
                            ""Theres no transaction resource specified for transaction factory "" + pp.key), this);
                    }
                    singleTransactionFactories.push_back(parsePropertyEntry(pp.className, transactionResource));
                }
            }
            else {
                // ...
            }
        }
    }
}
```","void initialise()
{
    std::vector<std::map<std::string, std::string>> bootstraps;
    try
    {
        bootstraps = discoverer.discover();
    }
    catch (const std::exception& e1)
    {
        throw InitialisationException(e1, this);
    }

    int objectCounter = 1;
    int transformerCounter = 1;
    std::vector<ParsedProperty> transformers;
    std::vector<ParsedProperty> namedObjects;
    std::vector<ParsedProperty> unnamedObjects;
    std::vector<ParsedProperty> singleTransactionFactories;

    for (const auto& bootstrap : bootstraps)
    {
        for (const auto& entry : bootstrap)
        {
            ParsedProperty pp = parsePropertyEntry(entry.first, entry.second);
            if (pp.keyContains(OBJECT_KEY))
            {
                pp.disambiguateKey(objectCounter++);
                unnamedObjects.push_back(pp);
            }
            else if (pp.keyContains(TRANSFORMER_KEY) || pp.isOfType(Transformer::classType()))
            {
                if (pp.keyContains(TRANSFORMER_KEY))
                {
                    pp.disambiguateKey(transformerCounter++);
                }
                transformers.push_back(pp);
            }
            else if (pp.keyContains(SINGLE_TX))
            {
                if (!pp.keyContains("".transaction.resource""))
                {
                    std::string transactionResourceKey = replaceAll(pp.key, "".transaction.factory"", "".transaction.resource"");
                    auto it = bootstrap.find(transactionResourceKey);
                    if (it == bootstrap.end())
                    {
                        throw InitialisationException(
                            CoreMessages::createStaticMessage(
                                ""Theres no transaction resource specified for transaction factory "" + pp.key),
                            this);
                    }
                    singleTransactionFactories.push_back(parsePropertyEntry(pp.className, it->second));
                }
            }
            else
            {
                // Custom processing if required
            }
        }
    }
}",1
"#include ""BaseMessages.h""
#include ""ObjectId.h""
#include ""Repository.h""
#include ""RepositoryDirectory.h""
#include ""RepositoryDirectoryInterface.h""
#include ""RepositoryElementMetaInterface.h""
#include ""RepositoryObjectType.h""
#include ""RepositoryObjectAccessException.h""
#include ""TransMeta.h""
#include ""RepositoryExtension.h""
#include ""IUIEEUser.h""
#include ""UIEERepositoryDirectory.h""","#include ""LogChannel.h""
#include ""BaseMessages.h""
#include ""ObjectId.h""
#include ""Repository.h""
#include ""RepositoryDirectory.h""
#include ""RepositoryDirectoryInterface.h""
#include ""RepositoryElementMetaInterface.h""
#include ""RepositoryObjectType.h""
#include ""RepositoryObjectAccessException.h""
#include ""TransMeta.h""
#include ""RepositoryExtension.h""
#include ""IUIEEUser.h""
#include ""UIEERepositoryDirectory.h""",0
"return DEFAULT_TABLE_TYPE;
}

TimelineLayoutVersion getTimelineLayoutVersion() {
    return TimelineLayoutVersion(std::stoi(props.getProperty(HOODIE_TIMELINE_LAYOUT_VERSION,
                                  std::to_string(DEFAULT_TIMELINE_LAYOUT_VERSION))));
}","TimelineLayoutVersion getTimelineLayoutVersion() const {
    return TimelineLayoutVersion(std::stoi(props.getProperty(HOODIE_TIMELINE_LAYOUT_VERSION,
        std::to_string(DEFAULT_TIMELINE_LAYOUT_VERSION))));
}",0
"private:
    const int minPortNumber;
    const int portRange;
    const std::string LOCK_FILE_EXTENSION = "".lock"";
    std::unordered_map<int, std::unique_ptr<FileLock>> locks;
    std::mt19937 random;

public:
    FreePortFinder(int minPortNumber, int maxPortNumber)
        : minPortNumber(minPortNumber),
          portRange(maxPortNumber - minPortNumber + 1),
          random(std::random_device{}())
    {
    }","#include <set>
#include <map>
#include <random>
#include <string>

class FreePortFinder
{
private:
    int minPortNumber;
    int portRange;
    std::set<int> selectedPorts;
    std::mt19937 random{std::random_device{}()};
    const std::string LOCK_FILE_EXTENSION = "".lock"";
    std::map<int, /* FileLock */ void*> locks;

public:
    FreePortFinder(int minPortNumber, int maxPortNumber)
        : minPortNumber(minPortNumber), portRange(maxPortNumber - minPortNumber + 1)
    {}
};",0
"#include <string>
#include <vector>
#include <regex>
#include <memory>
#include <stdexcept>
#include <filesystem>

using std::string;
using std::vector;
using std::unique_ptr;
using std::regex;
using std::runtime_error;
using std::filesystem::path;","#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>
#include <regex>
#include <memory>

#include ""ConfigurationKeys.h""
#include ""CopyConfiguration.h""
#include ""Dataset.h""

#include <filesystem>",1
"#include <iostream>
#include <fstream>
#include <filesystem>
#include <vector>
#include <string>
#include <zip.h>","#include <fstream>
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>
#include <filesystem>
#include <system_error>
#include <zip.h>",0
"[[deprecated(""If IO pool is busy OVERLOAD error is thrown"")]]
void blockingRejectedExecution() {
    auto blockingSchedulerSpy = std::make_shared<SchedulerSpy>(blocking);
    auto rejectingSchedulerSpy = std::make_shared<RejectingScheduler>(blockingSchedulerSpy);

    flow = flowBuilder.get()->processors(blockingProcessor)
        .processingStrategyFactory([=](auto context, auto prefix) {
            return std::make_shared<ProactorStreamEmitterProcessingStrategy>(DEFAULT_BUFFER_SIZE,
                /* ... other args ... */
            );
        });
}","void blockingRejectedExecution() {
    Scheduler* blockingSchedulerSpy = spy(blocking);
    RejectingScheduler* rejectingSchedulerSpy = new RejectingScheduler(blockingSchedulerSpy);

    flow = flowBuilder.get()->processors(blockingProcessor)
        ->processingStrategyFactory([=](auto context, auto prefix) {
            return new ProactorStreamEmitterProcessingStrategy(DEFAULT_BUFFER_SIZE,
            /* ... */);
        });
}",0
"s = s.substr(1);
if (version == '\003')
{
    if (!m_load_deprecated_formats)
    {
        LOG_PRINT_L0(""Not loading deprecated format"");
        return false;
    }
    try
    {
        std::istringstream iss(s);","```cpp
s = s.substr(1);
if (version == '\003')
{
    if (!m_load_deprecated_formats)
    {
        LOG_PRINT_L0(""Not loading deprecated format"");
        return false;
    }
    try
    {
        std::istringstream iss(s);
```",1
"```cpp
protected:
bool createCloudStackSecret(const std::vector<std::string>& keys) {
    auto pkFile = getManagementServerSshPublicKeyFile();
    auto publicIpSshPort = getKubernetesClusterServerIpSshPort(nullptr);
    publicIpAddress = publicIpSshPort.first;
    sshPort = publicIpSshPort.second;

    try {
        auto result = SshHelper::sshExecute(
            publicIpAddress, sshPort, CLUSTER_NODE_VM_USER,
            pkFile, nullptr, 
            (boost::format(""sudo /opt/bin/deploy-cloudstack-secret -u '%1%' -k '%2%' -s '%3%'"") 
                % ApiServiceConfiguration::ApiServletPath::value() % keys[0] % keys[1]).str(),
            10000, 10000, 60000
        );
        return result.first;
    } catch (const std::exception& e) {
        std::string msg = (boost::format(""Failed to add cloudstack-secret to Kubernetes cluster: %1%"") 
                          % kubernetesCluster->getName()).str();
        LOGGER.warn(msg, e);
    }
    return false;
}

protected:
std::shared_ptr<File> retrieveScriptFile(const std::string& filename) {
    std::shared_ptr<File> file = nullptr;
    try {
        std::string data = readResourceFile(""/script/"" + filename);
        file = File::createTempFile(filename, "".sh"");
        std::ofstream writer(file->getPath());
        writer << data;
        writer.close();
    } catch (const std::ios_base::failure& e) {
        logAndThrow(Level::ERROR, 
            (boost::format(""Failed to upgrade Kubernetes cluster %1%, unable to prepare upgrade script %2%"") 
                % kubernetesCluster->getName() % filename).str(), e);
    }
    return file;
}

protected:
void retrieveScriptFiles() {
    deploySecretsScriptFile = retrieveScriptFile(deploySecretsScriptFilename);
    deployProviderScriptFile = retrieveScriptFile(deployProviderScriptFilename);
}

protected:
void copyScripts(const std::string& nodeAddress, int sshPort) {
    try {
        SshHelper::scpTo(nodeAddress, sshPort, CLUSTER_NODE_VM_USER, sshKeyFile, nullptr,
                         ""~/"", deploySecretsScriptFile->getAbsolutePath(), ""0755"");
        SshHelper::scpTo","protected:
    bool createCloudStackSecret(const std::vector<std::string>& keys) {
        auto pkFile = getManagementServerSshPublicKeyFile();
        auto publicIpSshPort = getKubernetesClusterServerIpSshPort(nullptr);
        publicIpAddress = publicIpSshPort.first;
        sshPort = publicIpSshPort.second;

        try {
            auto result = SshHelper::sshExecute(
                publicIpAddress, sshPort, CLUSTER_NODE_VM_USER,
                pkFile, nullptr, 
                (std::ostringstream() << ""sudo /opt/bin/deploy-cloudstack-secret -u '"" 
                    << ApiServiceConfiguration::ApiServletPath::value() 
                    << ""' -k '"" << keys[0] << ""' -s '"" << keys[1] << ""'"").str(),
                10000, 10000, 60000
            );
            return result.first;
        } catch (const std::exception& e) {
            auto msg = (std::ostringstream() << ""Failed to add cloudstack-secret to Kubernetes cluster: "" 
                << kubernetesCluster.getName()).str();
            LOGGER.warn(msg, e);
        }
        return false;
    }

    std::filesystem::path retrieveScriptFile(const std::string& filename) {
        std::filesystem::path file;
        try {
            std::string data = readResourceFile(""/script/"" + filename);

            auto temp = std::filesystem::temp_directory_path() / (filename + "".sh"");
            std::ofstream writer(temp);
            writer << data;
            writer.close();
            file = temp;
        } catch (const std::exception& e) {
            logAndThrow(Level::ERROR,
                (std::ostringstream() 
                    << ""Failed to upgrade Kubernetes cluster "" 
                    << kubernetesCluster.getName() 
                    << "", unable to prepare upgrade script "" 
                    << filename).str(), e);
        }
        return file;
    }

    void retrieveScriptFiles() {
        deploySecretsScriptFile = retrieveScriptFile(deploySecretsScriptFilename);
        deployProviderScriptFile = retrieveScriptFile(deployProviderScriptFilename);
    }

    void copyScripts(const std::string& nodeAddress, int sshPort) {
        try {
            SshHelper::scpTo(nodeAddress, sshPort, CLUSTER_NODE_VM_USER, sshKeyFile, nullptr,
                             ""~/"", deploySecretsScriptFile.string(), ""0755"");
            SshHelper::scpTo(node",1
"}
  }
}
if (currentOutputWatermark != std::numeric_limits<long long>::max()) {
  if (stateInternals != nullptr) {
    throw std::logic_error(
      getRuntimeContext().getTaskNameWithSubtasks() +
      std::string("" Watermark should be at "") + std::to_string(std::numeric_limits<long long>::max()) + "" when shutting down, is "" +
      std::to_string(currentInputWatermark) + ""/"" + std::to_string(getPushbackWatermarkHold()) + ""/"" +
      std::to_string(currentOutputWatermark) + "". Watermark hold: "" +
      std::to_string(stateInternals->watermarkHold()->getMillis())
    );
  } else {
    throw std::logic_error(
      getRuntimeContext().getTaskNameWithSubtasks() +
      std::string("" Watermark should be at "") + std::to_string(std::numeric_limits<long long>::max()) + "" when shutting down, is "" +
      std::to_string(currentInputWatermark) + ""/"" + std::to_string(getPushbackWatermarkHold()) + ""/"" +
      std::to_string(currentOutputWatermark) + "". No watermark hold.""
    );
  }
}
doFnInvoker.invokeTeardown();
}","if (currentOutputWatermark != std::numeric_limits<long long>::max()) {
    if (stateInternals != nullptr) {
        throw std::logic_error(
            getRuntimeContext()->getTaskNameWithSubtasks() +
            "" Watermark should be at "" + std::to_string(std::numeric_limits<long long>::max()) +
            "" when shutting down, is "" + std::to_string(currentInputWatermark) + ""/"" +
            std::to_string(getPushbackWatermarkHold()) + ""/"" +
            std::to_string(currentOutputWatermark) + "". Watermark hold: "" +
            std::to_string(stateInternals->watermarkHold()->getMillis())
        );
    } else {
        throw std::logic_error(
            getRuntimeContext()->getTaskNameWithSubtasks() +
            "" Watermark should be at "" + std::to_string(std::numeric_limits<long long>::max()) +
            "" when shutting down, is "" + std::to_string(currentInputWatermark) + ""/"" +
            std::to_string(getPushbackWatermarkHold()) + ""/"" +
            std::to_string(currentOutputWatermark) + "". No watermark hold.""
        );
    }
}

doFnInvoker->invokeTeardown();",1
"#include <string>
#include <set>

#include <gtest/gtest.h> // Assuming similar to Guava's utility (for demonstration purposes)
#include <gmock/gmock.h> // For test utility if needed

#include <nlohmann/json.hpp>

using std::string;
using std::set;

using json = nlohmann::json;","#include <set>
#include <string>
#include <algorithm>
#include <cctype>

// Helper for string checks similar to Guava's Strings
namespace Strings {
    inline bool isNullOrEmpty(const std::string& s) {
        return s.empty();
    }
}

// Alias for set operations similar to Guava's Sets
namespace Sets {
    template <typename T>
    std::set<T> unionSets(const std::set<T>& a, const std::set<T>& b) {
        std::set<T> result = a;
        result.insert(b.begin(), b.end());
        return result;
    }
}

// For JSON: use your choice of C++ JSON library; e.g., nlohmann/json
#include <nlohmann/json.hpp>
using JsonElement = nlohmann::json;",0
"std::regex leading_ws_regex(""^\\s*"");
std::regex trailing_ws_regex(""\\s*$"");
for (size_t i = 0; i < ends.size(); ++i) {
    ends[i] = std::regex_replace(ends[i], leading_ws_regex, """");
}

size_t maxLength = 0;
for (size_t i = 0; i < starts.size(); ++i) {
    std::string trimmed = std::regex_replace(starts[i], trailing_ws_regex, """");
    maxLength = std::max(maxLength, trimmed.length());
}

for (size_t i = 0; i < starts.size(); ++i) {
    size_t padLength = maxLength - starts[i].length();
    starts[i] += std::string(padLength, ' ');
}

std::ostringstream newSelectionBuilder;
for (size_t i = 0; i < starts.size(); ++i) {
    newSelectionBuilder << starts[i];
    newSelectionBuilder << "" "" << delimiters[i] << "" "";
    newSelectionBuilder << ends[i];
    if (i < starts.size() - 1)
        newSelectionBuilder << ""\n"";
}","```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>

std::string repeat(const std::string& str, int times) {
    std::string result;
    for (int i = 0; i < times; ++i) result += str;
    return result;
}

void alignAndBuildSelection(
    std::vector<std::string>& starts,
    std::vector<std::string>& ends,
    const std::vector<std::string>& delimiters,
    std::string& newSelection)
{
    // Remove trailing whitespace from 'starts' for alignment calculation
    int maxLength = 0;
    std::vector<std::string> trimmed_starts(starts.size());
    for (size_t i = 0; i < starts.size(); ++i) {
        auto& s = starts[i];
        size_t end = s.find_last_not_of("" \t\n\r\f\v"");
        std::string trimmed = (end == std::string::npos) ? """" : s.substr(0, end + 1);
        trimmed_starts[i] = trimmed;
        if (static_cast<int>(trimmed.length()) > maxLength)
            maxLength = static_cast<int>(trimmed.length());
    }
    // Pad 'starts' to maxLength
    for (size_t i = 0; i < starts.size(); ++i) {
        int padding = maxLength - static_cast<int>(trimmed_starts[i].length());
        starts[i] = trimmed_starts[i] + repeat("" "", padding);
    }

    std::ostringstream builder;
    for (size_t i = 0; i < starts.size(); ++i) {
        builder << starts[i] << "" "" << delimiters[i] << "" "" << ends[i];
        if (i < starts.size() - 1)
            builder << ""\n"";
    }
    newSelection = builder.str();
}
```",0
#include <optional>,#include <optional>,0
"#include <exception>
#include <stdexcept>
#include <string>","#include ""MuleContext.h""
#include ""MuleException.h""
#include ""MuleRuntimeException.h""
#include ""ConfigurationBuilder.h""
#include ""ConnectivityTestingService.h""
#include ""InitialisationException.h""
#include ""CoreMessages.h""
#include ""ClassUtils.h""",0
"#include <gmock/gmock.h>
#include <gtest/gtest.h>
using ::testing::Return;
using ::testing::_;
using ::testing::Eq;

constexpr auto BOOLEAN = /* appropriate C++ equivalent */;
constexpr auto OBJECT = /* appropriate C++ equivalent */;
constexpr auto STRING = /* appropriate C++ equivalent */;","#include <gtest/gtest.h>
#include <gmock/gmock.h>
using ::testing::Return;
using ::testing::_;
using ::testing::Eq;
using ::testing::NotNull;
using ::testing::Test;
using ::testing::NiceMock;",1
"private:
    Toolbar* toolbar_;

    RSConnectPublishButton* publishButton_;
    ToolbarButton* zoomButton_;
    ToolbarButton* clearAllButton_;
    ToolbarMenuButton* exportButton_;
    Widget* exportButtonSeparator_;","Toolbar* toolbar_;

RSConnectPublishButton* publishButton_;

ToolbarButton* zoomButton_;
ToolbarButton* clearAllButton_;
ToolbarMenuButton* exportButton_;
Widget* exportButtonSeparator_;",0
"std::to_string(!std::stoi(getProperty(MULE_FORCE_TOOLING_APP_LOGS_DEPLOYMENT_PROPERTY, ""false"")))
    .put(MULE_LAZY_INIT_DEPLOYMENT_PROPERTY, true)
    .put(MULE_LAZY_INIT_ENABLE_DSL_DECLARATION_VALIDATIONS_DEPLOYMENT_PROPERTY, true)
    .put(SHARED_PARTITIONED_PERSISTENT_OBJECT_STORE_PATH, getToolingWorkingDir().string())
    .build();
}

std::filesystem::path getToolingWorkingDir() {
    return getExecutionFolder() / ""tooling"";
}

DeclarationSession* createService(ApplicationSupplier applicationSupplier) override {
    return new DefaultDeclarationSession(applicationSupplier);
}","std::map<std::string, std::string> buildProperties() {
    std::map<std::string, std::string> properties;
    properties[MULE_FORCE_TOOLING_APP_LOGS_DEPLOYMENT_PROPERTY] = 
        std::to_string(!valueOf(getProperty(MULE_FORCE_TOOLING_APP_LOGS_DEPLOYMENT_PROPERTY, ""false"")));
    properties[MULE_LAZY_INIT_DEPLOYMENT_PROPERTY] = ""true"";
    properties[MULE_LAZY_INIT_ENABLE_DSL_DECLARATION_VALIDATIONS_DEPLOYMENT_PROPERTY] = ""true"";
    properties[SHARED_PARTITIONED_PERSISTENT_OBJECT_STORE_PATH] = getToolingWorkingDir().string();
    return properties;
}

std::filesystem::path getToolingWorkingDir() {
    return getExecutionFolder() / ""tooling"";
}

std::unique_ptr<DeclarationSession> createService(ApplicationSupplier applicationSupplier) override {
    return std::make_unique<DefaultDeclarationSession>(applicationSupplier);
}",1
"std::vector<std::future<void>> validatorPromises;
for (const auto& promise : promises) {
    validatorPromises.push_back(std::async(std::launch::async, [&, name, promise]() {
        try {
            promise.get();
            setValidity(name, true);
        } catch (const std::exception& error) {
            allValid = false;
            setValidity(name, false);
        }
    }));
}
if (validatorPromises.empty()) {
    validationDone(true);
} else {
    std::thread([&]() {
        for (auto& f : validatorPromises) {
            f.get();
        }
        validationDone(allValid);
    }).detach();
}","```cpp
std::vector<std::shared_ptr<std::future<void>>> validatorPromises;
bool allValid = true;

for (const auto& validator : validators) {
    auto promise = validator();
    validatorPromises.push_back(std::make_shared<std::future<void>>(promise.then([&, name]() {
        setValidity(name, true);
    }, [&, name, &allValid](auto error) {
        allValid = false;
        setValidity(name, false);
    })));
}

if (validatorPromises.empty()) {
    validationDone(true);
} else {
    std::vector<std::shared_ptr<std::future<void>>> futures = validatorPromises;
    std::async(std::launch::async, [&, futures]() {
        for (auto& future : futures) {
            future->wait();
        }
        validationDone(allValid);
    });
}
```",1
"FileTypeRegistry::OBJECT_EXPLORER.getTypeId(),
nullptr,
static_cast<JsObject*>(handle),
new SimpleRequestCallback<SourceDocument>(constants_.showObjectExplorer())
{
public:
    void onResponseReceived(SourceDocument response) override","@@ -935,7 +935,7 @@
FileTypeRegistry::OBJECT_EXPLORER.getTypeId(),
nullptr,
static_cast<JsObject*>(handle),
new SimpleRequestCallback<SourceDocument>(constants_.showObjectExplorer())
{
    void onResponseReceived(SourceDocument response) override",0
"std::unordered_set<std::string> hs;

std::vector<std::string> testHs;

std::set<std::string> overridenConfig;

LogConfig defaultConfig(config, overridenConfig);","```cpp
std::map<std::string, int> config = {
    {LogConfig::MinInSyncReplicasProp(), 1}
};

// nothing to override

std::unordered_set<std::string> hs;

std::vector<std::string> testHs;

// No equivalent for Scala specific types, so use empty set
std::set<std::string> overridenConfig;

LogConfig defaultConfig(config, overridenConfig);
```",1
"```
Span* startSpan(Statement* statement, const std::string& query) {
    return startSpan(statement, normalizeAndExtractInfo(query));
}

Span* startSpan(Statement* statement, const SqlStatementInfo& queryInfo) {
    Connection* connection = connectionFromStatement(statement);
    if (connection == nullptr) {
        return nullptr;
    }
```","Span* startSpan(Statement* statement, const std::string& query) {
    return startSpan(statement, normalizeAndExtractInfo(query));
}

Span* startSpan(Statement* statement, const SqlStatementInfo& queryInfo) {
    Connection* connection = connectionFromStatement(statement);
    if (connection == nullptr) {
        return nullptr;
    }
    // ...rest of the method...
}",1
"if (!(std::filesystem::exists(javaagentFile) || std::filesystem::is_regular_file(javaagentFile))) {
    throw std::runtime_error(""Unable to find javaagent file: "" + javaagentFile.string());
}
javaAgentJarURL = std::filesystem::absolute(javaagentFile).string();
checkJarManifestMainClassIsThis(javaAgentJarURL);
inst.appendToBootstrapClassLoaderSearch(JarFile(javaagentFile));
return javaAgentJarURL;

static std::vector<std::string> getVMArgumentsThroughReflection() {
    try {
        // Try Oracle-based
        auto managementFactoryHelperClass = thisClass.getClassLoader().loadClass(""sun.management.ManagementFactoryHelper"");
        auto vmManagementClass = thisClass.getClassLoader().loadClass(""sun.management.VMManagement"");
        void* vmManagement;","if (!(std::filesystem::exists(javaagentFile) || std::filesystem::is_regular_file(javaagentFile))) {
    throw std::runtime_error(""Unable to find javaagent file: "" + javaagentFile.string());
}
std::string javaAgentJarURL = javaagentFile.string();
checkJarManifestMainClassIsThis(javaAgentJarURL);
inst.appendToBootstrapClassLoaderSearch(JarFile(javaagentFile));
return javaAgentJarURL;

static std::vector<std::string> getVMArgumentsThroughReflection() {
    try {
        auto managementFactoryHelperClass =
            thisClass.getClassLoader().loadClass(""sun.management.ManagementFactoryHelper"");

        auto vmManagementClass =
            thisClass.getClassLoader().loadClass(""sun.management.VMManagement"");

        // ...
    } catch (const std::exception& e) {
        // ...
    }
}",0
"#include <string>
#include <gtest/gtest.h>

class AbstractClassNoFieldShouldBeInterfaceCheckTest : public ::testing::Test {
protected:
    static const std::string TEST_FILE;
};

const std::string AbstractClassNoFieldShouldBeInterfaceCheckTest::TEST_FILE = ""src/test/files/checks/AbstractClassNoFieldShouldBeInterfaceCheck.java"";","#include <string>
#include <vector>
#include <cassert>

class AbstractClassNoFieldShouldBeInterfaceCheckTest {
public:
    static const std::string TEST_FILE;
};

const std::string AbstractClassNoFieldShouldBeInterfaceCheckTest::TEST_FILE = ""src/test/files/checks/AbstractClassNoFieldShouldBeInterfaceCheck.java"";",0
"```cpp
#include <string>
#include <optional>
#include <atomic>
#include <cstdint>
#include <functional>

// Assumes UUIDConverter::getUUID exists and returns something with toString()
std::optional<std::string> getKey(const void* input) {
    if (input == nullptr) {
        return std::nullopt;
    }
    return UUIDConverter::getUUID(input).toString();
}

long getGroupCreatedDate(const std::string& groupKey) {
    std::atomic<long> date{0};
    this->jdbcTemplate.query(
        getQuery(GET_GROUP_CREATED_DATE),
        std::vector<std::string>{groupKey, region},
        [&](ResultSet& rs) {
            date = rs.getTimestamp(""CREATED_DATE"").getTime();
        }
    );
    long returnedDate = date.load();
    return returnedDate;
}
```","```cpp
#include <string>
#include <atomic>
#include <optional>

long getGroupCreatedDate(const std::string& groupKey) {
    std::atomic<std::optional<long>> date{std::nullopt};
    this->jdbcTemplate.query(
        getQuery(GET_GROUP_CREATED_DATE),
        { groupKey, region },
        [&date](const ResultSet& rs) {
            date.store(rs.getTimestamp(""CREATED_DATE"").getTime());
        }
    );
    auto returnedDate = date.load();
    if (!returnedDate.has_value()) {
        return 0;
    } else {
        return returnedDate.value();
    }
}
```",1
".value_or(this->dataset.table.getDbName());
this->existingEntityPolicy = ExistingEntityPolicyFromString(
    toUpper(this->dataset.getProperties().getProperty(EXISTING_ENTITY_POLICY_KEY, DEFAULT_EXISTING_ENTITY_POLICY))
);
this->managedDataPolicy = ManagedDataPolicyFromString(
    toUpper(this->dataset.getProperties().getProperty(MANAGED_DATA_POLICY_KEY, DEFAULT_MANAGED_DATA_POLICY))
);

this->deleteMethod = this->dataset.getProperties().containsKey(DELETE_FILES_ON_DEREGISTER)
    ? DeregisterFileDeleteMethod","this->dbName = this->dataset.table.getDbName().value_or(this->dataset.table.getDbName());
this->existingEntityPolicy = ExistingEntityPolicy::fromString(
    toUpper(this->dataset.getProperties().getProperty(EXISTING_ENTITY_POLICY_KEY, DEFAULT_EXISTING_ENTITY_POLICY))
);
this->managedDataPolicy = ManagedDataPolicy::fromString(
    toUpper(this->dataset.getProperties().getProperty(MANAGED_DATA_POLICY_KEY, DEFAULT_MANAGED_DATA_POLICY))
);

this->deleteMethod = this->dataset.getProperties().containsKey(DELETE_FILES_ON_DEREGISTER)
    ? DeregisterFileDeleteMethod
    : this->deleteMethod;",0
"std::string serializedOriginalRequesterList = originalFlowConfig.getProperties().get(RequesterService::REQUESTER_LIST);
if (!serializedOriginalRequesterList.empty()) {
    std::vector<ServiceRequester> originalRequesterList = RequesterService::deserialize(serializedOriginalRequesterList);
    this->requesterService.requesterAllowed(originalRequesterList, requesterList);
}
catch (const std::ios_base::failure& e) {
    throw FlowConfigLoggedException(HttpStatus::S_400_BAD_REQUEST, ""Failed to get original requester list"", e);
}","std::string serializedOriginalRequesterList = originalFlowConfig.getProperties().at(RequesterService::REQUESTER_LIST);
if (!serializedOriginalRequesterList.empty()) {
    std::vector<ServiceRequester> originalRequesterList = RequesterService::deserialize(serializedOriginalRequesterList);
    this->requesterService.requesterAllowed(originalRequesterList, requesterList);
}",0
"auto leftIndex = leftRows
    | Map([](const auto& row) { return BeamSetOperatorsTransforms::BeamSqlRow2KvFn()(row); });

auto rightIndex = rightRows
    | Map([](const auto& row) { return BeamSetOperatorsTransforms::BeamSqlRow2KvFn()(row); });

auto middleIndex = middleRows
    | Map([](const auto& row) { return BeamSetOperatorsTransforms::BeamSqlRow2KvFn()(row); });

auto coGbkResultCollection = CoGroupByKey::create()
    .and(middleTag, middleIndex)
    .and(rightTag, rightIndex);

return coGbkResultCollection
    | ParDo(BeamSetOperatorsTransforms::SetOperatorFilteringDoFn(leftTag, middleTag, rightTag, opType, all));","auto coGbkResultCollection =
    CoGroupByKey::CreateBuilder()
        .and(
            leftTag,
            leftRows->Apply(
                ""CreateLeftIndex"",
                MakeMapElements(std::make_shared<BeamSqlRow2KvFn>())))
        .and(
            middleTag,
            middleRows->Apply(
                ""CreateLastIndex"",
                MakeMapElements(std::make_shared<BeamSqlRow2KvFn>())))
        .and(
            rightTag,
            rightRows->Apply(
                ""CreateRightIndex"",
                MakeMapElements(std::make_shared<BeamSqlRow2KvFn>())))
        .Apply();

return coGbkResultCollection->Apply(
    std::make_shared<ParDo>(
        std::make_shared<SetOperatorFilteringDoFn>(
            leftTag, middleTag, rightTag, opType, all)
    )
);",1
"Message* msg = readMessageFromQueue(""sanity"");
assert(msg != nullptr);
msg->acknowledge();","@@ -161,5 +161,6 @@
     // Delivery failed so message should be back on the queue
     Message* msg = readMessageFromQueue(""sanity"");
     assert(msg != nullptr);
+    msg->acknowledge();
 }",1
"name_->setText(job.name);
progress_->setLabel(job.name);
std::string status = JobConstants::stateDescription(job.state);

stop_->onClick([this, &job]() {
    eventBus_->fireEvent(JobExecuteActionEvent(job.id, JobConstants::ACTION_STOP));
});

if (job.completed > 0)
{
    // Job is not running; show its completion status and time
}","```cpp
name_->setText(job.name);
progress_->setLabel(job.name);
std::string status = JobConstants::stateDescription(job.state);
stop_->onClick([this, &eventBus_ = eventBus_, id = job.id] {
    eventBus_.fireEvent(JobExecuteActionEvent(id, JobConstants::ACTION_STOP));
});

if (job.completed > 0)
{
    // Job is not running; show its completion status and time
}
```",1
"int shiftby = high - low + 1;
mCol.getDb().execute(
    ""UPDATE cards SET mod = ?, usn = ?, due = due + ?""
    "" WHERE id NOT IN "" + scids + "" AND due >= ? AND type = "" + std::to_string(Consts::CARD_TYPE_NEW),
    now, mCol.usn(), shiftby, low
);

std::vector<std::array<int64_t, 4>> d;
for (const auto& pair : cid2nid) {
    int64_t cid = pair.first;
    int64_t nid = pair.second;
    d.push_back({ due[nid], now, mCol.usn(), cid });
}
mCol.getDb().executeMany(""UPDATE cards SET due = ?, mod = ?, usn = ? WHERE id = ?"", d);

void randomizeCards(int64_t did) {
    auto cids = mCol.getDb().queryLongList(""select id from cards where type = "" +
        std::to_string(Consts::CARD_TYPE_NEW) + "" and did = ?"", did);
    sortCards(cids, 1, 1, true, false);
}

void orderCards(int64_t did) {
    auto cids = mCol.getDb().queryLongList(""SELECT id FROM cards WHERE type = "" +
        std::to_string(Consts::CARD_TYPE_NEW) + "" AND did = ? ORDER BY nid"", did);
    sortCards(cids, 1, 1, false, false);
}","```cpp
void SchedV2::someFunction() {
    int shiftby = high - low + 1;
    mCol.getDb().execute(
        ""UPDATE cards SET mod = ?, usn = ?, due = due + ?""
        "" WHERE id NOT IN "" + scids + "" AND due >= ? AND type = "" + std::to_string(Consts::CARD_TYPE_NEW),
        now, mCol.usn(), shiftby, low
    );

    std::vector<std::array<int64_t, 4>> d;
    d.reserve(cids.size());
    for (const auto& pair : cid2nid) {
        int64_t cid = pair.first;
        int64_t nid = pair.second;
        d.push_back({due[nid], now, mCol.usn(), cid});
    }
    mCol.getDb().executeMany(""UPDATE cards SET due = ?, mod = ?, usn = ? WHERE id = ?"", d);
}

void SchedV2::randomizeCards(int64_t did) {
    auto cids = mCol.getDb().queryLongList(
        ""select id from cards where type = "" + std::to_string(Consts::CARD_TYPE_NEW) + "" and did = ?"",
        did
    );
    sortCards(cids, 1, 1, true, false);
}

void SchedV2::orderCards(int64_t did) {
    auto cids = mCol.getDb().queryLongList(
        ""SELECT id FROM cards WHERE type = "" + std::to_string(Consts::CARD_TYPE_NEW) + "" AND did = ? ORDER BY nid"",
        did
    );
    sortCards(cids, 1, 1, false, false);
}
```",1
"std::vector<ProgramState> copyConstraint(SymbolicValue from, SymbolicValue to, ProgramState programState) {
    ProgramState newState = programState;
    if (programState.canReach(from) || programState.canReach(to)) {
        newState = programState.addConstraint(this, BooleanConstraint::TRUE);
    }
    return copyConstraintFromTo(from, to, newState);
}

std::vector<ProgramState> copyConstraintFromTo(SymbolicValue from, SymbolicValue to, ProgramState programState) {
    std::vector<ProgramState> states;
    states.push_back(programState);
    auto leftConstraints = programState.getConstraints(from);
    if (leftConstraints) {
        for (const auto& [d, c] : *leftConstraints) {
            std::vector<ProgramState> newStates;
            std::shared_ptr<Constraint> constraint = c->copyOver(kind);
            for (const auto& state : states) {
                if (!constraint) {
                    auto constraints = state.getConstraints(to);","```cpp
std::vector<ProgramState> copyConstraint(SymbolicValue* from, SymbolicValue* to, ProgramState programState) {
    ProgramState newState = programState;
    if (programState.canReach(from) || programState.canReach(to)) {
        newState = programState.addConstraint(this, BooleanConstraint::TRUE);
    }
    return copyConstraintFromTo(from, to, newState);
}

std::vector<ProgramState> copyConstraintFromTo(SymbolicValue* from, SymbolicValue* to, ProgramState programState) {
    std::vector<ProgramState> states{programState};
    auto leftConstraints = programState.getConstraints(from);
    if (leftConstraints != nullptr) {
        for (const auto& [d, c] : *leftConstraints) {
            std::vector<ProgramState> newStates;
            Constraint* constraint = c->copyOver(kind);
            for (const auto& state : states) {
                if (constraint == nullptr) {
                    auto constraints = state.getConstraints(to);
```",0
"static constexpr int DEFAULT_MOVING_AVERAGE_WINDOW = 10;

#include <atomic>

class DefaultMessageHandlerMetrics {
protected:
    std::atomic<long long> activeCount{};
    std::atomic<long long> handleCount{};
    std::atomic<long long> errorCount{};

    class ExponentialMovingAverage {
        // ...
    };

    ExponentialMovingAverage duration;

public:
    DefaultMessageHandlerMetrics()
        : DefaultMessageHandlerMetrics(nullptr) {}
};","#include <atomic>

class ExponentialMovingAverage;

class DefaultMessageHandlerMetrics : public AbstractMessageHandlerMetrics {
protected:
    std::atomic<long long> activeCount{};
    std::atomic<long long> handleCount{};
    std::atomic<long long> errorCount{};
    ExponentialMovingAverage* duration;

public:
    DefaultMessageHandlerMetrics() : DefaultMessageHandlerMetrics(nullptr) {}
};",0
"class YourClassName {
public:
    void setFocus() override {}

private:
    WorkbenchPane* const pane_;
    JobsPaneOperations* const widgets_;
};","class JobsDisplayImpl : public JobsDisplay
{
public:
    JobsDisplayImpl(WorkbenchPane* pane, JobsPaneOperations* widgets)
        : pane_(pane), widgets_(widgets)
    {
    }

    void setFocus() override
    {
    }

private:
    WorkbenchPane* const pane_;
    JobsPaneOperations* const widgets_;
};",1
"#include <stdexcept>
#include <string>
#include <typeinfo>
#include <vector>
#include <memory>

class ChannelResolutionException : public std::runtime_error {
public:
    explicit ChannelResolutionException(const std::string& message)
        : std::runtime_error(message) {}
};

class ChannelResolver {
public:
    virtual ~ChannelResolver() = default;
    // Define virtual resolveChannel method if needed
};

class Assert {
public:
    static void isTrue(bool condition, const std::string& message = ""Assertion failed"") {
        if (!condition) throw std::invalid_argument(message);
    }
};

class ClassUtils {
public:
    template<typename Base, typename Derived>
    static bool isAssignableFrom() {
        return std::is_base_of<Base, Derived>::value;
    }

    template<typename T>
    static std::string getClassName() {
        return typeid(T).name();
    }
};

class CollectionUtils {
public:
    template<typename T>
    static bool isEmpty(const T& collection) {
        return collection.empty();
    }
};","#include <stdexcept>
#include <cassert>
#include <typeinfo>
#include <vector>

class ChannelResolver {};
class ChannelResolutionException : public std::runtime_error {
public:
    using std::runtime_error::runtime_error;
};

class MessageHandlerBase {
protected:
    ChannelResolver* channelResolver;
    
    void assertTrue(bool condition, const char* message) {
        assert(condition && message);
    }
    
    template<typename T>
    bool isInstanceOf(const T* obj, const std::type_info& type) {
        return typeid(*obj) == type;
    }
    
    template<typename T>
    bool isCollectionEmpty(const std::vector<T>& vec) {
        return vec.empty();
    }
};",0
"#include <memory>
#include <stdexcept>","#include <memory>

class MuleMessage;
class MuleSession;
class DefaultObjectSerializer;
class ObjectSerializer;
class SerializationException;
class SessionHandler;
class ClassSpecificObjectSerializer;
class DeserializationPostInitialisable;",0
"}
ctx.addVariable(IS_XA, isXa);
txHandle = ctx.bindConnection(connection);
sourceCallback.handle(Result<TestTransactionalConnection, void>::builder().output(connection).build(), ctx);
} catch (const ConnectionException& e) {
    sourceCallback.onConnectionException(e);
} catch (const std::exception& e) {
    throw std::runtime_error(e.what());
} finally {
    try {
        if (txHandle != nullptr) {
            txHandle->commit();
        }
    } catch (const TransactionException& e) {
        throw std::runtime_error(e.what());
    }
}
});","```cpp
void TransactionalSource::someFunction() {
    try {
        bool isXa = /*...*/;
        ctx.addVariable(IS_XA, isXa);
        auto txHandle = ctx.bindConnection(connection);
        sourceCallback.handle(Result<TestTransactionalConnection, void>::builder().output(connection).build(), ctx);
    } catch (const ConnectionException& e) {
        sourceCallback.onConnectionException(e);
    } catch (const std::exception& e) {
        throw std::runtime_error(e.what());
    } 
    try {
        if (txHandle != nullptr) {
            txHandle->commit();
        }
    } catch (const TransactionException& e) {
        throw std::runtime_error(e.what());
    }
}
```",1
"void initialise() {
    if (!(fileLocation.size() >= PROPERTIES_EXTENSION.size() &&
          fileLocation.compare(fileLocation.size() - PROPERTIES_EXTENSION.size(), PROPERTIES_EXTENSION.size(), PROPERTIES_EXTENSION) == 0) &&
        !(fileLocation.size() >= YAML_EXTENSION.size() &&
          fileLocation.compare(fileLocation.size() - YAML_EXTENSION.size(), YAML_EXTENSION.size(), YAML_EXTENSION) == 0)) {
        throw ConfigurationPropertiesException(
            createStaticMessage(format(""Configuration properties file %s must end with yaml or properties extension"", fileLocation)),
            this
        );
    }

    std::unique_ptr<std::istream> is;

    try {
        is = resourceProvider.getResourceAsStream(fileLocation);
        if (!is || !(*is)) {
            std::ifstream fileStream(fileLocation);
            if (fileStream) {
                is = std::make_unique<std::ifstream>(std::move(fileStream));
            }
        }
    } catch (...) {
        // ignore, will detect if is is null
    }

    if (!is || !(*is)) {
        throw ConfigurationPropertiesException(
            createStaticMessage(format(""Couldn't find configuration properties file %s neither on classpath or in file system"", fileLocation)),
            this
        );
    }

    try {
        if (fileLocation.size() >= PROPERTIES_EXTENSION.size() &&
            fileLocation.compare(fileLocation.size() - PROPERTIES_EXTENSION.size(), PROPERTIES_EXTENSION.size(), PROPERTIES_EXTENSION) == 0
        ) {
            Properties properties;
            properties.load(*is);
            for (const auto& key : properties.keySet()) {
                // Equivalent to key -> { ... }
            }
        }
    } catch (...) {
        // handle exceptions as needed
    }
}","```cpp
void initialise() override {
    if (!(endsWith(fileLocation, PROPERTIES_EXTENSION) || endsWith(fileLocation, YAML_EXTENSION))) {
        throw ConfigurationPropertiesException(
            createStaticMessage(
                format(""Configuration properties file %s must end with yaml or properties extension"", fileLocation)
            ),
            this
        );
    }

    std::unique_ptr<std::istream> is;
    try {
        is = resourceProvider.getResourceAsStream(fileLocation);
        if (!is) {
            std::ifstream* fileStream = new std::ifstream(fileLocation);
            if (fileStream->good()) {
                is.reset(fileStream);
            } else {
                delete fileStream;
            }
        }
    } catch (...) {
        // ignore, will detect if is is null
    }

    if (!is) {
        throw ConfigurationPropertiesException(
            createStaticMessage(
                format(""Couldn't find configuration properties file %s neither on classpath or in file system"", fileLocation)
            ),
            this
        );
    }

    try {
        if (endsWith(fileLocation, PROPERTIES_EXTENSION)) {
            Properties properties;
            properties.load(*is);
            for (const auto& key : properties.keys()) {
                // ...
            }
        }
    } catch (...) {
        // Exception handling as needed
    }
}
```",1
"class AbstractMqttMessageDrivenChannelAdapter : public MessageProducerSupport, public ApplicationEventPublisherAware {
public:
    static constexpr long DEFAULT_COMPLETION_TIMEOUT = 30000L;

protected:
    const std::string url;
};","#include <string>

class ApplicationEventPublisherAware {
public:
    virtual ~ApplicationEventPublisherAware() = default;
};

class MessageProducerSupport {
public:
    virtual ~MessageProducerSupport() = default;
};

class AbstractMqttMessageDrivenChannelAdapter : public MessageProducerSupport, public ApplicationEventPublisherAware {
public:
    static constexpr long DEFAULT_COMPLETION_TIMEOUT = 30000L;

protected:
    const std::string url;

    AbstractMqttMessageDrivenChannelAdapter(const std::string& url_) : url(url_) {}
};",0
"AttachmentConnection::streamSend(respStream, Response::ERROR +
    std::string("" "") + attachError);
}
else if (cmd.rfind(Command::GET_THREAD_GROUP_INFO, 0) == 0) {
    try {
        replyWithProperties(getDiagnosticsProvider().getThreadGroupInfo());
    } catch (const std::exception& e) {
        replyWithProperties(makeExceptionProperties(e));
    }
}
else if (cmd.rfind(Command::GET_SYSTEM_PROPERTIES, 0) == 0) {
    auto internalProperties = VM::getVMLangAccess().internalGetProperties();
    std::string argumentString = join(VM::getVMArgs(), "" "");","```cpp
else if (cmd.rfind(Command::GET_THREAD_GROUP_INFO, 0) == 0) {
    try {
        replyWithProperties(getDiagnosticsProvider().getThreadGroupInfo());
    } catch (const std::exception& e) {
        replyWithProperties(makeExceptionProperties(e));
    }
}
else if (cmd.rfind(Command::GET_SYSTEM_PROPERTIES, 0) == 0) {
    auto internalProperties = com::ibm::oti::vm::VM::getVMLangAccess().internalGetProperties();
    std::string argumentString;
    auto args = com::ibm::oti::vm::VM::getVMArgs();
    for (size_t i = 0; i < args.size(); ++i) {
        if (i != 0) argumentString += "" "";
        argumentString += args[i];
    }
```",0
"#include <gtest/gtest.h>
#include ""FilebasedSchemaProvider.h""

class TestDFSHoodieTestSuiteWriterAdapter : public UtilitiesTestBase {
protected:
    FilebasedSchemaProvider* schemaProvider;
};","#include <gtest/gtest.h>

class TestDFSHoodieTestSuiteWriterAdapter : public UtilitiesTestBase {
protected:
    FilebasedSchemaProvider* schemaProvider;
};",1
"#include <netinet/in.h>
#include <memory>

class Context {};
class Scope {};
class TypeInstrumentation {};
class TypeTransformer {};
class Bootstrap {};
class ChannelPromise {};
class AddressResolverGroup {};
class DefaultAddressResolverGroup : public AddressResolverGroup {};
class NettyConnectionRequest {};
class ConnectionCompleteListener {};
class InstrumentedAddressResolverGroup : public AddressResolverGroup {};

using SocketAddress = sockaddr;","#include <netinet/in.h>
#include <memory>

using SocketAddress = sockaddr;

class Context {};
class Scope {};
class TypeInstrumentation {};
class TypeTransformer {};

namespace io {
namespace opentelemetry {
namespace javaagent {
namespace instrumentation {
namespace netty {
namespace v4_1 {
namespace client {
class NettyClientSingletons {
public:
    static void connectionInstrumenter();
};
} // client

class NettyConnectionRequest {};

class ConnectionCompleteListener {};

class InstrumentedAddressResolverGroup {};

} // v4_1
} // netty
} // instrumentation
} // javaagent
} // opentelemetry
} // io

class Bootstrap {};

class ChannelPromise {};

class AddressResolverGroup {};

class DefaultAddressResolverGroup : public AddressResolverGroup {};",0
"#include <HoodieIndex.h>
#include <SchemaProvider.h>
#include <Source.h>
#include <ChainedTransformer.h>
#include <Transformer.h>

#include <avro/Schema.hh>","#include <org/apache/hudi/exception/HoodieIOException.h>
#include <org/apache/hudi/index/HoodieIndex.h>
#include <org/apache/hudi/utilities/schema/SchemaProvider.h>
#include <org/apache/hudi/utilities/sources/Source.h>
#include <org/apache/hudi/utilities/transform/ChainedTransformer.h>
#include <org/apache/hudi/utilities/transform/Transformer.h>

#include <org/apache/avro/Schema.h>",0
"#include <vector>
#include <memory>
#include <cassert>

using namespace std;

template<typename T>
vector<T> singletonList(const T& value) {
    return vector<T>{value};
}

#define assertEquals(expected, actual) assert((expected) == (actual))
#define assertNotNull(ptr) assert((ptr) != nullptr)
#define assertTrue(condition) assert(condition)

template <typename T>
shared_ptr<T> mock() {
    return make_shared<T>();
}

// Placeholder class definitions for types used in imports
class Processor {};
class AbstractExceptionListener {};
class OnErrorPropagateHandler {};","#include <cassert>
#include <memory>
#include <vector>

using std::vector;
using std::unique_ptr;
using std::make_unique;

#define ASSERT_EQ assert
#define ASSERT_NOT_NULL(ptr) assert((ptr) != nullptr)
#define ASSERT_TRUE(cond) assert(cond)

template <typename T>
std::vector<T> singletonList(const T& value) {
    return std::vector<T>{value};
}

// Mocking is often implemented via frameworks like GoogleMock.
// Here we provide a placeholder for a mock function.
template <typename T>
std::shared_ptr<T> mock() {
    return std::make_shared<T>();
}

// Forward declarations for classes
class Processor;
class AbstractExceptionListener;
class OnErrorPropagateHandler;",0
"assertStackElements(
    stackToAssert,
    isFlowStackElement(""subFlow"", ""subFlow/processors/0""),
    isFlowStackElement(""subFlowDynamicWithScatterGatherChain"",
                       ""subFlowDynamicWithScatterGatherChain/processors/0/route/1/processors/0/processors/0"")
);","assertStackElements(
    stackToAssert,
    isFlowStackElement(""subFlow"", ""subFlow/processors/0""),
    isFlowStackElement(""subFlowDynamicWithScatterGatherChain"", ""subFlowDynamicWithScatterGatherChain/processors/0/route/1/processors/0/processors/0"")
);",0
"if (conversionService == nullptr) {
    conversionService = std::make_shared<GenericConversionService>();
}
if (dynamic_cast<ConfigurableConversionService*>(conversionService.get()) == nullptr) {
    logger.warn(""ConversionService is not an instance of ConfigurableConversionService therefore""
                ""ClassToStringConverter and ObjectToStringConverter will not be registered"");
} else {
    auto gConversionService = static_cast<ConfigurableConversionService*>(conversionService.get());
    gConversionService->addConverter(std::make_shared<ClassToStringConverter>());
    gConversionService->addConverter(std::make_shared<ObjectToStringConverter>());
    this->evaluationContext.setTypeConverter(std::make_shared<StandardTypeConverter>(gConversionService));
}

class ClassToStringConverter : public Converter<std::type_index, std::string> {
    // ...
};","if (conversionService == nullptr) {
    conversionService = std::make_shared<GenericConversionService>();
}
auto configurableService = std::dynamic_pointer_cast<ConfigurableConversionService>(conversionService);
if (!configurableService) {
    logger.warn(""ConversionService is not an instance of ConfigurableConversionService therefore""
                ""ClassToStringConverter and ObjectToStringConverter will not be registered"");
} else {
    configurableService->addConverter(std::make_shared<ClassToStringConverter>());
    configurableService->addConverter(std::make_shared<ObjectToStringConverter>());
    this->evaluationContext.setTypeConverter(std::make_shared<StandardTypeConverter>(configurableService));
}",1
"```cpp
#include <vector>
#include <string>

class Context {
public:
    std::string getString(int id) const;
};

class DialogFragment {};

class Item {
public:
    virtual std::string getTitle() const = 0;
    virtual std::vector<Item*> getChildren() const = 0;
};

class RecursivePictureMenu {
public:
    static DialogFragment* createInstance(const std::vector<Item*>& children, const std::string& title);
};

class AnkiActivity : public Context {
public:
    void showDialogFragment(DialogFragment* fragment);
};

namespace UsageAnalytics {
    enum class Category { LINK_CLICKED };
    void sendAnalyticsEvent(Category category, const std::string& id);
}

class MyItem : public Item {
protected:
    std::vector<Item*> mChildren;
    int mAnalyticsStringId;

public:
    virtual void onClicked(AnkiActivity* activity) {
        std::vector<Item*> children = this->getChildren();
        DialogFragment* nextFragment = RecursivePictureMenu::createInstance(children, getTitle());
        activity->showDialogFragment(nextFragment);
    }

    virtual std::string getAnalyticsId(const Context* context) const {
        return context->getString(mAnalyticsStringId);
    }

    virtual void execute(AnkiActivity* activity) {
        onClicked(activity);
        UsageAnalytics::sendAnalyticsEvent(UsageAnalytics::Category::LINK_CLICKED, getAnalyticsId(activity));
    }

    virtual void remove(Item* toRemove) {
        auto it = std::remove(mChildren.begin(), mChildren.end(), toRemove);
        mChildren.erase(it, mChildren.end());
    }
};
```","```cpp
class RecursivePictureMenu : public DialogFragment {
public:

    void onClicked(AnkiActivity* activity) {
        std::vector<Item> children = this->getChildren();
        DialogFragment* nextFragment = RecursivePictureMenu::createInstance(children, getTitle());
        activity->showDialogFragment(nextFragment);
    }

    std::string getAnalyticsId(Context* context) override {
        return context->getString(mAnalyticsStringId);
    }

    void execute(AnkiActivity* activity) override {
        onClicked(activity);
        UsageAnalytics::sendAnalyticsEvent(
            UsageAnalytics::Category::LINK_CLICKED,
            getAnalyticsId(activity)
        );
    }

    void remove(const Item& toRemove) override {
        auto it = std::remove(mChildren.begin(), mChildren.end(), toRemove);
        mChildren.erase(it, mChildren.end());
    }

private:
    std::vector<Item> mChildren;
    int mAnalyticsStringId;
};
```",1
"void exception() {
    MuleEvent event = getTestEvent("""");
    std::runtime_error rte("""");
    event.setError(builder(rte).build());
    event.setMessage(MuleMessage::builder(event.getMessage()).build());
    ASSERT_EQ(rte, evaluate(""exception"", event));
}

void assignException() {
    MuleEvent event = getTestEvent("""");
    event.setMessage(MuleMessage::builder(event.getMessage()).build());
    event.setError(builder(std::runtime_error("""")).build());
    assertImmutableVariable(""exception='other'"", event);
}","```cpp
void exception() {
    MuleEvent event = getTestEvent("""");
    std::runtime_error rte("""");
    event.setError(builder(rte).build());
    event.setMessage(MuleMessage::builder(event.getMessage()).build());
    assertEquals(rte, evaluate(""exception"", event));
}

void assignException() {
    MuleEvent event = getTestEvent("""");
    event.setMessage(MuleMessage::builder(event.getMessage()).build());
    event.setError(builder(std::runtime_error("""")).build());
    assertImmutableVariable(""exception='other'"", event);
}
```",1
"static const long DEFAULT_SEND_TIMEOUT = 1000L;

std::atomic<MessageGroupStore*> messageStore;

const MessageGroupProcessor* const outputProcessor;","static constexpr long DEFAULT_SEND_TIMEOUT = 1000L;

protected:
    std::atomic<MessageGroupStore*> messageStore;

private:
    const MessageGroupProcessor outputProcessor;",0
"static constexpr std::string_view EMPTY[] = {};

static constexpr EE DEFAULT_MODULE_EE = EE::JavaSE_11_0;
static constexpr std::string_view INTERNAL_MODULE_DIRECTIVE = ""-internal-module:"";
static constexpr std::string_view META_INF = ""META-INF"";
static constexpr std::string_view OSGI_INF = ""OSGI-INF"";
static constexpr std::string_view OSGI_OPT = ""OSGI-OPT"";
static constexpr std::string_view WEB_INF = ""WEB-INF"";

void verify(Analyzer& analyzer) {","static constexpr const char* EMPTY[] = {};
static constexpr EE DEFAULT_MODULE_EE = EE::JavaSE_11_0;
static constexpr const char* INTERNAL_MODULE_DIRECTIVE = ""-internal-module:"";
static constexpr const char* META_INF = ""META-INF"";
static constexpr const char* OSGI_INF = ""OSGI-INF"";
static constexpr const char* OSGI_OPT = ""OSGI-OPT"";
static constexpr const char* WEB_INF = ""WEB-INF"";",0
"auto metadata = CopyableDatasetMetadata::deserialize(
    datasetWorkUnitStates.begin()->getProp(CopySource::SERIALIZED_COPYABLE_DATASET));

Path datasetWriterOutputPath(this->writerOutputDir, datasetAndPartition.identifier());

log.info(fmt::format(""Publishing fileSet from {} to {}"", datasetWriterOutputPath, metadata.getDatasetTargetRoot()));

HadoopUtils::renameRecursively(fs, datasetWriterOutputPath, findPathRoot(metadata.getDatasetTargetRoot()));

fs.deletePath(datasetWriterOutputPath, true);","auto metadata = CopyableDatasetMetadata::deserialize(
    datasetWorkUnitStates.begin()->getProp(CopySource::SERIALIZED_COPYABLE_DATASET));
auto datasetWriterOutputPath = Path(this->writerOutputDir, datasetAndPartition.identifier());

log.info(fmt::format(""Publishing fileSet from {} to {}"", datasetWriterOutputPath.toString(), metadata.getDatasetTargetRoot().toString()));

HadoopUtils::renameRecursively(fs, datasetWriterOutputPath, findPathRoot(metadata.getDatasetTargetRoot()));

fs.deletePath(datasetWriterOutputPath, true);",1
"props[KeyGeneratorOptions::RECORDKEY_FIELD_OPT_KEY] = ""_row_key"";
props[KeyGeneratorOptions::PARTITIONPATH_FIELD_OPT_KEY] = ""current_date"";
auto env = StreamExecutionEnvironment::getExecutionEnvironment();
env.setParallelism(1);

SimpleTestSinkFunction::valuesList.clear();
env.fromCollection(recordStr);","std::map<std::string, std::string> props;
props[KeyGeneratorOptions::RECORDKEY_FIELD_OPT_KEY] = ""_row_key"";
props[KeyGeneratorOptions::PARTITIONPATH_FIELD_OPT_KEY] = ""current_date"";

auto env = StreamExecutionEnvironment::getExecutionEnvironment();
env.setParallelism(1);

SimpleTestSinkFunction::valuesList.clear();
env.fromCollection(recordStr);",1
"#include <string>
#include <unordered_map>
#include <vector>
#include <memory>
#include <optional>
#include <algorithm>

template<typename T>
class ManagedMap : public std::unordered_map<typename T::first_type, typename T::second_type> {};

template<typename T>
class ManagedList : public std::vector<T> {};

class ComponentAst {
public:
    const std::string& getIdentifier() const;
    std::vector<std::shared_ptr<ComponentAst>> directChildren() const;
    bool operator==(const ComponentAst& other) const;
};

class SpringComponentModel {};

class CreateComponentBeanDefinitionRequest {
public:
    std::shared_ptr<ComponentAst> getComponent() const;
    std::vector<std::shared_ptr<ComponentAst>> getComponentHierarchy() const;
};

template<typename T>
class BeanDefinitionCreator {
public:
    virtual bool handleRequest(
        std::unordered_map<std::shared_ptr<ComponentAst>, SpringComponentModel>& springComponentModels,
        const T& createBeanDefinitionRequest) = 0;
};

static const std::string MULE_PROPERTIES_IDENTIFIER = ""mule-properties"";
static const std::string MULE_PROPERTY_IDENTIFIER = ""mule-property"";

class PropertiesMapBeanDefinitionCreator : public BeanDefinitionCreator<CreateComponentBeanDefinitionRequest> {
public:
    bool handleRequest(
        std::unordered_map<std::shared_ptr<ComponentAst>, SpringComponentModel>& springComponentModels,
        const CreateComponentBeanDefinitionRequest& createBeanDefinitionRequest) override
    {
        std::shared_ptr<ComponentAst> component = createBeanDefinitionRequest.getComponent();
        if (component &&
            (component->getIdentifier() == MULE_PROPERTIES_IDENTIFIER ||
             component->getIdentifier() == MULE_PROPERTY_IDENTIFIER)) {
            ManagedMap<std::pair<std::string, std::string>> managedMap;
            if (component->getIdentifier() == MULE_PROPERTIES_IDENTIFIER) {
                managedMap = createManagedMapFromEntries(component);
            } else {
                managedMap = ManagedMap<std::pair<std::string, std::string>>();
                const auto& hierarchy = createBeanDefinitionRequest.getComponentHierarchy();
                std::shared_ptr<ComponentAst> parentComponentModel =
                    hierarchy.empty() ? nullptr : hierarchy.back();
                if (parentComponentModel) {
                    auto children = parentComponentModel->directChildren();
                    std::vector<std::shared_ptr<ComponentAst>> filteredProps;
                    std::copy_if(
                        children.begin(),
                        children.end(),
                        std::back_inserter(filteredProps),
                        [](const std::shared_ptr","#include <map>
#include <vector>
#include <memory>
#include <string>
#include <algorithm>

template<typename T>
class BeanDefinitionCreator {
public:
    virtual bool handleRequest(
        std::map<std::shared_ptr<ComponentAst>, std::shared_ptr<SpringComponentModel>>& springComponentModels,
        T& createBeanDefinitionRequest) = 0;
};

class PropertiesMapBeanDefinitionCreator : public BeanDefinitionCreator<CreateComponentBeanDefinitionRequest> {
public:
    bool handleRequest(
        std::map<std::shared_ptr<ComponentAst>, std::shared_ptr<SpringComponentModel>>& springComponentModels,
        CreateComponentBeanDefinitionRequest& createBeanDefinitionRequest) override
    {
        std::shared_ptr<ComponentAst> component = createBeanDefinitionRequest.getComponent();
        if (component &&
            (component->getIdentifier() == MULE_PROPERTIES_IDENTIFIER ||
             component->getIdentifier() == MULE_PROPERTY_IDENTIFIER)) {

            std::map<std::string, std::string> managedMap;

            if (component->getIdentifier() == MULE_PROPERTIES_IDENTIFIER) {
                managedMap = createManagedMapFromEntries(component);
            } else {
                managedMap = std::map<std::string, std::string>();
                const std::vector<std::shared_ptr<ComponentAst>>& hierarchy = createBeanDefinitionRequest.getComponentHierarchy();
                std::shared_ptr<ComponentAst> parentComponentModel = hierarchy.empty() ? nullptr : hierarchy.back();

                if (parentComponentModel) {
                    auto children = parentComponentModel->directChildren();
                    for (const auto& childComponentModel : children) {
                        if (childComponentModel->getIdentifier() == MULE_PROPERTY_IDENTIFIER) {
                            // further logic here
                        }
                    }
                }
            }
            // further logic, e.g., using managedMap, would go here
            return true;
        }
        return false;
    }
};",1
"double calculateDistance(double lat1, double lon1, double lat2, double lon2, double el1, double el2) {
    static const double R = 6371e3;
    double phi1 = lat1 * M_PI / 180.0;
    double phi2 = lat2 * M_PI / 180.0;
    double dPhi = (lat2 - lat1) * M_PI / 180.0;
    double dLambda = (lon2 - lon1) * M_PI / 180.0;

    double a = sin(dPhi / 2) * sin(dPhi / 2) +
               cos(phi1) * cos(phi2) *
               sin(dLambda / 2) * sin(dLambda / 2);
    double c = 2 * atan2(sqrt(a), sqrt(1 - a));
    double horizontalDist = R * c;
    double heightDiff = el2 - el1;
    return sqrt(horizontalDist * horizontalDist + heightDiff * heightDiff);
}","@@ -522,6 +522,7 @@
    /**
     *
     * lat1, lon1 Start point lat2, lon2 End point el1 Start altitude in meters
     * el2 End altitude in meters
     *
     * @returns Distance in Meters
     */
    double computeDistance(double lat1, double lon1, double lat2, double lon2, double el1, double el2) override;",0
"std::vector<std::string> segments;
std::string token;
std::istringstream tokenStream(serviceName);
while (std::getline(tokenStream, SERVICE_NAME_SEPARATOR, token)) {
    segments.push_back(token);
}
int length = segments.size();
if (length != 4) {
    return false;
}

std::string category = segments[CATEGORY_INDEX];
if (std::find(categories.begin(), categories.end(), category) == categories.end()) {
    return false;
}

std::string serviceInterface = segments[SERVICE_INTERFACE_INDEX];
if (targetServiceInterface != WILDCARD && targetServiceInterface != serviceInterface) {
    return false;
}

std::string version = segments[SERVICE_VERSION_INDEX];
if (targetVersion != WILDCARD && targetVersion != version) {
    return false;
}

std::string group = segments[SERVICE_GROUP_INDEX];
return group.empty() || targetGroup == WILDCARD || targetGroup == group;","std::vector<std::string> segments;
std::stringstream ss(serviceName);
std::string item;
while (std::getline(ss, item, SERVICE_NAME_SEPARATOR)) {
    segments.push_back(item);
}
int length = static_cast<int>(segments.size());
if (length != 4) {
    return false;
}

const std::string& category = segments[CATEGORY_INDEX];
if (std::find(categories.begin(), categories.end(), category) == categories.end()) {
    return false;
}

const std::string& serviceInterface = segments[SERVICE_INTERFACE_INDEX];
if (targetServiceInterface != WILDCARD && targetServiceInterface != serviceInterface) {
    return false;
}

const std::string& version = segments[SERVICE_VERSION_INDEX];
if (targetVersion != WILDCARD && targetVersion != version) {
    return false;
}

const std::string& group = segments[SERVICE_GROUP_INDEX];
return group.empty() || targetGroup == WILDCARD || targetGroup == group;",1
"InsertBranch(Js::OpCode::BrNeq_A, labelHelper, instr);

IR::RegOpnd* cachedDataOpnd = IR::RegOpnd::New(TyMachPtr, m_func);
InsertMove(cachedDataOpnd,
    GetForInEnumeratorFieldOpnd(forInEnumeratorOpnd, Js::ForInObjectEnumerator::GetOffsetOfEnumeratorCachedData(), TyMachPtr), instr);

InsertCompareBranch(cachedDataOpnd, IR::AddrOpnd::NewNull(m_func), Js::OpCode::BrEq_A, labelHelper, instr);

IR::RegOpnd* enumeratedCountOpnd = IR::RegOpnd::New(TyUint32, m_func);
InsertMove(enumeratedCountOpnd,
    GetForInEnumeratorFieldOpnd(forInEnumeratorOpnd, Js::ForInObjectEnumerator::GetOffsetOfEnumeratorEnumeratedCount(), TyUint32), instr);","IR::RegOpnd* cachedDataOpnd = IR::RegOpnd::New(TyMachPtr, m_func);
InsertMove(
    cachedDataOpnd,
    GetForInEnumeratorFieldOpnd(forInEnumeratorOpnd, Js::ForInObjectEnumerator::GetOffsetOfEnumeratorCachedData(), TyMachPtr),
    instr
);

InsertCompareBranch(
    cachedDataOpnd,
    IR::AddrOpnd::NewNull(m_func),
    Js::OpCode::BrEq_A,
    labelHelper,
    instr
);

IR::RegOpnd* enumeratedCountOpnd = IR::RegOpnd::New(TyUint32, m_func);
InsertMove(
    enumeratedCountOpnd,
    GetForInEnumeratorFieldOpnd(forInEnumeratorOpnd, Js::ForInObjectEnumerator::GetOffsetOfEnumeratorEnumeratedCount(), TyUint32),
    instr
);",1
"void broadcast(
    const std::vector<std::shared_ptr<WebSocket>>& sockets,
    const std::string& content,
    const std::function<void(const std::shared_ptr<WebSocket>&, const std::string&)>& errorCallback)
{
    std::vector<std::shared_ptr<WebSocket>> activeSockets;
    for (const auto& socket : sockets) {
        if (!socket->isClosed() && socket->isConnected()) {
            activeSockets.push_back(socket);
        }
    }

    for (const auto& socket : activeSockets) {
        try {
            socket->send(content);
        } catch (const std::exception& e) {
            errorCallback(socket, e.what());
        }
    }
}","```cpp
class WebSocket {
    // WebSocket implementation
};

class WebSocketBroadcaster {
public:
    using ErrorCallback = std::function<void(WebSocket&, const std::exception&)>;

    virtual ~WebSocketBroadcaster() = default;

    virtual void broadcast(
        const std::vector<WebSocket*>& sockets,
        const std::string& content,
        const ErrorCallback& errorCallback
    ) = 0;
};
```",0
"std::unordered_set<std::string> jobNames;
jobNames.insert(
    join(flowGroup, flowName, expectedJobNames[i],
         sourceNodes[i] + "":"" + destinationNodes[i] + "":"" + edgeNames[i])
);
if (i < 8) {
    jobNames.insert(
        join(flowGroup, flowName, expectedJobNames[i + 1],
             sourceNodes[i + 1] + "":"" + destinationNodes[i + 1] + "":"" + edgeNames[i + 1])
    );
}

for (const auto& dagNode : currentHopNodes) {","```cpp
std::set<std::string> jobNames;
jobNames.insert(
    flowGroup + std::string(1, JobExecutionPlan::Factory::JOB_NAME_COMPONENT_SEPARATION_CHAR) +
    flowName + std::string(1, JobExecutionPlan::Factory::JOB_NAME_COMPONENT_SEPARATION_CHAR) +
    expectedJobNames[i] + std::string(1, JobExecutionPlan::Factory::JOB_NAME_COMPONENT_SEPARATION_CHAR) +
    (sourceNodes[i] + "":"" + destinationNodes[i] + "":"" + edgeNames[i])
);
if (i < 8) {
    jobNames.insert(
        flowGroup + std::string(1, JobExecutionPlan::Factory::JOB_NAME_COMPONENT_SEPARATION_CHAR) +
        flowName + std::string(1, JobExecutionPlan::Factory::JOB_NAME_COMPONENT_SEPARATION_CHAR) +
        expectedJobNames[i + 1] + std::string(1, JobExecutionPlan::Factory::JOB_NAME_COMPONENT_SEPARATION_CHAR) +
        (sourceNodes[i + 1] + "":"" + destinationNodes[i + 1] + "":"" + edgeNames[i + 1])
    );
}

for (const auto& dagNode : currentHopNodes) {
```",0
"constructor(std::formatter).parameters(std::ostream&),
constructor(std::istringstream).parameters(const std::filesystem::path&),
constructor(std::istringstream).parameters(const std::ifstream&),
constructor(std::istringstream).parameters(std::istream&);

matchers.insert(matchers.end(), COMMONS_IO.begin(), COMMONS_IO.end());
matchers.insert(matchers.end(), COMMONS_IO_WITH_CHARSET.begin(), COMMONS_IO_WITH_CHARSET.end());
matchers.insert(matchers.end(), FILEUTILS_WRITE_WITH_CHARSET.begin(), FILEUTILS_WRITE_WITH_CHARSET.end());

return matchers; 
}

static MethodMatcher method(const std::string& type, const std::string& methodName) {","return MethodMatchersBuilder()
    .add(constructor(JAVA_UTIL_FORMATTER).parameters(JAVA_IO_OUTPUTSTREAM))
    .add(constructor(JAVA_UTIL_SCANNER).parameters(JAVA_IO_FILE))
    .add(constructor(JAVA_UTIL_SCANNER).parameters(JAVA_NIO_FILE_PATH))
    .add(constructor(JAVA_UTIL_SCANNER).parameters(JAVA_IO_INPUTSTREAM))
    .addAll(COMMONS_IO)
    .addAll(COMMONS_IO_WITH_CHARSET)
    .addAll(FILEUTILS_WRITE_WITH_CHARSET)
    .build();",0
"auto finalOutputPath = Path(publisherOutputDir, status.getPath().getName());

LOG.info(fmt::format(""Moving {} to {}"", status.getPath(), finalOutputPath));
parallelRunner.movePath(status.getPath(), publisherFileSystemByBranches[branchId],
    finalOutputPath, std::nullopt);","std::string finalOutputPath = (branchId == 0)
    ? publisherOutputDir / status.getPath().getName()
    : publisherOutputDir / status.getPath().getName();

LOG.info(fmt::format(""Moving {} to {}"", status.getPath(), finalOutputPath));
parallelRunner.movePath(
    status.getPath(),
    this->publisherFileSystemByBranches[branchId],
    finalOutputPath,
    std::nullopt
);",0
"context.setJobStatus(typeid(*this).name(), ""Collect compaction write status and commit compaction"");
std::vector<HoodieWriteStat> writeStats;
std::transform(writeStatuses.begin(), writeStatuses.end(), std::back_inserter(writeStats),
    [](const WriteStatus& ws) { return ws.getStat(); });
writeTableMetadata(table, metadata, HoodieInstant(HoodieInstant::State::INFLIGHT, HoodieTimeline::COMPACTION_ACTION, compactionCommitTime), true);
finalizeWrite(table, compactionCommitTime, writeStats);
LOG.info(""Committing Compaction "" + compactionCommitTime + "". Finished with result "" + metadata);","this->context.setJobStatus(typeid(*this).name(), ""Collect compaction write status and commit compaction"");
std::vector<HoodieWriteStat> writeStats = writeStatuses.map([](const WriteStatus& ws) { return ws.getStat(); }).collect();
writeTableMetadata(table, metadata, HoodieInstant(HoodieInstant::State::INFLIGHT, HoodieTimeline::COMPACTION_ACTION, compactionCommitTime), true);
finalizeWrite(table, compactionCommitTime, writeStats);
LOG.info(""Committing Compaction "" + compactionCommitTime + "". Finished with result "" + metadata);",1
"```cpp
#include <string>
#include <memory>

class KafkaOffsetGen;
class TypedProperties;
class JavaSparkContext;
class SparkSession;
class SchemaProvider;
class StringDeserializer;
class HoodieAvroKafkaDeserializer;
class KafkaAvroDeserializer;

class AvroKafkaSource {
private:
    std::unique_ptr<KafkaOffsetGen> offsetGen;
    const std::string useCustomDeserializerProp = ""hoodie.deltastreamer.kafka.custom.avro.deserializer"";

public:
    AvroKafkaSource(TypedProperties& props, JavaSparkContext& sparkContext, SparkSession& sparkSession, SchemaProvider& schemaProvider)
        : offsetGen(nullptr)
    {
        // Assuming Base class constructor is called here if necessary
        bool useCustomDeserializer = props.getBoolean(useCustomDeserializerProp, false);
        props.put(""key.deserializer"", typeid(StringDeserializer).name());
        if (useCustomDeserializer) {
            props.put(""value.deserializer"", typeid(HoodieAvroKafkaDeserializer).name());
        } else {
            props.put(""value.deserializer"", typeid(KafkaAvroDeserializer).name());
        }
        offsetGen = std::make_unique<KafkaOffsetGen>(props);
    }
};
```","#include <string>
#include <memory>
#include ""AvroSource.h""
#include ""KafkaOffsetGen.h""
#include ""TypedProperties.h""
#include ""SchemaProvider.h""
#include ""StringDeserializer.h""
#include ""KafkaAvroDeserializer.h""
#include ""HoodieAvroKafkaDeserializer.h""

class AvroKafkaSource : public AvroSource {
private:
    KafkaOffsetGen offsetGen;
    const std::string useCustomDeserializerProp = ""hoodie.deltastreamer.kafka.custom.avro.deserializer"";
public:
    AvroKafkaSource(TypedProperties& props,
                    std::shared_ptr<JavaSparkContext> sparkContext,
                    std::shared_ptr<SparkSession> sparkSession,
                    std::shared_ptr<SchemaProvider> schemaProvider)
        : AvroSource(props, sparkContext, sparkSession, schemaProvider),
          offsetGen(props)
    {
        bool useCustomDeserializer = props.getBoolean(useCustomDeserializerProp, false);
        props.put(""key.deserializer"", typeid(StringDeserializer).name());
        props.put(""value.deserializer"",
                  useCustomDeserializer
                  ? typeid(HoodieAvroKafkaDeserializer).name()
                  : typeid(KafkaAvroDeserializer).name());
    }
};",1
"MetadataResource putResource(ServiceContext& context, const std::string& metadataUuid, const std::string& filename,
                            std::istream& is, const std::optional<std::chrono::system_clock::time_point>& changeDate,
                            MetadataResourceVisibility visibility, bool approved) {
    return putResource(context, metadataUuid, filename, is, changeDate, visibility, approved, nullptr);
}

private:
MetadataResource putResource(ServiceContext& context, const std::string& metadataUuid, const std::string& filename,
                             std::istream& is, const std::optional<std::chrono::system_clock::time_point>& changeDate,
                             MetadataResourceVisibility visibility, bool approved, 
                             std::map<std::string, std::any>* additionalProperties) {
    int metadataId = canEdit(context, metadataUuid, approved);
    std::string key = getKey(context, metadataUuid, metadataId, visibility, filename);
    // ...
}","```cpp
MetadataResource putResource(const ServiceContext& context, const std::string& metadataUuid, const std::string& filename,
                             std::istream& is, const std::optional<std::chrono::system_clock::time_point>& changeDate,
                             MetadataResourceVisibility visibility, bool approved) {
    return putResource(context, metadataUuid, filename, is, changeDate, visibility, approved, nullptr);
}

MetadataResource putResource(const ServiceContext& context, const std::string& metadataUuid, const std::string& filename,
                             std::istream& is, const std::optional<std::chrono::system_clock::time_point>& changeDate,
                             MetadataResourceVisibility visibility, bool approved, std::map<std::string, std::any>* additionalProperties) {
    int metadataId = canEdit(context, metadataUuid, approved);
    std::string key = getKey(context, metadataUuid, metadataId, visibility, filename);
}
```",0
"protected:
    const std::filesystem::path outputPath;
    FileSystem* fs;
    FsPermission perm;
    const bool deduplicate;

    MRCompactorJobRunner(const State& jobProps, FileSystem* fs)
        : jobProps(jobProps), fs(fs) {}","protected:
  Path outputPath;
  FileSystem fs;
  FsPermission perm;
  bool deduplicate;

  MRCompactorJobRunner(State jobProps, FileSystem fs)
      : jobProps(jobProps), fs(fs) {}",0
"bool IsAnyUpstreamFrozen() {
    bool ret = false;
    std::vector<NodeModel*> nodes;
    return CheckIfAnyUpstreamNodeIsFrozen(this, nodes, ret);
}

private:
bool CheckIfAnyUpstreamNodeIsFrozen(NodeModel* node, std::vector<NodeModel*> nodes, bool& ret) {
    auto& sets = node->InputNodes; // Assuming InputNodes is std::map or similar
    std::set<NodeModel*> inpNodes;
    for (const auto& kv : sets) {
        if (kv.second != nullptr) {
            inpNodes.insert(kv.second->second); // Assuming second is std::pair<..., NodeModel*>
        }
    }

    for (auto inode : inpNodes) {
        if (std::find(nodes.begin(), nodes.end(), inode) != nodes.end()) {
            continue;
        }

        if (inode->isFrozenExplicitly) {
            ret = true;
            break;
        }

        std::vector<NodeModel*> newNodes(nodes);
        newNodes.push_back(inode);
        CheckIfAnyUpstreamNodeIsFrozen(inode, newNodes, ret);
    }
    return ret;
}","```cpp
bool IsAnyUpstreamFrozen() {
    bool ret = false;
    std::vector<NodeModel*> nodes;
    return CheckIfAnyUpstreamNodeIsFrozen(this, nodes, ret);
}

bool CheckIfAnyUpstreamNodeIsFrozen(NodeModel* node, std::vector<NodeModel*> nodes, bool& ret) {
    auto& sets = node->InputNodes.Values;
    std::set<NodeModel*> inpNodes;
    for (const auto& x : sets) {
        if (x != nullptr)
            inpNodes.insert(x->second);
    }
    for (auto* inode : inpNodes) {
        if (std::find(nodes.begin(), nodes.end(), inode) != nodes.end()) {
            continue;
        }

        if (inode->isFrozenExplicitly) {
            ret = true;
            break;
        }

        std::vector<NodeModel*> newNodes(nodes);
        newNodes.push_back(inode);
        CheckIfAnyUpstreamNodeIsFrozen(inode, newNodes, ret);
    }
    return ret;
}
```",1
"private:
FixedFrequencySchedulerFactory* schedulerFactory() {
    class CustomFactory : public FixedFrequencySchedulerFactory {
    public:
        Scheduler* doCreate(const std::string& name, std::function<void()> job) override {
            return spy(FixedFrequencySchedulerFactory::doCreate(name, job));
        }
    };
    auto* factory = new CustomFactory();
    factory->setFrequency(1000);
    factory->setMuleContext(muleContext);
    return factory;
}","FixedFrequencySchedulerFactory* schedulerFactory()
{
    struct SpySchedulerFactory : public FixedFrequencySchedulerFactory
    {
        Scheduler* doCreate(const std::string& name, std::function<void()> job) override
        {
            return spy(FixedFrequencySchedulerFactory::doCreate(name, job));
        }
    };
    auto* factory = new SpySchedulerFactory();
    factory->setFrequency(1000);
    factory->setMuleContext(muleContext);
    return factory;
}",0
"Exception isResolvable(const Config& userConfig, const DatasetDescriptor& inputDescriptor, const DatasetDescriptor& outputDescriptor) {
    Config inputDescriptorConfig = inputDescriptor.getRawConfig().atPath(DatasetDescriptorConfigKeys::FLOW_EDGE_INPUT_DATASET_DESCRIPTOR_PREFIX);
    Config outputDescriptorConfig = outputDescriptor.getRawConfig().atPath(DatasetDescriptorConfigKeys::FLOW_EDGE_OUTPUT_DATASET_DESCRIPTOR_PREFIX);
    Config mergedUserConfig = userConfig.withFallback(inputDescriptorConfig).withFallback(outputDescriptorConfig);
    // ...
}","virtual std::exception_ptr isResolvable(const Config& userConfig, const DatasetDescriptor& inputDescriptor, const DatasetDescriptor& outputDescriptor) override {
    Config inputDescriptorConfig = inputDescriptor.getRawConfig().atPath(DatasetDescriptorConfigKeys::FLOW_EDGE_INPUT_DATASET_DESCRIPTOR_PREFIX);
    Config outputDescriptorConfig = outputDescriptor.getRawConfig().atPath(DatasetDescriptorConfigKeys::FLOW_EDGE_OUTPUT_DATASET_DESCRIPTOR_PREFIX);
    Config mergedUserConfig = userConfig.withFallback(inputDescriptorConfig).withFallback(outputDescriptorConfig);
    // ...
}",1
"#include <set>
#include <memory>

using std::set;
using std::shared_ptr;

namespace mule {
namespace metadata {
namespace internal {
namespace utils {
    // getDefaultValue function should be declared here.
}
}
}
}

namespace mule {
namespace runtime {
namespace dsl {
namespace api {
namespace component {
namespace AttributeDefinition {
namespace Builder {
    // fromChildConfiguration and fromFixedValue functions should be declared here.
}
}
}
namespace TypeDefinition {
    // fromType function should be declared here.
}
}
}
}
}
}

namespace mule {
namespace runtime {
namespace extension {
namespace api {
namespace introspection {
namespace declaration {
namespace type {
    // acceptsReferences and getExpressionSupport functions should be declared here.
}
}
}
}
}
}
}

namespace org {
namespace mule {
namespace metadata {
namespace api {
namespace model {
    class ArrayType;
}
}
}
}
}","#include <set>
#include <utility>
#include ""org/mule/metadata/internal/utils/MetadataTypeUtils.h""
#include ""org/mule/runtime/dsl/api/component/AttributeDefinition.h""
#include ""org/mule/runtime/dsl/api/component/TypeDefinition.h""
#include ""org/mule/runtime/extension/api/introspection/declaration/type/TypeUtils.h""
#include ""org/mule/metadata/api/model/ArrayType.h""

using std::set;
using org::mule::metadata::internal::utils::getDefaultValue;
using org::mule::runtime::dsl::api::component::AttributeDefinition::Builder::fromChildConfiguration;
using org::mule::runtime::dsl::api::component::AttributeDefinition::Builder::fromFixedValue;
using org::mule::runtime::dsl::api::component::TypeDefinition::fromType;
using org::mule::runtime::extension::api::introspection::declaration::type::acceptsReferences;
using org::mule::runtime::extension::api::introspection::declaration::type::getExpressionSupport;",0
"#include <string>
#include <algorithm>
#include <cstddef>
#include <cstdlib>

static const std::string ARTIFACT_ID = ""testAppId"";
static const std::string GROUP_ID = ""com.organization"";
static const std::string SPECIFIC_ARTIFACT_ID = ""test-artifact"";
static const std::string SPECIFIC_ARTIFACT_ID_WITH_SPACES = ""test-artifact-with-spaces"";
static const std::string ARTIFACT_VERSION = ""1.0.0"";
static const std::string SPECIFIC_RESOURCE_FORMAT = ""resource::"" + GROUP_ID + "":"" + SPECIFIC_ARTIFACT_ID + "":%s:%s:%s:%s"";
static const std::string SPECIFIC_RESOURCE_FORMAT_WITH_SPACES = ""resource::"" + GROUP_ID + "":"" + SPECIFIC_ARTIFACT_ID_WITH_SPACES + "":%s:%s:%s:%s"";
static const std::string API_RESOURCE_NAME = ""test-api.raml"";
static const std::string API_RESOURE_NAME_WITH_SPACES = ""raml with spaces.raml"";
static const std::string API_FOLDER_NAME_WITH_SPACES = ""folder with spaces"";

static std::string replace_space_with_percent20(const std::string& input) {
    std::string result = input;
    std::string::size_type pos = 0;
    while ((pos = result.find(' ', pos)) != std::string::npos) {
        result.replace(pos, 1, ""%20"");
        pos += 3;
    }
    return result;
}

static const std::string API_RESOURCE_NAME_WITH_SPACES_ENCODED = replace_space_with_percent20(API_RESOURE_NAME_WITH_SPACES);
static const std::string API_FOLDER_NAME_WITH_SPACES_ENCODED = replace_space_with_percent20(API_FOLDER_NAME_WITH_SPACES);

#include <memory>
#include <string>

class MyClass {
public:
    const std::string APP_LOADED_RESOURCE;
    const std::string PLUGIN_LOADED_RESOURCE;

    MyClass(const std::string& appResource, const std::string& pluginResource)
        : APP_LOADED_RESOURCE(appResource), PLUGIN_LOADED_RESOURCE(pluginResource) {}
};","#include <string>
#include <algorithm>

static const std::string ARTIFACT_ID = ""testAppId"";
static const std::string GROUP_ID = ""com.organization"";
static const std::string SPECIFIC_ARTIFACT_ID = ""test-artifact"";
static const std::string SPECIFIC_ARTIFACT_ID_WITH_SPACES = ""test-artifact-with-spaces"";
static const std::string ARTIFACT_VERSION = ""1.0.0"";
static const std::string SPECIFIC_RESOURCE_FORMAT = ""resource::"" + GROUP_ID + "":"" + SPECIFIC_ARTIFACT_ID + "":%s:%s:%s:%s"";
static const std::string SPECIFIC_RESOURCE_FORMAT_WITH_SPACES = ""resource::"" + GROUP_ID + "":"" + SPECIFIC_ARTIFACT_ID_WITH_SPACES + "":%s:%s:%s:%s"";
static const std::string API_RESOURCE_NAME = ""test-api.raml"";
static const std::string API_RESOURE_NAME_WITH_SPACES = ""raml with spaces.raml"";
static const std::string API_FOLDER_NAME_WITH_SPACES = ""folder with spaces"";

inline std::string encode_spaces(const std::string& str) {
    std::string res = str;
    size_t pos = 0;
    while ((pos = res.find(' ', pos)) != std::string::npos) {
        res.replace(pos, 1, ""%20"");
        pos += 3;
    }
    return res;
}

static const std::string API_RESOURCE_NAME_WITH_SPACES_ENCODED = encode_spaces(API_RESOURE_NAME_WITH_SPACES);
static const std::string API_FOLDER_NAME_WITH_SPACES_ENCODED = encode_spaces(API_FOLDER_NAME_WITH_SPACES);

const std::string APP_LOADED_RESOURCE;
const std::string PLUGIN_LOADED_RESOURCE;",1
"return network;
}

bool isSharedNetworkWithoutSpecifyVlan(const NetworkOffering& offering) override {
    if (&offering == nullptr || offering.getTrafficType() != TrafficType::Guest || offering.getGuestType() != GuestType::Shared) {
        return false;
    }
    if (!offering.isSpecifyVlan()) {
        return true;
    }
    return false;
}

bool isPrivateGatewayWithoutSpecifyVlan(const NetworkOffering& ntwkOff) {
    return ntwkOff.getId() == _networkOfferingDao.findByUniqueName(NetworkOffering::SystemPrivateGatewayNetworkOfferingWithoutVlan).getId();
}","bool isSharedNetworkWithoutSpecifyVlan(const NetworkOffering* offering) override {
    if (offering == nullptr || offering->getTrafficType() != TrafficType::Guest || offering->getGuestType() != GuestType::Shared) {
        return false;
    }
    if (!offering->isSpecifyVlan()) {
        return true;
    }
    return false;
}

bool isPrivateGatewayWithoutSpecifyVlan(const NetworkOffering& ntwkOff) {
    return ntwkOff.getId() == _networkOfferingDao->findByUniqueName(NetworkOffering::SystemPrivateGatewayNetworkOfferingWithoutVlan)->getId();
}",1
"std::string name = clz.getName();
std::size_t index = name.rfind('.');
if (index != std::string::npos) {
    return name.substr(0, index);
}
return """";","static std::string getNonArrayClassPackageName(const std::type_info& typeInfo) {
    std::string name = typeInfo.name();
    std::size_t index = name.rfind('.');
    if (index != std::string::npos) {
        return name.substr(0, index);
    }
    return """";
}",1
"#include <vector>
#include <array>
#include <map>
#include <algorithm>
#include <utility>
#include <memory>

using std::vector;
using std::array;
using std::map;
using std::pair;
using std::unique_ptr;
using std::make_unique;
using std::make_pair;

template<typename T>
using ImmutableList = const std::vector<T>;

template<typename T>
std::vector<T> toList(const std::vector<T>& input) {
    return input;
}

template<typename T>
std::vector<T> toList(const std::vector<T>&& input) {
    return input;
}

template<typename T>
using RayActor = std::shared_ptr<T>;

template<typename T>
using RayObject = std::shared_ptr<T>;

template<typename T>
struct WaitResult {
    std::vector<std::shared_ptr<T>> ready;
    std::vector<std::shared_ptr<T>> unready;
};","#include <vector>
#include <array>
#include <algorithm>
#include <unordered_map>
#include <utility>
#include <memory>",0
"```cpp
static PhongMaterial SelectedMaterial;

static PhongMaterial FrozenMaterial;
static PhongMaterial IsolatedMaterial;
```","static PhongMaterial* SelectedMaterial;

static PhongMaterial* FrozenMaterial;
static PhongMaterial* IsolatedMaterial;",1
"PCollection<KV<long, Event>> auctionsBySellerId =
    events
        .apply(NexmarkQueryUtil::JUST_NEW_AUCTIONS)
        .apply(name + "".InCategory"", Filter::by([](const Auction& auction) {
            return auction.category == 10;
        }))
        .apply(""EventByAuctionSeller"",
               ParDo::of([](const Auction& auction, auto& c) {
                   Event e;
                   e.newAuction = auction;
                   c.output(KV<long, Event>(auction.seller, e));
               }));

PCollection<KV<long, Event>> personsById =
    events
        .apply(NexmarkQueryUtil::JUST_NEW_PERSONS);","```cpp
PCollection<KV<long, Event>> auctionsBySellerId =
    events
        // Only want the new auction events.
        | NexmarkQueryUtil::JUST_NEW_AUCTIONS()

        // We only want auctions in category 10.
        | FilterBy([&](const Auction& auction) { return auction.category == 10; })

        // Key auctions by their seller id and move to union Event type.
        | ParDo(""EventByAuctionSeller"",
            [](const Auction& auction, auto& emitter) {
                Event e;
                e.newAuction = auction;
                emitter(KV<long, Event>(auction.seller, e));
            });

PCollection<KV<long, Event>> personsById =
    events
        // Only want the new people events.
        | NexmarkQueryUtil::JUST_NEW_PERSONS();
```",1
"assert(testTable.baseFileExists(p1, ""00000000000001"", file1P1C0));

auto partitionAndFileId002 = testTable.forReplaceCommit(""00000000000002"").getFileIdsWithBaseFilesInPartitions(p0);
std::string file2P0C1 = partitionAndFileId002[p0];
auto replaceMetadata = generateReplaceCommitMetadata(p0, file1P0C0, file2P0C1);
testTable.addReplaceCommit(""00000000000002"", std::make_optional(replaceMetadata.first), std::nullopt, replaceMetadata.second);

auto hoodieCleanStatsTwo = runCleaner(config);","assertTrue(testTable.baseFileExists(p1, ""00000000000001"", file1P1C0));

std::map<std::string, std::string> partitionAndFileId002 = testTable.forReplaceCommit(""00000000000002"").getFileIdsWithBaseFilesInPartitions(p0);
std::string file2P0C1 = partitionAndFileId002[p0];
auto replaceMetadata = generateReplaceCommitMetadata(p0, file1P0C0, file2P0C1);
testTable.addReplaceCommit(""00000000000002"", std::make_optional(replaceMetadata.first), std::nullopt, replaceMetadata.second);

std::vector<HoodieCleanStat> hoodieCleanStatsTwo = runCleaner(config);",0
"#include <vector>
#include <memory>
using namespace std::chrono;
using namespace std;

using SchedulerConfig = org::mule::runtime::core::api::scheduler::SchedulerConfig;
using RejectionAction = SchedulerConfig::RejectionAction;

constexpr auto OBJECT_SCHEDULER_BASE_CONFIG = org::mule::runtime::core::api::config::MuleProperties::OBJECT_SCHEDULER_BASE_CONFIG;
constexpr auto config = SchedulerConfig::config;
constexpr RejectionAction DEFAULT = SchedulerConfig::RejectionAction::DEFAULT;
constexpr RejectionAction WAIT = SchedulerConfig::RejectionAction::WAIT;
constexpr auto CPU_INTENSIVE = org::mule::service::scheduler::ThreadType::CPU_INTENSIVE;","#include <list>
#include <mutex>
#include <memory>
#include <chrono>
#include <thread>

using namespace std::chrono_literals;",0
"#include <gtest/gtest.h>
#include <filesystem>
#include <vector>
#include <chrono>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <memory>

namespace fs = std::filesystem;

class Path {
public:
    explicit Path(const fs::path& p) : path_(p) {}
    Path(const Path& parent, const std::string& child) : path_(parent.path_ / child) {}
    Path(const std::string& p) : path_(p) {}
    const fs::path& value() const { return path_; }
    operator fs::path() const { return path_; }
    bool operator==(const Path& other) const { return path_ == other.path_; }
private:
    fs::path path_;
};

class LocalFileSystem {
public:
    bool exists(const Path& path) const {
        return fs::exists(path.value());
    }
    void deletePath(const Path& path, bool recursive) {
        if (recursive)
            fs::remove_all(path.value());
        else
            fs::remove(path.value());
    }
    void mkdirs(const Path& path) {
        fs::create_directories(path.value());
    }
    void create(const Path& file) {
        std::ofstream ofs(file.value());
    }
    fs::directory_entry getFileStatus(const Path& path) {
        return fs::directory_entry(path.value());
    }
};

class DateTime {
public:
    DateTime(std::chrono::system_clock::time_point tp) : timePoint_(tp) {}
    DateTime minusDays(int days) const {
        return DateTime(timePoint_ - std::chrono::hours(24 * days));
    }
    std::chrono::system_clock::time_point getTimePoint() const {
        return timePoint_;
    }
private:
    std::chrono::system_clock::time_point timePoint_;
};

class DateTimeFormatter {
public:
    DateTimeFormatter(const std::string& pattern) : pattern_(pattern) {}
    std::string print(const DateTime& dt) const {
        std::time_t t = std::chrono::system_clock::to_time_t(dt.getTimePoint());
        std::tm tm = *std::gmtime(&t);
        char buf[64];
        std::strftime(buf, sizeof(buf), pattern_.c_str(), &tm);
        return std::string(buf);
    }
private:
    std::string pattern_;
};

class Properties {
public:
    void setProperty(const std","#include <gtest/gtest.h>
#include <filesystem>
#include <chrono>
#include <vector>
#include <string>
#include <memory>
#include <queue>
#include <optional>
#include <unordered_map>

using namespace std;
namespace fs = std::filesystem;

// Mock classes and methods (Replace with actual or appropriate test/mocking library)
class FileSystem {
public:
    bool exists(const fs::path &p) {
        return fs::exists(p);
    }
    void delete_(const fs::path &p, bool recursive) {
        if(recursive)
            fs::remove_all(p);
        else
            fs::remove(p);
    }
    void mkdirs(const fs::path &p) {
        fs::create_directories(p);
    }
    void create(const fs::path &p) {
        ofstream ofs(p);
        ofs.close();
    }
    fs::path getFileStatus(const fs::path &p) {
        return p;
    }
};

class Properties {
    unordered_map<string, string> m;
public:
    void setProperty(const string &k, const string &v) { m[k] = v; }
    string getProperty(const string& k) const { 
        auto it = m.find(k); return it != m.end() ? it->second : """";
    }
};

class CopyConfiguration {
public:
    FileSystem* getTargetFs() { return nullptr; }
    fs::path getPublishDir() { return """"; }
    string getPreserve() { return """"; }
    int getCopyContext() { return 0; }
    optional<string> getTargetGroup() { return {}; }
};
unique_ptr<CopyConfiguration> mockCopyConfiguration(FileSystem* fs, const fs::path& destRoot) {
    class MockCopyConfiguration : public CopyConfiguration {
    public:
        FileSystem* localFs;
        fs::path destRoot;
        MockCopyConfiguration(FileSystem* l, const fs::path& d) : localFs(l), destRoot(d) {}
        FileSystem* getTargetFs() override { return localFs; }
        fs::path getPublishDir() override { return localFs->getFileStatus(destRoot); }
        string getPreserve() override { return ""g""; }
        int getCopyContext() override { return 0; }
        optional<string> getTargetGroup() override { return {}; }
    };
    return make_unique<MockCopyConfiguration>(fs, destRoot);
}

// Placeholders for specific dataset copy and filter policies",1
"getDefault(DslResolvingContext::getDefault(extensionModels));

auto rootComponent = ComponentModel::Builder()
    .setIdentifier(ComponentIdentifier::builder()
        .withNamespace(CORE_PREFIX)
        .withName(CORE_PREFIX)
        .build())
    .build();

this->muleComponentModels.push_back(rootComponent);

std::atomic<bool> atLeastOneComponentAdded(false);

for (const auto& e : artifactDeclaration.getGlobalElements())
{
    elementFactory.create(static_cast<const ElementDeclaration&>(e));
}","```cpp
ComponentModel rootComponent = ComponentModel::Builder()
    .setIdentifier(ComponentIdentifier::builder()
        .withNamespace(CORE_PREFIX)
        .withName(CORE_PREFIX)
        .build())
    .build();

this->muleComponentModels.push_back(rootComponent);

std::atomic<bool> atLeastOneComponentAdded(false);

for (const auto& e : artifactDeclaration.getGlobalElements()) {
    elementFactory.create(static_cast<const ElementDeclaration&>(e));
}
```",0
"#include <fstream>
#include <vector>
#include <string>
#include <map>","#include <fstream>
#include <iostream>
#include <ostream>
#include <string>
#include <vector>
#include <map>",0
"```cpp
template<typename T>
void* postProcess(void* bean, const std::string& beanName, std::function<void()> method, T annotation) {
    auto handler = this->createHandler(bean, method, annotation);
    setAdviceChainIfPresent(beanName, annotation, handler);
    if (dynamic_cast<Orderable*>(handler)) {
        auto orderAnnotation = AnnotationUtils::findAnnotation<Order>(method);
        if (orderAnnotation != nullptr) {
```","```cpp
public:
    virtual void* postProcess(void* bean, const std::string& beanName, Method* method, T* annotation) {
        MessageHandler* handler = this->createHandler(bean, method, annotation);
        setAdviceChainIfPresent(beanName, annotation, handler);
        if (auto orderable = dynamic_cast<Orderable*>(handler)) {
            Order* orderAnnotation = AnnotationUtils::findAnnotation<Order>(method);
            if (orderAnnotation != nullptr) {
```",0
"if (!metadata) {
    Log::trace(Geonet::DATA_MANAGER, ""Record identified by "" + uuidOrInternalId + "" not found."");
    throw ResourceNotFoundException(
        ""Record with UUID '"" + uuidOrInternalId + ""' not found in this catalog""
    );
}

Log::trace(Geonet::DATA_MANAGER, ""ApiUtils::getRecord("" + uuidOrInternalId + "") -> "" + to_string(metadata));

return metadata;","```cpp
if (metadata == nullptr) {
    Log::trace(Geonet::DATA_MANAGER, ""Record identified by "" + uuidOrInternalId + "" not found."");
    throw ResourceNotFoundException(
        ""Record with UUID '"" + uuidOrInternalId + ""' not found in this catalog""
    );
}

Log::trace(Geonet::DATA_MANAGER, ""ApiUtils::getRecord("" + uuidOrInternalId + "") -> "" + std::to_string(reinterpret_cast<std::uintptr_t>(metadata)));
return metadata;
```",0
"virtual SyntaxToken openParenToken() = 0;

[[deprecated(""since 4.11. Use resourceList() to get all declared resources."")]]
virtual ListTree<VariableTree> resources() = 0;

virtual ListTree<Tree> resourceList() = 0;

virtual SyntaxToken closeParenToken() = 0;","```cpp
class TryStatementTree : public StatementTree {
public:
    virtual SyntaxToken openParenToken() = 0;

    [[deprecated(""Use resourceList() to get all declared resources."")]]
    virtual ListTree<VariableTree> resources() = 0;

    virtual ListTree<Tree> resourceList() = 0;

    virtual SyntaxToken* closeParenToken() = 0;
};
```",1
"HoodieTableType::MERGE_ON_READ;
FileCreateUtils::createDeltaCommit(basePath.string(), instantTime);

FileInputFormat::setInputPaths(baseJobConf, partitionDir.getPath());

std::string newCommitTime = ""101"";","baseJobConf.setInputPaths(partitionDir.getPath());

std::string newCommitTime = ""101"";",0
"case HoodieTimeline::COMMIT_ACTION:
  LOG.info(""Rolling back commit action. There are higher delta commits. So only rolling back this instant"");
  partitionRollbackRequests.push_back(
    RollbackRequest::createRollbackRequestWithDeleteBaseAndLogFilesAction(partitionPath, instantToRollback)
  );
  break;
case HoodieTimeline::COMPACTION_ACTION:
  // If there is no delta commit present after the current commit (if compaction), no action, else we","switch (action) {
  case HoodieTimeline::COMMIT_ACTION:
    LOG.info(""Rolling back commit action. There are higher delta commits. So only rolling back this instant"");
    partitionRollbackRequests.push_back(
      RollbackRequest::createRollbackRequestWithDeleteBaseAndLogFilesAction(partitionPath, instantToRollback));
    break;
  case HoodieTimeline::COMPACTION_ACTION:
    // If there is no delta commit present after the current commit (if compaction), no action, else we
    // ...
    break;
}",1
"#include ""Configuration.h""
#include ""ConfigurationException.h""
#include ""ConfigurationRequest.h""
#include ""Codec.h""
#include ""Transport.h""
#include ""RawMessage.h""","#include ""plugin/buffers/InputBuffer.h""
#include ""plugin/configuration/Configuration.h""
#include ""plugin/configuration/ConfigurationException.h""
#include ""plugin/configuration/ConfigurationRequest.h""
#include ""plugin/inputs/codecs/Codec.h""
#include ""plugin/inputs/transports/Transport.h""
#include ""plugin/journal/RawMessage.h""",0
"ReturnDelegate* valueReturnDelegate;
protected:
PolicyManager policyManager;","private:
    ReturnDelegate* valueReturnDelegate;
protected:
    PolicyManager* policyManager;",0
"currentBlock->successors.push_back(cfg.blocks[0]);
    }
  }
  BytecodeCFG& cfg() {
    cfg.isStaticMethod = isStaticMethod;
    cfg.isVarArgs = isVarArgs;
    return cfg;
  }
}","```cpp
BytecodeCFG cfg() {
    cfg.isStaticMethod = isStaticMethod;
    cfg.isVarArgs = isVarArgs;
    return cfg;
}
```",0
"```cpp
static GenericRecord convertRecordSchema(const GenericRecord& record, const Schema& newSchema) {
    if (checkReaderWriterCompatibility(newSchema, record.getSchema()).getType() != COMPATIBLE) {
        LOG.debug(""Record schema not compatible with writer schema. Converting record schema to writer schema may fail."");
    }

    auto closer = Closer::create();
}
```","if (checkReaderWriterCompatibility(newSchema, record.schema()).getType() != COMPATIBLE) {
    LOG.debug(""Record schema not compatible with writer schema. Converting record schema to writer schema may fail."");
}

Closer closer = Closer::create();",1
"metaClient = HoodieTableMetaClient::reload(metaClient);
HoodieCopyOnWriteTable newTable(config, jsc);
std::vector<int> ints = {1};
std::vector<WriteStatus> statuses;
for (int x : ints) {
    auto res = newTable.handleUpdate(
        newCommitTime,
        updatedRecord1.getPartitionPath(),
        updatedRecord1.getCurrentLocation().getFileId(),
        updatedRecords.begin()
    );
    auto collected = HoodieClientTestUtils::collectStatuses(res);
    statuses.insert(statuses.end(), collected.begin(), collected.end());
}","metaClient = HoodieTableMetaClient::reload(metaClient);
HoodieCopyOnWriteTable newTable(config, jsc);
std::vector<WriteStatus> statuses;
std::vector<int> elements = {1};
for (int x : elements) {
    auto statusList = newTable.handleUpdate(
        newCommitTime,
        updatedRecord1.getPartitionPath(),
        updatedRecord1.getCurrentLocation().getFileId(),
        updatedRecords.begin(), updatedRecords.end()
    );
    auto collected = HoodieClientTestUtils::collectStatuses(statusList);
    statuses.insert(statuses.end(), collected.begin(), collected.end());
}",1
"private:
    void setUnderlyingTimer(const Instant& target) {
        timerInternals.setTimer(namespace_, timerId_, timerId_, target, target, spec.getTimeDomain());
    }

    Instant getCurrentTime() {","void setUnderlyingTimer(const Instant& target) {
    timerInternals.setTimer(namespace_, timerId, timerId, target, target, spec.getTimeDomain());
}",1
"#include <utility>
#include <vector>
#include <set>
#include <iterator>","#include <vector>
#include <set>
#include <utility>",0
"long sessionExpireInMin,
std::shared_ptr<CloseableHttpClient> httpClient,
std::shared_ptr<SessionManager> sessionManager,
std::shared_ptr<ExecutorService> executorService,
std::chrono::milliseconds requestTimeout)
{
    this->username = username;
    this->password = password;
}","AzkabanClient(const std::string& username,
              const std::string& password,
              long sessionExpireInMin,
              std::shared_ptr<CloseableHttpClient> httpClient,
              std::shared_ptr<SessionManager> sessionManager,
              std::shared_ptr<ExecutorService> executorService,
              std::chrono::duration<double> requestTimeout)
    : username(username),
      password(password),
      sessionExpireInMin(sessionExpireInMin),
      httpClient(std::move(httpClient)),
      sessionManager(std::move(sessionManager)),
      executorService(std::move(executorService)),
      requestTimeout(requestTimeout)
{
}",1
"virtual HoodieWriteMetadata<O> compact(const HoodieEngineContext& context,
                                       const std::string& compactionInstantTime) = 0;

virtual std::optional<HoodieClusteringPlan> scheduleClustering(
    const HoodieEngineContext& context,
    const std::string& instantTime,
    const std::optional<std::map<std::string, std::string>>& extraMetadata) = 0;

virtual HoodieWriteMetadata<O> cluster(const HoodieEngineContext& context,
                                       const std::string& clusteringInstantTime) = 0;","virtual HoodieWriteMetadata<O> compact(HoodieEngineContext& context, const std::string& compactionInstantTime) = 0;

virtual std::optional<HoodieClusteringPlan> scheduleClustering(
    HoodieEngineContext& context,
    const std::string& instantTime,
    std::optional<std::map<std::string, std::string>> extraMetadata) = 0;

virtual HoodieWriteMetadata<O> cluster(
    HoodieEngineContext& context, 
    const std::string& clusteringInstantTime) = 0;",1
"std::string errorMsg1 = ""Must use windowed writes when applying "" + std::string(typeid(WriteFiles).name()) + "" to an unbounded PCollection"";
// The reason for this is https://issues.apache.org/jira/browse/BEAM-1438
// and similar behavior in other runners. Runners can choose to ignore this check and perform
// runner determined sharding for unbounded data by overriding the option
// `withRunnerDeterminedShardingUnboundedInternal`.
if (!getWithRunnerDeterminedShardingUnbounded()) {
    if (getComputeNumShards() == nullptr && getNumShardsProvider() == nullptr) {
        throw std::invalid_argument(
            ""When applying "" + std::string(typeid(WriteFiles).name()) +
            "" to an unbounded PCollection, must specify number of output shards explicitly""
        );
    }
}
this->writeOperation = getSink().createWriteOperation();
this->writeOperation.setWindowedWrites(getWindowedWrites());","if (!isBounded()) {
    throw std::invalid_argument(
        (std::string(""Must use windowed writes when applying "") +
         typeid(*this).name()).c_str());
    // The reason for this is https://issues.apache.org/jira/browse/BEAM-1438
    // and similar behavior in other runners. Runners can choose to ignore this check and perform
    // runner determined sharding for unbounded data by overriding the option
    // `withRunnerDeterminedShardingUnboundedInternal`.
    if (!getWithRunnerDeterminedShardingUnbounded()) {
        if (getComputeNumShards() == nullptr && getNumShardsProvider() == nullptr) {
            throw std::invalid_argument(
                (std::string(""When applying "") +
                 typeid(*this).name() +
                 "" to an unbounded PCollection, must specify number of output shards explicitly"").c_str());
        }
    }
}
this->writeOperation = getSink()->createWriteOperation();
this->writeOperation->setWindowedWrites(getWindowedWrites());",1
"return parentWindow_;
}

void setNeverVisible(bool value)
{
    neverVisible_ = value;
}

private:
    ModuleTabLayoutPanel* tabPanel_;
    std::vector<WorkbenchTab*> tabs_;
    LogicalWindow* const parentWindow_;
    HandlerRegistrations* const releaseOnUnload_ = new HandlerRegistrations();
    bool clearing_ = false;
    bool neverVisible_ = false;
    LayoutPanel* panel_;
    HTML* utilPanel_;
};","class WorkbenchTabPanel
{
public:
    LogicalWindow* getParentWindow()
    {
        return parentWindow_;
    }

    void setNeverVisible(bool value)
    {
        neverVisible_ = value;
    }

private:
    ModuleTabLayoutPanel* tabPanel_;
    std::vector<WorkbenchTab*> tabs_;
    LogicalWindow* const parentWindow_;
    HandlerRegistrations* const releaseOnUnload_ = new HandlerRegistrations();
    bool clearing_ = false;
    bool neverVisible_ = false;
    LayoutPanel* panel_;
    HTML* utilPanel_;
};",0
"[[deprecated]]
virtual CoreEvent handleException(const std::exception& exception, const CoreEvent& event) = 0;

[[deprecated]]
virtual std::shared_ptr<Publisher<CoreEvent>> apply(const std::exception& exception) {
    try {
        if (dynamic_cast<const MessagingException*>(&exception)) {","#include <exception>
#include <memory>
#include <functional>
#include <type_traits>

class CoreEvent {};
class MessagingException : public std::exception {};
template<typename T>
class Publisher {};

struct FlowExceptionHandler : public std::function<std::shared_ptr<Publisher<CoreEvent>>(std::exception_ptr)> {
    [[deprecated]]
    virtual std::shared_ptr<CoreEvent> handleException(const std::exception& exception, std::shared_ptr<CoreEvent> event) = 0;

    [[deprecated]]
    virtual std::shared_ptr<Publisher<CoreEvent>> apply(const std::exception& exception) {
        try {
            if (dynamic_cast<const MessagingException*>(&exception) != nullptr) {
                // Implementation depending on context
            }
        } catch (...) {
            // Implementation depending on context
        }
        return nullptr;
    }
};",1
"#include <filesystem>
#include <vector>
#include <map>
#include <optional>
#include <regex>","#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <optional>
#include <regex>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>",0
"private:
    bool isRequestFullySent;
    std::unique_ptr<CleanupTask> cleanupTask;

    const std::function<void(Closeable&, CloseType)> listener = 
        [](Closeable& c, CloseType t) {
            // method implementation goes here
        };","```cpp
#include <atomic>
#include <memory>

class CleanupTask;

class HttpTransactionContext {
private:
    bool isRequestFullySent;
    std::unique_ptr<CleanupTask> cleanupTask;

    class Listener {
    public:
        // implementation of listener
    };

    Listener listener;
};
```",0
"#include <map>
#include <vector>
#include <string>
#include <stdexcept>

// Forward declarations or appropriate includes for ClusterHealthStatus, InvalidAliasNameException, Indices","#include <map>
#include <vector>
#include <string>
#include <stdexcept>

enum class ClusterHealthStatus {
    // Enum values as needed
};

class InvalidAliasNameException : public std::runtime_error {
public:
    InvalidAliasNameException(const std::string& msg) : std::runtime_error(msg) {}
};

namespace org {
namespace graylog2 {
namespace indexer {

class Indices {
    // Class definition as needed
};

} // namespace indexer
} // namespace graylog2
} // namespace org",0
"std::map<std::shared_ptr<CommittedBundleBase>, std::vector<std::shared_ptr<AppliedPTransformBase>>>
handleResult(
    std::shared_ptr<CommittedBundleBase> completedBundle,
    const std::vector<TimerData>& completedTimers,
    const InProcessTransformResult& result) 
{
    auto committedBundles = commitBundles(result.getOutputBundles());
    // Update watermarks and timers
    watermarkManager.updateWatermarks(
        /* args as appropriate */
    );
    return committedBundles;
}","class InProcessEvaluationContext {
public:
    std::map<std::shared_ptr<CommittedBundleBase>, std::vector<std::shared_ptr<AppliedPTransformBase>>>
    handleResult(
        std::shared_ptr<CommittedBundleBase> completedBundle,
        const std::vector<TimerData>& completedTimers,
        const InProcessTransformResult& result
    ) {
        auto committedBundles = commitBundles(result.getOutputBundles());
        // Update watermarks and timers
        watermarkManager.updateWatermarks(
            /* ... */
        );
        return committedBundles;
    }
private:
    WatermarkManager watermarkManager;
    
    std::map<std::shared_ptr<CommittedBundleBase>, std::vector<std::shared_ptr<AppliedPTransformBase>>>
    commitBundles(const std::vector<std::shared_ptr<OutputBundle>>& outputBundles);
};",1
"{
    std::string get() const {
        return GUID.To_string_n();
    }
}","std::string getGuidString() const
{
    std::stringstream ss;
    ss << std::hex << std::nouppercase;
    for (auto b : guid) // Assume guid is an array or vector<uint8_t> of 16 elements
    {
        if (b < 0x10) ss << '0';
        ss << (int)b;
    }
    return ss.str();
}",1
"```cpp
/**
 * Prepare upload parameters internal method for templates and ISOs local upload
 */
TemplateProfile prepareUploadParamsInternal(
    bool isIso,
    long userId,
    const std::string& name,
    const std::string& displayText,
    std::optional<int> bits,
    std::optional<bool> passwordEnabled,
    std::optional<bool> requiresHVM,
    const std::string& url,
    std::optional<bool> isPublic,
    std::optional<bool> featured,
    std::optional<bool> isExtractable,
    const std::string& format,
    std::optional<long> guestOSId,
    std::optional<long> zoneId,
    HypervisorType hypervisorType,
    const std::string& chksum,
    std::optional<bool> bootable,
    const std::string& templateTag,
    long templateOwnerId,
    std::map<std::string, std::any> details,
    std::optional<bool> sshkeyEnabled,
    const std::string& imageStoreUuid,
    std::optional<bool> isDynamicallyScalable,
    std::optional<bool> isRoutingType,
    bool directDownload
)
{
    // check if the caller can operate with the template owner
    Account* caller = CallContext::current().getCallingAccount();
    Account* owner = _accountMgr.getAccount(templateOwnerId);
    _accountMgr.checkAccess(caller, nullptr, true, owner);

    bool isRouting = (!isRoutingType.has_value()) ? false : isRoutingType.value();

    std::vector<long> zoneList;
    // ignore passed zoneId if we are using region wide image store
    std::vector<ImageStoreVO> stores = _imgStoreDao.findRegionImageStores();
    if (!(stores.size() > 0)) {
```","```cpp
TemplateProfile* prepareUploadParamsInternal(
    bool isIso, long userId, const std::string& name, const std::string& displayText,
    std::optional<int> bits, std::optional<bool> passwordEnabled, std::optional<bool> requiresHVM,
    const std::string& url, std::optional<bool> isPublic, std::optional<bool> featured,
    std::optional<bool> isExtractable, const std::string& format, std::optional<long> guestOSId,
    std::optional<long> zoneId, HypervisorType hypervisorType, const std::string& chksum,
    std::optional<bool> bootable, const std::string& templateTag, long templateOwnerId,
    std::map<std::string, std::string> details, std::optional<bool> sshkeyEnabled, const std::string& imageStoreUuid,
    std::optional<bool> isDynamicallyScalable, std::optional<bool> isRoutingType,
    bool directDownload)
{
    Account* caller = CallContext::current()->getCallingAccount();
    Account* owner = _accountMgr->getAccount(templateOwnerId);
    _accountMgr->checkAccess(caller, nullptr, true, owner);

    bool isRouting = isRoutingType.has_value() ? isRoutingType.value() : false;

    std::vector<long> zoneList;
    // zoneId is already an argument
    // ignore passed zoneId if we are using region wide image store
    std::vector<ImageStoreVO*> stores = _imgStoreDao->findRegionImageStores();
    if (!(stores.size() > 0)) {
        // ...
    }
}
```",1
"void testBrokenAppArchiveAsArgument() {
    std::unordered_map<std::string, std::any> startupOptions;
    startupOptions[""app""] = BROKEN_APP;
    StartupContext::get().setStartupOptions(startupOptions);

    doBrokenAppArchiveTest();
}","std::map<std::string, std::any> startupOptions;
startupOptions[""app""] = BROKEN_APP;
StartupContext::get().setStartupOptions(startupOptions);

doBrokenAppArchiveTest();",0
"auto reader = std::make_unique<SequenceFile::Reader>(this->fs, tablePath, this->conf);
try {
    Text key;
    T state = this->stateClass.newInstance();
    while (reader->next(key, state)) {
        states.push_back(state);
        state = this->stateClass.newInstance();
    }
}","```cpp
SequenceFile::Reader reader(this->fs, tablePath, this->conf);
try {
    Text key;
    T* state = this->stateClass->newInstance();
    while (reader.next(key, *state)) {
        states.push_back(*state);
        state = this->stateClass->newInstance();
    }
} catch (...) {
    // handle exceptions as needed
}
```",0
"pnodeRet->grfnop = 0;
pnodeRet->pnodeOuter = nullptr;

pnodeLambda->ichLim = std::max(pnodeRet->ichLim, lastRParen);
pnodeLambda->cbLim = this->GetScanner()->IecpLimTokPrevious();","pnodeRet->grfnop = 0;

pnodeLambda->ichLim = std::max(pnodeRet->ichLim, lastRParen);
pnodeLambda->cbLim = this->GetScanner()->IecpLimTokPrevious();",1
"callbacks.output(value);
}

void outputRetraction(const OutputT& value) override {
    callbacks.outputRetraction(value);
}

Timers& timers() override {
    return timers;
}","template <typename K, typename InputT, typename OutputT, typename W>
class ReduceFnContextFactory {
public:
    void output(const OutputT& value) {
        callbacks.output(value);
    }

    void outputRetraction(const OutputT& value) {
        callbacks.outputRetraction(value);
    }

    Timers& timers() {
        return timers_;
    }

private:
    Callbacks callbacks;
    Timers timers_;
};",1
"writeStatus.getStat().setPath(Path(config.getBasePath()), newFilePath);

createMarkerFile(partitionPath, newFileName);

fileWriter = createNewFileWriter(instantTime, newFilePath, hoodieTable, config, writerSchema, sparkTaskContextSupplier);

} catch (const std::ios_base::failure& io) {
    LOG.error(""Error in update task at commit "" + instantTime, io);
    writeStatus.setGlobalError(io);
}","writeStatus.getStat().setPath(Path(config.getBasePath()), newFilePath);

createMarkerFile(partitionPath, newFileName);

fileWriter = createNewFileWriter(instantTime, newFilePath, hoodieTable, config, writerSchema, sparkTaskContextSupplier);

} catch (const std::ios_base::failure& io) {
    LOG.error(""Error in update task at commit "" + instantTime, io);
    writeStatus.setGlobalError(io);
}",0
"#include <string>
#include <map>
#include <stdexcept>

class URL {};
class Invocation {};
class Result {};
class RpcException : public std::runtime_error {
public:
    explicit RpcException(const std::string& msg) : std::runtime_error(msg) {}
};
class RpcContext {
public:
    static RpcContext& getContext() {
        static RpcContext instance;
        return instance;
    }
    void setRemoteAddress(const std::string& host, int port) {
        // implement as needed
    }
};
constexpr const char* LOCALHOST_VALUE = ""127.0.0.1"";

template<typename T>
class Invoker {
public:
    virtual bool isAvailable() const = 0;
    virtual Result doInvoke(const Invocation& invocation) = 0;
    virtual ~Invoker() = default;
};

template<typename T>
class Exporter {
public:
    virtual Invoker<T>* getInvoker() = 0;
    virtual ~Exporter() = default;
};

template<typename T>
class AbstractInvoker : public Invoker<T> {
protected:
    URL url_;
public:
    AbstractInvoker(const URL& url) : url_(url) {}
    const URL& getUrl() const { return url_; }
    bool isAvailable() const override { return true; }
};

class InjvmProtocol {
public:
    template<typename T>
    static Exporter<T>* getExporter(const std::map<std::string, Exporter<T>*>& exporterMap, const URL& url) {
        // Implement logic as necessary
        // This is just a stub
        return nullptr;
    }
};

template<typename T>
class InjvmInvoker : public AbstractInvoker<T> {
    std::string key_;
    std::map<std::string, Exporter<T>*> exporterMap_;
public:
    InjvmInvoker(const URL& url, const std::string& key, const std::map<std::string, Exporter<T>*>& exporterMap)
        : AbstractInvoker<T>(url), key_(key), exporterMap_(exporterMap) {}

    bool isAvailable() const override {
        auto it = exporterMap_.find(key_);
        if (it == exporterMap_.end()) {
            return false;
        } else {
            return AbstractInvoker<T>::isAvailable();
        }
    }

    Result doInvoke(const Invocation& invocation) override {
        Exporter<T>* exporter = InjvmProtocol::getExporter(exporterMap_, this->getUrl());
        if (!exporter) {
            throw RpcException(""Service","#include <string>
#include <map>
#include <stdexcept>
#include ""URL.h""
#include ""Exporter.h""
#include ""Invocation.h""
#include ""Result.h""
#include ""RpcContext.h""
#include ""AbstractInvoker.h""
#include ""InjvmProtocol.h""

const std::string LOCALHOST_VALUE = ""127.0.0.1"";

template <typename T>
class InjvmInvoker : public AbstractInvoker<T> {
private:
    std::string key;
    std::map<std::string, Exporter*> exporterMap;

public:
    InjvmInvoker(const std::type_info& type, const URL& url, const std::string& key, const std::map<std::string, Exporter*>& exporterMap)
        : AbstractInvoker<T>(type, url), key(key), exporterMap(exporterMap) {}

    virtual bool isAvailable() const override {
        auto it = exporterMap.find(key);
        if (it == exporterMap.end() || it->second == nullptr) {
            return false;
        } else {
            return AbstractInvoker<T>::isAvailable();
        }
    }

    virtual Result doInvoke(const Invocation& invocation) override {
        Exporter* exporter = InjvmProtocol::getExporter(exporterMap, this->getUrl());
        if (exporter == nullptr) {
            throw std::runtime_error(""Service ["" + key + ""] not found."");
        }
        RpcContext::getContext().setRemoteAddress(LOCALHOST_VALUE, 0);
        return exporter->getInvoker()->invoke(invocation);
    }
};",1
"```cpp
#include <string>
#include <stdexcept>
#include <filesystem>
#include <memory>
#include <cstdlib>

class LoggerContext {};

class MuleLoggerContextFactory {
public:
    std::unique_ptr<LoggerContext> buildLoggerContext(const std::string& classLoader, const std::string& selector) {
        // Implement logic here as per your requirements in C++
        return std::make_unique<LoggerContext>();
    }
};
```","```cpp
#include <string>
#include <stdexcept>
#include <filesystem>
#include <memory>

class ArtifactClassLoader {
  // implementation details
};

class LoggerContext {
  // implementation details
};

class MuleLoggerContextFactory {
public:
    static std::unique_ptr<LoggerContext> buildLoggerContext(ArtifactClassLoader* classLoader, const std::string& selector) {
        // logic to create and configure a LoggerContext instance based on classLoader and selector
        return std::make_unique<LoggerContext>();
    }
};
```",0
"#include <atomic>
#include <memory>

class BeanFactory {};
class MessageBuilderFactory {};
class DefaultMessageBuilderFactory : public MessageBuilderFactory {};

class DefaultPahoMessageConverter {
private:
    std::atomic<bool> payloadAsBytes{false};
    std::atomic<BeanFactory*> beanFactory{nullptr};
    std::shared_ptr<MessageBuilderFactory> messageBuilderFactory = std::make_shared<DefaultMessageBuilderFactory>();

public:
    DefaultPahoMessageConverter() : DefaultPahoMessageConverter(0, false) {}
    DefaultPahoMessageConverter(int /*unused*/, bool /*unused*/) {}
};","class DefaultPahoMessageConverter : public MqttMessageConverter {
private:
    std::atomic<bool> payloadAsBytes{false};

    std::atomic<BeanFactory*> beanFactory{nullptr};

    std::atomic<MessageBuilderFactory*> messageBuilderFactory{new DefaultMessageBuilderFactory()};

public:
    DefaultPahoMessageConverter() : DefaultPahoMessageConverter(0, false) {}
};",0
"#include <string>
#include <type_traits>

template <typename T>
struct value {
    static std::string get();
};

struct KeyId {};

template <typename...>
struct AccessedFields;","#include <string>

struct KeyId {
};",1
"auto classLoaderModelDescriptor = mulePluginModel.getClassLoaderModelLoaderDescriptor();

const auto& attributes = classLoaderModelDescriptor.getAttributes();

auto packages = std::any_cast<std::vector<std::string>>(
    attributes.getOrDefault(EXPORTED_PACKAGES, std::vector<std::string>{})
);
exportPackages.insert(exportPackages.end(), packages.begin(), packages.end());

auto resources = std::any_cast<std::vector<std::string>>(
    attributes.getOrDefault(EXPORTED_RESOURCES, std::vector<std::string>{})
);
exportResources.insert(exportResources.end(), resources.begin(), resources.end());

auto privilegedPkgs = std::any_cast<std::vector<std::string>>(
    attributes.getOrDefault(PRIVILEGED_EXPORTED_PACKAGES, std::vector<std::string>{})
);
privilegedExportedPackages.insert(privilegedExportedPackages.end(), privilegedPkgs.begin(), privilegedPkgs.end());

auto privilegedArts = std::any_cast<std::vector<std::string>>(
    attributes.getOrDefault(PRIVILEGED_ARTIFACTS_IDS, std::vector<std::string>{})
);
privilegedArtifacts.insert(privilegedArtifacts.end(), privilegedArts.begin(), privilegedArts.end());

return PluginUrlClassification(
    pluginUrlClassification.getName(),
    pluginUrlClassification.getUrls(),
    pluginUrlClassification.getExportClasses()
);","```cpp
MuleArtifactLoaderDescriptor* classLoaderModelDescriptor = mulePluginModel.getClassLoaderModelLoaderDescriptor();

auto attributes = classLoaderModelDescriptor->getAttributes();

auto exportPackagesList = std::any_cast<std::vector<std::string>>(attributes.count(EXPORTED_PACKAGES) ? attributes[EXPORTED_PACKAGES] : std::vector<std::string>{});
exportPackages.insert(exportPackages.end(), exportPackagesList.begin(), exportPackagesList.end());

auto exportResourcesList = std::any_cast<std::vector<std::string>>(attributes.count(EXPORTED_RESOURCES) ? attributes[EXPORTED_RESOURCES] : std::vector<std::string>{});
exportResources.insert(exportResources.end(), exportResourcesList.begin(), exportResourcesList.end());

auto privilegedExportedPackagesList = std::any_cast<std::vector<std::string>>(attributes.count(PRIVILEGED_EXPORTED_PACKAGES) ? attributes[PRIVILEGED_EXPORTED_PACKAGES] : std::vector<std::string>{});
privilegedExportedPackages.insert(privilegedExportedPackages.end(), privilegedExportedPackagesList.begin(), privilegedExportedPackagesList.end());

auto privilegedArtifactsList = std::any_cast<std::vector<std::string>>(attributes.count(PRIVILEGED_ARTIFACTS_IDS) ? attributes[PRIVILEGED_ARTIFACTS_IDS] : std::vector<std::string>{});
privilegedArtifacts.insert(privilegedArtifacts.end(), privilegedArtifactsList.begin(), privilegedArtifactsList.end());

return PluginUrlClassification(pluginUrlClassification.getName(), pluginUrlClassification.getUrls(),
                              pluginUrlClassification.getExportClasses(), ...);
```",1
"DeckAdapter::DeckAdapter(LayoutInflater* layoutInflater, Context* context)
    : mLayoutInflater(layoutInflater),
      mDeckList()
{
    // Get the colors from the theme attributes
    std::vector<int> attrs = {
        // fill with attribute IDs as needed
    };
}","DeckAdapter::DeckAdapter(LayoutInflater* layoutInflater, Context* context)
    : mLayoutInflater(layoutInflater) {
    mDeckList = std::vector<Deck>();
    int attrs[] = {
        // attribute ids here
    };
}",0
"auto descriptor = result.get();
auto param = descriptor.getModel().getOutput().getType();
assert(dynamic_cast<ArrayType*>(param) != nullptr);
assert(getId(param).empty());
return param;","auto descriptor = result.get();
auto param = descriptor.getModel().getOutput().getType();
ASSERT_TRUE(dynamic_cast<ArrayType*>(param) != nullptr);
ASSERT_TRUE(getId(param).empty());
return param;",1
"}
 
if (!hasError) {
    // We can stop if the job is done.
    if (state.isTerminal()) {
        return state;
    }

    // The job is not done, so we must keep polling.
    backoff.reset();

    // If a total duration for all backoff has been set, update the new cumulative sleep time to
    // be the remaining total backoff duration, stopping if we have already exceeded the
    // allotted time.
    if (duration > Duration::ZERO) {
        long long nanosConsumed = nanoClock.nanoTime() - startNanos;
        Duration consumed = Duration::millis((nanosConsumed + 999999) / 1000000);
        Duration remaining = duration - consumed;
        if (remaining > Duration::ZERO) {
            backoff = MESSAGES_BACKOFF_FACTORY.withMaxCumulativeBackoff(remaining).backoff();
        } else {
            // If there is no time remaining, don't bother backing off.
            backoff = BackOff::STOP_BACKOFF;
        }
    }
}
} while (BackOffUtils::next(sleeper, backoff));","```cpp
do {
    if (!hasError) {
        // We can stop if the job is done.
        if (state.isTerminal()) {
            return state;
        }

        // The job is not done, so we must keep polling.
        backoff.reset();

        // If a total duration for all backoff has been set, update the new cumulative sleep time to
        // be the remaining total backoff duration, stopping if we have already exceeded the
        // allotted time.
        if (duration > Duration::ZERO) {
            long long nanosConsumed = nanoClock.nanoTime() - startNanos;
            Duration consumed = Duration::millis((nanosConsumed + 999999) / 1000000);
            Duration remaining = duration - consumed;
            if (remaining > Duration::ZERO) {
                backoff = MESSAGES_BACKOFF_FACTORY.withMaxCumulativeBackoff(remaining).backoff();
            } else {
                // If there is no time remaining, don't bother backing off.
                backoff = BackOff::STOP_BACKOFF;
            }
        }
    }
} while (BackOffUtils::next(sleeper, backoff));
```",1
"```
RexNode convertResolvedStructFieldAccess(const ResolvedGetStructField& resolvedGetStructField) {
    RexNode referencedExpr = convertRexNodeFromResolvedExpr(resolvedGetStructField.getExpr());
    return convertResolvedStructFieldAccessInternal(referencedExpr, static_cast<int>(resolvedGetStructField.getFieldIdx()));
}

RexNode convertResolvedStructFieldAccess(
    const ResolvedGetStructField& resolvedGetStructField,
    const std::vector<ResolvedColumn>& columnList,
    const std::vector<RelDataTypeField>& fieldList) {
    RexNode referencedExpr =
        convertRexNodeFromResolvedExpr(resolvedGetStructField.getExpr(), columnList, fieldList);
    return convertResolvedStructFieldAccessInternal(referencedExpr, static_cast<int>(resolvedGetStructField.getFieldIdx()));
}

RexNode convertResolvedStructFieldAccessInternal(const RexNode& referencedExpr, int fieldIdx) {
    // Calcite SQL does not allow the ROW constructor to be dereferenced directly, so do it here.
    if (auto call = dynamic_cast<const RexCall*>(&referencedExpr)) {
        if (dynamic_cast<const SqlRowOperator*>(call->getOperator())) {
            return call->getOperands().at(fieldIdx);
        }
    }
    return rexBuilder().makeFieldAccess(referencedExpr, fieldIdx);
}
```","```cpp
RexNode* convertResolvedStructFieldAccess(const ResolvedGetStructField& resolvedGetStructField) {
    RexNode* referencedExpr = convertRexNodeFromResolvedExpr(resolvedGetStructField.getExpr());
    return convertResolvedStructFieldAccessInternal(referencedExpr, static_cast<int>(resolvedGetStructField.getFieldIdx()));
}

RexNode* convertResolvedStructFieldAccess(
    const ResolvedGetStructField& resolvedGetStructField,
    const std::vector<ResolvedColumn>& columnList,
    const std::vector<RelDataTypeField>& fieldList) {
    RexNode* referencedExpr = convertRexNodeFromResolvedExpr(
        resolvedGetStructField.getExpr(), columnList, fieldList);
    return convertResolvedStructFieldAccessInternal(referencedExpr, static_cast<int>(resolvedGetStructField.getFieldIdx()));
}

RexNode* convertResolvedStructFieldAccessInternal(RexNode* referencedExpr, int fieldIdx) {
    // Calcite SQL does not allow the ROW constructor to be dereferenced directly, so do it here.
    if (auto call = dynamic_cast<RexCall*>(referencedExpr)) {
        if (dynamic_cast<SqlRowOperator*>(call->getOperator())) {
            return call->getOperands().at(fieldIdx);
        }
    }
    return rexBuilder().makeFieldAccess(referencedExpr, fieldIdx);
}
```",1
"#include <string>
#include <memory>","#include <string>
#include <map>
#include <memory>",0
"break;

case WM_DRAWITEM:
    if (m.WParam != 0)
    {
        WmOwnerDraw(m);
    }
    break;

case WM_ERASEBKGND:
    WmEraseBkgnd(m);
    break;

case WM_HELP:
    WmHelp(m);
    break;","switch (m.Msg) {
    case WindowMessages::WM_DRAWITEM:
        if (m.WParam != nullptr) {
            WmOwnerDraw(m);
        }
        break;

    case WindowMessages::WM_ERASEBKGND:
        WmEraseBkgnd(m);
        break;

    case WindowMessages::WM_HELP:
        WmHelp(m);
        break;
}",1
"mAllDeckIds.push_back(thisDid);
}

class NoteDeckAdapter : public QStandardItemModel {
public:
    NoteDeckAdapter(QObject* parent, const QStringList& deckNames)
        : QStandardItemModel(parent) {
        for (const QString& name : deckNames) {
            appendRow(new QStandardItem(name));
        }
    }

    QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override {
        if (role == Qt::BackgroundRole) {
            if (index.row() == mNoteDeckSpinner->currentIndex()) {
                return QColor(Qt::lightGray);
            }
        }
        if (role == Qt::TextColorRole) {
            if (index.row() == mNoteDeckSpinner->currentIndex()) {
                return QColor(Qt::black);
            }
        }
        return QStandardItemModel::data(index, role);
    }
};

NoteDeckAdapter* noteDeckAdapter = new NoteDeckAdapter(this, deckNames);
mNoteDeckSpinner->setModel(noteDeckAdapter);

mCurrentDid = intent->value(EXTRA_DID, mCurrentDid).toLongLong();","std::vector<std::string> mAllDeckIds;
std::vector<std::string> deckNames;

// Assume mNoteDeckComboBox is a pointer to a QComboBox (e.g. in Qt)
// Fill in combo box items
for (const auto& deckName : deckNames) {
    mNoteDeckComboBox->addItem(QString::fromStdString(deckName));
}

// Set up map from index to deck ID
// You may want to use the mAllDeckIds vector for this

QObject::connect(mNoteDeckComboBox, QOverload<int>::of(&QComboBox::currentIndexChanged),
    [this](int index) {
        if (index >= 0 && index < mAllDeckIds.size()) {
            mCurrentDid = mAllDeckIds[index];
        }
    }
);

// Customizing appearance of dropdown (popup) items
// If using Qt, you can subclass QStyledItemDelegate
class DeckItemDelegate : public QStyledItemDelegate {
public:
    DeckItemDelegate(QObject* parent = nullptr, QComboBox* comboBox = nullptr)
        : QStyledItemDelegate(parent), mComboBox(comboBox) {}

    QWidget* createEditor(QWidget* parent, const QStyleOptionViewItem&, const QModelIndex&) const override {
        return nullptr; // not editable
    }

    void paint(QPainter* painter, const QStyleOptionViewItem& option,
               const QModelIndex& index) const override {
        QStyleOptionViewItem opt(option);
        if (mComboBox && index.row() == mComboBox->currentIndex()) {
            opt.backgroundBrush = QBrush(Qt::lightGray);
            opt.palette.setColor(QPalette::Text, Qt::black);
        }
        QStyledItemDelegate::paint(painter, opt, index);
    }

private:
    QComboBox* mComboBox;
};

// Usage:
mNoteDeckComboBox->setItemDelegate(new DeckItemDelegate(nullptr, mNoteDeckComboBox));

// mCurrentDid is updated above when combo box index changes

// For getting value from some intent or incoming method:
mCurrentDid = intent.value(EXTRA_DID, mCurrentDid);",1
"std::string clusteringInstantTime,
bool runSchedule,
std::string runningMode) {
    return buildHoodieClusteringUtilConfig(basePath, clusteringInstantTime, runSchedule, runningMode, false);
}

HoodieClusteringJob::Config buildHoodieClusteringUtilConfig(const std::string& basePath,
                                                           const std::string& clusteringInstantTime,
                                                           bool runSchedule,
                                                           const std::string& runningMode,
                                                           bool retryLastFailedClusteringJob) {
    HoodieClusteringJob::Config config;
    config.basePath = basePath;
    config.clusteringInstantTime = clusteringInstantTime;
    config.runSchedule = runSchedule;
    config.propsFilePath = dfsBasePath + ""/clusteringjob.properties"";
    config.runningMode = runningMode;
    config.retryLastFailedClusteringJob = retryLastFailedClusteringJob;
    return config;
}","HoodieClusteringJob::Config buildHoodieClusteringUtilConfig(const std::string& basePath,
                                                           const std::string& clusteringInstantTime,
                                                           bool runSchedule,
                                                           const std::string& runningMode,
                                                           bool retryLastFailedClusteringJob) {
    HoodieClusteringJob::Config config;
    config.basePath = basePath;
    config.clusteringInstantTime = clusteringInstantTime;
    config.runSchedule = runSchedule;
    config.propsFilePath = dfsBasePath + ""/clusteringjob.properties"";
    config.runningMode = runningMode;
    config.retryLastFailedClusteringJob = retryLastFailedClusteringJob;
    return config;
}

HoodieClusteringJob::Config buildHoodieClusteringUtilConfig(const std::string& basePath,
                                                           const std::string& clusteringInstantTime,
                                                           bool runSchedule,
                                                           const std::string& runningMode) {
    return buildHoodieClusteringUtilConfig(basePath, clusteringInstantTime, runSchedule, runningMode, false);
}",1
"auto bestMatchingPattern = request.getAttribute(HandlerMapping::BEST_MATCHING_PATTERN_ATTRIBUTE);
if (bestMatchingPattern != nullptr) {
    std::string contextPath = request.getContextPath();
    if (!contextPath.empty() && contextPath != ""/"") {
        span.updateName(contextPath + bestMatchingPattern->toString());
    } else {
        span.updateName(bestMatchingPattern->toString());
    }
}","void SpringWebMvcTracer::someMethod() {
    auto bestMatchingPattern = request->getAttribute(HandlerMapping::BEST_MATCHING_PATTERN_ATTRIBUTE);
    if (bestMatchingPattern != nullptr) {
        std::string contextPath = request->getContextPath();
        if (!contextPath.empty() && contextPath != ""/"") {
            span.updateName(contextPath + bestMatchingPattern->toString());
        } else {
            span.updateName(bestMatchingPattern->toString());
        }
    }
}",1
"#include <vector>
#include <string>
#include <memory>
#include <sstream>
#include <algorithm>

class Kind {
public:
    static const int METHOD_INVOCATION;
};

class Rule {
public:
    Rule(const std::string& key) {}
};

#define RULE(key) /* annotation replacement */

class Type;
class ExpressionTree;
class Tree;

class TypeChecker {
public:
    int argumentIndex;
    int parametrizedTypeIndex;
    std::shared_ptr<class MethodMatcher> methodMatcher;
    std::string methodOwnerType;
};

class TypeCheckerBuilder {
public:
    TypeCheckerBuilder& on(const std::string&) { return *this; }
    TypeCheckerBuilder& method(const std::string&) { return *this; }
    TypeCheckerBuilder& argument(int) { return *this; }
    TypeCheckerBuilder& outOf(int) { return *this; }
    TypeCheckerBuilder& shouldMatchParametrizedType(int) { return *this; }
    std::vector<TypeChecker> build() { return {}; }
};

class IssuableSubscriptionVisitor {
public:
    virtual std::vector<int> nodesToVisit() = 0;
    virtual void visitNode(Tree* tree) = 0;
    void reportIssue(const std::string&, const std::string&) {}
    bool hasSemantic() { return true; }
};

class Tree {
public:
    virtual int kind() const { return 0; }
};

class MethodInvocationTree : public Tree {
public:
    std::vector<std::shared_ptr<ExpressionTree>> arguments() { return {}; }
    std::shared_ptr<Tree> methodSelect() { return nullptr; }
};

class ExpressionTree : public Tree {
public:
    Type symbolType();
};

class MemberSelectExpressionTree : public ExpressionTree {
public:
    std::shared_ptr<ExpressionTree> expression() { return nullptr; }
};

class Type {
public:
    bool isUnknown() const { return false; }
    std::string name() const { return {}; }
    bool operator==(const Type& other) const { return true; }
};

namespace JUtils {
    bool isParametrized(const Type&) { return false; }
    std::vector<Type> typeArguments(const Type&) { return {}; }
}

class ExpressionUtils {
public:
    static std::string methodName(MethodInvocationTree*) { return """"; }
};

class MessageFormat {
public:
    static std::string format(const std::string& fmt, const std::string& arg1, const std::string& arg2","```cpp
#include <vector>
#include <string>
#include <memory>
#include <functional>
#include <sstream>
#include <algorithm>

class Type {
public:
    bool isUnknown() const;
    std::string name() const;
    // ... other methods
};

class ExpressionTree {
public:
    virtual const Type& symbolType() const = 0;
    virtual ~ExpressionTree() = default;
    // ...
};

class MethodInvocationTree : public ExpressionTree {
public:
    virtual std::vector<std::shared_ptr<ExpressionTree>> arguments() const = 0;
    virtual std::shared_ptr<ExpressionTree> methodSelect() const = 0;
    // ...
};

class MemberSelectExpressionTree : public ExpressionTree {
public:
    virtual std::shared_ptr<ExpressionTree> expression() const = 0;
    // ...
};

namespace Tree {
    enum Kind {
        METHOD_INVOCATION,
        MEMBER_SELECT
    };
}

class TypeChecker {
public:
    struct MethodMatcher {
        std::function<bool(const MethodInvocationTree&)> matches;
    };
    MethodMatcher methodMatcher;
    std::string methodOwnerType;
    int argumentIndex;
    int parametrizedTypeIndex;
};

class TypeCheckerBuilder {
    // Implement builder for TypeChecker
};

class JUtils {
public:
    static bool isParametrized(const Type& type);
    static std::vector<Type> typeArguments(const Type& type);
};

class ExpressionUtils {
public:
    static std::string methodName(const MethodInvocationTree& tree);
};

class IssuableSubscriptionVisitor {
public:
    virtual std::vector<int> nodesToVisit() = 0;
    virtual void visitNode(const std::shared_ptr<ExpressionTree>& tree) = 0;
    void reportIssue(const std::string& where, const std::string& message) {
        // ... issue reporting logic
    }
    bool hasSemantic() const {
        // ... context check logic
        return true;
    }
    // ...
};

class CollectionInappropriateCallsCheck : public IssuableSubscriptionVisitor {
private:
    static const std::vector<TypeChecker> TYPE_CHECKERS;

    static std::string message(const Type& actualMethodType, const Type& checkedMethodType, const Type& parameterType, const Type& argumentType) {
        std::string actualType = typeNameWithParameters(actualMethodType);
        bool actualTypeHasTheParameterType = false;
        for (const auto& typeArg : JUtils::typeArguments(actualMethodType",1
"void testOverrideBundleAnnotationsInstruction_success() {
    Builder b;
    b.addClasspath(IO::getFile(""bin_test""));
    b.setPrivatePackage(""test.annotationheaders.attrs.std.activator"");
    b.setProperty(Constants::BUNDLE_ACTIVATOR,
        ""test.annotationheaders.attrs.std.activator.TypeInVersionedPackage2"");
    b.setProperty(""-bundleannotations"", ""!test.annotationheaders.attrs.std.activator.TypeInVersionedPackage,*"");
    b.build();
    assert(b.check());
    Manifest manifest = b.getJar().getManifest();
    manifest.write(std::cout);

    Attributes mainAttributes = manifest.getMainAttributes();

    Header repeated = Header::parseHeader(mainAttributes.getValue(Constants::BUNDLE_ACTIVATOR));
    assertThat(repeated).containsOnlyKeys({""test.annotationheaders.attrs.std.activator.TypeInVersionedPackage2""});
}","#include <gtest/gtest.h>
#include <memory>
#include <fstream>
#include <string>
#include ""Builder.h""
#include ""IO.h""
#include ""Constants.h""
#include ""Manifest.h""
#include ""Header.h""

TEST(StdAnnotationHeadersTest, testOverrideBundleAnnotationsInstruction_success) {
    Builder b;
    b.addClasspath(IO::getFile(""bin_test""));
    b.setPrivatePackage(""test.annotationheaders.attrs.std.activator"");
    b.setProperty(Constants::BUNDLE_ACTIVATOR, 
                  ""test.annotationheaders.attrs.std.activator.TypeInVersionedPackage2"");
    b.setProperty(""-bundleannotations"", ""!test.annotationheaders.attrs.std.activator.TypeInVersionedPackage,*"");
    b.build();
    ASSERT_TRUE(b.check());
    auto manifest = b.getJar().getManifest();
    manifest.write(std::cout);

    auto& mainAttributes = manifest.getMainAttributes();

    Header repeated = Header::parseHeader(mainAttributes.getValue(Constants::BUNDLE_ACTIVATOR));
    ASSERT_THAT(repeated, ContainsOnlyKeys({""test.annotationheaders.attrs.std.activator.TypeInVersionedPackage2""}));
}",1
"builder.withExtensionModelDescriber().setId(XmlExtensionModelLoader::DESCRIBER_ID).addProperty(RESOURCE_XML, moduleDestination);
builder.withClassLoaderModelDescriber().setId(MAVEN);
builder.withBundleDescriptorLoader(createBundleDescriptorLoader(extensionName, MULE_EXTENSION_CLASSIFIER, MAVEN));

ArtifactPluginFileBuilder byeXmlExtensionPlugin(extensionName);
byeXmlExtensionPlugin
    .containingResource(""module-byeSource.xml"", moduleDestination)
    .containingResource(""module-bye-pom.xml"",
        get(""META-INF"", ""maven"", ""org.mule.extension"", ""mule-module-bye"", MULE_PLUGIN_POM).toString())
    .describedBy(builder.build());

ApplicationFileBuilder applicationFileBuilder(""appWithExtensionXmlPlugin"");
applicationFileBuilder
    .definedBy(""app-with-extension-xml-plugin-module-bye.xml"")
    .dependingOn(byeXmlExtensionPlugin);
addPackedAppFromBuilder(applicationFileBuilder);

DefaultDomainManager domainManager;","```cpp
builder.withExtensionModelDescriber().setId(XmlExtensionModelLoader::DESCRIBER_ID).addProperty(RESOURCE_XML, moduleDestination);
builder.withClassLoaderModelDescriber().setId(MAVEN);
builder.withBundleDescriptorLoader(createBundleDescriptorLoader(extensionName, MULE_EXTENSION_CLASSIFIER, MAVEN));

ArtifactPluginFileBuilder byeXmlExtensionPlugin(extensionName);
byeXmlExtensionPlugin
    .containingResource(""module-byeSource.xml"", moduleDestination)
    .containingResource(
        ""module-bye-pom.xml"",
        get(""META-INF"", ""maven"", ""org.mule.extension"", ""mule-module-bye"", MULE_PLUGIN_POM).toString()
    )
    .describedBy(builder.build());

ApplicationFileBuilder applicationFileBuilder(""appWithExtensionXmlPlugin"");
applicationFileBuilder
    .definedBy(""app-with-extension-xml-plugin-module-bye.xml"")
    .dependingOn(byeXmlExtensionPlugin);
addPackedAppFromBuilder(applicationFileBuilder);

DefaultDomainManager domainManager;
```",0
virtual std::string getCorrelationId() const = 0;,"class MuleEvent {
public:
    virtual std::string getCorrelationId() const = 0;
    virtual /*payload type*/ getPayload() const = 0;
    virtual ~MuleEvent() = default;
};",0
"}
backlog = eventBacklogService.getMessagesForEvent(ctx.event(), backlogSize);
} else {
    backlog = eventBacklogService.getMessagesForEvent(ctx.event(), eventsConfiguration.eventNotificationsBacklog());
}
catch (const NotFoundException& e) {
    LOG.error(""Failed to fetch backlog for event {}"", ctx.event().id());
}","```cpp
try {
    if (backlogSize > 0) {
        backlog = eventBacklogService.getMessagesForEvent(ctx.event(), backlogSize);
    } else {
        backlog = eventBacklogService.getMessagesForEvent(ctx.event(), eventsConfiguration.eventNotificationsBacklog());
    }
} catch (const NotFoundException& e) {
    LOG.error(""Failed to fetch backlog for event {}"", ctx.event().id());
}
```",0
"#include <string>
#include <algorithm>
#include <cctype>
#include <memory>
#include <functional>

class MuleContext {};

class MuleEvent {};

class MessagingException : public std::exception {};

class CompletionHandler {
public:
    virtual void onComplete(const MuleEvent&) = 0;
    virtual void onError(const MessagingException&) = 0;
    virtual ~CompletionHandler() = default;
};

class OptimizedRequestContext {};
class RequestContext {};

inline bool containsIgnoreCase(const std::string& str, const std::string& searchStr) {
    auto it = std::search(
        str.begin(), str.end(),
        searchStr.begin(), searchStr.end(),
        [](char ch1, char ch2) { return std::tolower(ch1) == std::tolower(ch2); }
    );
    return (it != str.end());
}

#include ""spdlog/spdlog.h""
auto logger = spdlog::get(""default"");  // Or spdlog::stdout_color_mt(""default"") if not already created","#include <string>
#include <algorithm>
#include <cctype>

#include <memory>

#include <spdlog/spdlog.h>

class MuleContext;
class MuleEvent;
class MessagingException;

inline bool containsIgnoreCase(const std::string& str, const std::string& searchStr) {
    auto it = std::search(
        str.begin(), str.end(),
        searchStr.begin(), searchStr.end(),
        [](char ch1, char ch2) {
            return std::tolower(ch1) == std::tolower(ch2);
        }
    );
    return (it != str.end());
}

std::shared_ptr<spdlog::logger> logger = spdlog::default_logger();",0
"handler.storeSessionInfoToMessage(session, message);
auto s = message.removeProperty(MULE_SESSION_PROPERTY);
message.setInboundProperty(MULE_SESSION_PROPERTY, s);
session = handler.retrieveSessionInfoFromMessage(message);
sc = session.getSecurityContext();","handler.storeSessionInfoToMessage(session, message);
auto s = message.removeProperty(MULE_SESSION_PROPERTY);
message.setInboundProperty(MULE_SESSION_PROPERTY, s);
session = handler.retrieveSessionInfoFromMessage(message);

auto sc = session.getSecurityContext();",0
"uint8_t byteAtO1 = helpers.getByteFromArrayByIndex(s1Value, o1++);
uint8_t byteAtO2 = helpers.getByteFromArrayByIndex(s2Value, o2++);

if ((byteAtO1 != byteAtO2)
    && (toUpperCase(helpers.byteToCharUnsigned(byteAtO1)) != toUpperCase(helpers.byteToCharUnsigned(byteAtO2)))
   ) {
    return false;
}","if ((byteAtO1 != byteAtO2)
    && (toUpperCase(helpers.byteToCharUnsigned(byteAtO1)) != toUpperCase(helpers.byteToCharUnsigned(byteAtO2)))
) {
    return false;
}",0
"#include <set>
#include <string>
#include <memory>","#include <set>
#include <memory>",0
"```cpp
switch (command) {
    case COMPACT_UNSCHEDULE_PLAN:
        assert(args.size() == 9);
        doCompactUnschedule(jsc, args[3], args[4], args[5], std::stoi(args[6]),
                            (args[7] == ""true"" || args[7] == ""1""),
                            (args[8] == ""true"" || args[8] == ""1""));
        returnCode = 0;
        break;
    case CLUSTERING_RUN:
        assert(args.size() >= 9);
        propsFilePath = """";
        if (!StringUtils::isNullOrEmpty(args[8])) {
            propsFilePath = args[8];
        }
        configs.clear();
        if (args.size() > 9) {
            configs.insert(configs.end(), args.begin() + 9, args.end());
        }
        returnCode = cluster(jsc, args[3], args[4], args[5], std::stoi(args[6]), args[2],
                             std::stoi(args[7]), false, propsFilePath, configs);
        break;
    case CLUSTERING_SCHEDULE:
        assert(args.size() >= 7);
        propsFilePath = """";
        if (!StringUtils::isNullOrEmpty(args[6])) {
            propsFilePath = args[6];
        }
        configs.clear();
        if (args.size() > 7) {
            configs.insert(configs.end(), args.begin() + 7, args.end());
        }
        returnCode = cluster(jsc, args[3], args[4], args[5], 1, args[2],
                             0, true, propsFilePath, configs);
        break;
    case CLEAN:
        assert(args.size() >= 5);
        // ...
        break;
}
```","```cpp
switch (cmd) {
    case COMPACT_UNSCHEDULE_PLAN:
        assert(args.size() == 9);
        doCompactUnschedule(jsc, args[3], args[4], args[5], std::stoi(args[6]),
                            (args[7] == ""true"" || args[7] == ""1""), (args[8] == ""true"" || args[8] == ""1""));
        returnCode = 0;
        break;
    case CLUSTERING_RUN:
        assert(args.size() >= 9);
        propsFilePath = """";
        if (!StringUtils::isNullOrEmpty(args[8])) {
            propsFilePath = args[8];
        }
        configs.clear();
        if (args.size() > 9) {
            configs.assign(args.begin() + 9, args.end());
        }
        returnCode = cluster(jsc, args[3], args[4], args[5], std::stoi(args[6]), args[2],
                             std::stoi(args[7]), false, propsFilePath, configs);
        break;
    case CLUSTERING_SCHEDULE:
        assert(args.size() >= 7);
        propsFilePath = """";
        if (!StringUtils::isNullOrEmpty(args[6])) {
            propsFilePath = args[6];
        }
        configs.clear();
        if (args.size() > 7) {
            configs.assign(args.begin() + 7, args.end());
        }
        returnCode = cluster(jsc, args[3], args[4], args[5], 1, args[2],
                             0, true, propsFilePath, configs);
        break;
    case CLEAN:
        assert(args.size() >= 5);
        // ... (rest of the case)
        break;
}
```",1
"```cpp
this->writeSupport = parquetConfig.getWriteSupport();
this->instantTime = instantTime;
this->taskContextSupplier = taskContextSupplier;
this->populateMetaFields = populateMetaFields;
}

void writeAvroWithMetadata(R avroRecord, HoodieRecord record) override {
    if (populateMetaFields) {
        prepRecordWithMetadata(avroRecord, record, instantTime,
            taskContextSupplier.getPartitionIdSupplier().get(), recordIndex, file.getName());
        BaseClass::write(avroRecord);
        writeSupport.add(record.getRecordKey());
    } else {
        BaseClass::write(avroRecord);
    }
}
```","void writeAvroWithMetadata(R avroRecord, HoodieRecord& record) override {
    if (populateMetaFields) {
        prepRecordWithMetadata(avroRecord, record, instantTime,
            taskContextSupplier.getPartitionIdSupplier().get(), recordIndex, file.getName());
        BaseClass::write(avroRecord);
        writeSupport.add(record.getRecordKey());
    } else {
        BaseClass::write(avroRecord);
    }
}",1
"#include <vector>
#include <algorithm>
#include <unordered_map>
#include <map>","#include <vector>
#include <algorithm>
#include <unordered_map>
#include <map>",0
"using static org::mule::runtime::config::spring::internal::dsl::spring::ComponentModelHelper::isRouter;
using static org::mule::runtime::config::spring::internal::dsl::spring::ComponentModelHelper::isTemplateOnErrorHandler;
using static org::mule::runtime::config::spring::internal::dsl::spring::ComponentModelHelper::resolveComponentType;","#include ""ComponentModelHelper.h""
using namespace ComponentModelHelper;

#include ""ComponentIdentifier.h""
#include ""TypedComponentIdentifier.h""
#include ""ComponentLocation.h""",0
"template <typename T>
class InProcessBundle {
public:
    static InProcessBundle<T> unkeyed(PCollection<T>* pcollection) {
        return InProcessBundle<T>(pcollection, nullptr);
    }

    static InProcessBundle<T> keyed(PCollection<T>* pcollection, void* key) {
        return InProcessBundle<T>(pcollection, key);
    }

private:
    InProcessBundle(PCollection<T>* pcollection, void* key)
        : pcollection(pcollection), key(key), elements() {}

    PCollection<T>* pcollection;
    void* key;
    std::vector<T> elements;
};","template <typename T>
class InProcessBundle {
public:
    static InProcessBundle<T> unkeyed(PCollection<T>* pcollection) {
        return InProcessBundle<T>(pcollection, nullptr);
    }

    static InProcessBundle<T> keyed(PCollection<T>* pcollection, void* key) {
        return InProcessBundle<T>(pcollection, key);
    }

private:
    InProcessBundle(PCollection<T>* pcollection, void* key)
        : pcollection(pcollection), key(key), elements{} {}

    PCollection<T>* pcollection;
    void* key;
    std::vector<T> elements;
};",1
"void test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_byte() {
    auto mh = MethodHandles::lookup().findStatic<PackageExamples>(""addPublicStaticVariableArity"", MethodType::methodType<int, std::vector<int>>());

    Assert::assertTrue(mh.isVarargsCollector());

    mh = mh.asType(MethodType::methodType<int, uint8_t>());

    Assert::assertFalse(mh.isVarargsCollector());
}","#include <gtest/gtest.h>
#include <vector>
#include <cstdint>

class PackageExamples {
public:
    static int addPublicStaticVariableArity(const std::vector<int>& args) {
        int sum = 0;
        for (int n : args) sum += n;
        return sum;
    }
};

class MethodHandle {
    // Simplified stand-in for demonstration
    bool varargsCollector = true;
public:
    using FuncType = int(const std::vector<int>&);
    FuncType* func;

    MethodHandle(FuncType* f, bool isVarargs = true)
        : func(f), varargsCollector(isVarargs) {}

    bool isVarargsCollector() const { return varargsCollector; }

    MethodHandle asType(int(*)(uint8_t)) const {
        return MethodHandle(reinterpret_cast<FuncType*>(nullptr), false);
    }
};

TEST(MethodHandleTest, test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_byte) {
    MethodHandle mh(&PackageExamples::addPublicStaticVariableArity);

    ASSERT_TRUE(mh.isVarargsCollector());

    mh = mh.asType(nullptr);

    ASSERT_FALSE(mh.isVarargsCollector());
}",0
"std::string commitSha;
try {
    std::map<std::string, std::string> git;
    std::istream* gitResource = getResource(clazz, gitPath);
    std::string line;
    while (std::getline(*gitResource, line)) {
        auto delimPos = line.find('=');
        if (delimPos != std::string::npos) {
            std::string key = line.substr(0, delimPos);
            std::string value = line.substr(delimPos + 1);
            git[key] = value;
        }
    }
    commitSha = git[gitPropertyName];
} catch (const std::exception&) {
}","std::string commitSha;
try {
    std::ifstream gitResource(getResource(clazz, gitPath));
    std::map<std::string, std::string> git;
    std::string line;
    while (std::getline(gitResource, line)) {
        auto pos = line.find('=');
        if (pos != std::string::npos) {
            git[line.substr(0, pos)] = line.substr(pos + 1);
        }
    }
    commitSha = git[gitPropertyName];
    // abbreviate if present and looks like a long sha
}",0
"std::string commitInstantFileName = HoodieTimeline::makeCommitFileName(""002"");
assert(fs().Delete((basePath() + Path::SEPARATOR + HoodieTableMetaClient::METAFOLDER_NAME + ""/"" + commitInstantFileName), false));
testTable.doWriteOperation(""003"", UPSERT, {}, {""p1"", ""p2""}, 1);
syncTableMetadata(writeConfig);
auto metadataMetaClient = HoodieTableMetaClient::builder().setConf(hadoopConf()).setBasePath(metadataTableBasePath).build();
auto timeline = metadataMetaClient.getActiveTimeline();
assert(timeline.containsInstant(HoodieInstant(false, HoodieTimeline::DELTA_COMMIT_ACTION, ""001"")));
assert(timeline.containsInstant(HoodieInstant(false, HoodieTimeline::DELTA_COMMIT_ACTION, ""002"")));","std::string commitInstantFileName = HoodieTimeline::makeCommitFileName(""002"");
assert(fs()->Delete(Path(basePath() + Path::SEPARATOR + HoodieTableMetaClient::METAFOLDER_NAME,
    commitInstantFileName), false));
testTable.doWriteOperation(""003"", UPSERT, {}, {""p1"", ""p2""}, 1);
syncTableMetadata(writeConfig);
auto metadataMetaClient = HoodieTableMetaClient::builder().setConf(hadoopConf()).setBasePath(metadataTableBasePath).build();
HoodieActiveTimeline timeline = metadataMetaClient->getActiveTimeline();
assert(timeline.containsInstant(HoodieInstant(false, HoodieTimeline::DELTA_COMMIT_ACTION, ""001"")));
assert(timeline.containsInstant(HoodieInstant(false, HoodieTimeline::DELTA_COMMIT_ACTION, ""002"")));",0
"return oldFilePath;
}

WriteStatus getWriteStatus() override {
    return writeStatus;
}","Path getStorageWriterPath() {
    return (this->tempPath == nullptr) ? this->newFilePath : this->tempPath;
}

WriteStatus getWriteStatus() override {
    return writeStatus;
}",0
"#include <set>
#include <string>","#include <set>
#include <string>
#include <memory>",0
"```cpp
#include <string>
#include <filesystem>
#include <cassert>
#include <stdexcept>

class DomainFileBuilder {
public:
    std::string getDeployedPath() const;
    std::string getConfigFile() const;
};

std::filesystem::path domainsDir;
DomainFileBuilder dummyDomainFileBuilder;

void doRedeployDomainByChangingConfigFileWithGoodOne() {
    doRedeployDomainByChangingConfigFile(""/empty-domain-config.xml"", dummyDomainFileBuilder);
}

void doRedeployDomainByChangingConfigFileWithGoodOne(const DomainFileBuilder& domain) {
    doRedeployDomainByChangingConfigFile(""/empty-domain-config.xml"", domain);
}

void doRedeployDummyDomainByChangingConfigFileWithBadOne() {
    doRedeployDomainByChangingConfigFile(""/bad-domain-config.xml"", dummyDomainFileBuilder);
}

void doRedeployDomainByChangingConfigFile(const std::string& configFile, const DomainFileBuilder& domain) {
    std::filesystem::path originalConfigFile = domainsDir / domain.getDeployedPath() / domain.getConfigFile();
    assert(std::filesystem::exists(originalConfigFile) && ""Cannot find domain config file"");
    std::filesystem::path newConfigFile = std::filesystem::path(""resources"") / configFile; // Replace with your resource loading logic
    if (!std::filesystem::exists(newConfigFile)) {
        throw std::runtime_error(""Resource file not found: "" + newConfigFile.string());
    }
    // further logic here...
}
```","```cpp
#include <string>
#include <cassert>
#include <filesystem>
#include <fstream>
#include <stdexcept>

class DomainFileBuilder
{
public:
    std::string getDeployedPath() const;
    std::string getConfigFile() const;
};

std::filesystem::path domainsDir;
DomainFileBuilder dummyDomainFileBuilder;

void doRedeployDomainByChangingConfigFile(const std::string& configFile, const DomainFileBuilder& domain)
{
    std::filesystem::path originalConfigFile = domainsDir / domain.getDeployedPath() / domain.getConfigFile();
    assert(std::filesystem::exists(originalConfigFile) && ""Cannot find domain config file"");
    std::filesystem::path newConfigFile = std::filesystem::canonical(configFile);
    // ...
}

void doRedeployDummyDomainByChangingConfigFileWithGoodOne()
{
    doRedeployDomainByChangingConfigFile(""/empty-domain-config.xml"", dummyDomainFileBuilder);
}

void doRedeployDomainByChangingConfigFileWithGoodOne(const DomainFileBuilder& domain)
{
    doRedeployDomainByChangingConfigFile(""/empty-domain-config.xml"", domain);
}

void doRedeployDummyDomainByChangingConfigFileWithBadOne()
{
    doRedeployDomainByChangingConfigFile(""/bad-domain-config.xml"", dummyDomainFileBuilder);
}
```",1
"#include ""ParameterGroupModel.h""
#include ""ParameterModel.h""
#include ""ParameterizedModel.h""
#include ""DataType.h""
#include ""TypedValue.h""
#include ""ParameterElementDeclaration.h""
#include ""ParameterGroupElementDeclaration.h""
#include ""ParameterizedElementDeclaration.h""","#include ""NamedObject.h""
#include ""ParameterGroupModel.h""
#include ""ParameterModel.h""
#include ""ParameterizedModel.h""
#include ""DataType.h""
#include ""TypedValue.h""
#include ""ParameterElementDeclaration.h""
#include ""ParameterGroupElementDeclaration.h""
#include ""ParameterizedElementDeclaration.h""",0
"auto stepsIter = aggregatorSteps.find(aggregator);
std::unordered_map<std::string, T> stepValues;
for (const auto& transform : evaluationContext.getSteps()) {
    if (stepsIter != aggregatorSteps.end() && stepsIter->second.count(transform.getTransform()) > 0) {
        T aggregate = aggregators.getAggregate(
            evaluationContext.getStepName(transform), aggregator.getName());
        if (aggregate != nullptr) {","std::vector<PTransform*>* steps = aggregatorSteps[aggregator];
std::map<std::string, T> stepValues;
for (auto* transform : evaluationContext.getSteps()) {
    if (steps != nullptr && std::find(steps->begin(), steps->end(), transform->getTransform()) != steps->end()) {
        T aggregate = aggregators.getAggregate(
            evaluationContext.getStepName(transform), aggregator.getName());
        if (aggregate != nullptr) {",1
"} else {
  std::string dateString = valueMeta->getString(valueData);
  if (!dateString.empty()) {
    pgCopyOut.write(dateString.c_str(), dateString.size());
  }
}
break;","```cpp
std::string dateString = valueMeta.getString(valueData);
if (!dateString.empty()) {
    pgCopyOut.write(dateString.c_str(), dateString.size()); // C++ does not have encoding variants for getBytes as in Java; set encoding elsewhere if needed
}
```",0
"SimplePropertyDescriptor const JavascriptLibrary::FunctionWithLengthAndNameTypeDescriptors[2] = {
    SimplePropertyDescriptor(BuiltInPropertyRecords::length, PropertyConfigurable),
    SimplePropertyDescriptor(BuiltInPropertyRecords::name, PropertyConfigurable)
};

SimpleTypeHandler<1> JavascriptLibrary::SharedPrototypeTypeHandler(
    BuiltInPropertyRecords::constructor,
    PropertyWritable | PropertyConfigurable,
    PropertyTypesWritableDataOnly,
    4,
    sizeof(DynamicObject)
);

SimpleTypeHandler<1> JavascriptLibrary::SharedFunctionWithoutPrototypeTypeHandler(
    BuiltInPropertyRecords::name,
    PropertyConfigurable
);

SimpleTypeHandler<1> JavascriptLibrary::SharedFunctionWithPrototypeTypeHandlerV11(
    BuiltInPropertyRecords::prototype,
    PropertyWritable
);

SimpleTypeHandler<2> JavascriptLibrary::SharedFunctionWithPrototypeTypeHandler(
    SharedFunctionPropertyDescriptors
);

SimpleTypeHandler<1> JavascriptLibrary::SharedIdMappedFunctionWithPrototypeTypeHandler(
    BuiltInPropertyRecords::prototype
);

SimpleTypeHandler<1> JavascriptLibrary::SharedFunctionWithLengthTypeHandler(
    BuiltInPropertyRecords::length
);

SimpleTypeHandler<2> JavascriptLibrary::SharedFunctionWithLengthAndNameTypeHandler(
    FunctionWithLengthAndNameTypeDescriptors
);

MissingPropertyTypeHandler JavascriptLibrary::MissingPropertyHolderTypeHandler;","namespace Js
{
    const SimplePropertyDescriptor JavascriptLibrary::FunctionWithLengthAndNameTypeDescriptors[2] = {
        SimplePropertyDescriptor(BuiltInPropertyRecords::length, PropertyConfigurable),
        SimplePropertyDescriptor(BuiltInPropertyRecords::name, PropertyConfigurable)
    };

    SimpleTypeHandler<1> JavascriptLibrary::SharedPrototypeTypeHandler(
        BuiltInPropertyRecords::constructor, PropertyWritable | PropertyConfigurable, PropertyTypesWritableDataOnly, 4, sizeof(DynamicObject));
    SimpleTypeHandler<1> JavascriptLibrary::SharedFunctionWithoutPrototypeTypeHandler(
        BuiltInPropertyRecords::name, PropertyConfigurable);
    SimpleTypeHandler<1> JavascriptLibrary::SharedFunctionWithPrototypeTypeHandlerV11(
        BuiltInPropertyRecords::prototype, PropertyWritable);
    SimpleTypeHandler<2> JavascriptLibrary::SharedFunctionWithPrototypeTypeHandler(
        SharedFunctionPropertyDescriptors);
    SimpleTypeHandler<1> JavascriptLibrary::SharedIdMappedFunctionWithPrototypeTypeHandler(
        BuiltInPropertyRecords::prototype);
    SimpleTypeHandler<1> JavascriptLibrary::SharedFunctionWithLengthTypeHandler(
        BuiltInPropertyRecords::length);
    SimpleTypeHandler<2> JavascriptLibrary::SharedFunctionWithLengthAndNameTypeHandler(
        FunctionWithLengthAndNameTypeDescriptors);
    MissingPropertyTypeHandler JavascriptLibrary::MissingPropertyHolderTypeHandler;
}",1
"```cpp
bool checkReceivedData(long checkpointId) {
    int numberOfParallelSubtasks = runtimeContext.getNumberOfParallelSubtasks();
    std::vector<FileStatus> fileStatuses;
    Path instantMarkerPath = generateCurrentMakerPath();
    while (true) {
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
```","```cpp
bool checkReceivedData(long checkpointId) {
    int numberOfParallelSubtasks = runtimeContext.getNumberOfParallelSubtasks();
    std::vector<FileStatus> fileStatuses;
    Path instantMarkerPath = generateCurrentMakerPath();
    // waiting all subtask create marker file ready
    while (true) {
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
```",0
"virtual std::optional<HoodieBaseFile> getLatestDataFile(const std::string& partitionStr, const std::string& fileId) override {
    std::unique_lock<std::shared_mutex> lock(readLock);
    std::string partitionPath = formatPartitionKey(partitionStr);","virtual std::optional<HoodieBaseFile> getLatestDataFile(const std::string& partitionStr, const std::string& fileId) final {
    try {
        readLock.lock();
        std::string partitionPath = formatPartitionKey(partitionStr);",0
"```cpp
void validateMuzzle(ClassLoader* agentClassLoader, ClassLoader* userClassLoader, bool assertPass) {
  // Iterate over all InstrumentationModules loaded with agentClassLoader
  for (auto& instrumentationModule : ServiceLoader<InstrumentationModule>::load(agentClassLoader)) {
    Method* getMuzzleReferenceMatcher = nullptr;
    try {
      getMuzzleReferenceMatcher = InstrumentationModule::classType()->getDeclaredMethod(""getMuzzleReferenceMatcher"");
      getMuzzleReferenceMatcher->setAccessible(true);
      ReferenceMatcher* muzzle = static_cast<ReferenceMatcher*>(getMuzzleReferenceMatcher->invoke(instrumentationModule.get()));
      std::vector<Mismatch> mismatches = muzzle->getMismatchedReferenceSources(userClassLoader);

      bool classLoaderMatch = instrumentationModule->classLoaderMatcher()->matches(userClassLoader);
      bool passed = mismatches.empty() && classLoaderMatch;

      if (passed && !assertPass) {
        std::cerr << ""MUZZLE PASSED ""
                  << typeid(*instrumentationModule).name()
                  << "" BUT FAILURE WAS EXPECTED"" << std::endl;
        throw std::runtime_error(""Instrumentation unexpectedly passed Muzzle validation"");
      } else if (!passed && assertPass) {
        std::cerr << ""FAILED MUZZLE VALIDATION: ""
                  << typeid(*instrumentationModule).name()
                  << "" mismatches:"" << std::endl;

        if (!classLoaderMatch) {
          std::cerr << ""-- classloader mismatch"" << std::endl;
        }
      }
    } catch (const std::exception& ex) {
      throw;
    }
  }
}
```","```cpp
#include <vector>
#include <string>
#include <stdexcept>
#include <iostream>

void validateAllInstrumenters(ClassLoader* agentClassLoader, ClassLoader* userClassLoader, bool assertPass) {
    for (auto& instrumentationModule : ServiceLoader<InstrumentationModule>::load(agentClassLoader)) {
        ReferenceMatcher* muzzle = nullptr;
        try {
            muzzle = instrumentationModule->getMuzzleReferenceMatcher();
            std::vector<Mismatch> mismatches = muzzle->getMismatchedReferenceSources(userClassLoader);

            bool classLoaderMatch = instrumentationModule->classLoaderMatcher()->matches(userClassLoader);
            bool passed = mismatches.empty() && classLoaderMatch;

            if (passed && !assertPass) {
                std::cerr << ""MUZZLE PASSED ""
                          << typeid(*instrumentationModule).name()
                          << "" BUT FAILURE WAS EXPECTED"" << std::endl;
                throw std::runtime_error(""Instrumentation unexpectedly passed Muzzle validation"");
            } else if (!passed && assertPass) {
                std::cerr << ""FAILED MUZZLE VALIDATION: ""
                          << typeid(*instrumentationModule).name()
                          << "" mismatches:"" << std::endl;

                if (!classLoaderMatch) {
                    std::cerr << ""-- classloader mismatch"" << std::endl;
                }
                for (const auto& m : mismatches) {
                    std::cerr << m.toString() << std::endl;
                }
                throw std::runtime_error(""Instrumentation failed Muzzle validation"");
            }
        } catch (const std::exception& ex) {
            throw;
        }
    }
}
```",0
"clearClientContextIfNeeded(getMessageObserver());
return;
}

// If this branch is reached, it means that the message payload is empty.
// By asserting that the inboundProperty 'http.status' exists, I'm verifying that
// the last inbound endpoint used was HTTP, and that it set the property correctly.
else if (resEvent.getMessage().getInboundPropertyNames().count(""http.status"") > 0)
{
    int httpResponseStatusCode = std::stoi(resEvent.getMessage().getInboundProperty(""http.status"").toString());
    // Fail for any status code, but an Accepted (202) one.
    if (httpResponseStatusCode != SC_ACCEPTED)
    {
        throw HttpResponseException(""HTTP Response payload empty can't be processed through CXF components"", httpResponseStatusCode);
    }
}","```cpp
if (resEvent.getMessage().getInboundPropertyNames().count(""http.status"") > 0)
{
    int httpResponseStatusCode = std::stoi(resEvent.getMessage().getInboundProperty(""http.status"").toString());
    // Fail for any status code, but an Accepted (202) one.
    if (httpResponseStatusCode != SC_ACCEPTED)
    {
        throw HttpResponseException(""HTTP Response payload empty can't be processed through CXF components"", httpResponseStatusCode);
    }
}
```",1
"#include <map>
#include <string>
#include <vector>
#include <algorithm>

inline std::map<std::string, std::string> singletonMap(const std::string& key, const std::string& value) {
    return {{key, value}};
}

template<typename T>
bool hasItem(const std::vector<T>& collection, const T& item) {
    return std::find(collection.begin(), collection.end(), item) != collection.end();
}

template<typename T>
bool hasItems(const std::vector<T>& collection, const std::vector<T>& items) {
    for (const auto& item : items) {
        if (std::find(collection.begin(), collection.end(), item) == collection.end()) {
            return false;
        }
    }
    return true;
}

template<typename T>
bool hasSize(const std::vector<T>& collection, std::size_t size) {
    return collection.size() == size;
}","#include <map>
#include <string>
#include <gmock/gmock.h>
#include <gtest/gtest.h>

using ::testing::Contains;
using ::testing::ElementsAre;
using ::testing::SizeIs;

inline std::map<std::string, int> singletonMap(const std::string& key, int value) {
    return { {key, value} };
}",0
"std::sort(catchBlocks.begin(), catchBlocks.end(), [](const auto& b1, const auto& b2) {
    return b2.id() < b1.id();
});
auto firstMatchingCatchBlock = std::find_if(catchBlocks.begin(), catchBlocks.end(), <matching_predicate>);
if (firstMatchingCatchBlock != catchBlocks.end()) {
    enqueue(ExplodedGraph::ProgramPoint(*firstMatchingCatchBlock, 0), ps, methodYield);
    return;
}

for (const auto& b : catchBlocks) {
    if (ExplodedGraphWalker::isCatchingUncheckedException(b)) {
        enqueue(ExplodedGraph::ProgramPoint(b, 0), ps, methodYield);
    }
}

ps.storeExitValue();","std::optional<BlockType> firstMatchingCatchBlock = 
    std::ranges::max_element(
        catchBlocks,
        [](const auto& b1, const auto& b2) { return b1->id() < b2->id(); },
        [](const auto& b) { return b; }
    );
if (firstMatchingCatchBlock != catchBlocks.end()) {
    enqueue(ExplodedGraph::ProgramPoint(*firstMatchingCatchBlock, 0), ps, methodYield);
    return;
}

for (const auto& b : catchBlocks) {
    if (isCatchingUncheckedException(b)) {
        enqueue(ExplodedGraph::ProgramPoint(b, 0), ps, methodYield);
    }
}

ps.storeExitValue();",0
"#include <vector>
#include <string>

class DataTable
{
};","#include <vector>
#include <string>

class DataTable
{",0
"#include <filesystem>
#include <memory>
#include <stdexcept>
#include <mutex>

namespace fs = std::filesystem;

inline void checkArgument(bool expression, const std::string& message) {
    if (!expression) throw std::invalid_argument(message);
}

class LockFactory {
public:
    virtual std::unique_ptr<std::mutex> createLock() = 0;
    virtual ~LockFactory() = default;
};

class ObjectStoreException : public std::runtime_error {
public:
    explicit ObjectStoreException(const std::string& msg) : std::runtime_error(msg) {}
};","#include <string>
#include <filesystem>
#include <memory>
#include <stdexcept>
#include <mutex>

using namespace std;
namespace fs = std::filesystem;",0
"ASSERT_EQ(readClient.latestCommit(), newCommitTime);
ASSERT_EQ(readClient.readCommit(newCommitTime).count(), records.size());

HoodieTableMetaClient metaClient(fs, basePath);
HoodieTable table = HoodieTable::getHoodieTable(metaClient, getConfig());

auto taggedRecords = index.tagLocation(jsc.parallelize(records, 1), table).collect();
checkTaggedRecords(taggedRecords, ""001"");","assert(readClient.latestCommit() == newCommitTime && ""Latest commit should be 001"");
assert(readClient.readCommit(newCommitTime).count() == records.size() && ""Must contain 200 records"");
HoodieTableMetaClient metaClient(fs, basePath);
HoodieTable table = HoodieTable::getHoodieTable(metaClient, getConfig());

auto taggedRecords = index.tagLocation(jsc.parallelize(records, 1), table).collect();
checkTaggedRecords(taggedRecords, ""001"");",0
"LookupResult performLookup(const std::string& name, const std::string& key) {
    return lookupTableService.newBuilder().lookupTable(name).build().lookup(key);
}","LookupResult performLookup(const std::string& name, const std::string& key) {
    return lookupTableService.newBuilder().lookupTable(name).build().lookup(key);
}",0
"return userPrefs->getBoolean(ANALYTICS_OPTIN_KEY, false);
}

static void setEnabled(bool value) {
    auto prefs = AnkiDroidApp::getSharedPrefs(AnkiDroidApp::getInstance());
    prefs->edit()
         ->putBoolean(UsageAnalytics::ANALYTICS_OPTIN_KEY, value)
         ->apply();
}

class Category {","static bool isEnabled() {
    return userPrefs.getBoolean(ANALYTICS_OPTIN_KEY, false);
}

static void setEnabled(bool value) {
    // A listener on this preference handles the rest
    auto prefs = AnkiDroidApp::getSharedPrefs(AnkiDroidApp::getInstance());
    prefs->edit()->putBoolean(UsageAnalytics::ANALYTICS_OPTIN_KEY, value)->apply();
}

class Category {",0
"{
    ServiceStatistics stats = getServiceStatistics();
    assert(stats.getAverageQueueSize() == 1);
    FlowConstructStatistics fstats = getFlowConstructStatistics();
    assert(fstats.getAverageQueueSize() == 1);
}","TEST(JmxStatisticsAsyncTestCase, TestCaseName)
{
    ServiceStatistics stats = getServiceStatistics();
    ASSERT_EQ(1, stats.getAverageQueueSize());
    FlowConstructStatistics fstats = getFlowConstructStatistics();
    ASSERT_EQ(1, fstats.getAverageQueueSize());
}",1
"if (result) {
    std::string message = 
        std::format(""Transitioned host HA state from:{} to:{} due to event:{} for the host id:{}"",
            currentHAState, nextState, event, haConfig.getResourceId());

    LOG.debug(message);

    if (nextState == HAConfig::HAState::Recovering ||
        nextState == HAConfig::HAState::Fencing ||
        nextState == HAConfig::HAState::Fenced) {
        ActionEventUtils::onActionEvent(
            CallContext::current().getCallingUserId(),
            CallContext::current().getCallingAccountId(),
            Domain::ROOT_DOMAIN,
            EventTypes::EVENT_HA_STATE_TRANSITION,
            message
        );
    }
}","if (result) {
    std::string message = ""Transitioned host HA state from:"" + std::to_string(currentHAState) +
                          "" to:"" + std::to_string(nextState) +
                          "" due to event:"" + std::to_string(event) +
                          "" for the host id:"" + std::to_string(haConfig.getResourceId());
    LOG.debug(message);

    if (nextState == HAConfig::HAState::Recovering ||
        nextState == HAConfig::HAState::Fencing ||
        nextState == HAConfig::HAState::Fenced) {
        ActionEventUtils::onActionEvent(CallContext::current().getCallingUserId(),
                                        CallContext::current().getCallingAccountId(),
                                        Domain::ROOT_DOMAIN,
                                        EventTypes::EVENT_HA_STATE_TRANSITION,
                                        message);
    }
}",1
"try {
    createNode(key, value);
} catch (const KeeperException::NodeExistsException&) {
    updateNode(key, value, -1);
}","```cpp
try {
    createNode(key, value);
}
catch (const KeeperException::NodeExistsException& /*e*/) {
    updateNode(key, value, -1);
}
```",0
"#include ""org/mule/runtime/api/message/Message.h""
#include ""org/mule/runtime/core/api/lifecycle/LifecycleUtils.h""
#include ""org/mule/runtime/dsl/api/component/config/DefaultComponentLocation.h""
#include ""org/mule/runtime/api/exception/MuleException.h""
#include ""org/mule/runtime/core/DefaultEventContext.h""

using org::mule::runtime::api::message::Message;
using org::mule::runtime::core::DefaultEventContext;
using org::mule::runtime::api::exception::MuleException;

using org::mule::runtime::core::api::lifecycle::stopIfNeeded;
using org::mule::runtime::api::message::of;
using org::mule::runtime::dsl::api::component::config::DefaultComponentLocation::fromSingleComponent;","#include ""org/mule/runtime/api/message/Message.h""
#include ""org/mule/runtime/core/api/lifecycle/LifecycleUtils.h""
#include ""org/mule/runtime/dsl/api/component/config/DefaultComponentLocation.h""
#include ""org/mule/runtime/api/exception/MuleException.h""
#include ""org/mule/runtime/core/DefaultEventContext.h""

using org::mule::runtime::api::message::Message;
using org::mule::runtime::core::api::lifecycle::LifecycleUtils::stopIfNeeded;
using org::mule::runtime::dsl::api::component::config::DefaultComponentLocation::fromSingleComponent;",0
"return _volStateMachine.transitTo(vol, event, nullptr, _volsDao);
}

Volume destroyVolume(long volumeId, const Account& caller, bool expunge, bool forceExpunge) {
    VolumeVO volume = retrieveAndValidateVolume(volumeId, caller);

    if (expunge) {
        const auto userId = caller.getAccountId();
        if (!forceExpunge && !_accountMgr.isAdmin(userId) && !AllowUserExpungeRecoverVolume::valueIn(userId)) {
            throw PermissionDeniedException(""Expunging a volume can only be done by an Admin. Or when the allow.user.expunge.recover.volume key is set."");
        }
    } else if (volume.getState() == Volume::State::Allocated || volume.getState() == Volume::State::Uploaded) {
        throw InvalidParameterValueException(""The volume in Allocated/Uploaded state can only be expunged not destroyed/recovered"");
    }

    destroyVolumeIfPossible(volume);

    if (expunge) {
        if (volume.getState() == Volume::State::Allocated) {
            _volsDao.remove(volume.getId());
            try {
                stateTransitTo(volume, Volume::Event::DestroyRequested);
            } catch (const NoTransitionException& e) {
                s_logger.debug(""Failed to destroy volume"" + std::to_string(volume.getId()), e);
                return nullptr;
            }
            _resourceLimitMgr.decrementResourceCount(volume.getAccountId(), ResourceType::volume, volume.isDisplay());
            _resourceLimitMgr.decrementResourceCount(volume.getAccountId(), ResourceType::primary_storage, volume.isDisplay(), static_cast<long>(volume.getSize()));
            return volume;
        }
        if (!deleteVolumeFromStorage(volume, caller)) {
            s_logger.warn(""Failed to expunge volume: "" + std::to_string(volumeId));
            return nullptr;
        }
    }

    return volume;
}

Volume recoverVolume(long volumeId) {
    Account caller = CallContext::current().getCallingAccount();
    const auto userId = caller.getAccountId();

    VolumeVO volume = _volsDao.findById(volumeId);

    if (!volume) {
        throw InvalidParameterValueException(""Unable to find a volume with id "" + std::to_string(volumeId));
    }

    if (!_accountMgr.isAdmin(userId) && !AllowUserExpungeRecoverVolume::valueIn(userId)) {
        throw PermissionDeniedException(""Recovering a volume can only be","```cpp
Volume* destroyVolume(long volumeId, const Account& caller, bool expunge, bool forceExpunge) {
    VolumeVO* volume = retrieveAndValidateVolume(volumeId, caller);

    if (expunge) {
        // When trying to expunge, permission is denied when the caller is not an admin and the AllowUserExpungeRecoverVolume is false for the caller.
        const long userId = caller.getAccountId();
        if (!forceExpunge && !_accountMgr.isAdmin(userId) && !AllowUserExpungeRecoverVolume::valueIn(userId)) {
            throw PermissionDeniedException(""Expunging a volume can only be done by an Admin. Or when the allow.user.expunge.recover.volume key is set."");
        }
    } else if (volume->getState() == Volume::State::Allocated || volume->getState() == Volume::State::Uploaded) {
        throw InvalidParameterValueException(""The volume in Allocated/Uploaded state can only be expunged not destroyed/recovered"");
    }

    destroyVolumeIfPossible(*volume);

    if (expunge) {
        // Mark volume as removed if volume has not been created on primary or secondary
        if (volume->getState() == Volume::State::Allocated) {
            _volsDao.remove(volume->getId());
            try {
                stateTransitTo(*volume, Volume::Event::DestroyRequested);
            } catch (const NoTransitionException& e) {
                s_logger.debug(""Failed to destroy volume"" + std::to_string(volume->getId()), e);
                return nullptr;
            }
            _resourceLimitMgr.decrementResourceCount(volume->getAccountId(), ResourceType::volume, volume->isDisplay());
            _resourceLimitMgr.decrementResourceCount(volume->getAccountId(), ResourceType::primary_storage, volume->isDisplay(), static_cast<long>(volume->getSize()));
            return volume;
        }
        if (!deleteVolumeFromStorage(*volume, caller)) {
            s_logger.warn(""Failed to expunge volume: "" + std::to_string(volumeId));
            return nullptr;
        }
    }

    return volume;
}

Volume* recoverVolume(long volumeId) {
    Account caller = CallContext::current().getCallingAccount();
    const long userId = caller.getAccountId();

    // Verify input parameters
    VolumeVO* volume = _volsDao.findById(volumeId);

    if (volume == nullptr) {
        throw InvalidParameterValueException",1
"std::mutex previousOffsetsMutex;

void getAllPreviousOffsets(SourceState& state) {
    std::lock_guard<std::mutex> lock(previousOffsetsMutex);
    if (doneGettingAllPreviousOffsets.load()) {
        return;
    }

    previousOffsets.clear();
    for (auto& workUnitState : state.getPreviousWorkUnitStates()) {
        std::vector<KafkaPartition> partitions = KafkaUtils::getPartitions(workUnitState);","```cpp
void getAllPreviousOffsets(SourceState& state) {
    std::lock_guard<std::mutex> lock(this->mutex_);
    if (this->doneGettingAllPreviousOffsets.load()) {
        return;
    }

    this->previousOffsets.clear();
    for (auto& workUnitState : state.getPreviousWorkUnitStates()) {
        std::vector<KafkaPartition> partitions = KafkaUtils::getPartitions(workUnitState);
        // Rest of the logic goes here
    }
}

// Class members assumed:
// std::atomic<bool> doneGettingAllPreviousOffsets;
// std::mutex mutex_;
```",1
"#include <vector>
#include <string>
#include <optional>
#include <stdexcept>

class TableReference {};
class TableRow {};

class SomeClass {
public:
    // Returns the total bytes count of TableRows.
    virtual long insertAll(
        const TableReference& ref,
        const std::vector<TableRow>& rowList,
        const std::optional<std::vector<std::string>>& insertIdList
    ) = 0;

    // Inserts TableRows with the specified insertIds if not null.
    // Returns the total bytes count of TableRows.
    virtual long insertAll(
        const TableReference& ref,
        const std::vector<TableRow>& rowList,
        const std::optional<std::vector<std::string>>& insertIdList,
        std::optional<bool> ignoreUnknownValues
    ) = 0;
};","```cpp
#include <cstddef>
#include <vector>
#include <optional>
#include <string>
#include <stdexcept>

struct TableReference {};
struct TableRow {};

class BigQueryServices {
public:
    virtual ~BigQueryServices() = default;
    
    virtual std::size_t insertAll(
        const TableReference& ref,
        const std::vector<TableRow>& rowList,
        const std::optional<std::vector<std::string>>& insertIdList
    ) = 0;

    virtual std::size_t insertAll(
        const TableReference& ref,
        const std::vector<TableRow>& rowList,
        const std::optional<std::vector<std::string>>& insertIdList,
        bool ignoreUnknownValues
    ) = 0;
};
```",1
"#include <hive/ql/metadata/Table.h>
#include <hadoop/mapred/InputFormat.h>
#include <hadoop/mapred/InvalidInputException.h>
#include <hadoop/security/UserGroupInformation.h>
#include <thrift/TException.h>

#include <gtest/gtest_prod.h>","#include <hive/ql/metadata/Partition.h>
#include <hive/ql/metadata/Table.h>
#include <hadoop/mapred/InputFormat.h>
#include <hadoop/mapred/InvalidInputException.h>
#include <hadoop/security/UserGroupInformation.h>
#include <thrift/TException.h>

#include <google/common/annotations/VisibleForTesting.h>",0
"#include <Messages.h>
#include <messageprocessors/MessageProcessor.h>
#include <streams/Stream.h>
#include <providers/ObjectMapperProvider.h>
#include <buffers/processors/ProcessBufferProcessor.h>
#include <messageq/MessageQueueAcknowledger.h>
#include <metrics/MetricUtils.h>","#include ""MessageCollection.h""
#include ""Messages.h""
#include ""MessageProcessor.h""
#include ""Stream.h""
#include ""ObjectMapperProvider.h""
#include ""ProcessBufferProcessor.h""
#include ""MessageQueueAcknowledger.h""
#include ""MetricUtils.h""",0
"private:
    Registry& registry;","class MuleRegistryHelper : public MuleRegistry {
private:
    Registry& registry;

public:
    // ...
};",1
"```cpp
protected:
    DistributionSummary* newDistributionSummary(
        Meter::Id id,
        const DistributionStatisticConfig& distributionStatisticConfig,
        double scale) override
    {
        auto* distributionSummary = new OpenTelemetryDistributionSummary(
            id, clock, distributionStatisticConfig, scale, otelMeter);
        if (distributionSummary->isUsingMicrometerHistograms()) {
            HistogramGauges::registerWithCommonFormat(distributionSummary, this);
        }
        return distributionSummary;
    }

    Meter* newMeter(Meter::Id id, Meter::Type type, const std::vector<Measurement>& iterable) override
    {
        throw std::runtime_error(""Not implemented yet"");
    }

    template<typename T>
    FunctionTimer* newFunctionTimer(
        Meter::Id id,
        T obj,
        ToLongFunction<T> countFunction,
        ToDoubleFunction<T> totalTimeFunction,
        TimeUnit totalTimeFunctionUnit) override
    {
        return new OpenTelemetryFunctionTimer<T>(
            id, obj, countFunction, totalTimeFunction, totalTimeFunctionUnit, asyncInstrumentRegistry);
    }

    template<typename T>
    FunctionCounter* newFunctionCounter(
        Meter::Id id,
        T obj,
        ToDoubleFunction<T> countFunction) override
    {
        return new OpenTelemetryFunctionCounter<T>(id, obj, countFunction, asyncInstrumentRegistry);
    }
```","#include <stdexcept>
#include <functional>

class OpenTelemetryMeterRegistry : public MeterRegistry {
protected:
    DistributionSummary* newDistributionSummary(
        Meter::Id id, 
        DistributionStatisticConfig distributionStatisticConfig, 
        double scale) override 
    {
        auto* distributionSummary = new OpenTelemetryDistributionSummary(
            id, clock, distributionStatisticConfig, scale, otelMeter);
        if (distributionSummary->isUsingMicrometerHistograms()) {
            HistogramGauges::registerWithCommonFormat(distributionSummary, this);
        }
        return distributionSummary;
    }
    
    Meter* newMeter(Meter::Id id, Meter::Type type, const std::vector<Measurement>& iterable) override
    {
        throw std::runtime_error(""Not implemented yet"");
    }

    template<typename T>
    FunctionTimer* newFunctionTimer(
        Meter::Id id,
        T obj,
        std::function<long(const T&)> countFunction,
        std::function<double(const T&)> totalTimeFunction,
        TimeUnit totalTimeFunctionUnit) override
    {
        return new OpenTelemetryFunctionTimer<T>(
            id, obj, countFunction, totalTimeFunction, totalTimeFunctionUnit, asyncInstrumentRegistry);
    }

    template<typename T>
    FunctionCounter* newFunctionCounter(
        Meter::Id id, 
        T obj, 
        std::function<double(const T&)> countFunction) override
    {
        return new OpenTelemetryFunctionCounter<T>(id, obj, countFunction, asyncInstrumentRegistry);
    }
};",1
"protected:
Config getLocallyResolvedConfig(const Config& userConfig) override {
    Config filteredUserConfig = SecureJobTemplate::filterUserConfig(this, userConfig, log);
    return filteredUserConfig.withFallback(this->rawConfig);
}

public:
bool isSecure() override {
    return this->rawConfig.hasPath(IS_SECURE_KEY) && this->rawConfig.getBoolean(IS_SECURE_KEY);
}

std::vector<std::string> overridableProperties() override {
    if (isSecure()) {
        return SPLITTER.splitToList(this->rawConfig.getString(SECURE_OVERRIDABLE_PROPERTIES_KEYS));
    } else {
        return {};
    }
}","class StaticJobTemplate : public InheritingJobTemplate {
protected:
    Config getLocallyResolvedConfig(const Config& userConfig) override {
        Config filteredUserConfig = SecureJobTemplate::filterUserConfig(this, userConfig, log);
        return filteredUserConfig.withFallback(this->rawConfig);
    }

public:
    bool isSecure() override {
        return this->rawConfig.hasPath(IS_SECURE_KEY) && this->rawConfig.getBoolean(IS_SECURE_KEY);
    }

    std::vector<std::string> overridableProperties() override {
        if (isSecure()) {
            return SPLITTER.splitToList(this->rawConfig.getString(SECURE_OVERRIDABLE_PROPERTIES_KEYS));
        } else {
            return {};
        }
    }
};",1
"EXPECT_CALL(*databaseDialog, getDatabaseMeta())
    .WillOnce(::testing::Return(createDefaultDatabase()));

auto dialog = std::make_shared<::testing::NiceMock<BaseStepDialog>>();
dialog->databaseDialog = databaseDialog;","EXPECT_CALL(*databaseDialog, askForDatabaseName(_))
    .WillOnce(Return(expectedResult));

EXPECT_CALL(*databaseDialog, getDatabaseMeta())
    .WillOnce(Return(createDefaultDatabase()));

auto dialog = std::make_shared<MockBaseStepDialog>();
dialog->databaseDialog = databaseDialog;",1
"#include ""AnkiActivity.h""
#include ""AnkiDroidApp.h""
#include ""R.h""
#include ""UIUtils.h""
#include ""dialogs/AsyncDialogFragment.h""
#include ""dialogs/DatabaseErrorDialog.h""
#include ""exception/ConfirmModSchemaException.h""
#include ""backend/exception/DeckRenameException.h""","#include <string>
#include <vector>

#include ""AnkiActivity.h""
#include ""AnkiDroidApp.h""
#include ""R.h""
#include ""UIUtils.h""
#include ""AsyncDialogFragment.h""
#include ""DatabaseErrorDialog.h""
#include ""ConfirmModSchemaException.h""
#include ""DeckRenameException.h""",1
"void send(SenderConnection& connection,
          const SMTPConfiguration& configuration,
          const EmailContent& content, // TODO: create a transformer from string to EmailContent when the sdk have support for it - MULE-9181.
          const std::string& subject = ""[No Subject]"",
          const std::vector<std::string>& toAddresses,
          const std::vector<std::string>& ccAddresses = {});","void send(SenderConnection& connection,
          const SMTPConfiguration& configuration,
          const EmailContent& content,
          const std::string& subject = ""[No Subject]"",
          const std::vector<std::string>& toAddresses,
          const std::vector<std::string>& ccAddresses = {})",1
"#include <map>
#include <string>","#include <map>
#include <string>

#include <gobblin/configuration/ConfigurationKeys.h>
#include <gobblin/configuration/State.h>
#include <gobblin/converter/jdbc/JdbcEntryData.h>
#include <gobblin/converter/jdbc/JdbcType.h>

/**
 * The implementation of JdbcWriterCommands for MySQL.
 */",0
"#include <chrono>
#include <optional>
#include <memory>
using std::optional;
using std::nullopt;
using std::make_optional;

class ComponentLocation {};

class Event {};

class EventContext {};

class FlowConstruct {};","#include <chrono>
#include <optional>

using std::nullopt;
using std::optional;
using std::make_optional;

#include ""ComponentLocation.h""
#include ""Event.h""
#include ""EventContext.h""
#include ""FlowConstruct.h""",0
"bool Parser::ParseFncDeclHelper(ParseNodePtr pnodeFnc, LPCOLESTR pNameHint, ushort flags, bool* pHasName, bool fUnaryOrParen, bool noStmtContext, bool* pNeedScanRCurly)
{
    ParseNodePtr pnodeFncSave = buildAST ? m_currentNodeFunc : m_currentNodeDeferredFunc;
    ParseNodePtr pnodeFncSaveNonLambda = buildAST ? m_currentNodeNonLambdaFunc : m_currentNodeNonLambdaDeferredFunc;
    int32_t* pAstSizeSave = m_pCurrentAstSize;

    bool fDeclaration = (flags & fFncDeclaration) != 0;
    bool fLambda = (flags & fFncLambda) != 0;
    bool fAsync = (flags & fFncAsync) != 0;","template<bool buildAST>
bool Parser::ParseFncDeclHelper(ParseNodePtr pnodeFnc, LPCOLESTR pNameHint, ushort flags, bool* pHasName, bool fUnaryOrParen, bool noStmtContext, bool* pNeedScanRCurly)
{
    ParseNodePtr pnodeFncSave = buildAST ? m_currentNodeFunc : m_currentNodeDeferredFunc;
    ParseNodePtr pnodeFncSaveNonLambda = buildAST ? m_currentNodeNonLambdaFunc : m_currentNodeNonLambdaDeferredFunc;
    int32_t* pAstSizeSave = m_pCurrentAstSize;

    bool fDeclaration = (flags & fFncDeclaration) != 0;
    bool fLambda = (flags & fFncLambda) != 0;
    bool fAsync = (flags & fFncAsync) != 0;
}",1
"}
 
// Simple JIT counts down and transitions on overflow
uint32_t callCount = simpleJitEntryPointInfo->callsCount;
assert(simpleJitLimit == 0 ? callCount == 0 : simpleJitLimit > callCount);
return callCount == 0 ?
    static_cast<uint16_t>(simpleJitLimit) :
    static_cast<uint16_t>(simpleJitLimit) - static_cast<uint8_t>(callCount) - 1;
}

void FunctionBody::ResetSimpleJitLimitAndCallCount()","```cpp
uint32_t callCount = simpleJitEntryPointInfo->callsCount;
assert(simpleJitLimit == 0 ? callCount == 0 : simpleJitLimit > callCount);
return callCount == 0 ?
    static_cast<uint16_t>(simpleJitLimit) :
    static_cast<uint16_t>(simpleJitLimit) - static_cast<uint8_t>(callCount) - 1;
```",1
"#include <string>
#include <cassert>

namespace Decks {
    std::string strip(const std::string& s) {
        std::string result;
        size_t i = 0, n = s.size();
        while (i < n && (s[i] == '\n' || s[i] == '\t' || s[i] == ' ')) ++i;
        size_t j = n;
        while (j > i && (s[j - 1] == '\n' || s[j - 1] == '\t' || s[j - 1] == ' ')) --j;
        for (size_t k = i; k < j; ++k) {
            if ( (s[k] == '\n' || s[k] == '\t' || s[k] == ' ')
                 && k+1 < j
                 && (s[k+1] == '\n' || s[k+1] == '\t' || s[k+1] == ' ') )
                continue;
            result += s[k];
        }
        return result;
    }
}

void trim() {
    assert(Decks::strip(""A\nB C\t D"") == ""A\nB C\t D"");
    assert(Decks::strip(""\n A\n\t"") == ""A"");
    assert(Decks::strip(""Z::\n A\n\t::Y"") == ""Z::A::Y"");
}","#include <string>
#include <cassert>

struct Decks {
    static std::string strip(const std::string& s) {
        std::string res;
        size_t i = 0, n = s.size();
        // Remove leading whitespace (including newlines and tabs)
        while (i < n && std::isspace(static_cast<unsigned char>(s[i])))
            ++i;
        size_t j = n;
        // Remove trailing whitespace
        while (j > i && std::isspace(static_cast<unsigned char>(s[j - 1])))
            --j;
        if (i >= j) return """";
        res = s.substr(i, j - i);

        // For ""::\n"" and ""\n\t::"" in ""Z::\n A\n\t::Y"", remove '\n' and '\t' after/before ""::""
        // Replace ""::\n"" -> ""::"", ""\n::"" -> ""::"", ""::\t"" -> ""::"", ""\t::"" -> ""::""
        std::string result;
        for (size_t k = 0; k < res.size(); ++k) {
            if (k + 2 < res.size() && res.substr(k, 2) == ""::"" &&
                (res[k + 2] == '\n' || res[k + 2] == '\t')) {
                result += ""::"";
                ++k; // skip the ':' at k+1
                ++k; // skip \n or \t at k+2
                continue;
            }
            if (k > 0 && (res[k] == '\n' || res[k] == '\t') &&
                k + 1 < res.size() && res.substr(k + 1, 2) == ""::"") {
                // skip current \n or \t
                continue;
            }
            result += res[k];
        }
        return result;
    }
};

void trim_test() {
    assert(Decks::strip(""A\nB C\t D"") == ""A\nB C\t D"");
    assert(Decks::strip(""\n A\n\t"") == ""A"");
    assert(Decks::strip(""Z::\n A\n\t::Y"") == ""Z::A::Y"");
}",1
"this->taskState.addFinalConstructState(
    toLower(Constructs::EXTRACTOR.toString()),
    extractor.getFinalState()
);
this->taskState.addFinalConstructState(
    toLower(Constructs::CONVERTER.toString()),
    converter.getFinalState()
);
int forkIdx = 0;
for (const std::optional<Fork>& fork : this->forks) {
    if (fork.has_value()) {
        this->taskState.addFinalConstructState(
            toLower(RuntimeConstructs::FORK.toString()) + ""."" + std::to_string(forkIdx),
            fork->getFinalState()
        );
    }
    ++forkIdx;
}","this->taskState.addFinalConstructState(
    std::string(Constructs::EXTRACTOR).append(""""), extractor.getFinalState()
);
this->taskState.addFinalConstructState(
    std::string(Constructs::CONVERTER).append(""""), converter.getFinalState()
);
int forkIdx = 0;
for (const auto& fork : this->forks) {
    if (fork.has_value()) {
        this->taskState.addFinalConstructState(
            std::string(RuntimeConstructs::FORK).append(""."").append(std::to_string(forkIdx)),
            fork->getFinalState()
        );
    }
    ++forkIdx;
}",0
"#include <vector>
#include <deque>
#include <algorithm>","#include <optional>
#include <vector>
#include <deque>
#include <algorithm>",0
"```cpp
std::vector<std::string> readBuffer;
for (const auto& kv : scanner.getRecords()) {
    const auto& hoodieRecord = kv.second;
    try {
        auto insertValueOpt = hoodieRecord.getData().getInsertValue(schema, std::map<std::string, std::string>{});
        GenericRecord* record = insertValueOpt.has_value() ? static_cast<GenericRecord*>(insertValueOpt.value()) : nullptr;
        if (record != nullptr) {
            std::string filtered = filterOutVariables(*record);
            readBuffer.push_back(filtered);
        }
    } catch (const std::ios_base::failure& e) {
        throw std::runtime_error(e.what());
    }
}
std::sort(readBuffer.begin(), readBuffer.end());
assert(readBuffer == expected[partitionDir.getName()]);
```","```cpp
std::vector<std::string> readBuffer;
for (const auto& pair : scanner.getRecords()) {
    const auto& hoodieRecord = pair.second;
    try {
        // in case it is a delete
        std::optional<GenericRecord> record = hoodieRecord.getData().getInsertValue(schema, Properties());
        if (record.has_value()) {
            readBuffer.push_back(filterOutVariables(record.value()));
        }
        // else, skip (like Java's .filter(Objects::nonNull))
    } catch (const std::ios_base::failure& e) {
        throw std::runtime_error(e.what());
    }
}
std::sort(readBuffer.begin(), readBuffer.end());
assert(readBuffer == expected.at(partitionDir.getName()));
```",0
"#include ""NewArrayTree.h""
#include ""NewClassTree.h""
#include ""ReturnStatementTree.h""
#include ""SwitchExpressionTree.h""
#include ""SwitchStatementTree.h""
#include ""ThrowStatementTree.h""
#include ""Tree.h""
#include ""TypeCastTree.h""","#include ""MethodTree.h""
#include ""NewArrayTree.h""
#include ""NewClassTree.h""
#include ""ReturnStatementTree.h""
#include ""SwitchExpressionTree.h""
#include ""SwitchStatementTree.h""
#include ""ThrowStatementTree.h""
#include ""Tree.h""
#include ""TypeCastTree.h""",0
"std::string toString() override {
    return ""{"" + values.toString() + ""}  {"" + constraints.toString() + ""}"" + "" { "" + stack.toString() + "" }"" + relationsString();
}

std::string relationsString() {
    std::string buffer;
    if (!symbolicValueRelations.empty()) {
        buffer += "" {"";
        bool first = true;
        for (const auto& relation : symbolicValueRelations) {
            if (first) {
                first = false;
            } else {
                buffer += "";"";
            }
            buffer += relation.toString();
        }
        buffer += ""}"";
    }
    return buffer;
}

ProgramState addConstraint(const SymbolicValue& symbolicValue, const Object& constraint) {","std::string toString() const override {
    return ""{"" + values.toString() + ""}  {"" + constraints.toString() + ""}"" + "" { "" + stack.toString() + "" }"" + relationsString();
}

std::string relationsString() const {
    std::string buffer;
    if (!symbolicValueRelations.empty()) {
        buffer += "" {"";
        bool first = true;
        for (const auto& relation : symbolicValueRelations) {
            if (first) {
                first = false;
            } else {
                buffer += ';';
            }
            buffer += relation.toString();
        }
        buffer += '}';
    }
    return buffer;
}",0
"#include <locale>
#include <memory>
#include <string>

class Logger {
public:
    static std::shared_ptr<Logger> getAnonymousLogger(const std::string& /*name*/) {
        return std::make_shared<Logger>();
    }
};

class Calendar {};

class A {
    std::shared_ptr<Logger> loggerField = Logger::getAnonymousLogger(""som.foo.resources.i18n.LogMessages"");
public:
    void foo(Calendar c) {
        void* myObject;
        double value;
    }
};","#include <locale>
#include <memory>
#include <string>

class Logger {
public:
    static std::shared_ptr<Logger> getAnonymousLogger(const std::string& name) {
        return std::make_shared<Logger>(name);
    }
    explicit Logger(const std::string& /*name*/) {}
};

class Calendar {};

class A {
    std::shared_ptr<Logger> loggerField = Logger::getAnonymousLogger(""som.foo.resources.i18n.LogMessages"");
public:
    void foo(Calendar c) {
        void* myObject;
        double value;
    }
};",0
"bool ia = elgg_set_ignore_access(true);
auto delete_result = elgg_delete_metadata(options);
elgg_set_ignore_access(ia);

if (delete_result == false) {
    return false;
}

owner_guid = owner_guid ? static_cast<int>(owner_guid) : this->owner_guid;","```cpp
if (remove_access_restrictions_now) {
    auto ia = elgg_set_ignore_access(true);
    auto delete_result = elgg_delete_metadata(options);
    elgg_set_ignore_access(ia);

    if (!delete_result) {
        return false;
    }
}

auto owner_id = owner_guid ? static_cast<int>(owner_guid) : this->owner_guid;
```",1
"void try_catch() {
    bool a = false, b = false, c = false, d = false;
    try {
        foo();
        b = true;
        foo();
        c = true;
        foo();
    } catch (const std::invalid_argument& e) {
        if (a) {
        }
        if (b) {
        }
    }
}","```cpp
class Class : public SuperClass {
public:
    void try_catch() {
        bool a = false, b = false, c = false, d = false;
        try {
            foo();
            b = true;
            foo();
            c = true;
            foo();
        } catch (const std::invalid_argument& e) {
            if (a) {
            }
            if (b) {
            }
        }
    }
};
```",0
"/*****
 * This describes the MIME type of the row, which describes how to interpret the columns
 * DATA1 and DATA2. Allowed values are:
 * <ul>
 * <li>Data::Field::CONTENT_ITEM_TYPE:
 * You can use the aliases described in
 * Data::Field to access the
 * columns instead of the generic ""DATA1"" or ""DATA2"".
 * </li>
 * <li>Data::Tags::CONTENT_ITEM_TYPE:
 * You can use the aliases described in
 * Data::Tags to access the
 * columns instead of the generic ""DATA1"" or ""DATA2"".
 * </li>
 * </ul>
 *****/","```cpp
class FlashCardsContract {
public:
    /**
     * This describes the MIME type of the row, which describes how to interpret the columns
     * DATA1 and DATA2. Allowed values are:
     * - Data::Field::CONTENT_ITEM_TYPE:
     *   You can use the aliases described in
     *   Data::Field to access the
     *   columns instead of the generic ""DATA1"" or ""DATA2"".
     * - Data::Tags::CONTENT_ITEM_TYPE:
     *   You can use the aliases described in
     *   Data::Tags to access the
     *   columns instead of the generic ""DATA1"" or ""DATA2"".
     */
};
```",0
"#include <optional>
#include <string>

enum class DiskCacheMode {
    // values equivalent to Java enum DiskCacheMode
};

struct YourClassName {
    std::optional<long long> bytesReadRate;
    std::optional<long long> bytesReadRateMax;
    std::optional<long long> bytesReadRateMaxLength;
    std::optional<long long> bytesWriteRate;
    std::optional<long long> bytesWriteRateMax;
    std::optional<long long> bytesWriteRateMaxLength;
    std::optional<long long> iopsReadRate;
    std::optional<long long> iopsReadRateMax;
    std::optional<long long> iopsReadRateMaxLength;
    std::optional<long long> iopsWriteRate;
    std::optional<long long> iopsWriteRateMax;
    std::optional<long long> iopsWriteRateMaxLength;
    DiskCacheMode cacheMode;
};","#include <optional>
#include <string>

class DiskOfferingVO {
public:
    std::optional<long long> bytesReadRate;
    std::optional<long long> bytesReadRateMax;
    std::optional<long long> bytesReadRateMaxLength;
    std::optional<long long> bytesWriteRate;
    std::optional<long long> bytesWriteRateMax;
    std::optional<long long> bytesWriteRateMaxLength;
    std::optional<long long> iopsReadRate;
    std::optional<long long> iopsReadRateMax;
    std::optional<long long> iopsReadRateMaxLength;
    std::optional<long long> iopsWriteRate;
    std::optional<long long> iopsWriteRateMax;
    std::optional<long long> iopsWriteRateMaxLength;

    enum class DiskCacheMode {
        // Define values as appropriate
        // Example: None, WriteBack, WriteThrough
    };
    DiskCacheMode cacheMode;
};",1
"#include <map>
#include <string>

using std::map;
using std::string;

// Placeholder for TRACER
namespace io {
namespace opentelemetry {
namespace javaagent {
namespace instrumentation {
namespace jedis {
namespace v3_0 {
    struct JedisClientTracer {
        static JedisClientTracer TRACER;
        struct CommandWithArgs{};
    };
} // namespace v3_0
} // namespace jedis
} // namespace instrumentation
} // namespace javaagent
} // namespace opentelemetry
} // namespace io

using io::opentelemetry::javaagent::instrumentation::jedis::v3_0::JedisClientTracer;
using io::opentelemetry::javaagent::instrumentation::jedis::v3_0::JedisClientTracer::CommandWithArgs;

// Singleton map utility
template<typename K, typename V>
std::map<K, V> singletonMap(const K& key, const V& value) {
    return std::map<K, V>{{key, value}};
}

// Placeholders for matcher methods
struct ElementMatcher {
    static ElementMatcher is(const std::string& arg) { return ElementMatcher(); }
    static ElementMatcher isMethod() { return ElementMatcher(); }
    static ElementMatcher named(const std::string& name) { return ElementMatcher(); }
    template<typename T>
    static ElementMatcher takesArgument(int, T) { return ElementMatcher(); }
    static ElementMatcher takesArguments(int) { return ElementMatcher(); }
};

// Annotations auto-service would be handled differently in C++, possibly with registration macros

// Placeholders for Scope & Span (to match usage in OpenTelemetry API)
namespace io {
namespace opentelemetry {
    class Scope {};
    namespace trace {
        class Span {};
    }
} // namespace opentelemetry
} // namespace io

using io::opentelemetry::Scope;
using io::opentelemetry::trace::Span;

// Placeholders for Instrumenter
namespace io {
namespace opentelemetry {
namespace javaagent {
namespace tooling {
    class Instrumenter {};
} // namespace tooling
} // namespace javaagent
} // namespace opentelemetry
} // namespace io

using io::opentelemetry::javaagent::tooling::Instrumenter;","#include <map>
#include <string>
#include <memory>

using std::map;
using std::string;
using std::shared_ptr;",0
"private:
void* executeOperation(OperationContext* operationContext) {
    try
    {
        return operationExecutor.execute(operationContext);
    }
    catch (const std::exception& e)
    {
        throw handledException(
            fmt::format(""Operation '{}' threw exception"", operation.getName()),
            static_cast<OperationContextAdapter*>(operationContext)->getEvent(),
            e
        );
    }
}","```cpp
private:
    Any executeOperation(OperationContext& operationContext)
    {
        try
        {
            return operationExecutor.execute(operationContext);
        }
        catch (const std::exception& e)
        {
            throw handledException(
                fmt::format(""Operation '{}' threw exception"", operation.getName()),
                static_cast<OperationContextAdapter&>(operationContext).getEvent(),
                e
            );
        }
    }
```",0
"#include ""ClassUtils.h""
#include ""MuleMessage.h""
#include ""Filter.h""
#include ""ObjectFilter.h""","#include ""org/mule/api/MuleMessage.h""
#include ""org/mule/api/routing/filter/Filter.h""
#include ""org/mule/api/routing/filter/ObjectFilter.h""
#include ""org/mule/util/ClassUtils.h""

using org::mule::api::MuleMessage;
using org::mule::api::routing::filter::Filter;
using org::mule::api::routing::filter::ObjectFilter;
using org::mule::util::ClassUtils::equal;
using org::mule::util::ClassUtils::hash;",0
"if (Language::kAssociative == executingLanguage)
{
    int ci = Constants::kInvalidIndex;
    int fi = Constants::kInvalidIndex;
    if (!isGlobScope)
    {
        ci = static_cast<int>(rmem.GetAtRelative(StackFrame::kFrameIndexClass).opdata);
        fi = static_cast<int>(rmem.GetAtRelative(StackFrame::kFrameIndexFunction).opdata);
    }

    if (fepRun)
    {
        UpdateMethodDependencyGraph(pc, fi, ci);
    }
    else","if (Language::kAssociative == executingLanguage)
{
    // Get the class and function scope if the current scope is not global
    int ci = Constants::kInvalidIndex;
    int fi = Constants::kInvalidIndex;
    if (!isGlobScope)
    {
        ci = static_cast<int>(rmem.GetAtRelative(StackFrame::kFrameIndexClass).opdata);
        fi = static_cast<int>(rmem.GetAtRelative(StackFrame::kFrameIndexFunction).opdata);
    }

    if (fepRun)
    {
        UpdateMethodDependencyGraph(pc, fi, ci);
    }
    else
    {
        // ...
    }
}",1
"void doRestart(Session& session)
{
    prepareForQuit(
        constants_.restartRStudio(),
        [&](auto saveChanges) {
            std::string project = session.getSessionInfo().getActiveProjectFile();
            if (project.empty())","void doRestart(Session& session)
{
    prepareForQuit(
        constants_.restartRStudio(),
        [&](bool saveChanges) {
            std::string project = session.getSessionInfo().getActiveProjectFile();
            if (project.empty())
            {
                // ...
            }
        }
    );
}",0
"try {
    assert(client.getPartition(""hivedb"", ""testTable"", {""2020-03-17-00""}) != nullptr);
    // Test additional table been registered
    assert(client.tableExists(dedupedDbName, ""testTable""));
} catch (const TException& e) {
    throw std::ios_base::failure(e.what());
}","try {
    assert(client.getPartition(""hivedb"", ""testTable"", {""2020-03-17-00""}) != nullptr);
    assert(client.tableExists(dedupedDbName, ""testTable""));
} catch (const TException& e) {
    throw std::ios_base::failure(e.what());
}",0
"mActionBarSpinner->setSelection(position);
if (position == 0) {
    mRestrictOnDeck = """";
    saveLastDeckId(ALL_DECKS_ID);
} else {
    nlohmann::json deck = mDropDownDecks[position - 1];
    try {
        mRestrictOnDeck = ""deck:\"""" + deck.at(""name"").get<std::string>() + ""\"" "";
        saveLastDeckId(deck.at(""id"").get<long long>());
    } catch (const nlohmann::json::exception&) {
        throw std::runtime_error("""");
    }
}
searchCards();","```cpp
mActionBarSpinner->setSelection(position);
if (position == 0) {
    mRestrictOnDeck = """";
    saveLastDeckId(ALL_DECKS_ID);
} else {
    nlohmann::json deck = mDropDownDecks[position - 1];
    try {
        mRestrictOnDeck = ""deck:\"""" + deck.at(""name"").get<std::string>() + ""\"" "";
        saveLastDeckId(deck.at(""id"").get<int64_t>());
    } catch (const nlohmann::json::exception&) {
        throw std::runtime_error(""JSON exception"");
    }
}
searchCards();
```",1
"#include <memory>
#include <vector>
#include <string>
#include <cstdint>
#include ""FileLinesVisitor.h""
#include ""SyntaxHighlighterVisitor.h""
#include ""CollectionUtils.h""
#include ""SonarJavaIssueFilter.h""
#include ""JParserConfig.h""
#include ""VisitorsBridge.h""
#include ""JavaCheck.h""
#include ""JavaResourceLocator.h""
#include ""JavaVersion.h""
#include ""ListUtils.h""
#include ""PerformanceMeasure.h""
#include ""Loggers.h""

class JavaFrontend {
public:
    static const int64_t MAX_BATCH_SIZE;

private:
    static Logger LOG;
    static constexpr const char* BATCH_ERROR_MESSAGE = ""Batch Mode failed, analysis of Java Files stopped."";

    JavaVersion javaVersion;
    SonarComponents sonarComponents;

public:
    // ...
};

const int64_t JavaFrontend::MAX_BATCH_SIZE = static_cast<int64_t>(Runtime::getRuntime().totalMemory() * 0.1);
Logger JavaFrontend::LOG = Loggers::get(typeid(JavaFrontend));","#include <vector>
#include <memory>
#include <string>
#include <cstdint>

class JavaFrontend {
public:
    static constexpr std::int64_t MAX_BATCH_SIZE = static_cast<std::int64_t>(Runtime::getRuntime().totalMemory() * 0.1);

private:
    static Logger LOG;
    static constexpr const char* BATCH_ERROR_MESSAGE = ""Batch Mode failed, analysis of Java Files stopped."";

    JavaVersion javaVersion;
    SonarComponents sonarComponents;
};",1
"#include <regex>
#include <string>
#include <memory>
#include <vector>

static const std::string JAVA_UTIL_REGEX_MATCHER = ""java.util.regex.Matcher"";

static const std::regex GROUP_NUMBER_REPLACEMENT_REGEX(R""((?<!\\)\$(?<number>\d+))"");
static const std::regex GROUP_NAME_REPLACEMENT_REGEX(R""((?<!\\)\$\{(?<name>[A-Za-z][0-9A-Za-z]*)\})"");

class MethodMatchers {
public:
    static constexpr const char* ANY = ""*"";

    // Factory methods as per the Java builder pattern.
    static MethodMatchers create() {
        return MethodMatchers();
    }

    MethodMatchers& ofTypes(const std::string& type) {
        types_.push_back(type);
        return *this;
    }

    MethodMatchers& names(const std::string& name) {
        names_.push_back(name);
        return *this;
    }

    MethodMatchers& names(const std::initializer_list<std::string>& names) {
        names_.insert(names_.end(), names.begin(), names.end());
        return *this;
    }

    MethodMatchers& addParametersMatcher(const std::string& param) {
        parameterMatchers_.emplace_back(std::vector<std::string>{param});
        return *this;
    }

    MethodMatchers& addParametersMatcher(const char* param) {
        parameterMatchers_.emplace_back(std::vector<std::string>{param});
        return *this;
    }

    // Overload for multiple parameters
    MethodMatchers& addParametersMatcher(const std::string& param1, const std::string& param2) {
        parameterMatchers_.emplace_back(std::vector<std::string>{param1, param2});
        return *this;
    }

    MethodMatchers build() {
        return *this;
    }

    static MethodMatchers or_(const MethodMatchers& a, const MethodMatchers& b, const MethodMatchers& c) {
        MethodMatchers m;
        m.orMatchers_.push_back(a);
        m.orMatchers_.push_back(b);
        m.orMatchers_.push_back(c);
        return m;
    }

private:
    std::vector<std::string> types_;
    std::vector<std::string> names_;
    std::vector<std::vector<std::string>> parameterMatchers_;
    std::vector<MethodMatchers> orMatchers_;
};

static const MethodMatchers MATCHER_GROUP = MethodMatchers::or_(
    MethodMatchers::create()
        .ofTypes","#include <regex>
#include <string>
#include <memory>
#include <vector>

static const std::regex GROUP_NUMBER_REPLACEMENT_REGEX(R""((?<!\\)\$(?<number>\d+))"");
static const std::regex GROUP_NAME_REPLACEMENT_REGEX(R""((?<!\\)\$\{(?<name>[A-Za-z][0-9A-Za-z]*)\})"");

class MethodMatchers {
public:
    using Ptr = std::shared_ptr<MethodMatchers>;

    static Ptr create() {
        return std::make_shared<MethodMatchers>();
    }

    MethodMatchers& ofTypes(const std::string& type) {
        types.push_back(type);
        return *this;
    }

    MethodMatchers& names(const std::string& name) {
        namesVec.push_back(name);
        return *this;
    }

    MethodMatchers& names(const std::initializer_list<std::string>& nameList) {
        namesVec.insert(namesVec.end(), nameList.begin(), nameList.end());
        return *this;
    }

    MethodMatchers& addParametersMatcher(const std::string& param) {
        params.push_back(param);
        return *this;
    }

    static Ptr orList(const std::vector<Ptr>& matchers) {
        auto result = std::make_shared<MethodMatchers>();
        result->alternatives = matchers;
        return result;
    }

    template <typename... Ptrs>
    static Ptr orMatchers(Ptrs... ptrs) {
        return orList({ptrs...});
    }

    static const std::string ANY;

private:
    std::vector<std::string> types;
    std::vector<std::string> namesVec;
    std::vector<std::string> params;
    std::vector<Ptr> alternatives;
};
const std::string MethodMatchers::ANY = ""*"";

static const auto MATCHER_GROUP = MethodMatchers::orMatchers(
    MethodMatchers::create()
        ->ofTypes(""java.util.regex.Matcher"")
        .names(""group"")
        .addParametersMatcher(""java.lang.String"")
        .addParametersMatcher(""int""),
    MethodMatchers::create()
        ->ofTypes(""java.util.regex.Matcher"")
        .names(""appendReplacement"")
        .addParametersMatcher(MethodMatchers::ANY)
        .addParametersMatcher(MethodMatchers::ANY),
    MethodMatchers::create()
        ->ofTypes(""java.util.regex.Matcher"")
        .names({""replaceAll"", ""replaceFirst""})
        .addParametersMatcher(MethodMatchers::ANY)
);",1
void start() override {,"void start() override {
}",0
"```cpp
std::string commitFile = basePath + ""/"" + HoodieTableMetaClient::AUXILIARYFOLDER_NAME + ""/"" + instant.getFileName();
std::shared_ptr<FileSystem> fs = FSUtils::getFs(basePath, configuration);
{
    std::unique_ptr<FSDataOutputStream> os = fs->create(commitFile, true);
    HoodieCompactionPlan workload = HoodieCompactionPlan::newBuilder().setVersion(1).build();
    os->write(TimelineMetadataUtils::serializeCompactionPlan(workload).get());
}
```","std::filesystem::path commitFile = std::filesystem::path(basePath) / HoodieTableMetaClient::AUXILIARYFOLDER_NAME / instant.getFileName();
auto fs = FSUtils::getFs(basePath, configuration);
{
    auto os = fs->create(commitFile.string(), true);
    auto workload = HoodieCompactionPlan::newBuilder().setVersion(1).build();
    auto data = TimelineMetadataUtils::serializeCompactionPlan(workload).get();
    os->write(reinterpret_cast<const char*>(data.data()), data.size());
}",1
"std::vector<SocketPortAllocation>* serverSocketPorts;
{
    std::lock_guard<std::mutex> lock(hostServerSocketPortsMapMutex);
    auto it = hostServerSocketPortsMap.find(hostname);
    if (it == hostServerSocketPortsMap.end()) {
        auto newList = std::make_unique<std::vector<SocketPortAllocation>>();
        serverSocketPorts = newList.get();
        hostServerSocketPortsMap[hostname] = std::move(newList);
    } else {
        serverSocketPorts = it->second.get();
    }
}
SocketPortAllocation* socketPortAllocation = nullptr;
int maxPort = portRangeStart - 1;
for (size_t index = 0; index < serverSocketPorts->size(); ++index) {
    SocketPortAllocation& spa = (*serverSocketPorts)[index];
    if (spa.getPort() > maxPort) {
        maxPort = spa.getPort();
    }
    {
        std::lock_guard<std::mutex> lock(spa.mutex());
        if (spa.getClusterRunId().equalsIgnoreCase(clusteredRunId) &&
            spa.getSourceSlaveName().equalsIgnoreCase(sourceSlaveName) &&
            spa.getTargetSlaveName().equalsIgnoreCase(targetSlaveName) &&
            spa.getTransformationName().equalsIgnoreCase(transformationName)) {
            // ... rest of logic ...
        }
    }
}","if (targetSteps.empty()) {
    throw std::runtime_error(""A server socket allocation always has to accompanied by a target step copy but it was empty"");
}

std::vector<std::shared_ptr<SocketPortAllocation>>& serverSocketPorts = 
    hostServerSocketPortsMap[hostname];
    
SocketPortAllocation* socketPortAllocation = nullptr;
int maxPort = portRangeStart - 1;
for (size_t index = 0; index < serverSocketPorts.size(); ++index) {
    auto& spa = serverSocketPorts[index];
    if (spa->getPort() > maxPort) {
        maxPort = spa->getPort();
    }

    std::lock_guard<std::mutex> lock(spa->mutex());
    if (equalsIgnoreCase(spa->getClusterRunId(), clusteredRunId) &&
        equalsIgnoreCase(spa->getSourceSlaveName(), sourceSlaveName) &&
        equalsIgnoreCase(spa->getTargetSlaveName(), targetSlaveName) &&
        equalsIgnoreCase(spa->getTransformationName(), transformationName)) {
        // ...
    }
}",1
"if (!isFileSliceNeededForPendingCompaction(nextSlice)) {
    if (nextSlice.getDataFile().has_value()) {
        const auto& dataFile = nextSlice.getDataFile().value();
        deletePaths.push_back(dataFile.getPath());
    }
    if (hoodieTable.getMetaClient().getTableType() == HoodieTableType::MERGE_ON_READ) {
        // If merge on read, then clean the log files for the commits as well","if (!isFileSliceNeededForPendingCompaction(nextSlice)) {
    if (nextSlice.getDataFile().has_value()) {
        const HoodieDataFile& dataFile = nextSlice.getDataFile().value();
        deletePaths.push_back(dataFile.getPath());
    }
    if (hoodieTable.getMetaClient().getTableType() == HoodieTableType::MERGE_ON_READ) {
        // If merge on read, then clean the log files for the commits as well
    }
}",1
"{
    std::vector<uint8_t> bytes;

    if (auto p = dynamic_cast<std::vector<uint8_t>*>(src)) {
        bytes = *p;
    } else {
        bytes = static_cast<std::vector<uint8_t>>(super::doTransform(src, encoding));
    }

    try
    {","```cpp
#include <vector>
#include <any>
#include <typeinfo>

class FileToByteArray {
public:
    virtual std::vector<uint8_t> doTransform(const std::any& src, const std::string& encoding) {
        // implementation placeholder
        return {};
    }
};

class FileToString : public FileToByteArray {
public:
    std::vector<uint8_t> doTransform(const std::any& src, const std::string& encoding) override
    {
        std::vector<uint8_t> bytes;

        if (src.type() == typeid(std::vector<uint8_t>))
        {
            bytes = std::any_cast<std::vector<uint8_t>>(src);
        }
        else
        {
            bytes = FileToByteArray::doTransform(src, encoding);
        }

        try
        {
            //...
        }
        catch (...)
        {
            //...
        }

        return bytes;
    }
};
```",0
"#include <functional>
#include <vector>

class DesignOptionNamePromptEventArgs {};

class WorkspaceModel {};

class MyClass {
public:
    using DesignOptionNamePromptHandler = std::function<void(DesignOptionNamePromptEventArgs)>;
    using WorkspaceHandler = std::function<void(WorkspaceModel)>;

    void addRequestDesignOptionNamePromptHandler(const DesignOptionNamePromptHandler& handler) {
        requestDesignOptionNamePromptHandlers.push_back(handler);
    }

    void OnRequestsDesignOptionNamePrompt(DesignOptionNamePromptEventArgs e) {
        for (auto& handler : requestDesignOptionNamePromptHandlers) {
            handler(e);
        }
    }

    void addWorkspaceSavedHandler(const WorkspaceHandler& handler) {
        workspaceSavedHandlers.push_back(handler);
    }

    void OnWorkspaceSaved(WorkspaceModel model) {
        for (auto& handler : workspaceSavedHandlers) {
            handler(model);
        }
    }

private:
    std::vector<DesignOptionNamePromptHandler> requestDesignOptionNamePromptHandlers;
    std::vector<WorkspaceHandler> workspaceSavedHandlers;
};","public:
    std::function<void(DesignOptionNamePromptEventArgs&)> RequestDesignOptionNamePrompt;

    void OnRequestsDesignOptionNamePrompt(DesignOptionNamePromptEventArgs& e)
    {
        if (RequestDesignOptionNamePrompt)
            RequestDesignOptionNamePrompt(e);
    }

    std::function<void(WorkspaceModel&)> WorkspaceSaved;

protected:
    void OnWorkspaceSaved(WorkspaceModel& model)
    {",1
"#include <hudi/common/model/HoodieCommitMetadata.h>
#include <hudi/common/model/HoodieRecord.h>
#include <hudi/common/model/HoodieRecordPayload.h>
#include <hudi/common/model/HoodieTableType.h>
#include <hudi/common/model/WriteOperationType.h>
#include <hudi/common/table/HoodieTableMetaClient.h>
#include <hudi/common/table/timeline/HoodieActiveTimeline.h>
#include <hudi/common/table/timeline/HoodieInstant.h>
#include <hudi/common/table/timeline/HoodieTimeline.h>
#include <hudi/common/util/CommitUtils.h>
#include <hudi/common/util/Option.h>
#include <hudi/common/util/ReflectionUtils.h>
#include <hudi/common/util/ValidationUtils.h>
#include <hudi/common/util/collection/Pair.h>
#include <hudi/config/HoodieClusteringConfig.h>
#include <hudi/config/HoodieCompactionConfig.h>
#include <hudi/config/HoodiePayloadConfig.h>
#include <hudi/config/HoodieWriteConfig.h>","#include ""FSUtils.h""
#include ""HoodieCommitMetadata.h""
#include ""HoodieRecord.h""
#include ""HoodieRecordPayload.h""
#include ""HoodieTableType.h""
#include ""WriteOperationType.h""
#include ""HoodieTableMetaClient.h""
#include ""HoodieActiveTimeline.h""
#include ""HoodieInstant.h""
#include ""HoodieTimeline.h""
#include ""CommitUtils.h""
#include ""Option.h""
#include ""ReflectionUtils.h""
#include ""ValidationUtils.h""
#include ""Pair.h""
#include ""HoodieClusteringConfig.h""
#include ""HoodieCompactionConfig.h""
#include ""HoodiePayloadConfig.h""
#include ""HoodieWriteConfig.h""",0
"ClassGenerator& addField(const std::string& code)
{
    if (!mFields)
        mFields = std::make_unique<std::vector<std::string>>();
    mFields->push_back(code);
    return *this;
}","ClassGenerator& addField(const std::string& code)
{
    if (mFields == nullptr)
        mFields = new std::vector<std::string>();
    mFields->push_back(code);
    return *this;
}",0
"template <typename T>
MetadataResult<T> mergeFailures(const T& descriptor, const std::vector<MetadataResultBase*>& results)
{
    std::vector<const MetadataResultBase*> failedResults;
    for (auto& result : results) {
        if (!result->isSuccess()) {
            failedResults.push_back(result);
        }
    }

    std::string messages;
    for (size_t i = 0; i < failedResults.size(); ++i) {
        auto failure = failedResults[i]->getFailure().value();
        if (i != 0) messages += "" and "";
        messages += failure.getMessage();
    }

    std::string stackTrace = """";
    FailureCode failureCode = FailureCode::MULTIPLE;
    if (failedResults.size() == 1) {
        auto failure = results[0]->getFailure().value();
        stackTrace = failure.getReason();
        failureCode = failure.getFailureCode();
    }

    return failure(descriptor, messages, failureCode, stackTrace);
}","template <typename T>
MetadataResult<T> mergeFailures(T descriptor, std::initializer_list<MetadataResultBase*> results)
{
    std::vector<MetadataResultBase*> failedResults;
    for (auto result : results) {
        if (!result->isSuccess()) {
            failedResults.push_back(result);
        }
    }
    std::string messages;
    for (size_t i = 0; i < failedResults.size(); ++i) {
        if (i != 0) messages += "" and "";
        messages += failedResults[i]->getFailure()->getMessage();
    }
    std::string stackTrace = (failedResults.size() == 1) ? failedResults[0]->getFailure()->getReason() : """";
    FailureCode failureCode = (failedResults.size() == 1) ? failedResults[0]->getFailure()->getFailureCode() : FailureCode::MULTIPLE;
    return failure(descriptor, messages, failureCode, stackTrace);
}",0
"}).getType()))
    .defaultingTo(""#[payload]"")
    .withExpressionSupport(REQUIRED)
    .describedAs(""Expression that defines the collection to iterate over."");

forEach.onDefaultParameterGroup()
    .withOptionalParameter(""batchSize"")
    .ofType(typeLoader.load(typeid(int)))
    .withExpressionSupport(NOT_SUPPORTED)
    .describedAs(""Partitions the collection in sub-collections of the specified size."");

forEach.onDefaultParameterGroup()
    .withOptionalParameter(""rootMessageVariableName"")
    .ofType(typeLoader.load(typeid(std::string)))
    .defaultingTo(""rootMessage"")
    .withExpressionSupport(NOT_SUPPORTED)
    .describedAs(""Variable name for the original message."");

forEach.onDefaultParameterGroup()
    .withOptionalParameter(""counterVariableName"")
    .ofType(typeLoader.load(typeid(std::string)))
    .defaultingTo(""counter"")
    .withExpressionSupport(NOT_SUPPORTED)
    .describedAs(""Variable name for the item number being processed."");

}

void declareUntilSuccessful(ExtensionDeclarer& extensionDeclarer, ClassTypeLoader& typeLoader) {
    ConstructDeclarer untilSuccessful = extensionDeclarer.withConstruct(""untilSuccessful"")
        .describedAs(
            ""Attempts to route a message to the message processor it contains in an asynchronous manner. ""
            ""Routing is considered successful if no error has been raised and, optionally, if the response matches an expression.""
        );

    untilSuccessful.withChain();
}","```cpp
class MuleExtensionModelDeclarer {
public:
    void declareForEach(ExtensionDeclarer& extensionDeclarer, ClassTypeLoader& typeLoader) {
        auto& forEach = extensionDeclarer.withConstruct(""forEach"")
            .describedAs(""Iterates over a collection and executes the child processors for each element."");

        forEach.onDefaultParameterGroup()
            .withRequiredParameter(""collection"")
            .ofType(typeLoader.load<SomeType>())
            .defaultingTo(""#[payload]"")
            .withExpressionSupport(REQUIRED)
            .describedAs(""Expression that defines the collection to iterate over."");

        forEach.onDefaultParameterGroup()
            .withOptionalParameter(""batchSize"")
            .ofType(typeLoader.load<int>())
            .withExpressionSupport(NOT_SUPPORTED)
            .describedAs(""Partitions the collection in sub-collections of the specified size."");

        forEach.onDefaultParameterGroup()
            .withOptionalParameter(""rootMessageVariableName"")
            .ofType(typeLoader.load<std::string>())
            .defaultingTo(""rootMessage"")
            .withExpressionSupport(NOT_SUPPORTED)
            .describedAs(""Variable name for the original message."");

        forEach.onDefaultParameterGroup()
            .withOptionalParameter(""counterVariableName"")
            .ofType(typeLoader.load<std::string>())
            .defaultingTo(""counter"")
            .withExpressionSupport(NOT_SUPPORTED)
            .describedAs(""Variable name for the item number being processed."");

    }

    void declareUntilSuccessful(ExtensionDeclarer& extensionDeclarer, ClassTypeLoader& typeLoader) {
        auto& untilSuccessful = extensionDeclarer.withConstruct(""untilSuccessful"")
            .describedAs(""Attempts to route a message to the message processor it contains in an asynchronous manner. ""
                         ""Routing is considered successful if no error has been raised and, optionally, if the response matches an expression."");

        untilSuccessful.withChain();
    }
};
```",0
".serialize(nullptr, os).writeObject(result.getValue());
    return RpcResult(os.toByteArray());
} catch (const IOException& e) {
    throw RpcException(
        std::string(""Generic serialization ["") +
        Constants::GENERIC_SERIALIZATION_NATIVE_JAVA +
        ""] serialize result failed."", e);
}
} else if (ProtocolUtils::isBeanGenericSerialization(generic)) {
    return RpcResult(JavaBeanSerializeUtil::serialize(result.getValue(), JavaBeanAccessor::METHOD));
} else if (ProtocolUtils::isProtobufGenericSerialization(generic)) {
    try {
        UnsafeByteArrayOutputStream os(512);
        ExtensionLoader::getExtensionLoader<Serialization>()
            .getExtension(Constants::GENERIC_SERIALIZATION_PROTOBUF)
            .serialize(nullptr, os).writeObject(result.getValue());
        return RpcResult(os.toString());
    } catch (const IOException& e) {
        throw RpcException(
            std::string(""Generic serialization ["") +
            Constants::GENERIC_SERIALIZATION_PROTOBUF +
            ""] serialize result failed."", e);
    }
} else {
    return RpcResult(PojoUtils::generalize(result.getValue()));
}","```cpp
if (ProtocolUtils::isNativeJavaGenericSerialization(generic)) {
    try {
        UnsafeByteArrayOutputStream os(512);
        ExtensionLoader::getExtensionLoader<Serialization>()
            .getExtension(Constants::GENERIC_SERIALIZATION_NATIVE_JAVA)
            ->serialize(nullptr, os)->writeObject(result.getValue());
        return RpcResult(os.toByteArray());
    } catch (const IOException& e) {
        throw RpcException(
            std::string(""Generic serialization ["") +
            Constants::GENERIC_SERIALIZATION_NATIVE_JAVA +
            ""] serialize result failed."", e
        );
    }
} else if (ProtocolUtils::isBeanGenericSerialization(generic)) {
    return RpcResult(JavaBeanSerializeUtil::serialize(result.getValue(), JavaBeanAccessor::METHOD));
} else if (ProtocolUtils::isProtobufGenericSerialization(generic)) {
    try {
        UnsafeByteArrayOutputStream os(512);
        ExtensionLoader::getExtensionLoader<Serialization>()
            .getExtension(Constants::GENERIC_SERIALIZATION_PROTOBUF)
            ->serialize(nullptr, os)->writeObject(result.getValue());
        return RpcResult(os.toString());
    } catch (const IOException& e) {
        throw RpcException(
            std::string(""Generic serialization ["") +
            Constants::GENERIC_SERIALIZATION_PROTOBUF +
            ""] serialize result failed."", e
        );
    }
} else {
    return RpcResult(PojoUtils::generalize(result.getValue()));
}
```",0
"protected:
VariableResolverFactory* createVariableVariableResolverFactory(MuleEvent* event)
{
    if (autoResolveVariables)
    {
        return new VariableVariableResolverFactory(parserConfiguration, muleContext, event);
    }
    else
    {
        return nullptr;
    }
}","protected:
    VariableVariableResolverFactory* createVariableVariableResolverFactory(MuleEvent* event)
    {
        if (autoResolveVariables)
        {
            return new VariableVariableResolverFactory(parserConfiguration, muleContext, event);
        }
        else
        {
            return nullptr;
        }
    }",1
"#include <avro/ValidSchema.hh>
#include <avro/Generic.hh>
#include <fstream>
#include <filesystem>
#include <memory>
#include <spdlog/spdlog.h>","#include <avro/Schema.hh>
#include <avro/Generic.hh>
#include <hdfs/hdfs.h>
#include <log4cxx/logger.h>",0
"```cpp
int _cntFnRev(long long did, int lim) {
    std::string query = ""SELECT count() FROM (SELECT id FROM cards WHERE did = "" + std::to_string(did) + "" AND queue = 2 and due <= "" + std::to_string(mToday);
    return mCol.getDb().queryScalar(query);
}
```","```cpp
private:
    // Dynamically invoked in _walkingCount, passed as a parameter in _resetRevCount
    int _cntFnRev(int64_t did, int lim) {
        return mCol.getDb().queryScalar(
            ""SELECT count() FROM (SELECT id FROM cards WHERE did = "" + std::to_string(did) + "" AND queue = 2 and due <= "" + std::to_string(mToday)
        );
    }
```",0
"#include <string>

class Config {
public:
    static const std::string DEFAULT_DFS_SOURCE_PROPERTIES;
};

const std::string Config::DEFAULT_DFS_SOURCE_PROPERTIES = std::string(""file://"") +
    std::filesystem::current_path().string() +
    ""/src/test/resources/delta-streamer-config/dfs-source.properties"";","#include <string>
#include <cstdlib>

class HoodieDeltaStreamer {
public:
    struct Config {
        static const std::string DEFAULT_DFS_SOURCE_PROPERTIES;
    };
};

const std::string HoodieDeltaStreamer::Config::DEFAULT_DFS_SOURCE_PROPERTIES =
    std::string(""file://"") +
    std::getenv(""PWD"") +
    ""/src/test/resources/delta-streamer-config/dfs-source.properties"";",0
"IPC::logMessage(""startAgent"");
if (MethodRefsHolder::startRemoteManagementAgentMethod != nullptr) {
    auto startArgument = std::string{};
#if defined(Sidecar19_SE_B165) || defined(Sidecar18_SE_OpenJ9)
    for (auto it = agentProperties.begin(); it != agentProperties.end(); ++it) {
        if (!startArgument.empty()) startArgument += "","";
        startArgument += it->first + ""="" + it->second;
    }
#else
    auto& startArgument = agentProperties;
#endif
    MethodRefsHolder::startRemoteManagementAgentMethod->invoke(nullptr, startArgument);
    return true;
}","if (MethodRefsHolder::startRemoteManagementAgentMethod != nullptr) {
    IPC::logMessage(""startAgent"");
    auto startArgument = std::string{};
#if defined(SIDECAR19_SE_B165) || defined(SIDECAR18_SE_OPENJ9)
    bool first = true;
    for (const auto& entry : agentProperties) {
        if (!first) {
            startArgument += "","";
        }
        startArgument += entry.first + ""="" + entry.second;
        first = false;
    }
#else
    auto& startArgument = agentProperties;
#endif
    MethodRefsHolder::startRemoteManagementAgentMethod->invoke(nullptr, startArgument);
    return true;
}",1
"class IdentityConverter : public Converter<Object, Object, Object, Object> {
public:
    Object convertSchema(const Object& inputSchema, WorkUnitState& workUnit) override {
        return inputSchema;
    }
};","class IdentityConverter : public Converter<Object, Object, Object, Object> {
public:
    Object convertSchema(Object inputSchema, WorkUnitState workUnit) override {
        return inputSchema;
    }
};",0
"#include <stdexcept>
#include <string>
#include <map>
#include <unordered_map>
#include <vector>","#include <stdexcept>
#include <string>
#include <map>
#include <unordered_map>
#include <vector>

class ConnectionException : public std::runtime_error {
public:
    using std::runtime_error::runtime_error;
};

enum class Method {
    GET,
    POST,
    PUT,
    DELETE,
    PATCH,
    // add other methods as needed
};

class HttpService {};
class HttpServer {};
class HttpServerConfiguration {};
class HttpServerFactory {};

class RequestHandler {};
class RequestHandlerManager {};
class ServerAddress {};

using Collection = std::vector<std::string>;

using HashMap = std::map<std::string, std::string>;
using ConcurrentHashMap = std::unordered_map<std::string, std::string>;",0
"routerChain.setInvokers(newInvokers);
this->invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;
this->urlInvokerMap = newUrlInvokerMap;","this->invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;
this->urlInvokerMap = newUrlInvokerMap;",0
"}

void rescheduleWithoutValidation(const std::vector<long>& selectedCardIds, int newDays) {
    CollectionTask::launchCollectionTask(
        DISMISS_MULTI,
        rescheduleCardHandler(),
        TaskData({selectedCardIds, Collection::DismissType::RESCHEDULE_CARDS, newDays})
    );
}


void showChangeDeckDialog() {
    if (!hasSelectedCards()) {
        Timber::i(""Not showing Change Deck - No Cards"");","void rescheduleWithoutValidation(const std::vector<long>& selectedCardIds, std::optional<int> newDays) {
    CollectionTask::launchCollectionTask(
        DISMISS_MULTI,
        rescheduleCardHandler(),
        TaskData({selectedCardIds, Collection::DismissType::RESCHEDULE_CARDS, newDays})
    );
}",0
"```cpp
if (isFailOnTimeout())
{
    MuleEvent messageCollectionEvent = group.getMessageCollectionEvent();
    muleContext.fireNotification(RoutingNotification(messageCollectionEvent.getMessage(), nullptr,
                                                    RoutingNotification::CORRELATION_TIMEOUT));
    try
    {
        group.clear();
```","if (isFailOnTimeout())
{
    MuleEvent* messageCollectionEvent = group.getMessageCollectionEvent();
    muleContext.fireNotification(RoutingNotification(messageCollectionEvent->getMessage(), nullptr, RoutingNotification::CORRELATION_TIMEOUT));
    try
    {
        group.clear();
    }
    // Exception handling as per your framework (if needed)
}",1
"#include <stdexcept>
#include <type_traits>

namespace org {
namespace mule {
namespace module {
namespace extension {
namespace internal {
namespace runtime {

using org::mule::extension::introspection::declaration::fluent::OperationExecutorFactory;
using org::mule::extension::runtime::OperationExecutor;

inline void createStaticMessage(const std::string& message) {
    throw std::runtime_error(message);
}

template<typename T>
inline bool isVoid() {
    return std::is_void<T>::value;
}

inline void checkArgument(bool condition, const std::string& message) {
    if (!condition) {
        throw std::invalid_argument(message);
    }
}

class MuleRuntimeException : public std::runtime_error {
public:
    explicit MuleRuntimeException(const std::string& msg) : std::runtime_error(msg) {}
};

} // namespace runtime
} // namespace internal
} // namespace extension
} // namespace module
} // namespace mule
} // namespace org","#include ""IntrospectionUtils.h""
#include ""Preconditions.h""
#include ""OperationExecutorFactory.h""
#include ""OperationExecutor.h""
#include ""MuleRuntimeException.h""",0
"void runJob(const Properties& jobProps, JobListener* jobListener) {
    try {
        runJob(jobProps, jobListener, JobLauncherFactory::newJobLauncher(this->properties, jobProps));
    } catch (const std::exception& e) {","void runJob(const Properties& jobProps, JobListener* jobListener) {
    try {
        runJob(jobProps, jobListener, JobLauncherFactory::newJobLauncher(this->properties, jobProps));
    } catch (const std::exception& e) {
        throw JobException(e.what());
    }
}",0
"#include <vector>
#include <array>
#include <string>
#include <algorithm>
#include <iterator>

#include ""OpenTelemetry.h""
#include ""GlobalMeterProvider.h""
#include ""Meter.h""
#include ""SpanKind.h""
#include ""StatusCode.h""
#include ""TextMapGetter.h""
#include ""TextMapSetter.h""
#include ""UnstableApi.h""
#include ""Config.h""
#include ""DbAttributesExtractor.h""
#include ""HttpAttributesExtractor.h""
#include ""MessagingAttributesExtractor.h""
#include ""RpcAttributesExtractor.h""","#include <cassert>
#include <memory>
#include <string>
#include <vector>
#include <algorithm>",0
"}
std::optional<std::string> extractRoute(const REQUEST& request) {
    if (auto httpExtractor = dynamic_cast<HttpServerAttributesExtractor<REQUEST, void>*>(attributesExtractor)) {
        return httpExtractor->route(request);
    }
    return std::nullopt;
}","template <typename REQUEST>
class HttpSpanNameExtractor : public SpanNameExtractor<REQUEST> {
public:
    std::string extract(REQUEST request) override {
        // ... existing code ...
        return ""HTTP request"";
    }

private:
    std::optional<std::string> extractRoute(REQUEST request) {
        if (auto serverExtractor = dynamic_cast<HttpServerAttributesExtractor<REQUEST, void>*>(attributesExtractor)) {
            return serverExtractor->route(request);
        }
        return std::nullopt;
    }

    AttributesExtractor<REQUEST>* attributesExtractor;
};",1
"std::optional<std::vector<std::string>> soapBodyParts = getSoapBodyParts(bindingOperation);

if (!soapBodyParts.has_value()) {
    throw InvalidWsdlException(
        ""No SOAP body defined in the WSDL for the specified operation, cannot check if the operation""
        "" requires input parameters. Cannot build a default body request for the specified operation ["" + operation + ""]"");
}

Message message = bindingOperation.getOperation().getInput().getMessage();
std::optional<Part> part = getSinglePart(soapBodyParts.value(), message);

if (!part.has_value()) {
    throw BadRequestException(
        format(REQUIRED_PARAMS_ERROR_MASK, operation,
               "" there is no single part in the input message""));
}

if (!part.value().getElementName()) {
    throw BadRequestException(
        format(REQUIRED_PARAMS_ERROR_MASK, operation,
               "" there is one message body part but no does not have an element defined""));
}

Part bodyPart = part.value();
if (isOperationWithRequiredParameters(loader, bodyPart)) {
    throw BadRequestException(format(REQUIRED_PARAMS_ERROR_MASK, operation, """"));
}","std::optional<std::vector<std::string>> soapBodyParts = getSoapBodyParts(bindingOperation);

if (!soapBodyParts.has_value()) {
    throw InvalidWsdlException(
        ""No SOAP body defined in the WSDL for the specified operation, cannot check if the operation""
        "" requires input parameters. Cannot build a default body request for the specified operation ["" + operation + ""]""
    );
}

Message message = bindingOperation.getOperation().getInput().getMessage();
std::optional<Part> part = getSinglePart(*soapBodyParts, message);

if (!part.has_value()) {
    throw BadRequestException(
        format(REQUIRED_PARAMS_ERROR_MASK, operation,
               "" there is no single part in the input message"")
    );
}

if (!part->getElementName()) {
    throw BadRequestException(
        format(REQUIRED_PARAMS_ERROR_MASK, operation,
               "" there is one message body part but no does not have an element defined"")
    );
}

Part bodyPart = *part;
if (isOperationWithRequiredParameters(loader, bodyPart)) {
    throw BadRequestException(format(REQUIRED_PARAMS_ERROR_MASK, operation, """"));
}",1
"#include <memory>
#include <vector>
#include <map>
#include <set>

#include ""State.h""
#include ""WorkUnitState.h""
#include ""ConfigurationKeys.h""
#include ""ForkOperatorUtils.h""
#include ""WriterUtils.h""

#include ""ParallelRunner.h""
#include ""Closer.h""","#include <vector>
#include <set>
#include <map>
#include <memory>
#include <string>
#include <utility>
#include <algorithm>",0
"this->extraMetadata = extraMetadata;
}

private:
int getCommitInfo() {
    auto lastCleanInstant = table.getActiveTimeline().getCleanerTimeline().filterCompletedInstants().lastInstant();
    auto commitTimeline = table.getActiveTimeline().getCommitTimeline().filterCompletedInstants();

    std::string latestCleanTs;
    int commitsSinceLastCleaning = 0;
    if (lastCleanInstant.isPresent()) {
        latestCleanTs = lastCleanInstant.get().getTimestamp();
        commitsSinceLastCleaning = commitTimeline.findInstantsAfter(latestCleanTs).countInstants();
    } else {
        std::string firstCommitTs = commitTimeline.firstInstant().get().getTimestamp();
        commitsSinceLastCleaning = commitTimeline.findInstantsAfterOrEquals(firstCommitTs, std::numeric_limits<int>::max()).countInstants();
    }

    return commitsSinceLastCleaning;
}

bool needCleaning(CleaningTriggerStrategy strategy) {
    bool cleaningNeeded;
    if (strategy == CleaningTriggerStrategy::NUM_COMMITS) {
        int numberOfCommits = getCommitInfo();
        int maxInlineCommitsForNextClean = config.getInlineCleaningMaxCommits();
        cleaningNeeded = numberOfCommits >= maxInlineCommitsForNextClean;
    } else {
        throw HoodieException(""Unsupported cleaning trigger strategy: "" + config.getInlineCleaningTriggerStrategy());
    }

    return cleaningNeeded;
}","private:
  int getCommitInfo() {
    auto lastCleanInstant = table.getActiveTimeline().getCleanerTimeline().filterCompletedInstants().lastInstant();
    auto commitTimeline = table.getActiveTimeline().getCommitTimeline().filterCompletedInstants();

    std::string latestCleanTs;
    int commitsSinceLastCleaning = 0;
    if (lastCleanInstant.has_value()) {
      latestCleanTs = lastCleanInstant.value().getTimestamp();
      commitsSinceLastCleaning = commitTimeline.findInstantsAfter(latestCleanTs).countInstants();
    } else {
      std::string firstCommitTs = commitTimeline.firstInstant().value().getTimestamp();
      commitsSinceLastCleaning = commitTimeline.findInstantsAfterOrEquals(firstCommitTs, std::numeric_limits<int>::max()).countInstants();
    }

    return commitsSinceLastCleaning;
  }

  bool needCleaning(CleaningTriggerStrategy strategy) {
    bool cleaningNeeded;
    if (strategy == CleaningTriggerStrategy::NUM_COMMITS) {
      int numberOfCommits = getCommitInfo();
      int maxInlineCommitsForNextClean = config.getInlineCleaningMaxCommits();
      cleaningNeeded = numberOfCommits >= maxInlineCommitsForNextClean;
    } else {
      throw HoodieException(""Unsupported cleaning trigger strategy: "" + config.getInlineCleaningTriggerStrategy());
    }

    return cleaningNeeded;
  }",1
"try {
    return std::regex(convertGlobToRegEx(s), flags);
} catch (const std::exception& e) {
    logger.info(""failing regex in glob"", e.what());
}
return std::regex();","```cpp
#include <regex>
#include <optional>
#include <string>

std::optional<std::regex> createRegex(const std::string& s, std::regex_constants::syntax_option_type flags) {
    try {
        return std::regex(convertGlobToRegEx(s), flags);
    } catch (const std::exception& e) {
        logger.info(""failing regex in glob"", e);
    }
    return std::nullopt;
}
```",0
"}
 
 
void onPause() override {
    ParentClass::onPause();
    getPreferenceScreen()->getSharedPreferences()->unregisterOnSharedPreferenceChangeListener(this);
}

void onResume() override {
    ParentClass::onResume();
    getPreferenceScreen()->getSharedPreferences()->registerOnSharedPreferenceChangeListener(this);

    auto preferences = AnkiDroidApp::getSharedPrefs(getBaseContext());
    std::string username = preferences->getString(""username"", """");
    if (username.empty()) {
        syncAccount->setSummary(R::string::sync_account_summ_logged_out);
    } else {
        syncAccount->setSummary(getString(R::string::sync_account_summ_logged_in, username));
    }
}


void updateListPreference(const std::string& key) {
    auto listpref = dynamic_cast<ListPreference*>(getPreferenceScreen()->findPreference(key));
    std::string entry;","#include <QSettings>
#include <QString>
#include <QObject>
#include <QVariant>

class Preferences : public PreferenceActivity, public OnSharedPreferenceChangeListener
{
public:
    using PreferenceActivity::PreferenceActivity;

protected:
    void onPause() override {
        PreferenceActivity::onPause();
        getPreferenceScreen()->getSharedPreferences()->unregisterOnSharedPreferenceChangeListener(this);
    }

    void onResume() override {
        PreferenceActivity::onResume();
        getPreferenceScreen()->getSharedPreferences()->registerOnSharedPreferenceChangeListener(this);

        QSettings* preferences = AnkiDroidApp::getSharedPrefs(this->getBaseContext());
        QString username = preferences->value(""username"", """").toString();
        if (username.isEmpty()) {
            syncAccount->setSummary(tr(""Logged out"")); // Replace with appropriate translation
        } else {
            syncAccount->setSummary(tr(""Logged in as %1"").arg(username)); // Replace with appropriate translation
        }
    }

private:
    void updateListPreference(const QString& key) {
        ListPreference* listpref = static_cast<ListPreference*>(getPreferenceScreen()->findPreference(key));
        QString entry;
        // ...
    }

    // Assume syncAccount is previously declared and set up properly,
    // as well as getPreferenceScreen(), getBaseContext(), etc.
};",1
"#include <memory>
#include <functional>","#include <memory>
#include <functional>",0
"std::vector<std::vector<AnalyzerMessage>> flows;

AnalyzerMessage(JavaCheck* check, const std::filesystem::path& file, int line, const std::string& message, int cost)
    : AnalyzerMessage(check, file, (line > 0 ? new TextSpan(line) : nullptr), message, cost)
{}

AnalyzerMessage(JavaCheck* check, const std::filesystem::path& file, TextSpan* textSpan, const std::string& message, int cost)
{
    // constructor implementation
}","#include <string>
#include <vector>
#include <memory>

class JavaCheck {};
class File {};
class TextSpan {
public:
    TextSpan(int line) {}
};

class AnalyzerMessage {
public:
    std::vector<std::vector<std::shared_ptr<AnalyzerMessage>>> flows;

    AnalyzerMessage(JavaCheck* check, File* file, int line, const std::string& message, int cost)
        : AnalyzerMessage(check, file, line > 0 ? std::make_shared<TextSpan>(line) : nullptr, message, cost)
    {}

    AnalyzerMessage(JavaCheck* check, File* file, std::shared_ptr<TextSpan> textSpan, const std::string& message, int cost)
    {
        // ...
    }
};",0
"#include <map>
#include <unordered_map>
#include <string>
#include <list>
#include <mutex>
#include <memory>
#include <atomic>

template <typename T>
class DagNode {};

template <typename T>
class Dag {};

class DagManagerThread {
public:
    std::map<std::shared_ptr<DagNode<std::string>>, std::shared_ptr<Dag<std::string>>> jobToDag;
    static std::unordered_map<std::string, std::atomic<int>> proxyUserToJobCount;
    static std::unordered_map<std::string, std::atomic<int>> requesterToJobCount;
    std::map<std::string, std::shared_ptr<Dag<std::string>>> dags;
    std::map<std::string, std::list<std::shared_ptr<DagNode<std::string>>>> dagToJobs;
};

std::unordered_map<std::string, std::atomic<int>> DagManagerThread::proxyUserToJobCount;
std::unordered_map<std::string, std::atomic<int>> DagManagerThread::requesterToJobCount;","```cpp
#include <map>
#include <unordered_map>
#include <string>
#include <list>
#include <mutex>

template<typename T>
class DagNode {};

template<typename T>
class Dag {};

class DagManagerThread {
private:
    std::map<DagNode<void>*, Dag<void>*> jobToDag;
    static std::unordered_map<std::string, int> proxyUserToJobCount;
    static std::unordered_map<std::string, int> requesterToJobCount;
    std::map<std::string, Dag<void>*> dags;
public:
    std::map<std::string, std::list<DagNode<void>*>> dagToJobs;
};
std::unordered_map<std::string, int> DagManagerThread::proxyUserToJobCount;
std::unordered_map<std::string, int> DagManagerThread::requesterToJobCount;
```",1
"auto partitionRecords = engineContext.parallelize(std::vector<HoodieRecord>{allPartitionRecord}, 1);
if (!partitionInfoList.empty()) {
    auto fileListRecords = engineContext.parallelize(partitionInfoList, partitionInfoList.size())
        .map([&](const PartitionInfo& partitionInfo) {
            auto fileNameToSizeMap = partitionInfo.getFileNameToSizeMap();
            // filter for files that are part of the completed commits
            std::map<std::string, long> validFileNameToSizeMap;
            for (const auto& fileSizePair : fileNameToSizeMap) {
                std::string commitTime = FSUtils::getCommitTime(fileSizePair.first);
                if (HoodieTimeline::compareTimestamps(commitTime, HoodieTimeline::LESSER_THAN_OR_EQUALS, createInstantTime)) {
                    validFileNameToSizeMap[fileSizePair.first] = fileSizePair.second;
                }
            }
            // Record which saves files within a partition
            return HoodieMetadataPayload::createPartitionFilesRecord(
                partitionInfo.getRelativePath().empty() ? NON_PARTITIONED_NAME : partitionInfo.getRelativePath(),
                Option<std::map<std::string, long>>::of(validFileNameToSizeMap),
                Option<void>::empty());
        });
    partitionRecords = partitionRecords.unionWith(fileListRecords);
}","std::vector<HoodieRecord> partitionRecords = engineContext.parallelize({allPartitionRecord}, 1);
if (!partitionInfoList.empty()) {
    std::vector<HoodieRecord> fileListRecords = engineContext.parallelize(partitionInfoList, partitionInfoList.size());
    std::transform(fileListRecords.begin(), fileListRecords.end(), fileListRecords.begin(), [&](const auto& partitionInfo) {
        const auto& fileNameToSizeMap = partitionInfo.getFileNameToSizeMap();
        std::map<std::string, long> validFileNameToSizeMap;
        for (const auto& fileSizePair : fileNameToSizeMap) {
            std::string commitTime = FSUtils::getCommitTime(fileSizePair.first);
            if (HoodieTimeline::compareTimestamps(commitTime, HoodieTimeline::LESSER_THAN_OR_EQUALS, createInstantTime)) {
                validFileNameToSizeMap[fileSizePair.first] = fileSizePair.second;
            }
        }
        return HoodieMetadataPayload::createPartitionFilesRecord(
            partitionInfo.getRelativePath().empty() ? NON_PARTITIONED_NAME : partitionInfo.getRelativePath(),
            Option<std::map<std::string, long>>::of(validFileNameToSizeMap),
            Option<void>::empty()
        );
    });
    partitionRecords.insert(partitionRecords.end(), fileListRecords.begin(), fileListRecords.end());
}",1
#include <cassert>,"#include ""StandardEvaluationContext.h""
#include ""StandardTypeConverter.h""
#include ""IntegrationContextUtils.h""
#include ""CompositePropertyAccessor.h""
#include ""IntegrationUtils.h""
#include ""Assert.h""",0
"#include <atomic>
#include <mutex>
#include <condition_variable>

std::atomic<bool> awaited{false};

std::atomic<BootstrapTakeoverState> bootstrapTakeoverState{BootstrapTakeoverState::AUTO};

std::mutex lock;

std::condition_variable condition;","#include <atomic>
#include <mutex>
#include <condition_variable>

class DubboBootstrap {
private:
    std::atomic<bool> awaited{false};

    enum class BootstrapTakeoverState { AUTO };
    std::atomic<BootstrapTakeoverState> bootstrapTakeoverState{BootstrapTakeoverState::AUTO};

    std::mutex mtx;
    std::condition_variable_any condition;
};",1
"class BytecodeCompleter : public JavaSymbol::Completer {
public:
    static const int ASM_API_VERSION = Opcodes::ASM7_EXPERIMENTAL;

private:
    Symbols* symbols;
    ParametrizedTypeCache parametrizedTypeCache;
    SquidClassLoader classLoader;
};","#include <memory>

class BytecodeCompleter {
public:
    static constexpr int ASM_API_VERSION = 7; // Assuming ASM7_EXPERIMENTAL resolves to 7

private:
    Symbols symbols;
    ParametrizedTypeCache parametrizedTypeCache;
    std::shared_ptr<SquidClassLoader> classLoader;
};",1
"const ServletRequest* request,
const ServletResponse* response,
const std::exception* throwable,
const Span* span,
const Scope* scope) {
    if (scope == nullptr) {
        return;
    }
    scope->close();

    if (auto httpRequest = dynamic_cast<const HttpServletRequest*>(request)) {
        if (auto httpResponse = dynamic_cast<const HttpServletResponse*>(response)) {
            TRACER.setPrincipal(span, httpRequest);

            if (span == nullptr) {
                return;
            }

            const int* responseStatus =
                InstrumentationContext::get<ServletResponse, int>().get(response);

            if (throwable == nullptr) {","```cpp
void onExit(
    ServletRequest* request,
    ServletResponse* response,
    const std::exception* throwable,
    const Span* span,
    const Scope* scope) 
{
    if (scope == nullptr) {
        return;
    }
    scope->close();

    if (auto httpRequest = dynamic_cast<HttpServletRequest*>(request)) {
        if (auto httpResponse = dynamic_cast<HttpServletResponse*>(response)) {
            TRACER.setPrincipal(span, httpRequest);

            if (span == nullptr) {
                return;
            }

            const int* responseStatus =
                InstrumentationContext::get<ServletResponse, int>(response);

            if (throwable == nullptr) {
                // ...
            }
        }
    }
}
```",1
"auto endpoint = HttpServerTest::ServerEndpoint::forPath(req.getServletPath());
HttpServerTest::controller(
    endpoint,
    [&] {
        resp.setContentType(""text/plain"");
        resp.setStatus(endpoint.getStatus());
        resp.getWriter().print(req.getQueryString());
        return nullptr;
    }
);","```cpp
class TestServlets {
public:
    void handleRequest(Request& req, Response& resp) {
        auto endpoint = HttpServerTest::ServerEndpoint::forPath(req.getServletPath());
        HttpServerTest::controller(
            endpoint,
            [&]() -> void* {
                resp.setContentType(""text/plain"");
                resp.setStatus(endpoint.getStatus());
                resp.getWriter().print(req.getQueryString());
                return nullptr;
            }
        );
    }
};
```",0
"auto expressionDef = createExpressionDefinitionFromValueOrExpression(""value"", ""expression"", parserContext,
    headerElement, true);

headerExpressions[headerElement.getAttribute(NAME_ATTRIBUTE)] = expressionDef;

methodMetadataBuilder.addPropertyValue(""headerExpressions"", headerExpressions);","headerExpressions[headerElement.getAttribute(NAME_ATTRIBUTE)] = expressionDef;
methodMetadataBuilder.addPropertyValue(""headerExpressions"", headerExpressions);",0
"#include ""ConfirmModSchemaException.h""
#include ""SystemTime.h""
#include ""Time.h""
#include ""JSONArray.h""
#include ""JSONException.h""
#include ""JSONObject.h""","#include ""exception/ConfirmModSchemaException.h""

#include ""libanki/utils/SystemTime.h""
#include ""libanki/utils/Time.h""
#include ""utils/JSONArray.h""
#include ""utils/JSONException.h""
#include ""utils/JSONObject.h""",0
"#include <mutex>
#include <string>

class Log {
public:
    static Log* getLog(const std::string& name);
    // logging methods...
};

class LogFactory {
public:
    static Log* getLog(const std::string& name) {
        // Return logger instance
        return Log::getLog(name);
    }
};

template<typename T>
class GenericBeanPostProcessorAdapter {
    // Base class definition...
};

class AbstractConfig {
    // ...
};

class DefaultListableBeanFactory {
    // ...
};

class DubboConfigEarlyInitializationPostProcessor : public GenericBeanPostProcessorAdapter<AbstractConfig> {
private:
    static DubboConfigEarlyInitializationPostProcessor* SINGLETON;
    static std::mutex singleton_mutex;
    Log* logger;
    DefaultListableBeanFactory* beanFactory;

    DubboConfigEarlyInitializationPostProcessor(DefaultListableBeanFactory* beanFactory)
        : logger(LogFactory::getLog(""DubboConfigEarlyInitializationPostProcessor"")),
          beanFactory(beanFactory) {
    }

public:
    static DubboConfigEarlyInitializationPostProcessor* getSingleton(DefaultListableBeanFactory* beanFactory) {
        if (SINGLETON == nullptr && beanFactory != nullptr) {
            std::lock_guard<std::mutex> lock(singleton_mutex);
            if (SINGLETON == nullptr && beanFactory != nullptr) {
                SINGLETON = new DubboConfigEarlyInitializationPostProcessor(beanFactory);
            }
        }
        return SINGLETON;
    }

protected:
    void processBeforeInitialization(AbstractConfig* config, const std::string& beanName) {
        // Implementation...
    }
};

DubboConfigEarlyInitializationPostProcessor* DubboConfigEarlyInitializationPostProcessor::SINGLETON = nullptr;
std::mutex DubboConfigEarlyInitializationPostProcessor::singleton_mutex;","#include <mutex>
#include <string>

class Logger {
public:
    static Logger& getLogger(const std::string& /*name*/) {
        static Logger instance;
        return instance;
    }
};

class DefaultListableBeanFactory {};

template <typename T>
class GenericBeanPostProcessorAdapter {
protected:
    virtual void processBeforeInitialization(T* config, const std::string& beanName) {}
};

class AbstractConfig {};

class DubboConfigEarlyInitializationPostProcessor : public GenericBeanPostProcessorAdapter<AbstractConfig> {
private:
    static DubboConfigEarlyInitializationPostProcessor* SINGLETON;
    static std::mutex singleton_mutex;
    DefaultListableBeanFactory* beanFactory;
    static Logger& logger;

    DubboConfigEarlyInitializationPostProcessor(DefaultListableBeanFactory* beanFactory)
        : beanFactory(beanFactory) {}

public:
    static DubboConfigEarlyInitializationPostProcessor* getSingleton(DefaultListableBeanFactory* beanFactory) {
        if (SINGLETON == nullptr && beanFactory != nullptr) {
            std::lock_guard<std::mutex> lock(singleton_mutex);
            if (SINGLETON == nullptr && beanFactory != nullptr) {
                SINGLETON = new DubboConfigEarlyInitializationPostProcessor(beanFactory);
            }
        }
        return SINGLETON;
    }

protected:
    void processBeforeInitialization(AbstractConfig* config, const std::string& beanName) override {
        // Implementation here
    }
};

DubboConfigEarlyInitializationPostProcessor* DubboConfigEarlyInitializationPostProcessor::SINGLETON = nullptr;
std::mutex DubboConfigEarlyInitializationPostProcessor::singleton_mutex;
Logger& DubboConfigEarlyInitializationPostProcessor::logger = Logger::getLogger(""DubboConfigEarlyInitializationPostProcessor"");",1
"/  
 * AriaLiveStatusWidget.cpp
 *
 * Copyright (C) 2019-20 by RStudio, Inc.
 *
 * Unless you have received this program directly from RStudio pursuant
 * to the terms of a commercial license agreement with RStudio, then","/*
 * AriaLiveStatusWidget.cpp
 *
 * Copyright (C) 2019-20 by RStudio, Inc.
 *
 * Unless you have received this program directly from RStudio pursuant
 * to the terms of a commercial license agreement with RStudio, then
*/",0
"auto tag = JavascriptOperators::GetProperty(thisArgAsObject, PropertyIds::_symbolToStringTag, scriptContext);

auto buildToString = [&scriptContext](auto tag) {
    auto tagStr = JavascriptString::FromVar(tag);
    CompoundString::Builder<32> stringBuilder(scriptContext);","auto tag = JavascriptOperators::GetProperty(thisArgAsObject, PropertyIds::_symbolToStringTag, scriptContext);

auto buildToString = [&scriptContext](Var tag) {
    auto tagStr = JavascriptString::FromVar(tag);

    CompoundString::Builder<32> stringBuilder(scriptContext);",1
"if (optionalPartitionDMLInfo) {
    if (!optionalPartitionDMLInfo->empty()) {
        dmlQuery += ""WHERE "";
        bool isFirstPartitionSpec = true;
        for (const auto& partition : *optionalPartitionDMLInfo) {
            if (isFirstPartitionSpec) {
                isFirstPartitionSpec = false;
            } else {
                dmlQuery += "" and "";
            }
            dmlQuery += ""`"" + partition.first + ""`='"" + partition.second + ""'"";
        }
    }
}","if (optionalPartitionDMLInfo.has_value()) {
    if (!optionalPartitionDMLInfo->empty()) {
        dmlQuery += ""WHERE "";
        bool isFirstPartitionSpec = true;
        for (const auto& partition : *optionalPartitionDMLInfo) {
            if (isFirstPartitionSpec) {
                isFirstPartitionSpec = false;
            } else {
                dmlQuery += "" and "";
            }
            dmlQuery += ""`"" + partition.first + ""`='"" + partition.second + ""'"";
        }
    }
}",1
"```
private:
    void setupUIController(IFieldController* fieldController, Bundle* savedInstanceState) {
        fieldController->setField(mField);
        fieldController->setFieldIndex(mFieldIndex);
        fieldController->setNote(mNote);
        fieldController->setEditingActivity(this);
        fieldController->loadInstanceState(savedInstanceState);
    }

    void recreateEditingUi(const ChangeUIRequest& newUI) {
        this->recreateEditingUi(newUI, nullptr);
    }

    void recreateEditingUi(const ChangeUIRequest& newUI, Bundle* savedInstanceState) {
        Timber::d(""recreateEditingUi()"");
        // Permissions are checked async, save our current state to allow continuation
    }
```","void setupUIController(IFieldController* fieldController, Bundle* savedInstanceState = nullptr) {
    fieldController->setField(mField);
    fieldController->setFieldIndex(mFieldIndex);
    fieldController->setNote(mNote);
    fieldController->setEditingActivity(this);
    fieldController->loadInstanceState(savedInstanceState);
}

void recreateEditingUi(const ChangeUIRequest& newUI) {
    recreateEditingUi(newUI, nullptr);
}

void recreateEditingUi(const ChangeUIRequest& newUI, Bundle* savedInstanceState = nullptr) {
    Timber::d(""recreateEditingUi()"");
    // Permissions are checked async, save our current state to allow continuation
}",0
"Path path(config.getBasePath()), FSUtils::getPartitionPath(config.getBasePath(), partitionPath);
partitionMetadata.trySave(getPartitionId());
createMarkerFile(partitionPath, FSUtils::makeDataFileName(this->instantTime, this->writeToken, this->fileId, hoodieTable->getBaseFileExtension()));
this->fileWriter = HoodieFileWriterFactory::getFileWriter(instantTime, path, hoodieTable, config, writeSchemaWithMetaFields, this->taskContextSupplier);
} catch (const std::ios_base::failure& e) {
    throw HoodieInsertException(std::string(""Failed to initialize HoodieStorageWriter for path "") + path.toString(), e);
}","std::filesystem::path basePath(config.getBasePath());
std::filesystem::path partitionedPath = FSUtils::getPartitionPath(config.getBasePath(), partitionPath);
PartitionMetadata partitionMetadata(basePath, partitionedPath);
partitionMetadata.trySave(getPartitionId());
createMarkerFile(partitionPath, FSUtils::makeDataFileName(this->instantTime, this->writeToken, this->fileId, hoodieTable->getBaseFileExtension()));
try {
    this->fileWriter = HoodieFileWriterFactory::getFileWriter(instantTime, path, hoodieTable, config,
        writeSchemaWithMetaFields, this->taskContextSupplier);
} catch (const std::ios_base::failure& e) {
    throw HoodieInsertException(""Failed to initialize HoodieStorageWriter for path "" + path.string(), e);
}",0
"/**
 * full list of addresses from registry, classified by method name.
 */
std::atomic<BitList<Invoker<T>>> invokers = BitList<Invoker<T>>::emptyList();

/**
 * containing all routers, reconstruct every time 'route://' urls change.
 */","```cpp
#include <atomic>
#include <vector>

template<typename T>
class Invoker {};

template<typename T>
class BitList {
public:
    static BitList<Invoker<T>> emptyList() {
        return BitList<Invoker<T>>();
    }
};

template<typename T>
class RouterChain {
private:
    std::atomic<BitList<Invoker<T>>> invokers{BitList<Invoker<T>>::emptyList()};
};
```",0
"HoodieLockConfig::Builder& withDynamoDBTable(const std::string& dynamoDbTableName) {
    lockConfig.setValue(DYNAMODB_TABLE_NAME, dynamoDbTableName);
    return *this;
}

HoodieLockConfig::Builder& withDynamoDBPartitionKey(const std::string& partitionKey) {
    lockConfig.setValue(DYNAMODB_PARTITION_KEY, partitionKey);
    return *this;
}

HoodieLockConfig::Builder& withDynamoDBRegion(const std::string& region) {
    lockConfig.setValue(DYNAMODB_REGION, region);
    return *this;
}

HoodieLockConfig::Builder& withDynamoDBBillingMode(const std::string& mode) {
    lockConfig.setValue(DYNAMODB_BILLING_MODE, mode);
    return *this;
}

HoodieLockConfig::Builder& withDynamoDBReadCapacity(const std::string& capacity) {
    lockConfig.setValue(DYNAMODB_READ_CAPACITY, capacity);
    return *this;
}

HoodieLockConfig::Builder& withDynamoDBWriteCapacity(const std::string& capacity) {
    lockConfig.setValue(DYNAMODB_WRITE_CAPACITY, capacity);
    return *this;
}

HoodieLockConfig::Builder& withNumRetries(int numRetries) {
    lockConfig.setValue(LOCK_ACQUIRE_NUM_RETRIES, std::to_string(numRetries));
    return *this;
}","class HoodieLockConfig {
public:
    class Builder {
    public:
        Builder& withDynamoDBTable(const std::string& dynamoDbTableName) {
            lockConfig.setValue(DYNAMODB_TABLE_NAME, dynamoDbTableName);
            return *this;
        }

        Builder& withDynamoDBPartitionKey(const std::string& partitionKey) {
            lockConfig.setValue(DYNAMODB_PARTITION_KEY, partitionKey);
            return *this;
        }

        Builder& withDynamoDBRegion(const std::string& region) {
            lockConfig.setValue(DYNAMODB_REGION, region);
            return *this;
        }

        Builder& withDynamoDBBillingMode(const std::string& mode) {
            lockConfig.setValue(DYNAMODB_BILLING_MODE, mode);
            return *this;
        }

        Builder& withDynamoDBReadCapacity(const std::string& capacity) {
            lockConfig.setValue(DYNAMODB_READ_CAPACITY, capacity);
            return *this;
        }

        Builder& withDynamoDBWriteCapacity(const std::string& capacity) {
            lockConfig.setValue(DYNAMODB_WRITE_CAPACITY, capacity);
            return *this;
        }

        Builder& withNumRetries(int numRetries) {
            lockConfig.setValue(LOCK_ACQUIRE_NUM_RETRIES, std::to_string(numRetries));
            return *this;
        }

    private:
        HoodieLockConfig lockConfig;
        // Assume the static/constants DYNAMODB_TABLE_NAME, etc., are declared somewhere accessible.
    };
};",0
"try {
    // stop process should continue all the same
    logger.warn(""Jms connection failed to stop properly: "", e);
} catch (...) {
    // handle exception as needed
} 
stopping = false;

if (jndiNameResolver != nullptr)","try
{
    // stop process should continue all the same
    logger.warn(""Jms connection failed to stop properly: "", e);
}
catch (const std::exception& e)
{
    logger.warn(""Jms connection failed to stop properly: "", e);
}
catch (...)
{
    logger.warn(""Jms connection failed to stop properly: unknown exception"");
}
stopping = false;",0
"resultId = job.getContainerObjectId();
} else {
    auto node = getConfigNode(zipBaseUrl, Trans::CONFIGURATION_IN_EXPORT_FILENAME, TransExecutionConfiguration::XML_TAG);
    TransExecutionConfiguration transExecutionConfiguration(node);
}","```cpp
std::string resultId;
if (job) {
    resultId = job->getContainerObjectId();
} else {
    Node* node =
        getConfigNode(zipBaseUrl, Trans::CONFIGURATION_IN_EXPORT_FILENAME,
                      TransExecutionConfiguration::XML_TAG);
    TransExecutionConfiguration transExecutionConfiguration(node);
}
```",0
"/*******************************************************************************
 * Copyright (c) 2005, 2021 IBM Corp. and others
 *
 * This program and the accompanying materials are made available under
 * the terms of the Eclipse Public License 2.0 which accompanies this","/*******************************************************************************
 * Copyright (c) 2005, 2021 IBM Corp. and others
 *
 * This program and the accompanying materials are made available under
 * the terms of the Eclipse Public License 2.0 which accompanies this",0
"try {
    process(flow, eventBuilder().message(Message::of("""")).build());
} catch (...) {
    throw;
}
if (useMockInterceptor) {
    InOrder inOrder(processor, interceptor1, interceptor2);

    inOrder.verify(interceptor1).before(any(), any(), any());
    inOrder.verify(interceptor1).around(any(), any(), any(), any());
    inOrder.verify(interceptor2).before(any(), any(), any());
    inOrder.verify(interceptor2).around(any(), any(), any(), any());
    inOrder.verify(processor).process(any());
    inOrder.verify(interceptor2).after(any(), any(), eq(empty()));
    inOrder.verify(interceptor1).after(any(), any(), eq(of(expectedException)));

    verifyParametersResolvedAndDisposed(times(1));
}

void firstInterceptorThrowsExceptionAround() {
    std::exception_ptr expectedException = std::make_exception_ptr(std::runtime_error(""Some Error""));
    ProcessorInterceptor interceptor1 = prepareInterceptor(new ProcessorInterceptor{
        // override around method here
        // ...
    });
    // ...
}","try {
    process(flow, eventBuilder().message(Message::of("""")).build());
} finally {
    if (useMockInterceptor) {
        auto inOrder = ::testing::InSequence{};
        EXPECT_CALL(*interceptor1, before(::testing::_, ::testing::_, ::testing::_));
        EXPECT_CALL(*interceptor1, around(::testing::_, ::testing::_, ::testing::_, ::testing::_));
        EXPECT_CALL(*interceptor2, before(::testing::_, ::testing::_, ::testing::_));
        EXPECT_CALL(*interceptor2, around(::testing::_, ::testing::_, ::testing::_, ::testing::_));
        EXPECT_CALL(*processor, process(::testing::_));
        EXPECT_CALL(*interceptor2, after(::testing::_, ::testing::_, ::testing::Truly([](auto v){ return v == empty(); })));
        EXPECT_CALL(*interceptor1, after(::testing::_, ::testing::_, ::testing::Truly([&expectedException](auto v){ return v == of(expectedException); })));

        verifyParametersResolvedAndDisposed(1);
    }
}

TEST(ReactiveInterceptorAdapterTestCase, firstInterceptorThrowsExceptionAround) {
    std::runtime_error expectedException(""Some Error"");
    auto interceptor1 = prepareInterceptor(std::make_shared<ProcessorInterceptor>(/* ... */));
    
    // ... (rest of the code)
}",0
"#include ""gobblin/instrumented/Instrumented.h""
#include ""gobblin/metrics/MetricContext.h""
#include ""gobblin/metrics/Tag.h""
#include ""gobblin/util/ConfigUtils.h""
#include ""gobblin/util/PathUtils.h""","#include ""gobblin/hive/HiveMetastoreClientPool.h""
#include ""gobblin/instrumented/Instrumented.h""
#include ""gobblin/metrics/MetricContext.h""
#include ""gobblin/metrics/Tag.h""
#include ""gobblin/util/ConfigUtils.h""
#include ""gobblin/util/PathUtils.h""",0
"}

datasetState.setId(datasetUrn);
this->datasetStateStore.persistDatasetState(datasetUrn, datasetState);
}","@@ -445,7 +445,6 @@
     }
 
     datasetState.setId(datasetUrn);
-    this->datasetStateStore->persistDatasetState(datasetUrn, datasetState);
   }
 
   /**",0
"public:
  // Sets the pageview state token associated with the slot. Token does not expire.
  void setPageviewStateToken(const std::string& token) {
    pageviewStateTokens[token] = this;
  }

  // Checks for the presence of a pageview token in the module level object and removes it if present.
  void removePageviewStateToken() {
    for (auto it = pageviewStateTokens.begin(); it != pageviewStateTokens.end(); ++it) {
      if (it->second == this) {
        pageviewStateTokens.erase(it);
        break;
      }
    }
  }

  // @override
  auto getA4aAnalyticsVars(const std::string& analyticsTrigger) {
    return getCsiAmpAnalyticsVariables(analyticsTrigger, this, this->qqid_);
  }

  // @override
  auto getA4aAnalyticsConfig() { return getCsiAmpAnalyticsConfig(); }

};","```cpp
#include <string>
#include <unordered_map>

class AmpAdNetworkDoubleclickImpl : public AmpA4A {
public:
    static std::unordered_map<std::string, AmpAdNetworkDoubleclickImpl*> pageviewStateTokens;

    void setPageviewStateToken(const std::string& token) {
        pageviewStateTokens[token] = this;
    }

    void removePageviewStateToken() {
        for (auto it = pageviewStateTokens.begin(); it != pageviewStateTokens.end(); ++it) {
            if (it->second == this) {
                pageviewStateTokens.erase(it);
                break;
            }
        }
    }

    virtual std::string getA4aAnalyticsVars(const std::string& analyticsTrigger) override {
        return getCsiAmpAnalyticsVariables(analyticsTrigger, this, this->qqid_);
    }

    virtual std::string getA4aAnalyticsConfig() override {
        return getCsiAmpAnalyticsConfig();
    }
};

std::unordered_map<std::string, AmpAdNetworkDoubleclickImpl*> AmpAdNetworkDoubleclickImpl::pageviewStateTokens;
```",1
"#include ""gobblin/cluster/HelixUtils.h""
#include ""gobblin/cluster/TestHelper.h""
#include ""gobblin/cluster/TestShutdownMessageHandlerFactory.h""
#include ""gobblin/configuration/ConfigurationKeys.h""
#include ""gobblin/configuration/DynamicConfigGenerator.h""
#include ""gobblin/runtime/app/ServiceBasedAppLauncher.h""
#include ""gobblin/testing/AssertWithBackoff.h""

#include ""hadoop/yarn/api/records/ApplicationAttemptId.h""
#include ""hadoop/yarn/api/records/ApplicationId.h""
#include ""hadoop/yarn/api/records/ContainerId.h""
#include ""hadoop/yarn/api/records/YarnApplicationState.h""
#include ""hadoop/yarn/client/api/YarnClient.h""
#include ""hadoop/yarn/conf/YarnConfiguration.h""
#include ""hadoop/yarn/server/MiniYARNCluster.h""
#include ""hadoop/yarn/server/utils/YarnServerBuilderUtils.h""

#include ""helix/HelixManager.h""
#include ""helix/HelixManagerFactory.h""
#include ""helix/InstanceType.h""","#include ""HelixMessageTestBase.h""
#include ""HelixUtils.h""
#include ""TestHelper.h""
#include ""TestShutdownMessageHandlerFactory.h""
#include ""ConfigurationKeys.h""
#include ""DynamicConfigGenerator.h""
#include ""ServiceBasedAppLauncher.h""
#include ""AssertWithBackoff.h""
#include ""ApplicationAttemptId.h""
#include ""ApplicationId.h""
#include ""ContainerId.h""
#include ""YarnApplicationState.h""
#include ""YarnClient.h""
#include ""YarnConfiguration.h""
#include ""MiniYARNCluster.h""
#include ""YarnServerBuilderUtils.h""
#include ""HelixManager.h""
#include ""HelixManagerFactory.h""
#include ""InstanceType.h""",0
".append(attr);
    }

add(a, Constants::REQUIRE_CAPABILITY, req.str());
}

private:
std::string getFilter(const Annotation& a, const Requirement& annotation) {","```cpp
void AnnotationHeaders::methodName(Annotation a, Requirement annotation) {
    std::ostringstream req;
    req << attr;
    add(a, Constants::REQUIRE_CAPABILITY, req.str());
}

std::string AnnotationHeaders::getFilter(Annotation a, Requirement annotation) {
    // Implementation here
}
```",0
"case TypeIds_Number:
    return JavascriptNumber::ToLocaleString(JavascriptNumber::GetValue(aValue), scriptContext);

case TypeIds_String: {
    RecyclableObject* object = VarTo<RecyclableObject>(aValue);
    Var value = JavascriptOperators::GetProperty(object, PropertyIds::toLocaleString, scriptContext, nullptr);
    RecyclableObject* toLocaleStringFunction = VarTo<RecyclableObject>(value);
    Var aResult = scriptContext->GetThreadContext()->ExecuteImplicitCall(
        toLocaleStringFunction,
        Js::ImplicitCall_ToPrimitive,
        [=]() -> Js::Var {
            return CALL_FUNCTION(
                scriptContext->GetThreadContext(),
                toLocaleStringFunction,
                CallInfo(1),
                aValue
            );
        }
    );
    return UnsafeVarTo<JavascriptString>(aResult);
}

case TypeIds_VariantDate:
    // Legacy behavior was to create an empty object and call toLocaleString on it, which would result in this value","```cpp
    switch (typeId)
    {
        case TypeIds_Number:
            return JavascriptNumber::ToLocaleString(JavascriptNumber::GetValue(aValue), scriptContext);

        case TypeIds_String:
        {
            RecyclableObject* object = VarTo<RecyclableObject>(aValue);
            Var value = JavascriptOperators::GetProperty(object, PropertyIds::toLocaleString, scriptContext, nullptr);
            RecyclableObject* toLocaleStringFunction = VarTo<RecyclableObject>(value);
            Var aResult = scriptContext->GetThreadContext()->ExecuteImplicitCall(toLocaleStringFunction, Js::ImplicitCall_ToPrimitive, [=]() -> Js::Var
            {
                return CALL_FUNCTION(scriptContext->GetThreadContext(), toLocaleStringFunction, CallInfo(1), aValue);
            });
            return UnsafeVarTo<JavascriptString>(aResult);
        }

        case TypeIds_VariantDate:
            // Legacy behavior was to create an empty object and call toLocaleString on it, which would result in this value
```",1
"XmlDslModel getXmlDslModel(const ComponentModel& moduleModel, const std::string& name, const std::string& version) {
    auto& params = moduleModel.getParameters();
    std::optional<std::string> prefix;
    auto it_prefix = params.find(MODULE_PREFIX_ATTRIBUTE);
    if (it_prefix != params.end()) prefix = it_prefix->second;
    std::optional<std::string> ns;
    auto it_ns = params.find(MODULE_NAMESPACE_ATTRIBUTE);
    if (it_ns != params.end()) ns = it_ns->second;
    return createXmlLanguageModel(prefix, ns, name, version);
}

std::string getDescription(const ComponentModel& componentModel) {
    const auto& params = componentModel.getParameters();
    auto it = params.find(DOC_DESCRIPTION);
    return it != params.end() ? it->second : """";
}","XmlDslModel getXmlDslModel(const ComponentModel& moduleModel, const std::string& name, const std::string& version) {
    auto params = moduleModel.getParameters();
    auto prefixIter = params.find(MODULE_PREFIX_ATTRIBUTE);
    std::optional<std::string> prefix = (prefixIter != params.end()) ? std::make_optional(prefixIter->second) : std::nullopt;
    auto namespaceIter = params.find(MODULE_NAMESPACE_ATTRIBUTE);
    std::optional<std::string> ns = (namespaceIter != params.end()) ? std::make_optional(namespaceIter->second) : std::nullopt;
    return createXmlLanguageModel(prefix, ns, name, version);
}

std::string getDescription(const ComponentModel& componentModel) {
    auto params = componentModel.getParameters();
    auto it = params.find(DOC_DESCRIPTION);
    return (it != params.end()) ? it->second : """";
}",1
"if (!mAddNote && mCurrentEditedCard != nullptr) {
    std::printf(""NoteEditor:: Edit note activity successfully started with card id %d\n"", mCurrentEditedCard->getId());
}
if (mEditFields != nullptr) {
    FieldEditText* front = mEditFields->getFirst();
    front->requestFocus();
}","if (!mAddNote && mCurrentEditedCard != nullptr) {
    spdlog::info(""NoteEditor:: Edit note activity successfully started with card id {}"", mCurrentEditedCard->getId());
}

if (mEditFields != nullptr) {
    FieldEditText* front = mEditFields->front();
    front->requestFocus();
}",1
"#include <gtest/gtest.h>
#include <gmock/gmock.h>

class KinesisRecord {
public:
    MOCK_METHOD(Instant, getApproximateArrivalTimestamp, (), (const));
};

class CustomOptionalKinesisRecord {
public:
    static CustomOptionalKinesisRecord of(const KinesisRecord& record) {
        return CustomOptionalKinesisRecord(true, record);
    }
    static CustomOptionalKinesisRecord absent() {
        return CustomOptionalKinesisRecord(false, KinesisRecord());
    }
    bool has_value() const { return has; }
    const KinesisRecord& value() const { return rec; }
private:
    bool has;
    KinesisRecord rec;
    CustomOptionalKinesisRecord(bool h, const KinesisRecord& r) : has(h), rec(r) {}
};

class IteratorMock {
public:
    MOCK_METHOD(CustomOptionalKinesisRecord, next, (), ());
};

class Reader {
public:
    MOCK_METHOD(void, start, (), ());
    MOCK_METHOD(bool, advance, (), ());
    MOCK_METHOD(Instant, getWatermark, (), (const));
};

IteratorMock firstIterator;
IteratorMock secondIterator;
Reader reader;

KinesisRecord prepareRecordMockWithArrivalTimestamp(long timestampMs) {
    KinesisRecord record;
    EXPECT_CALL(record, getApproximateArrivalTimestamp())
        .WillRepeatedly(testing::Return(Instant(timestampMs)));
    return record;
}

TEST(ReaderTest, WatermarkDoesNotChangeWhenTooFewSampleRecords) {
    const long timestampMs = 1000L;

    KinesisRecord firstRecord = prepareRecordMockWithArrivalTimestamp(timestampMs);
    testing::InSequence s;
    EXPECT_CALL(firstIterator, next())
        .WillOnce(testing::Return(CustomOptionalKinesisRecord::of(firstRecord)));
    for (int i = 0; i < 5; i++) {
        KinesisRecord record = prepareRecordMockWithArrivalTimestamp(timestampMs + i);
        EXPECT_CALL(firstIterator, next())
            .WillOnce(testing::Return(CustomOptionalKinesisRecord::of(record)));
    }
    EXPECT_CALL(firstIterator, next())
        .WillOnce(testing::Return(CustomOptionalKinesisRecord::absent()));
    EXPECT_CALL(secondIterator, next())
        .WillRepeatedly(testing::Return(CustomOptionalKinesisRecord::absent()));

    EXPECT_CALL(reader, start());
    EXPECT_CALL(reader, getWatermark())
        .WillRepeatedly(testing::Return(BoundedWindow::TIMESTAMP_MIN_VALUE));

    reader.start();","#include <gtest/gtest.h>
#include <gmock/gmock.h>

class KinesisReaderTest : public ::testing::Test {
protected:
    std::unique_ptr<KinesisReader> reader;
    std::shared_ptr<MockIterator> firstIterator;
    std::shared_ptr<MockIterator> secondIterator;

    void SetUp() override {
        // Assume setup creates a reader with mock iterators
        firstIterator = std::make_shared<MockIterator>();
        secondIterator = std::make_shared<MockIterator>();
        reader = std::make_unique<KinesisReader>(firstIterator, secondIterator);
    }

    KinesisRecord* prepareRecordMockWithArrivalTimestamp(int64_t timestampMs) {
        auto record = new ::testing::NiceMock<MockKinesisRecord>();
        ON_CALL(*record, getApproximateArrivalTimestamp())
            .WillByDefault(::testing::Return(Instant(timestampMs)));
        return record;
    }
};

TEST_F(KinesisReaderTest, watermarkDoesNotChangeWhenToFewSampleRecords) {
    int64_t timestampMs = 1000L;

    ::testing::Sequence seq;

    KinesisRecord* firstRecord = prepareRecordMockWithArrivalTimestamp(timestampMs);
    EXPECT_CALL(*firstIterator, next())
        .InSequence(seq)
        .WillOnce(::testing::Return(CustomOptional<KinesisRecord*>(firstRecord)));
    for (int i = 0; i < 5; i++) {
        KinesisRecord* record = prepareRecordMockWithArrivalTimestamp(timestampMs + i);
        EXPECT_CALL(*firstIterator, next())
            .InSequence(seq)
            .WillOnce(::testing::Return(CustomOptional<KinesisRecord*>(record)));
    }
    EXPECT_CALL(*firstIterator, next())
        .InSequence(seq)
        .WillOnce(::testing::Return(CustomOptional<KinesisRecord*>::absent()));
    EXPECT_CALL(*secondIterator, next())
        .WillRepeatedly(::testing::Return(CustomOptional<KinesisRecord*>::absent()));

    reader->start();

    ASSERT_EQ(reader->getWatermark(), BoundedWindow::TIMESTAMP_MIN_VALUE);
    while (reader->advance()) {
        ASSERT_EQ(reader->getWatermark(), BoundedWindow::TIMESTAMP_MIN_VALUE);
    }
}

TEST_F(KinesisReaderTest, watermarkAdvancesWhenEnoughRecordsReadRecently) {
    int64_t timestampMs = 1000L;

    ::testing::Sequence seq;

    KinesisRecord* firstRecord = prepareRecordMockWithArrivalTimestamp(timestampMs);",1
"#include <memory>

class AutoConfigurationBuilderTestCase // : public AbstractMuleContextTestCase
{
public:
};","#include <cassert>

class AutoConfigurationBuilderTestCase : public AbstractMuleContextTestCase
{

};",0
"virtual std::optional<int> getCassandraPort() const = 0;
virtual void setCassandraPort(std::optional<int> port) = 0;

[[deprecated(""Lines of text count"")]]
virtual std::optional<long long> getLinesOfTextCount() const = 0;

virtual void setLinesOfTextCount(std::optional<long long> count) = 0;","class IOTestPipelineOptions : public TestPipelineOptions {
public:
    virtual int getCassandraPort() const = 0;
    virtual void setCassandraPort(int port) = 0;

    virtual long long getLinesOfTextCount() const = 0;
    virtual void setLinesOfTextCount(long long count) = 0;
};",1
"class GZIPEncodingTestCase : public AbstractCxfOverHttpExtensionTestCase {
private:
    static constexpr const char* GZIP = ""gzip"";
};","#include <string>

class GZIPEncodingTestCase : public AbstractCxfOverHttpExtensionTestCase {
protected:
    static constexpr const char* GZIP = ""gzip"";
};",0
"#include <vector>
#include <iterator>
#include <memory>","#include <vector>
#include <memory>
#include <algorithm>

#include ""AnalyzerMessage.h""
#include ""SonarComponents.h""
#include ""ComplexityVisitor.h""
#include ""SemanticModel.h""
#include ""SECheck.h""
#include ""JavaCheck.h""
#include ""JavaFileScannerContext.h""
#include ""JavaVersion.h""",0
"if (pToken->tk == tkID && pToken->pid == wellKnownPropertyPids.eval && count > 0)
{
    this->MarkEvalCaller();
    this->PushPidRef(wellKnownPropertyPids._this);
    this->PushPidRef(wellKnownPropertyPids._newTarget);
    this->PushPidRef(wellKnownPropertyPids._super);
    this->PushPidRef(wellKnownPropertyPids._superConstructor);
}
pToken->tk = tkNone;","if (pToken->tk == tkID && pToken->pid == wellKnownPropertyPids.eval && count > 0)
{
    this->MarkEvalCaller();

    this->PushPidRef(wellKnownPropertyPids._this);
    this->PushPidRef(wellKnownPropertyPids._newTarget);
    this->PushPidRef(wellKnownPropertyPids._super);
    this->PushPidRef(wellKnownPropertyPids._superConstructor);
}
pToken->tk = tkNone;",1
"RpcContext::getContext().setInvokers(invokers);
std::exception_ptr exception = nullptr;
Result result;
URL url = getUrl();
// The value range of broadcast.fail.threshold must be 0～100.
// 100 means that an exception will be thrown last, and 0 means that as long as an exception occurs, it will be thrown.
int broadcastFailPercent = url.getParameter(""broadcast.fail.percent"", 100);

int failThresholdIndex = invokers.size() * broadcastFailPercent / 100;
int failIndex = 0;
for (auto& invoker : invokers) {
    try {
        result = invoker.invoke(invocation);
        if(result.hasException()){
            auto resultException = result.getException();
            if(resultException){
                exception = getRpcException(resultException);
                if(failIndex == failThresholdIndex){
                    break;
                }else{
                    logger.warn(exceptionMessage(exception), exception);
                    failIndex++;
                }
            }
        }
    } catch (...) {
        exception = getRpcException(std::current_exception());
        if(failIndex == failThresholdIndex){
            break;
        }else{
            logger.warn(exceptionMessage(exception), exception);
            failIndex++;
        }
    }
}

if (exception != nullptr && failIndex == failThresholdIndex) {
    std::rethrow_exception(exception);
}

return result;

private:
std::exception_ptr getRpcException(std::exception_ptr throwable){
    try {
        if (throwable) {
            std::rethrow_exception(throwable);
        }
    } catch (const RpcException& e) {
        return std::make_exception_ptr(e);
    } catch (const std::exception& e) {
        return std::make_exception_ptr(RpcException(e.what(), throwable));
    } catch (...) {
        return std::make_exception_ptr(RpcException(""Unknown exception"", throwable));
    }
    return std::make_exception_ptr(RpcException(""Unknown exception"", throwable));
}

std::string exceptionMessage(std::exception_ptr exception) {
    try {
        if (exception) {
            std::rethrow_exception(exception);
        }
    } catch(const std::exception& e) {
        return e.what();
    } catch (...) {
        return ""Unknown exception"";
    }
    return """";
}","```cpp
class BroadcastClusterInvoker : public AbstractClusterInvoker<T> {
public:
    Result invoke(const Invocation& invocation) override {
        RpcContext::getContext().setInvokers(invokers);
        std::exception_ptr exception = nullptr;
        std::unique_ptr<Result> result;
        URL url = getUrl();
        int broadcastFailPercent = url.getParameter(""broadcast.fail.percent"", 100);

        int failThresholdIndex = invokers.size() * broadcastFailPercent / 100;
        int failIndex = 0;
        for (auto& invoker : invokers) {
            try {
                result.reset(invoker->invoke(invocation));
                if (result && result->hasException()) {
                    std::exception_ptr resultException = result->getException();
                    if (resultException) {
                        exception = getRpcException(result->getException());
                        if (failIndex == failThresholdIndex) {
                            break;
                        } else {
                            logger.warn(getExceptionMessage(exception), exception);
                            ++failIndex;
                        }
                    }
                }
            } catch (...) {
                exception = getRpcException(std::current_exception());
                if (failIndex == failThresholdIndex) {
                    break;
                } else {
                    logger.warn(getExceptionMessage(exception), exception);
                    ++failIndex;
                }
            }
        }

        if (exception && failIndex == failThresholdIndex) {
            std::rethrow_exception(exception);
        }

        return result ? *result : Result();
    }

private:
    std::exception_ptr getRpcException(const std::exception_ptr& throwable) {
        try {
            if (throwable) std::rethrow_exception(throwable);
        } catch (const RpcException& e) {
            return std::make_exception_ptr(e);
        } catch (const std::exception& e) {
            return std::make_exception_ptr(RpcException(e.what()));
        } catch (...) {
            return std::make_exception_ptr(RpcException(""Unknown exception""));
        }
        return nullptr;
    }

    std::string getExceptionMessage(const std::exception_ptr& eptr) {
        try {
            if (eptr) std::rethrow_exception(eptr);
        } catch (const std::exception& e) {
            return e.what();
        } catch (...) {
            return ""Unknown exception"";
        }
        return """";
    }
};
```",1
"#include <memory>
#include <string>
#include <uri.h>
#include <okhttp/Request.h>
#include <okhttp/Response.h>

class KubernetesClientTracer : public HttpClientTracer<Request, Request, Response> {
public:
    static KubernetesClientTracer& tracer() {
        static KubernetesClientTracer instance;
        return instance;
    }

    // Override functions as needed

private:
    KubernetesClientTracer() = default;
};","#include <string>
#include <memory>

class Request {};
class Response {};

class HttpClientTracer {
public:
    virtual ~HttpClientTracer() = default;
};

class KubernetesClientTracer : public HttpClientTracer {
public:
    static KubernetesClientTracer& getInstance() {
        static KubernetesClientTracer instance;
        return instance;
    }
private:
    KubernetesClientTracer() = default;
};",0
"#include <string>
#include <map>

class PrimaryDataStoreTO {};

class DirectDownloadCommand {
public:
    DirectDownloadCommand(const std::string& url, long long templateId, const PrimaryDataStoreTO& destPool,
                          const std::string& checksum, const std::map<std::string, std::string>& headers) {}

    void setConnectTimeout(int timeout) {}
    void setSoTimeout(int timeout) {}
};

class HttpDirectDownloadCommand : public DirectDownloadCommand {
public:
    HttpDirectDownloadCommand(const std::string& url,
                              long long templateId,
                              const PrimaryDataStoreTO& destPool,
                              const std::string& checksum,
                              const std::map<std::string, std::string>& headers,
                              int connectTimeout,
                              int soTimeout)
        : DirectDownloadCommand(url, templateId, destPool, checksum, headers)
    {
        setConnectTimeout(connectTimeout);
        setSoTimeout(soTimeout);
    }
};","#include <string>
#include <map>

class PrimaryDataStoreTO {};

class DirectDownloadCommand {
public:
    DirectDownloadCommand(const std::string& url, long templateId, PrimaryDataStoreTO* destPool,
                          const std::string& checksum, const std::map<std::string, std::string>& headers) {}
    void setConnectTimeout(int timeout) {}
    void setSoTimeout(int timeout) {}
};

class HttpDirectDownloadCommand : public DirectDownloadCommand {
public:
    HttpDirectDownloadCommand(const std::string& url, long templateId, PrimaryDataStoreTO* destPool,
                             const std::string& checksum, const std::map<std::string, std::string>& headers,
                             int connectTimeout, int soTimeout)
        : DirectDownloadCommand(url, templateId, destPool, checksum, headers) {
        setConnectTimeout(connectTimeout);
        setSoTimeout(soTimeout);
    }
};",1
"Element* getLastChildElement(Element* parent)
{
    Node* lastTab = parent->getLastChild();
    if (lastTab == nullptr)
        return nullptr;

    while (lastTab->getNodeType() != Node::ELEMENT_NODE)
        lastTab = lastTab->getPreviousSibling();

    return static_cast<Element*>(lastTab);
}","```cpp
#include <optional>

Element* getLastChildElement(Element* parent)
{
    Node* lastTab = parent->getLastChild();
    if (lastTab == nullptr)
        return nullptr;

    while (lastTab->getNodeType() != Node::ELEMENT_NODE)
    {
        lastTab = lastTab->getPreviousSibling();
        if (lastTab == nullptr)
            return nullptr;
    }
    return static_cast<Element*>(lastTab);
}
```",0
"#include <string>
#include <uuid/uuid.h>

class DBObject {
public:
    std::string get(const std::string& key) const;
};

class DBObjectToUUIDConverter {
public:
    uuid_t convert(const DBObject& source) {
        uuid_t id;
        std::string value = source.get(""_value"");
        uuid_parse(value.c_str(), id);
        return id;
    }
};","#include <string>
#include <unordered_map>
#include <uuid/uuid.h>

using DBObject = std::unordered_map<std::string, std::string>;

class UUID {
public:
    static UUID fromString(const std::string& str) {
        UUID id;
        uuid_parse(str.c_str(), id.data);
        return id;
    }
    unsigned char data[16];
};

class DBObjectToUUIDConverter {
public:
    UUID convert(const DBObject& source) {
        return UUID::fromString(source.at(""_value""));
    }
};",0
"#include <memory>
#include <optional>
#include <set>
#include <string>

class Message;
class Stream;

class Sorting {
public:
    enum class Direction { ASC, DESC };
    Sorting(const std::string& field, Direction dir)
        : field_(field), direction_(dir) {}
private:
    std::string field_;
    Direction direction_;
};

class SortOrderMapper {};
class SearchRequestFactory {
private:
    static const Sorting DEFAULT_SORTING;
    SortOrderMapper sortOrderMapper;
    bool allowHighlighting;
    bool allowLeadingWildcardSearches;
};

const Sorting SearchRequestFactory::DEFAULT_SORTING(""_doc"", Sorting::Direction::ASC);","#include <string>
#include <memory>
#include <optional>
#include <set>

class Sorting {
public:
    enum class Direction { ASC, DESC };
    Sorting(const std::string& field, Direction dir) : field_(field), direction_(dir) {}
private:
    std::string field_;
    Direction direction_;
};

class SearchRequestFactory {
public:
    static const Sorting DEFAULT_SORTING;

    SearchRequestFactory(std::shared_ptr<class SortOrderMapper> sortOrderMapper,
                        bool allowHighlighting,
                        bool allowLeadingWildcardSearches)
        : sortOrderMapper_(sortOrderMapper),
          allowHighlighting_(allowHighlighting),
          allowLeadingWildcardSearches_(allowLeadingWildcardSearches) {}

private:
    std::shared_ptr<class SortOrderMapper> sortOrderMapper_;
    bool allowHighlighting_;
    bool allowLeadingWildcardSearches_;
};

const Sorting SearchRequestFactory::DEFAULT_SORTING(""_doc"", Sorting::Direction::ASC);",0
"registerJacksonSubtype<SpecificUsers>();

void registerParameterSubtypes() {
    registerJacksonSubtype<ValueParameter>();
}

void registerSharingStrategies() {
    registerSharingStrategy(AllUsersOfInstance::TYPE, AllUsersOfInstanceStrategy);
    registerSharingStrategy(SpecificRoles::TYPE, SpecificRolesStrategy);
    registerSharingStrategy(SpecificUsers::TYPE, SpecificUsersStrategy);
}

void registerExceptionMappers() {
    addJerseyExceptionMapper<MissingCapabilitiesExceptionMapper>();
    addJerseyExceptionMapper<PermissionExceptionMapper>();
}","void registerParameterSubtypes() {
    registerJacksonSubtype<ValueParameter>();
}

void registerSharingStrategies() {
    registerSharingStrategy(AllUsersOfInstance::TYPE, AllUsersOfInstanceStrategy);
    registerSharingStrategy(SpecificRoles::TYPE, SpecificRolesStrategy);
    registerSharingStrategy(SpecificUsers::TYPE, SpecificUsersStrategy);
}

void registerExceptionMappers() {
    addJerseyExceptionMapper<MissingCapabilitiesExceptionMapper>();
    addJerseyExceptionMapper<PermissionExceptionMapper>();
}",1
"if (auto [_, err] = pachClient.InspectRepo(request.Pipeline.Name); err && !isNotFoundErr(err) && !auth::IsErrNoRoleBinding(err)) {
    return {nullptr, err};
} else if (!isNotFoundErr(err)) {
    // Check if the caller is authorized to delete this pipeline. This must be
}","if (auto [repo, err] = pachClient->InspectRepo(request.Pipeline.Name); err && !isNotFoundErr(err) && !auth::IsErrNoRoleBinding(err)) {
    return {nullptr, err};
} else if (!isNotFoundErr(err)) {
    // Check if the caller is authorized to delete this pipeline. This must be
}",1
"return std::hash<std::string>{}(msg) ^ (std::hash<int>{}(syntaxNode) << 1);
}
}

//
// Return JSR 45 source map for current input file
// @return source map or nullptr if there is no source map available
//
virtual SourceMap* sourceMap() const {
    return nullptr;
}

}","#include <optional>

class SourceMap;

class JavaFileScannerContext {
public:
    virtual ~JavaFileScannerContext() = default;

    // Other virtual methods...

    virtual std::optional<SourceMap> sourceMap() const {
        return std::nullopt;
    }
};",1
"#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <stdexcept>","#include <sstream>
#include <fstream>
#include <string>",0
"rnwContext_ = rnwContext;
docDisplay_ = docDisplay;
canAutoPopup_ = canAutoPopup;
helpStrategy_ = helpStrategy;

input_->addBlurHandler([this](BlurEvent event) {
    this->onBlur(event);
});","RCompletionManager::RCompletionManager(/* params */, RnwContext* rnwContext, DocDisplay* docDisplay, bool canAutoPopup, HelpStrategy* helpStrategy)
    : rnwContext_(rnwContext),
      docDisplay_(docDisplay),
      canAutoPopup_(canAutoPopup),
      helpStrategy_(helpStrategy)
{
    input_->addBlurHandler([this](BlurEvent* event) {
        this->onBlur(event);
    });
}",0
"std::vector<std::filesystem::path> testClasspath;
if (sonarComponents != nullptr) {
    if (!sonarComponents->isSonarLintContext()) {
        codeVisitors.insert(codeVisitors.end(), {
            std::make_shared<FileLinesVisitor>(sonarComponents),
            std::make_shared<SyntaxHighlighterVisitor>(sonarComponents)
        });
        if (sonarComponents->shouldGenerateUCFG()) {
            codeVisitors.push_back(std::make_shared<UCFGJavaVisitor>(sonarComponents->workDir()));
        }
        testCodeVisitors.push_back(std::make_shared<SyntaxHighlighterVisitor>(sonarComponents));
    }
    classpath = sonarComponents->getJavaClasspath();
}","std::vector<File> testClasspath;
if (sonarComponents != nullptr) {
    if (!sonarComponents->isSonarLintContext()) {
        codeVisitors.insert(codeVisitors.end(), {
            new FileLinesVisitor(sonarComponents),
            new SyntaxHighlighterVisitor(sonarComponents)
        });
        if (sonarComponents->shouldGenerateUCFG()) {
            codeVisitors.push_back(new UCFGJavaVisitor(sonarComponents->workDir()));
        }
        testCodeVisitors.push_back(new SyntaxHighlighterVisitor(sonarComponents));
    }
    classpath = sonarComponents->getJavaClasspath();
}",1
"int cards;
int minutes;
std::string query = ""select sum(case when ease > 0 then 1 else 0 end), ""
    ""sum(time)/1000 from revlog where id > "" + std::to_string((collection.getSched().getDayCutoff() - SECONDS_PER_DAY) * 1000);
spdlog::debug(""DeckPreviewStatistics query: {}"", query);

auto cur = collection.getDb()->executeQuery(query);","```cpp
int cards;
int minutes;
std::string query = ""select sum(case when ease > 0 then 1 else 0 end), ""  // cards, excludes rescheduled cards
                    ""sum(time)/1000 from revlog where id > "" +
                    std::to_string((collection.getSched().getDayCutoff() - SECONDS_PER_DAY) * 1000);
spdlog::debug(""DeckPreviewStatistics query: {}"", query);

auto cur = collection.getDb()->executeQuery(query);
```",1
"}

private:
OAuthCallbackConfig buildOAuthCallbackConfig(const CoreEvent& event) {
    auto valueResolver = resolverSet.getResolvers().at(OAUTH_CALLBACK_GROUP_NAME);
    auto context = ValueResolvingContext::builder(event)
        .dynamic(valueResolver->isDynamic())
        .withExpressionManager(expressionManager)
        .build();
    auto map = std::any_cast<std::map<std::string, std::any>>(valueResolver->resolve(context));
    return buildOAuthCallbackConfig(map);
}","```cpp
OAuthCallbackConfig buildOAuthCallbackConfig(const CoreEvent& event) {
    ValueResolverBase* valueResolver = resolverSet.getResolvers().at(OAUTH_CALLBACK_GROUP_NAME).get();
    ValueResolvingContext context = ValueResolvingContext::builder(event)
        .dynamic(valueResolver->isDynamic())
        .withExpressionManager(expressionManager)
        .build();
    auto map = std::any_cast<std::map<std::string, std::any>>(valueResolver->resolve(context));
    return buildOAuthCallbackConfig(map);
}
```",0
"private:
    std::string describeType(const Type& type) {
        switch (type.getSort()) {
            case Type::OBJECT:
                return type.getInternalName();
            case Type::INT:
            case Type::BYTE:
            case Type::BOOLEAN:
                // ...
                break;
        }
        return """";
    }","```cpp
private:
    std::string describeType(const Type& type) {
        switch (type.getSort()) {
            case Type::OBJECT:
                return type.getInternalName();
            case Type::INT:
            case Type::BYTE:
            case Type::BOOLEAN:
                // handle other cases as appropriate
                break;
        }
        return {};
    }
```",1
"```cpp
IDATA j9mem_check_tags(VoidPointer memoryPointer, long headerEyecatcher, long footerEyecatcher) {
    J9MemTagPointer headerTagAddress = j9mem_get_header_tag(memoryPointer);
    J9MemTagPointer footerTagAddress = J9MemTagPointer::NULL_VALUE;
    try {
        footerTagAddress = j9mem_get_footer_tag(headerTagAddress);
```","IDATA j9mem_check_tags(VoidPointer memoryPointer, long headerEyecatcher, long footerEyecatcher)
{
    J9MemTagPointer headerTagAddress = j9mem_get_header_tag(memoryPointer);
    J9MemTagPointer footerTagAddress = J9MemTagPointer::NULLPOINTER;

    try {
        footerTagAddress = j9mem_get_footer_tag(headerTagAddress);",0
"int numPending = tracker.addNewAsPending(res);
if (numPending > 0) {
    LOG.info(
        ""{} - current round of polling took {} ms and returned {} results, ""
        ""of which {} were new. The output is {}."",
        c.element(),
        std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - now).count(),
        res.getOutputs().size(),
        numPending,
        BoundedWindow::TIMESTAMP_MAX_VALUE == res.getWatermark()
            ? ""final""
            : ""not yet final""
    );
}

int numEmittedInThisRound = 0;
int numTotalPending = tracker.getNumPending();
int numPreviouslyEmitted = tracker.currentRestriction().completed.size();
int numTotalKnown = numPreviouslyEmitted + numTotalPending;
while (true) {
    c.updateWatermark(tracker.getWatermark());
    auto entry = tracker.getNextPending();
    if (entry == nullptr || !tracker.tryClaim(entry->first)) {
        break;
    }
    TimestampedValue<OutputT> nextPending = entry->second;
    c.outputWithTimestamp(
        KV::of(c.element(), nextPending.getValue()), nextPending.getTimestamp());
    ++numEmittedInThisRound;
}
LOG.info(
    ""{} - emitted {} new results (of {} total known: {} emitted so far, {} more to emit)."",
    c.element(),
    numEmittedInThisRound,
    numTotalKnown,
    numEmittedInThisRound + numPreviouslyEmitted,
    numTotalPending - numEmittedInThisRound
);

auto watermark = tracker.getWatermark();
if (watermark != nullptr) {
    // Null means the poll result did not provide a watermark and there were no new elements,
}","```cpp
int numPending = tracker.addNewAsPending(res);
if (numPending > 0) {
    LOG.info(
        ""{} - current round of polling took {} ms and returned {} results, of which {} were new. The output is {}."",
        c.element(),
        std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now() - now).count(),
        res.getOutputs().size(),
        numPending,
        BoundedWindow::TIMESTAMP_MAX_VALUE == res.getWatermark()
            ? ""final""
            : ""not yet final""
    );
}

int numEmittedInThisRound = 0;
int numTotalPending = tracker.getNumPending();
int numPreviouslyEmitted = tracker.currentRestriction().completed.size();
int numTotalKnown = numPreviouslyEmitted + numTotalPending;
while (true) {
    c.updateWatermark(tracker.getWatermark());

    auto entry = tracker.getNextPending();
    if (!entry || !tracker.tryClaim(entry->first)) {
        break;
    }
    auto& nextPending = entry->second;
    c.outputWithTimestamp(
        std::make_pair(c.element(), nextPending.getValue()), nextPending.getTimestamp());
    ++numEmittedInThisRound;
}
LOG.info(
    ""{} - emitted {} new results (of {} total known: {} emitted so far, {} more to emit)."",
    c.element(),
    numEmittedInThisRound,
    numTotalKnown,
    numEmittedInThisRound + numPreviouslyEmitted,
    numTotalPending - numEmittedInThisRound);

auto watermark = tracker.getWatermark();
if (watermark != nullptr) {
    // Null means the poll result did not provide a watermark and there were no new elements,
}
```",1
"virtual void* getAsyncContext() override {
    return new AsyncContext(static_cast<LocalModeWorkerContext*>(workerContext)->getCurrentTask());
}

virtual void setAsyncContext(void* asyncContext) override {
    Preconditions::checkNotNull(asyncContext);
    TaskSpec* task = static_cast<AsyncContext*>(asyncContext)->task;
    static_cast<LocalModeWorkerContext*>(workerContext)->setCurrentTask(task);
    BaseClass::setAsyncContext(asyncContext);
}","```cpp
class RayDevRuntime : public AbstractRayRuntime {
public:
    virtual AsyncContext* getAsyncContext() override {
        return new AsyncContext(static_cast<LocalModeWorkerContext*>(workerContext)->getCurrentTask());
    }

    virtual void setAsyncContext(void* asyncContext) override {
        Preconditions::checkNotNull(asyncContext);
        TaskSpec* task = static_cast<AsyncContext*>(asyncContext)->task;
        static_cast<LocalModeWorkerContext*>(workerContext)->setCurrentTask(task);
        AbstractRayRuntime::setAsyncContext(asyncContext);
    }
};
```",1
"std::string message;
auto it = jsonObject.find(AzkabanClientParams::MESSAGE);
if (it != jsonObject.end() && it->second) {
    message = std::regex_replace(it->second->toString(), std::regex(""\""""), """");
} else {
    message = ""Unknown issue"";
}
if (message.find(""Invalid Session"") != std::string::npos) {
    throw InvalidSessionException(message);
}
throw std::ios_base::failure(message);","if (jsonObject[AzkabanClientParams::MESSAGE] != nullptr) {
    std::string message = jsonObject[AzkabanClientParams::MESSAGE].get<std::string>();
    message.erase(std::remove(message.begin(), message.end(), '\""'), message.end());

    if (message.find(""Invalid Session"") != std::string::npos) {
        throw InvalidSessionException(message);
    }

    throw std::ios_base::failure(message);
} else {
    std::string message = ""Unknown issue"";
    if (message.find(""Invalid Session"") != std::string::npos) {
        throw InvalidSessionException(message);
    }
    throw std::ios_base::failure(message);
}",0
"#include <vector>
#include <memory>

class Processor {};

class MuleException : public std::exception {};

class Scheduler {
public:
    void dispose() {}
};

class SchedulerService {
public:
    std::shared_ptr<Scheduler> ioScheduler(int) { return std::make_shared<Scheduler>(); }
};

class MuleContext {
public:
    int getSchedulerBaseConfig() const { return 0; }
};

std::shared_ptr<Scheduler> fromExecutorService(std::shared_ptr<Scheduler> scheduler) {
    return scheduler;
}

class BaseClass {
public:
    virtual void start() {}
    virtual void stop() {}
};

class MyClass : public BaseClass {
private:
    std::vector<std::shared_ptr<Processor>> routes;
    std::shared_ptr<Scheduler> scheduler;
    SchedulerService schedulerService;
    MuleContext muleContext;
public:
    void start() override {
        scheduler = fromExecutorService(schedulerService.ioScheduler(muleContext.getSchedulerBaseConfig()));
        BaseClass::start();
    }

    void stop() override {
        BaseClass::stop();
        if (scheduler) {
            scheduler->dispose();
            scheduler = nullptr;
        }
    }
};","#include <vector>
#include <memory>

class Processor {};

class ScatterGatherRouter : public AbstractMessageProcessorOwner, public SomeInterface {
private:
    std::vector<std::shared_ptr<Processor>> routes;

protected:
    std::shared_ptr<Scheduler> scheduler;

public:
    void start() override {
        scheduler = fromExecutorService(schedulerService.ioScheduler(muleContext.getSchedulerBaseConfig()));
        AbstractMessageProcessorOwner::start();
    }

    void stop() override {
        AbstractMessageProcessorOwner::stop();
        if (scheduler) {
            scheduler->dispose();
            scheduler = nullptr;
        }
    }
};",1
"#include <vector>
#include <unordered_map>
#include <iterator>
#include <string>","#include <vector>
#include <unordered_map>
#include <string>

using std::vector;
using std::unordered_map;
using std::string;",0
"#include ""ClassUtils.h""
#include ""MuleExtensionUtils.h""
#include ""ReconnectionUtils.h""

using mule::runtime::core::api::util::ClassUtils::setContextClassLoader;
using mule::runtime::module::extension::internal::util::MuleExtensionUtils::getClassLoader;
using mule::runtime::module::extension::internal::util::MuleExtensionUtils::getMutableConfigurationStats;
using mule::runtime::module::extension::internal::util::MuleExtensionUtils::isConnectedStreamingOperation;
using mule::runtime::module::extension::internal::util::ReconnectionUtils::NULL_THROWABLE_CONSUMER;
using mule::runtime::module::extension::internal::util::ReconnectionUtils::shouldRetry;","#include ""org/mule/runtime/core/api/rx/Exceptions.h""
#include ""org/mule/runtime/core/api/util/ClassUtils.h""
#include ""org/mule/runtime/module/extension/internal/util/MuleExtensionUtils.h""
#include ""org/mule/runtime/module/extension/internal/util/ReconnectionUtils.h""

using org::mule::runtime::core::api::rx::wrapFatal;
using org::mule::runtime::core::api::util::ClassUtils::setContextClassLoader;
using org::mule::runtime::module::extension::internal::util::MuleExtensionUtils::getClassLoader;
using org::mule::runtime::module::extension::internal::util::MuleExtensionUtils::getMutableConfigurationStats;
using org::mule::runtime::module::extension::internal::util::MuleExtensionUtils::isConnectedStreamingOperation;
using org::mule::runtime::module::extension::internal::util::ReconnectionUtils::NULL_THROWABLE_CONSUMER;
using org::mule::runtime::module::extension::internal::util::ReconnectionUtils::shouldRetry;",0
"#include <string>
#include <vector>
#include <map>
#include <set>
#include <memory>
#include <mutex>
#include <thread>
#include <atomic>
#include <algorithm>
#include <chrono>
#include <functional>
#include <random>
#include <sstream>

template<typename T>
class ServiceConfig : public AbstractServiceConfig {
private:
    static Protocol* protocol;
    static ProxyFactory* proxyFactory;
    static std::map<std::string, int> RANDOM_PORT_MAP;
    static std::mutex random_port_mutex;

    std::vector<URL> urls;
    std::vector<std::shared_ptr<ExporterBase>> exporters;

    std::string interfaceName;
    const std::type_info* interfaceClass = nullptr;
    T* ref = nullptr;
    std::string path;
    std::vector<MethodConfig> methods;
    ProviderConfig* provider = nullptr;
    std::string providerIds;
    std::atomic<bool> exported {false};
    std::atomic<bool> unexported {false};
    std::string generic;

public:
    ServiceConfig() = default;

    ServiceConfig(const Service& service) {
        appendAnnotation<Service>(service);
    }

    static std::vector<ProtocolConfig> convertProviderToProtocol(const std::vector<ProviderConfig>& providers) {
        std::vector<ProtocolConfig> protocols;
        for (const auto& provider : providers) {
            protocols.push_back(convertProviderToProtocol(provider));
        }
        return protocols;
    }

    static std::vector<ProviderConfig> convertProtocolToProvider(const std::vector<ProtocolConfig>& protocols) {
        std::vector<ProviderConfig> providers;
        for (const auto& protocol : protocols) {
            providers.push_back(convertProtocolToProvider(protocol));
        }
        return providers;
    }

    static ProtocolConfig convertProviderToProtocol(const ProviderConfig& provider) {
        ProtocolConfig protocol;
        protocol.setName(provider.getProtocol().getName());
        protocol.setServer(provider.getServer());
        protocol.setClient(provider.getClient());
        protocol.setCodec(provider.getCodec());
        protocol.setHost(provider.getHost());
        protocol.setPort(provider.getPort());
        protocol.setPath(provider.getPath());
        protocol.setPayload(provider.getPayload());
        protocol.setThreads(provider.getThreads());
        protocol.setParameters(provider.getParameters());
        return protocol;
    }

    static ProviderConfig convertProtocolToProvider(const ProtocolConfig& protocol) {
        ProviderConfig provider;
        provider.setProtocol(protocol);
        provider.setServer(protocol.getServer());
        provider.set","```cpp
#include <string>
#include <vector>
#include <map>
#include <set>
#include <memory>
#include <algorithm>
#include <iterator>
#include <mutex>
#include <atomic>
#include <thread>
#include <chrono>
#include <future>
#include <random>
#include <cstdlib>

// Forward declarations and type aliases
class URL;
class Protocol;
class ProxyFactory;
class ExporterBase;
template<typename T> using Exporter = std::shared_ptr<ExporterBase>;
class MethodConfig;
class ProviderConfig;
class ProtocolConfig;
class GenericService;
class AppendParametersComponent;
class MetadataReportService;
class DelegateProviderMetaDataInvoker;
template<typename T> class Invoker;
class ConfigManager;
class ApplicationModel;

class ServiceConfigBase {
protected:
    std::vector<ProtocolConfig> protocols;
    std::string group;
    std::string version;
    std::string id;
    // Other state/configuration fields...
    virtual void refresh() {} // stub
    virtual void checkApplication() {}
    virtual void checkRegistry() {}
    virtual void checkMetadataReport() {}
    virtual void startConfigCenter() {}
    virtual void checkInterfaceAndMethods(const std::type_info&, const std::vector<MethodConfig>&) {}
    virtual void checkStubAndLocal(const std::type_info&) {}
    virtual void checkMock(const std::type_info&) {}
    virtual void appendRuntimeParameters(std::map<std::string, std::string>&) {}
    virtual void appendParameters(std::map<std::string, std::string>&, ...) {}
    virtual void checkPathName(const std::string&, const std::string&) {}
    virtual std::vector<std::string> getSubProperties(const std::map<std::string, std::string>&, const std::string&) { return {}; }
    virtual std::vector<URL> loadRegistries(bool) { return {}; }
    virtual URL loadMonitor(const URL&) { return URL(); }
    virtual MetadataReportService* getMetadataReportService() { return nullptr; }
    // ... etc.
};

template<typename T>
class ServiceConfig : public ServiceConfigBase {
public:
    ServiceConfig() = default;

    // Constructor with annotation
    explicit ServiceConfig(const Service& service) {
        appendAnnotation(service);
        setMethods(MethodConfig::constructMethodConfig(service.methods()));
    }

    URL toUrl() const {
        return urls.empty() ? URL() : urls.front();
    }

    const std::vector<URL>& toUrls() const {
        return urls;",1
"#include ""graylog2/configuration/HttpConfiguration.h""
#include ""graylog2/jersey/PrefixAddingModelProcessor.h""
#include ""graylog2/plugin/rest/PluginRestResource.h""
#include ""graylog2/rest/filter/WebAppNotFoundResponseFilter.h""","#include <string>
#include <vector>
#include <memory> 

#include ""PluginAuditEventTypes.h""
#include ""AuditEventModelProcessor.h""
#include ""HttpConfiguration.h""
#include ""PrefixAddingModelProcessor.h""
#include ""PluginRestResource.h""
#include ""WebAppNotFoundResponseFilter.h""",0
"std::vector<std::string> dockerOptsBuilder;
// ...host networking on Mac...
dockerOptsBuilder.push_back(""--env=DOCKER_MAC_CONTAINER="" + std::getenv(""DOCKER_MAC_CONTAINER""));

bool retainDockerContainer = pipelineOptions.as<ManualDockerEnvironmentOptions>().getRetainDockerContainers();
if (!retainDockerContainer) {
    dockerOptsBuilder.push_back(""--rm"");
}

std::string semiPersistDir = pipelineOptions.as<RemoteEnvironmentOptions>().getSemiPersistDir();
std::vector<std::string> argsBuilder;
argsBuilder.push_back(""--id="" + workerId);
argsBuilder.push_back(""--logging_endpoint="" + loggingEndpoint);
argsBuilder.push_back(""--artifact_endpoint="" + artifactEndpoint);
argsBuilder.push_back(""--provision_endpoint="" + provisionEndpoint);
argsBuilder.push_back(""--control_endpoint="" + controlEndpoint);
if (!semiPersistDir.empty()) {
    argsBuilder.push_back(""--semi_persist_dir="" + semiPersistDir);
}

LOG.debug(""Creating Docker Container with ID {}"", workerId);
std::string containerId;
InstructionRequestHandler instructionHandler;
try {
    containerId = docker.runImage(containerImage, dockerOptsBuilder, argsBuilder);
    LOG.debug(""Created Docker Container with Container ID {}"", containerId);
    try {
        // ...","std::vector<std::string> dockerOptsBuilder;
dockerOptsBuilder.push_back(""--env=DOCKER_MAC_CONTAINER="" + std::getenv(""DOCKER_MAC_CONTAINER""));

bool retainDockerContainer = pipelineOptions.as<ManualDockerEnvironmentOptions>().getRetainDockerContainers();
if (!retainDockerContainer) {
    dockerOptsBuilder.push_back(""--rm"");
}

std::string semiPersistDir = pipelineOptions.as<RemoteEnvironmentOptions>().getSemiPersistDir();
std::vector<std::string> argsBuilder;
argsBuilder.push_back(""--id="" + workerId);
argsBuilder.push_back(""--logging_endpoint="" + loggingEndpoint);
argsBuilder.push_back(""--artifact_endpoint="" + artifactEndpoint);
argsBuilder.push_back(""--provision_endpoint="" + provisionEndpoint);
argsBuilder.push_back(""--control_endpoint="" + controlEndpoint);
if (!semiPersistDir.empty()) {
    argsBuilder.push_back(""--semi_persist_dir="" + semiPersistDir);
}

LOG.debug(""Creating Docker Container with ID {}"", workerId);
std::string containerId;
InstructionRequestHandler instructionHandler = nullptr;
try {
    containerId = docker.runImage(containerImage, dockerOptsBuilder, argsBuilder);
    LOG.debug(""Created Docker Container with Container ID {}"", containerId);
    try {
        // ...",1
"```cpp
static ServiceManager* serviceRepository;
static ClassLoaderRepository* classLoaderRepository;
static IsolatedClassLoaderExtensionsManagerConfigurationBuilder* extensionsManagerConfigurationBuilder;
static IsolatedClassLoaderExtensionsManagerConfigurationBuilder* alternativeExtensionsManagerConfigurationBuilder;

static TestServicesMuleContextConfigurator* serviceConfigurator;

Once::RunOnce loadExtensions = Once::of([]() { extensionsManagerConfigurationBuilder->loadExtensionModels(); });

static void configureClassLoaderRepository();
```","```cpp
static ServiceManager* serviceRepository;
static ClassLoaderRepository* classLoaderRepository;
static IsolatedClassLoaderExtensionsManagerConfigurationBuilder* extensionsManagerConfigurationBuilder;
static IsolatedClassLoaderExtensionsManagerConfigurationBuilder* alternativeExtensionsManagerConfigurationBuilder;

static TestServicesMuleContextConfigurator* serviceConfigurator;
Once::RunOnce loadExtensions = Once::of([&]() { extensionsManagerConfigurationBuilder->loadExtensionModels(); });


@BeforeClass
static void configureClassLoaderRepository();
```",1
"+ clazz.type().name() + "" is not subtype of interface."";
}
if (clazz.has_annotation<Adaptive>()) {
    cacheAdaptiveClass(clazz);
} else if (isWrapperClass(clazz)) {
    cacheWrapperClass(clazz);
} else {
    clazz.get_constructor();
    if (StringUtils::isEmpty(name)) {","```cpp
if (!std::is_base_of<InterfaceType, Clazz>::value) {
    throw std::logic_error(std::string(typeid(Clazz).name()) + "" is not subtype of interface."");
}
if (hasAdaptiveAnnotation<Clazz>()) {
    cacheAdaptiveClass<Clazz>();
} else if (isWrapperClass<Clazz>()) {
    cacheWrapperClass<Clazz>();
} else {
    Clazz();
    if (StringUtils::isEmpty(name)) {
```",0
"bool isFileSystemAvailable() override {
    return isPathAvailable(Path(""/""));
}

bool isDatasetAvailable(const Path& datasetPath) {
    return isPathAvailable(datasetPath);
}","class HadoopFsEndPoint : public EndPoint {
public:
    bool isFileSystemAvailable() override {
        return isPathAvailable(Path(""/""));
    }

    bool isDatasetAvailable(const Path& datasetPath) {
        return isPathAvailable(datasetPath);
    }
};",0
"FileBasedSink(ValueProvider<std::string> baseOutputFilename, const std::string& extension,
              const std::string& fileNamingTemplate, WritableByteChannelFactory writableByteChannelFactory) 
    : writableByteChannelFactory(writableByteChannelFactory),
      baseOutputFilename(baseOutputFilename)
{
    if (!writableByteChannelFactory.getFilenameSuffix().empty()) {","FileBasedSink(ValueProvider<std::string> baseOutputFilename, const std::string& extension,
              const std::string& fileNamingTemplate, WritableByteChannelFactory* writableByteChannelFactory)
    : writableByteChannelFactory(writableByteChannelFactory),
      baseOutputFilename(baseOutputFilename) {
    if (!isNullOrEmpty(writableByteChannelFactory->getFilenameSuffix())) {
        // implementation here
    }
}",1
"#include <vector>
#include <string>

std::vector<std::string> getExcludedArtifacts() {
    std::vector<std::string> listOfExcludeArtifacts;
    for (const std::string& excludeArtifact : excludeArtifacts) {
        listOfExcludeArtifacts.push_back(excludeArtifact);
    }
    return listOfExcludeArtifacts;
}

std::string getAdditionalIncludesForArtifact(const Artifact& artifact) {
    if ((buildInfo.getMinorVersion() == ""4"" || buildInfo.getMinorVersion() == ""6"")
        && buildInfo.getMajorVersion() == ""2"") {
        return ""$(UMA_PATH_TO_ROOT)include $(UMA_PATH_TO_ROOT)oti "";
    }
    return """";
}","std::vector<std::string> getExcludedArtifacts() {
    std::vector<std::string> listOfExcludeArtifacts;
    for (const auto& excludeArtifact : excludeArtifacts) {
        listOfExcludeArtifacts.push_back(excludeArtifact);
    }
    return listOfExcludeArtifacts;
}

std::string getAdditionalIncludesForArtifact(const Artifact& artifact) {
    if ((buildInfo.getMinorVersion() == ""4"" || buildInfo.getMinorVersion() == ""6"")
        && buildInfo.getMajorVersion() == ""2"") {
        return ""$(UMA_PATH_TO_ROOT)include $(UMA_PATH_TO_ROOT)oti "";
    }
    return """";
}",0
"private:
void createAndDisposeQueue(const std::string& queueName)
{
    DualRandomAccessFileQueueStoreDelegate queue(queueName, workingDirectory.getRoot().getAbsolutePath(), mockMuleContext, 1);
    queue.dispose();
}","void createAndDisposeQueue(const std::string& queueName)
{
    DualRandomAccessFileQueueStoreDelegate queue(queueName, workingDirectory.getRoot().getAbsolutePath(), mockMuleContext, 1);
    queue.dispose();
}",0
"#include <string>
#include <memory>
#include <stdexcept>
#include <cassert>
#include <mqtt/async_client.h>

class MessagingTemplate {};
class MqttHeaders {};
class MqttMessageConverter {};
template<typename T>
class Message {};
class MessageChannel {};

using IMqttDeliveryToken = mqtt::itoken;
using MqttAsyncClient = mqtt::async_client;
using MqttCallback = virtual mqtt::callback;
using MqttConnectOptions = mqtt::connect_options;
using MqttException = mqtt::exception;
using MqttMessage = mqtt::message;

class DefaultMqttPahoClientFactory {};
class MqttPahoClientFactory {};

class MessagingException : public std::runtime_error {
public:
    explicit MessagingException(const std::string& msg)
        : std::runtime_error(msg) {}
};

inline void Assert(bool condition, const std::string& message) {
    if (!condition) throw std::logic_error(message);
}","#include <string>
#include <memory>
#include <cassert>",0
"template<typename Context, typename Key>
MetadataResult<OutputMetadataDescriptor> getOutputMetadataDescriptor(const Context& context, const Key& key) {
    MetadataResult<MetadataType> outputMetadataResult = getOutputMetadata(context, key);
    MetadataResult<MetadataType> attributesMetadataResult = getOutputAttributesMetadata(context, key);

    MetadataResult<TypeMetadataDescriptor> outputDescriptor = toTypeMetadataDescriptorResult(outputMetadataResult);
    MetadataResult<TypeMetadataDescriptor> attributesDescriptor = toTypeMetadataDescriptorResult(attributesMetadataResult);

    OutputMetadataDescriptor descriptor =
        OutputMetadataDescriptor::builder()
            .withReturnType(outputDescriptor)
            .withAttributesType(attributesDescriptor)
            .build();

    return MetadataResult<OutputMetadataDescriptor>::success(descriptor);
}","```cpp
private:
MetadataResult<OutputMetadataDescriptor> getOutputMetadataDescriptor(MetadataContext context, MetadataKey key) {
    MetadataResult<MetadataType> outputMetadataResult = getOutputMetadata(context, key);
    MetadataResult<MetadataType> attributesMetadataResult = getOutputAttributesMetadata(context, key);

    MetadataResult<TypeMetadataDescriptor> outputDescriptor = toTypeMetadataDescriptorResult(outputMetadataResult);
    MetadataResult<TypeMetadataDescriptor> attributesDescriptor = toTypeMetadataDescriptorResult(attributesMetadataResult);

    OutputMetadataDescriptor descriptor =
        OutputMetadataDescriptor::builder()
            .withReturnType(outputDescriptor)
            .withAttributesType(attributesDescriptor)
            .build();

    return MetadataResult<OutputMetadataDescriptor>::success(descriptor);
}
```",0
"for (int i = 0; i <= J9SHR_DATA_TYPE_MAX; i++) {
    numByteOfType[i] = 0;
}

for (int i = 0; i < metaStartArray.size(); i++) {
    CommandUtils::dbgPrint(out, ""Meta data region to be used: %s..%s\n"",
        metaStartArray[i].getHexAddress().c_str(),
        metaEndArray[i].getHexAddress().c_str()
    );
}

for (int i = 0; i < metaStartArray.size(); i++) {
    U8Pointer metaStart = metaStartArray[i];
    U8Pointer metaEnd = metaEndArray[i];
    SharedClassMetadataIterator iterator(vm, metaStart, metaEnd, 0, true, out);
    while (iterator.hasNext()) {
        ShcItemPointer it = iterator.next();
        U16 itemType = it.dataType();

        J9ROMClassPointer romClass;
        J9UTF8Pointer romClassName;
        ROMClassWrapperPointer rcw;
        ScopedROMClassWrapperPointer srcw;
        J9UTF8Pointer rcPartition = J9UTF8Pointer::NULL_VALUE;
        J9UTF8Pointer rcModContext = J9UTF8Pointer::NULL_VALUE;
        ClasspathWrapperPointer cpw;
        ClasspathItemPointer cpi;
        UDATA cpiType;
        UDATA byteDataType;
        CompiledMethodWrapperPointer cmw;
        J9ROMMethodPointer romMethod;
        UDATA dataLen, codeLen;
        J9UTF8Pointer utf8;
        ByteDataWrapperPointer bdw;
        UDATA rwOffset, len;
        CharArrayWrapperPointer caw;
        CacheletWrapperPointer cachelet;
        AttachedDataWrapperPointer adw;
        bool isStale = ShcItemHdrHelper::CCITEMSTALE(ShcItemHdrPointer::cast(ShcItemHelper::ITEMEND(it)));

        if (isStale) {
            totalStaleBytes += ShcItemHdrHelper::CCITEMLEN(ShcItemHdrPointer::cast(ShcItemHelper::ITEMEND(it))).longValue();
            ++numStale;
        }

        if (itemType.eq(TYPE_ORPHAN)) {
            rcMetaLen += OrphanWrapper::SIZEOF + ShcItem::SIZEOF + ShcItemHdr::SIZEOF;
            romClass = OrphanWrapperHelper::romClass(Orphan","for (int i = 0; i <= J9SHR_DATA_TYPE_MAX; i++) {
    numByteOfType[i] = 0;
}

for (int i = 0; i < metaStartArray.size(); i++) {
    CommandUtils::dbgPrint(out, ""Meta data region to be used: %s..%s\n"", metaStartArray[i].getHexAddress().c_str(), metaEndArray[i].getHexAddress().c_str());
}

for (int i = 0; i < metaStartArray.size(); i++) {
    U8Pointer metaStart = metaStartArray[i];
    U8Pointer metaEnd = metaEndArray[i];
    SharedClassMetadataIterator iterator(vm, metaStart, metaEnd, 0, true, out);
    while (iterator.hasNext()) {
        ShcItemPointer it = iterator.next();
        U16 itemType = it.dataType();

        J9ROMClassPointer romClass;
        J9UTF8Pointer romClassName;
        ROMClassWrapperPointer rcw;
        ScopedROMClassWrapperPointer srcw;
        J9UTF8Pointer rcPartition = J9UTF8Pointer::NULL_;
        J9UTF8Pointer rcModContext = J9UTF8Pointer::NULL_;
        ClasspathWrapperPointer cpw;
        ClasspathItemPointer cpi;
        UDATA cpiType;
        UDATA byteDataType;
        CompiledMethodWrapperPointer cmw;
        J9ROMMethodPointer romMethod;
        UDATA dataLen, codeLen;
        J9UTF8Pointer utf8;
        ByteDataWrapperPointer bdw;
        UDATA rwOffset, len;
        CharArrayWrapperPointer caw;
        CacheletWrapperPointer cachelet;
        AttachedDataWrapperPointer adw;
        bool isStale = ShcItemHdrHelper::CCITEMSTALE(ShcItemHdrPointer::cast(ShcItemHelper::ITEMEND(it)));

        if (isStale) {
            totalStaleBytes += ShcItemHdrHelper::CCITEMLEN(ShcItemHdrPointer::cast(ShcItemHelper::ITEMEND(it))).longValue();
            ++numStale;
        }

        if (itemType.eq(TYPE_ORPHAN)) {
            rcMetaLen += OrphanWrapper::SIZEOF + ShcItem::SIZEOF + ShcItemHdr::SIZEOF;
            romClass = OrphanWrapperHelper::romClass(OrphanWrapperPointer::cast(Sh",1
"if (dynamic_cast<org::mule::sdk::api::runtime::connectivity::Reconnectable*>(sourceInvokationTarget.get()) != nullptr) {
    return of(create([&](auto sink) {
        static_cast<org::mule::sdk::api::runtime::connectivity::Reconnectable*>(sourceInvokationTarget.get())
            ->reconnect(e, std::make_shared<ReactiveReconnectionCallback>(sink));
    }));
}

return empty();","if (auto reconnectable = dynamic_cast<Reconnectable*>(sourceInvokationTarget.get())) {
    return of(create([=](auto& sink) {
        reconnectable->reconnect(e, ReactiveReconnectionCallback(sink));
    }));
} else if (auto reconnectable = dynamic_cast<org::mule::sdk::api::runtime::connectivity::Reconnectable*>(sourceInvokationTarget.get())) {
    return of(create([=](auto& sink) {
        reconnectable->reconnect(e, ReactiveReconnectionCallback(sink));
    }));
}

return empty();",1
"#include <windows.h>

private:
    void* ActiveXMergeRegion(void* region) {
        return ActiveXInstance.MergeRegion(region);
    }","inline void* ActiveXMergeRegion(void* region) {
    return ActiveXInstance.MergeRegion(region);
}",1
"```cpp
bool closeAllJobsAndTransformations() {
    if (getActiveMeta() == nullptr) {
        return true;
    }

    bool operationsNotAllowed = RepositorySecurityUI::verifyOperations(shell, rep, false,
        RepositoryOperation::EXECUTE_TRANSFORMATION, RepositoryOperation::EXECUTE_JOB);

    MessageDialog* md = nullptr;
    int answer = -1;

    if (operationsNotAllowed) {
        md = new MessageDialog(
            getShell(),
            BaseMessages::getString(PKG, ""Spoon.Dialog.WarnToCloseAll.Title""),
            nullptr,
            BaseMessages::getString(PKG, ""Spoon.Dialog.WarnToCloseAll.Message""),
            MessageDialog::WARNING,
            std::vector<std::string>{
                BaseMessages::getString(PKG, ""Spoon.Message.Warning.Yes""),
                BaseMessages::getString(PKG, ""Spoon.Message.Warning.No"")
            },
            0
        );
        answer = md->open();
    } else if (props.showCloseAllFilesWarning()) {
        md = new MessageDialogWithToggle(
            getShell(),
            BaseMessages::getString(PKG, ""Spoon.Dialog.PromptToCloseAll.Title""),
            nullptr,
            BaseMessages::getString(PKG, ""Spoon.Dialog.PromptToCloseAll.Message""),
            MessageDialog::QUESTION,
            std::vector<std::string>{
                BaseMessages::getString(PKG, ""Spoon.Message.Warning.Yes""),
                BaseMessages::getString(PKG, ""Spoon.Message.Warning.No""),
                BaseMessages::getString(PKG, ""Spoon.Message.Warning.Cancel"")
            },
            0,
            BaseMessages::getString(PKG, ""Spoon.Dialog.PromptToCloseAll.DontAskAgain.Label""),
            !props.showCloseAllFilesWarning()
        );

        MessageDialogWithToggle::setDefaultImage(GUIResource::getInstance().getImageSpoon());
        answer = md->open();
        props.showSetCloseAllFilesWarning(!static_cast<MessageDialogWithToggle*>(md)->getToggleState());
        props.saveProps();
    } else {
        Spoon::getInstance().closeAllFiles();
        return true;
    }

    if ((answer & 0xFF) == 0) {
        Spoon::getInstance().closeAllFiles();
    } else if (answer == 257) {
        return true;
    } else {
        return false;
    }

    return true;
}
```","```cpp
bool closeAllJobsAndTransformations() {
    if (getActiveMeta() == nullptr) {
        return true;
    }

    bool operationsNotAllowed = RepositorySecurityUI::verifyOperations(
        shell, rep, false,
        RepositoryOperation::EXECUTE_TRANSFORMATION,
        RepositoryOperation::EXECUTE_JOB
    );

    MessageDialog* md = nullptr;
    int answer = -1;

    if (operationsNotAllowed) {
        md = new MessageDialog(
            getShell(),
            BaseMessages::getString(PKG, ""Spoon.Dialog.WarnToCloseAll.Title""),
            nullptr,
            BaseMessages::getString(PKG, ""Spoon.Dialog.WarnToCloseAll.Message""),
            MessageDialog::WARNING,
            std::vector<std::string>{
                BaseMessages::getString(PKG, ""Spoon.Message.Warning.Yes""),
                BaseMessages::getString(PKG, ""Spoon.Message.Warning.No"")
            },
            0
        );
        answer = md->open();
    } else if (props.showCloseAllFilesWarning()) {
        md = new MessageDialogWithToggle(
            getShell(),
            BaseMessages::getString(PKG, ""Spoon.Dialog.PromptToCloseAll.Title""),
            nullptr,
            BaseMessages::getString(PKG, ""Spoon.Dialog.PromptToCloseAll.Message""),
            MessageDialog::QUESTION,
            std::vector<std::string>{
                BaseMessages::getString(PKG, ""Spoon.Message.Warning.Yes""),
                BaseMessages::getString(PKG, ""Spoon.Message.Warning.No""),
                BaseMessages::getString(PKG, ""Spoon.Message.Warning.Cancel"")
            },
            0,
            BaseMessages::getString(PKG, ""Spoon.Dialog.PromptToCloseAll.DontAskAgain.Label""),
            !props.showCloseAllFilesWarning()
        );

        MessageDialogWithToggle::setDefaultImage(
            GUIResource::getInstance().getImageSpoon()
        );

        answer = md->open();

        props.showSetCloseAllFilesWarning(
            !static_cast<MessageDialogWithToggle*>(md)->getToggleState()
        );
        props.saveProps();
    } else {
        Spoon::getInstance().closeAllFiles();
        return true;
    }

    if ((answer & 0xFF) == 0) {
        Spoon::getInstance().closeAllFiles();
    } else if (answer == 257) {
        return true;
    } else {
        return false;
    }
    return true;",1
"#include <vector>
#include <string>
#include <memory>
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <tuple>

namespace org {
namespace apache {
namespace hudi {
namespace table {
namespace action {
namespace rollback {

class HoodieRollbackStat;
class HoodieFileFormat;
class HoodieInstant;
class HoodieTimeline;
class HoodieSparkTable;
class HoodieClientTestBase;
class HoodieSparkEngineContext;
class HoodieWriteConfig;
class HoodieRecord;
class HoodieMetadataConfig;
class SparkRDDWriteClient;
class WriteStatus;
enum class HoodieTableType;

using std::vector;
using std::string;
using std::unique_ptr;
using std::shared_ptr;
using std::make_shared;
using std::tuple;

using Arguments = std::tuple<>;
using testing::TestWithParam;
using testing::Values;
using testing::Combine;

} // namespace rollback
} // namespace action
} // namespace table
} // namespace hudi
} // namespace apache
} // namespace org","#include <vector>
#include <string>
#include <gtest/gtest.h>

class HoodieRollbackStat {};
class HoodieFileFormat {};
class HoodieRecord {};
class HoodieInstant {};
class HoodieTimeline {};
class HoodieSparkTable {};
class HoodieWriteConfig {};
class HoodieMetadataConfig {};
class HoodieSparkEngineContext {};
class WriteStatus {};
class SparkRDDWriteClient {};

class HoodieClientTestBase {
protected:
    virtual void SetUp() {}
    virtual void TearDown() {}
};

class RollbackTest : public HoodieClientTestBase, public ::testing::TestWithParam<std::tuple<std::string, std::string>> {
protected:
    void SetUp() override {
        HoodieClientTestBase::SetUp();
    }
    void TearDown() override {
        HoodieClientTestBase::TearDown();
    }
};

std::vector<std::tuple<std::string, std::string>> test_params = {
    std::make_tuple(""param1"", ""param2"")
};

INSTANTIATE_TEST_SUITE_P(RollbackTestParams, RollbackTest, ::testing::ValuesIn(test_params));",0
"#include <algorithm>
#include <array>
#include <chrono>
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <list>
#include <map>
#include <memory>
#include <numeric>
#include <optional>
#include <random>
#include <set>
#include <sstream>
#include <string>
#include <unordered_map>
#include <utility>
#include <variant>
#include <vector>

using namespace std;
using namespace std::chrono;
namespace fs = std::filesystem;

// Placeholder for external class and enum definitions.
// Add definitions as needed for:
// HoodieActionInstant, HoodieCleanMetadata, HoodieCleanerPlan, HoodieCompactionPlan, HoodieInstantInfo, HoodieRequestedReplaceMetadata,
// HoodieRollbackMetadata, HoodieRollbackPartitionMetadata, HoodieSavepointMetadata, HoodieSavepointPartitionMetadata,
// HoodieCleanStat, FSUtils, FileSlice, HoodieCleaningPolicy, HoodieCommitMetadata, HoodieFileFormat,
// HoodiePartitionMetadata, HoodieReplaceCommitMetadata, HoodieTableType, HoodieWriteStat, IOType, WriteOperationType,
// HoodieTableConfig, HoodieTableMetaClient, HoodieInstant, HoodieTimeline, TimelineMetadataUtils,
// CleanPlanV2MigrationHandler, CompactionUtils, Option, ValidationUtils, Pair, HoodieIOException.


// Example static constants, typically C++ uses constexpr/const instead of import static for constants:

constexpr auto MERGE_ON_READ = HoodieTableType::MERGE_ON_READ;
constexpr auto CLUSTER = WriteOperationType::CLUSTER;
constexpr auto COMPACT = WriteOperationType::COMPACT;
constexpr auto INSERT = WriteOperationType::INSERT;
constexpr auto UPSERT = WriteOperationType::UPSERT;

constexpr auto CLEAN_ACTION = ""clean"";
constexpr auto COMMIT_ACTION = ""commit"";
constexpr auto DELTA_COMMIT_ACTION = ""deltacommit"";
constexpr auto REPLACE_COMMIT_ACTION = ""replacecommit"";

constexpr auto COMMIT_FORMATTER = ""%Y%m%d%H%M%S""; // placeholder

// FileCreateUtils namespace
namespace FileCreateUtils {
    string baseFileName(/* params */);
    void createCleanFile(/* params */);
    void createCommit(/* params */);
    void createDeltaCommit(/* params */);
    void createInflightCleanFile(/* params */);
    void createInflightCommit(/* params */);
    void createInflightCompaction(/* params */);
    void createInflightDeltaCommit(/* params */);
    void createInflightReplaceCommit(/* params */);
    void createInflightRollbackFile(/* params */);
}

// Additional utilities
static mt19937 rng(random_device","```cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <array>
#include <list>
#include <map>
#include <unordered_map>
#include <set>
#include <unordered_set>
#include <algorithm>
#include <functional>
#include <memory>
#include <optional>
#include <utility>
#include <iterator>
#include <string>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <ctime>
#include <random>
#include <chrono>
#include <filesystem>

using namespace std;
using namespace std::filesystem;
using namespace std::chrono;

// Placeholder includes for types dependent on external definitions
// #include ""HoodieActionInstant.h""
// #include ""HoodieCleanMetadata.h""
// #include ""HoodieCleanerPlan.h""
// #include ""HoodieCompactionPlan.h""
// #include ""HoodieInstantInfo.h""
// #include ""HoodieRequestedReplaceMetadata.h""
// #include ""HoodieRollbackMetadata.h""
// #include ""HoodieRollbackPartitionMetadata.h""
// #include ""HoodieSavepointMetadata.h""
// #include ""HoodieSavepointPartitionMetadata.h""
// #include ""HoodieCleanStat.h""
// #include ""FSUtils.h""
// #include ""FileSlice.h""
// #include ""HoodieCleaningPolicy.h""
// #include ""HoodieCommitMetadata.h""
// #include ""HoodieFileFormat.h""
// #include ""HoodiePartitionMetadata.h""
// #include ""HoodieReplaceCommitMetadata.h""
// #include ""HoodieTableType.h""
// #include ""HoodieWriteStat.h""
// #include ""IOType.h""
// #include ""WriteOperationType.h""
// #include ""HoodieTableConfig.h""
// #include ""HoodieTableMetaClient.h""
// #include ""HoodieInstant.h""
// #include ""HoodieTimeline.h""
// #include ""TimelineMetadataUtils.h""
// #include ""CleanPlanV2MigrationHandler.h""
// #include ""CompactionUtils.h""
// #include ""Option.h""
// #include ""ValidationUtils.h""
// #include ""Pair.h""
// #include ""HoodieIOException.h""

// Macros and type aliases to mimic Java constants/imports
constexpr auto SECONDS = chrono::seconds(1);

enum HoodieTableTypeImpl { MERGE_ON_READ };
using HoodieTableType = HoodieTableTypeImpl;

enum WriteOperationTypeImpl { CLUSTER, COMPACT, INSERT, UPSERT };
using WriteOperationType = WriteOperationTypeImpl;

#define CLEAN_ACTION """,0
"void setProp(const std::string& key, const std::any& value) {
    this->specProperties[key] = std::any_cast<std::string>(value);
}

void setProps(const std::map<std::string, std::string>& commonProperties, const std::map<std::string, std::string>& specProperties) {
    this->commonProperties = commonProperties;
    this->specProperties = specProperties;
}","void setProp(const std::string& key, const auto& value) {
    specProperties[key] = std::to_string(value);
}

void setProps(const std::map<std::string, std::string>& commonProperties,
              const std::map<std::string, std::string>& specProperties) {
    this->commonProperties = commonProperties;
    this->specProperties = specProperties;
}",0
"/ *
[DEL] *  Copyright 2002-2011 the original author or authors.
[ADD] *  Copyright 2002-2012 the original author or authors.
  *
  *  Licensed under the Apache License, Version 2.0 (the ""License"");
  *  you may not use this file except in compliance with the License.
*/","/*************************************************************
 *  Copyright 2002-2012 the original author or authors.
 *
 *  Licensed under the Apache License, Version 2.0 (the ""License"");
 *  you may not use this file except in compliance with the License.
 *************************************************************/",0
"assert(c != nullptr && ""Can not merge with NULL set"");
writeLock.lock();
try {
    for (const E& object : *c) {
        this->add(object);
    }
    return true;
}
catch (...) {
    // finally block to be filled after
    throw;
}","template <typename E>
class OrderedAwareLinkedHashSet : public std::list<E> {
public:
    bool mergeWith(const std::list<E>& c) {
        if (&c == nullptr) throw std::invalid_argument(""Can not merge with NULL set"");
        std::unique_lock<std::mutex> lock(writeLock);
        try {
            for (const auto& object : c) {
                this->add(object);
            }
            return true;
        } catch (...) {
            throw;
        }
    }

    void add(const E& object) {
        if (std::find(this->begin(), this->end(), object) == this->end()) {
            this->push_back(object);
        }
    }

private:
    std::mutex writeLock;
};",0
"PoolingProfile* poolingProfile = nullptr;
ReconnectionConfig reconnectionConfig = ReconnectionConfig::getDefault();

ConfigurationProperties* properties;

MuleContext* muleContext;","#include <memory>

class ConfigurationProperties;
class MuleContext;

class PoolingProfile;
class ReconnectionConfig {
public:
    static ReconnectionConfig getDefault();
};

class ConnectionProviderObjectFactory : public AbstractExtensionObjectFactory {
private:
    std::unique_ptr<PoolingProfile> poolingProfile = nullptr;
    ReconnectionConfig reconnectionConfig = ReconnectionConfig::getDefault();
    ConfigurationProperties* properties = nullptr;
    MuleContext* muleContext = nullptr;
};",1
"TableSchema getSchema() const {
    return fromJsonString(jsonSchema, TableSchema::typeClass());
}

TableReference getTable() const {
    return fromJsonString(jsonTableRef, TableReference::typeClass());
}

bool getValidate() const {
    return validate;
}

private:
BigQueryServices* getBigQueryServices() {
    if (testBigQueryServices != nullptr) {
        return testBigQueryServices;
    } else {
        return new BigQueryServicesImpl();
    }
}

};

Write() = delete;


class BigQuerySink : public FileBasedSink<TableRow> {
private:
    std::string jobIdToken;
    std::optional<std::string> jsonTable;
    std::optional<std::string> jsonSchema;
    WriteDisposition writeDisposition;
    CreateDisposition createDisposition;
    std::shared_ptr<Coder<TableRow>> coder;
    BigQueryServices* bqServices;

public:
    BigQuerySink(const std::string& jobIdToken,
                 const std::optional<std::string>& jsonTable,
                 const std::optional<std::string>& jsonSchema,
                 WriteDisposition writeDisposition,
                 CreateDisposition createDisposition,
                 const std::string& tempFile,
                 std::shared_ptr<Coder<TableRow>> coder,
                 BigQueryServices* bqServices)
        : FileBasedSink<TableRow>(tempFile, "".json""),
          jobIdToken(checkNotNull(jobIdToken, ""jobIdToken"")),
          jsonTable(jsonTable),
          jsonSchema(jsonSchema),
          writeDisposition(checkNotNull(writeDisposition, ""writeDisposition"")),
          createDisposition(checkNotNull(createDisposition, ""createDisposition"")),
          coder(checkNotNull(coder, ""coder"")),
          bqServices(checkNotNull(bqServices, ""bqServices""))
    {}

    std::unique_ptr<FileBasedSink<TableRow>::FileBasedWriteOperation> createWriteOperation(
            const PipelineOptions& options) override {
        return std::make_unique<BigQueryWriteOperation>(this);
    }

private:
    class BigQueryWriteOperation : public FileBasedWriteOperation<TableRow> {
        static constexpr int MAX_RETRY_LOAD_JOBS = 3;
        BigQuerySink* bigQuerySink;

    public:
        explicit BigQueryWriteOperation(BigQuerySink* sink)
            : FileBasedWriteOperation<TableRow>(checkNotNull(sink, ""sink"")),
              bigQuerySink(sink) {}

        std::unique_ptr<FileBasedWriter<TableRow>> createWriter(const PipelineOptions& options) override {
            return std","```cpp
class BigQueryIO {
public:
    class Write {
    public:
        TableSchema getSchema() const {
            return fromJsonString(jsonSchema, TableSchema::type());
        }

        TableReference getTable() const {
            return fromJsonString(jsonTableRef, TableReference::type());
        }

        bool getValidate() const {
            return validate;
        }

    private:
        BigQueryServices* getBigQueryServices() {
            if (testBigQueryServices != nullptr) {
                return testBigQueryServices;
            } else {
                return new BigQueryServicesImpl();
            }
        }

        Write() = delete;
    };

    class BigQuerySink : public FileBasedSink<TableRow> {
    private:
        std::string jobIdToken;
        std::optional<std::string> jsonTable;
        std::optional<std::string> jsonSchema;
        WriteDisposition writeDisposition;
        CreateDisposition createDisposition;
        std::shared_ptr<Coder<TableRow>> coder;
        BigQueryServices* bqServices;

        class BigQueryWriteOperation : public FileBasedWriteOperation<TableRow> {
        private:
            static constexpr int MAX_RETRY_LOAD_JOBS = 3;
            BigQuerySink* bigQuerySink;

            void load(
                LoadService* loadService,
                const std::string& jobIdPrefix,
                const TableReference& ref,
                const std::vector<std::string>& gcsUris,
                const std::optional<TableSchema>& schema,
                WriteDisposition writeDisposition,
                CreateDisposition createDisposition
            ) {
                JobConfigurationLoad loadConfig;
                loadConfig.setSourceUris(gcsUris);
                loadConfig.setDestinationTable(ref);
                if (schema) loadConfig.setSchema(*schema);
                loadConfig.setWriteDisposition(writeDisposition.name());
                loadConfig.setCreateDisposition(createDisposition.name());
                loadConfig.setSourceFormat(""NEWLINE_DELIMITED_JSON"");

                bool retrying = false;
                std::string projectId = ref.getProjectId();

                for (int i = 0; i < MAX_RETRY_LOAD_JOBS; ++i) {
                    std::string jobId = jobIdPrefix + ""-"" + std::to_string(i);
                    if (retrying) {
                        LOG_INFO(""Previous load jobs failed, retrying."");
                    }
                    LOG_INFO(""Starting BigQuery load job: {}"", jobId);
                    loadService->startLoadJob(jobId, loadConfig);
                    auto jobStatus = loadService->pollJobStatus(project",1
"assertAppsDir({""app with spaces.jar""}, NONE, true);
assertZombieApplication(""app with spaces.jar"", 1, false);
}","assertAppsDir({""app with spaces.jar""}, NONE, true);
assertZombieApplication(""app with spaces.jar"", 1, false);",0
"public:
    std::unordered_set<std::string> getNonHoodiePathCache() {
        return nonHoodiePathCache;
    }

    void setConf(const Configuration& conf) override {
        this->conf = SerializableConfiguration(conf);
    }","public:
    std::unordered_set<std::string> getNonHoodiePathCache() {
        return nonHoodiePathCache;
    }

    void setConf(const Configuration& conf) override {
        this->conf = SerializableConfiguration(conf);
    }",1
"class FetchRouterHealthChecksResultTask : public ManagedContextRunnable {
public:
    FetchRouterHealthChecksResultTask() {}

protected:
    void runInContext() override {
        try {
            std::vector<DomainRouterVO> routers = _routerDao->listByStateAndManagementServer(VirtualMachine::State::Running, mgmtSrvrId);
            s_logger->info(""Found "" + std::to_string(routers.size()) + "" running routers. Fetching, analysing and updating DB for the health checks."");
            if (!RouterHealthChecksEnabled::value()) {
                s_logger->debug(""Skipping fetching of router health check results as router.health.checks.enabled is disabled"");
                return;
            }

            for (auto& router : routers) {
                GetRouterMonitorResultsAnswer* answer = fetchAndUpdateRouterHealthChecks(router, false);
                std::vector<std::string> failingChecks = getFailingChecks(router, answer);
                handleFailingChecks(router, failingChecks);
            }
        } catch (const std::exception& ex) {
            s_logger->error(""Fail to complete the FetchRouterHealthChecksResultTask! "", ex);
        }
    }

private:
    std::vector<std::string> getFailingChecks(DomainRouterVO& router, GetRouterMonitorResultsAnswer* answer) {
        if (answer == nullptr) {
            s_logger->warn(""Unable to fetch monitor results for router "" + router.toString());
            updateRouterConnectivityHealthCheck(router.getId(), false, ""Communication failed"");
            return {CONNECTIVITY_TEST};
        } else if (!answer->getResult()) {
            s_logger->warn(""Failed to fetch monitor results from router "" + router.toString() + "" with details: "" + answer->getDetails());
            updateRouterConnectivityHealthCheck(router.getId(), false, ""Failed to fetch results with details: "" + answer->getDetails());
            return {CONNECTIVITY_TEST};
        } else {
            updateRouterConnectivityHealthCheck(router.getId(), true, ""Successfully fetched data"");
            updateDbHealthChecksFromRouterResponse(router.getId(), answer->getMonitoringResults());
            return answer->getFailingChecks();
        }
    }

    void handleFailingChecks(DomainRouterVO& router, const std::vector<std::string>& failingChecks) {
        if (failingChecks.empty()) {
            return;
        }

        std::string alertMessage = ""Health checks failed: "" + std::to_string(failingChecks.size()) + ""","```cpp
class FetchRouterHealthChecksResultTask : public ManagedContextRunnable {
public:
    FetchRouterHealthChecksResultTask() {}

protected:
    void runInContext() override {
        try {
            auto routers = _routerDao.listByStateAndManagementServer(VirtualMachine::State::Running, mgmtSrvrId);
            s_logger.info(""Found "" + std::to_string(routers.size()) + "" running routers. Fetching, analysing and updating DB for the health checks."");
            if (!RouterHealthChecksEnabled.value()) {
                s_logger.debug(""Skipping fetching of router health check results as router.health.checks.enabled is disabled"");
                return;
            }

            for (const auto& router : routers) {
                GetRouterMonitorResultsAnswer* answer = fetchAndUpdateRouterHealthChecks(router, false);
                auto failingChecks = getFailingChecks(router, answer);
                handleFailingChecks(router, failingChecks);
            }
        } catch (const std::exception& ex) {
            s_logger.error(std::string(""Fail to complete the FetchRouterHealthChecksResultTask! "") + ex.what());
        }
    }

private:
    std::vector<std::string> getFailingChecks(const DomainRouterVO& router, GetRouterMonitorResultsAnswer* answer) {
        if (!answer) {
            s_logger.warn(""Unable to fetch monitor results for router "" + router.toString());
            updateRouterConnectivityHealthCheck(router.getId(), false, ""Communication failed"");
            return {CONNECTIVITY_TEST};
        } else if (!answer->getResult()) {
            s_logger.warn(""Failed to fetch monitor results from router "" + router.toString() + "" with details: "" + answer->getDetails());
            updateRouterConnectivityHealthCheck(router.getId(), false, ""Failed to fetch results with details: "" + answer->getDetails());
            return {CONNECTIVITY_TEST};
        } else {
            updateRouterConnectivityHealthCheck(router.getId(), true, ""Successfully fetched data"");
            updateDbHealthChecksFromRouterResponse(router.getId(), answer->getMonitoringResults());
            return answer->getFailingChecks();
        }
    }

    void handleFailingChecks(const DomainRouterVO& router, const std::vector<std::string>& failingChecks) {
        if (failingChecks.empty()) {
            return;
        }

        std::string alertMessage = ""Health checks failed: "" + std::to_string(failingChecks.size()) + "" failing checks on router "" + router.getUuid();
        _alert",1
"ex.addProxyObject(std::to_string(id), ""templateId"");
throw ex;
long oldGuestOSId = template.getGuestOSId();

verifyTemplateId(id);","```cpp
long oldGuestOSId = template.getGuestOSId();

verifyTemplateId(id);
```",1
"```cpp
#include <gtest/gtest.h>
#include <queue>
#include <memory>
#include <optional>
#include <string>

template<typename T>
class Message {
public:
    Message(const T& payload) : payload_(payload) {}
    const T& getPayload() const { return payload_; }
private:
    T payload_;
};

template<typename T>
class QueueChannel {
public:
    void send(const std::shared_ptr<Message<T>>& msg) {
        queue_.push(msg);
    }
    std::shared_ptr<Message<T>> receive(int timeoutMillis) {
        if (!queue_.empty()) {
            auto msg = queue_.front();
            queue_.pop();
            return msg;
        }
        return nullptr;
    }
    void purge(std::nullptr_t) {
        std::queue<std::shared_ptr<Message<T>>> empty;
        std::swap(queue_, empty);
    }
private:
    std::queue<std::shared_ptr<Message<T>>> queue_;
};

class TransactionSynchronizationQueueChannelTests : public ::testing::Test {
protected:
    QueueChannel<std::string> queueChannel;
    QueueChannel<std::string> good;
    QueueChannel<std::string> queueChannel2;

    void SetUp() override {
        good.purge(nullptr);
        queueChannel.purge(nullptr);
        queueChannel2.purge(nullptr);
    }
};

TEST_F(TransactionSynchronizationQueueChannelTests, testCommit) {
    auto sentMessage = std::make_shared<Message<std::string>>(""hello"");
    queueChannel.send(sentMessage);
    auto message = good.receive(10000);
    ASSERT_NE(message, nullptr);
    ASSERT_EQ(message->getPayload(), ""hello"");
    ASSERT_EQ(message, sentMessage);
}
```","#include <gtest/gtest.h>
#include <memory>
#include <string>

class Message {
public:
    explicit Message(std::string payload) : payload_(std::move(payload)) {}
    const std::string& getPayload() const { return payload_; }
private:
    std::string payload_;
};

class QueueChannel {
public:
    void purge() { queue_.clear(); }
    void send(std::shared_ptr<Message> msg) { queue_.push_back(std::move(msg)); }
    std::shared_ptr<Message> receive(int /*timeoutMillis*/) {
        if (queue_.empty()) return nullptr;
        auto msg = queue_.front();
        queue_.erase(queue_.begin());
        return msg;
    }
private:
    std::vector<std::shared_ptr<Message>> queue_;
};

class TransactionSynchronizationQueueChannelTests : public ::testing::Test {
protected:
    std::unique_ptr<QueueChannel> queueChannel = std::make_unique<QueueChannel>();
    std::unique_ptr<QueueChannel> good = std::make_unique<QueueChannel>();
    std::unique_ptr<QueueChannel> queueChannel2 = std::make_unique<QueueChannel>();

    void SetUp() override {
        good->purge();
        queueChannel->purge();
        queueChannel2->purge();
    }
};

TEST_F(TransactionSynchronizationQueueChannelTests, testCommit) {
    auto sentMessage = std::make_shared<Message>(""hello"");
    queueChannel->send(sentMessage);
    auto message = good->receive(10000);
    ASSERT_NE(message, nullptr);
    ASSERT_EQ(message->getPayload(), ""hello"");
    ASSERT_EQ(message, sentMessage);
}",1
"/ *
[DEL] * Copyright 2002-2017 the original author or authors.
[ADD] * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
*/","/ Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.",0
"#include ""HoodieRecord.h""
#include ""StringUtils.h""
#include ""Pair.h""","#include ""org/apache/avro/specific/SpecificRecordBase.h""
#include ""org/apache/hudi/common/model/HoodieRecord.h""
#include ""org/apache/hudi/common/util/StringUtils.h""
#include ""org/apache/hudi/common/util/collection/Pair.h""",0
"#include <atomic>
#include <string>
#include <set>
#include <vector>
#include <list>
#include <map>
#include <memory>
#include <mutex>

class ClassPool;
class CtClass;
class Method;
class Constructor;
class ProtectionDomain;

class ClassGenerator {
private:
    static std::atomic<long> CLASS_NAME_COUNTER;
    static constexpr const char* SIMPLE_NAME_TAG = ""<init>"";
    static std::map<void*, std::shared_ptr<ClassPool>> POOL_MAP;
    std::shared_ptr<ClassPool> mPool;
    std::shared_ptr<CtClass> mCtc;
    std::string mClassName;
    std::string mSuperClass;
    std::set<std::string> mInterfaces;
    std::vector<std::string> mFields;
    std::list<std::string> mConstructors;
    std::vector<std::string> mMethods;
    std::map<std::string, std::shared_ptr<Method>> mCopyMethods;
    std::map<std::string, std::shared_ptr<Constructor>> mCopyConstructors;
    bool mDefaultConstructor = false;

    ClassGenerator() = default;

    ClassGenerator(std::shared_ptr<ClassPool> pool)
        : mPool(std::move(pool)) {}

    static std::string modifier(int mod); // platform-dependent

public:
    static std::shared_ptr<ClassGenerator> newInstance();
    static std::shared_ptr<ClassGenerator> newInstance(void* loader);
    static bool isDynamicClass(const std::type_info& cl);
    static std::shared_ptr<ClassPool> getClassPool(void* loader);

    std::string getClassName() const {
        return mClassName;
    }

    ClassGenerator& setClassName(const std::string& name) {
        mClassName = name;
        return *this;
    }

    ClassGenerator& addInterface(const std::string& cn) {
        mInterfaces.insert(cn);
        return *this;
    }

    template<typename Clazz>
    ClassGenerator& addInterface() {
        return addInterface(typeid(Clazz).name());
    }

    ClassGenerator& setSuperClass(const std::string& cn) {
        mSuperClass = cn;
        return *this;
    }

    template<typename Clazz>
    ClassGenerator& setSuperClass() {
        mSuperClass = typeid(Clazz).name();
        return *this;
    }

    ClassGenerator& addField(const std::string& code) {
        m","#include <atomic>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <list>
#include <memory>
#include <mutex>

class ClassPool;
class CtClass;
class Method;
class ConstructorBase;
class ProtectionDomain;
class LoaderClassPath;

class ClassGenerator {
private:
    static std::atomic<long> CLASS_NAME_COUNTER;
    static constexpr const char* SIMPLE_NAME_TAG = ""<init>"";
    static std::unordered_map<void*, std::shared_ptr<ClassPool>> POOL_MAP;
    static std::mutex pool_map_mutex;

    std::shared_ptr<ClassPool> mPool;
    std::shared_ptr<CtClass> mCtc;
    std::string mClassName;
    std::string mSuperClass;
    std::unordered_set<std::string> mInterfaces;
    std::vector<std::string> mFields;
    std::list<std::string> mConstructors;
    std::vector<std::string> mMethods;
    std::unordered_map<std::string, std::shared_ptr<Method>> mCopyMethods;
    std::unordered_map<std::string, std::shared_ptr<ConstructorBase>> mCopyConstructors;
    bool mDefaultConstructor = false;

    ClassGenerator() = default;
    ClassGenerator(std::shared_ptr<ClassPool> pool) : mPool(pool) {}

    static std::string modifier(int mod);

public:
    static std::shared_ptr<ClassGenerator> newInstance();
    static std::shared_ptr<ClassGenerator> newInstance(void* loader);
    static bool isDynamicClass(const std::type_info& type);

    static std::shared_ptr<ClassPool> getClassPool(void* loader);

    std::string getClassName() const { return mClassName; }

    ClassGenerator& setClassName(const std::string& name) {
        mClassName = name;
        return *this;
    }

    ClassGenerator& addInterface(const std::string& cn) {
        mInterfaces.insert(cn);
        return *this;
    }
    ClassGenerator& setSuperClass(const std::string& cn) {
        mSuperClass = cn;
        return *this;
    }

    ClassGenerator& addField(const std::string& code) {
        mFields.push_back(code);
        return *this;
    }

    ClassGenerator& addMethod(const std::string& code) {
        mMethods.push_back(code);
        return *this;
    }

    ClassGenerator& addConstructor(const std::",1
"static std::map<int, std::string> txStatusMappings; // populated later

std::atomic<void*> key;
std::atomic<void*> resource;","#include <map>
#include <string>
#include <atomic>

template <typename K, typename V>
using SmallMap = std::map<K, V>;

class AbstractSingleResourceTransaction : public AbstractTransaction {
protected:
    static SmallMap<int, std::string> txStatusMappings;

    std::atomic<void*> key;
    std::atomic<void*> resource;
};",1
"```cpp
bool dispatchKeyEvent(const KeyEvent& event) {
    if (event.getAction() == KeyEvent::ACTION_DOWN) {
        ViewerCommand gesture = COMMAND_NOTHING;

        switch (event.getKeyCode()) {
            case KeyEvent::KEYCODE_VOLUME_UP:
```","```cpp
bool dispatchKeyEvent(const KeyEvent& event) {
    if (event.getAction() == KeyEvent::ACTION_DOWN) {
        ViewerCommand gesture = COMMAND_NOTHING;

        switch (event.getKeyCode()) {
            case KeyEvent::KEYCODE_VOLUME_UP:
                // ...
                break;
            // other cases...
        }
        // ...
    }
    // ...
    return false;
}
```",0
"#include ""DefaultSizeEstimator.h""
#include ""HoodieRecordSizeEstimator.h""
#include ""HoodieTimer.h""
#include ""SpillableMapUtils.h""
#include ""ExternalSpillableMap.h""
#include ""HoodieIOException.h""
#include <stdexcept>","#include ""HoodieRecordPayload.h""
#include ""DefaultSizeEstimator.h""
#include ""HoodieRecordSizeEstimator.h""
#include ""HoodieTimer.h""
#include ""SpillableMapUtils.h""
#include ""ExternalSpillableMap.h""
#include ""HoodieIOException.h""
#include <stdexcept>",0
"if (!_networkName.empty()) {
    netBuilder += ""<target dev='"" + _networkName + ""'/>\n"";
}
if (_mtu > 0 && _mtu <= 9000) {
    netBuilder += ""<mtu size='"" + std::to_string(_mtu) + ""'/>\n"";
}
if (!_macAddr.empty()) {
    netBuilder += ""<mac address='"" + _macAddr + ""'/>\n"";
}","if (!_networkName.empty()) {
    netBuilder << ""<target dev='"" << _networkName << ""'/>\n"";
}
if (_mtu > 0 && _mtu <= 9000) {
    netBuilder << ""<mtu size='"" << _mtu << ""'/>\n"";
}
if (!_macAddr.empty()) {
    netBuilder << ""<mac address='"" << _macAddr << ""'/>\n"";
}",1
"if (showing_) {
    progressIndicator_.onProgress(status);
    onShowProgress.execute();
}
timer.schedule([=]() {
    // code inside lambda executed after startDelay_
}, startDelay_);","std::thread([this, status]() {
    std::this_thread::sleep_for(std::chrono::milliseconds(startDelay_));
    if (showing_) {
        progressIndicator_->onProgress(status);
        onShowProgress.execute();
    }
}).detach();",1
"```cpp
switch (indexType) {
    case SIMPLE:
        return std::make_unique<HoodieSimpleIndex>(config, getKeyGeneratorForSimpleIndex(config));
    case GLOBAL_SIMPLE:
        return std::make_unique<HoodieGlobalSimpleIndex>(config, getKeyGeneratorForSimpleIndex(config));
    case BUCKET_INDEX:
        return std::make_unique<SparkBucketIndex>(config);
    default:
        throw HoodieIndexException(""Index type unspecified, set "" + config.getIndexType());
}
```","```cpp
switch (indexType) {
  case SIMPLE:
    return new HoodieSimpleIndex<T>(config, getKeyGeneratorForSimpleIndex(config));
  case GLOBAL_SIMPLE:
    return new HoodieGlobalSimpleIndex<T>(config, getKeyGeneratorForSimpleIndex(config));
  case BUCKET_INDEX:
    return new SparkBucketIndex(config);
  default:
    throw HoodieIndexException(""Index type unspecified, set "" + config.getIndexType());
}
```",1
"#include <map>
#include <string>
#include <memory>
#include <optional>
#include <vector>
#include <sstream>
#include <stdexcept>

template<typename T>
class BulkInsertPartitioner;

class Schema {};
class HoodieAvroUtils {
public:
    static Schema addMetadataFields(const Schema& schema);
};
class HoodieSparkEngineContext {};
class WriteConfig {
public:
    enum class LayoutOptimizationStrategy { ZORDER, HILBERT, LINEAR };
    LayoutOptimizationStrategy getLayoutOptimizationStrategy() const;
    std::string getLayoutOptimizationCurveBuildMethod() const;
    bool isConsistentLogicalTimestampEnabled() const;
};
class EngineContext {};
struct PLAN_STRATEGY_SORT_COLUMNS {
    static const std::string& key() {
        static std::string key_str = ""plan_strategy_sort_columns"";
        return key_str;
    }
};

class RDDSpatialCurveSortPartitioner : public BulkInsertPartitioner<int> {
public:
    RDDSpatialCurveSortPartitioner(
        HoodieSparkEngineContext* ctx,
        const std::vector<std::string>& orderByColumns,
        WriteConfig::LayoutOptimizationStrategy layoutOptStrategy,
        const std::string& curveBuildMethod,
        Schema schema
    );
};

class RDDCustomColumnsSortPartitioner : public BulkInsertPartitioner<int> {
public:
    RDDCustomColumnsSortPartitioner(
        const std::vector<std::string>& orderByColumns,
        Schema schema,
        bool consistentTimestamp
    );
};

template<typename T>
class Option {
public:
    Option() = default;
    static Option empty() { return Option(); }
    static Option of(std::shared_ptr<T> value) { return Option(value); }
    bool isPresent() const { return static_cast<bool>(value_); }
    std::shared_ptr<T> get() const { return value_; }
    template<typename Func>
    auto map(Func f) const -> Option<typename std::result_of<Func(std::shared_ptr<T>)>::type> {
        if (isPresent()) {
            return Option<typename std::result_of<Func(std::shared_ptr<T>)>::type>::of(std::make_shared<typename std::result_of<Func(std::shared_ptr<T>)>::type>(f(value_)));
        } else {
            return Option<typename std::result_of<Func(std::shared_ptr<T>)>::type>();
        }
    }
private:
    Option(std::shared_ptr<T> v) : value_(v) {}
    std::shared_ptr<T> value_;
};

std::vector","protected:
std::optional<std::unique_ptr<BulkInsertPartitioner<T>>> getPartitioner(const std::map<std::string, std::string>& strategyParams, const Schema& schema) {
    auto it = strategyParams.find(PLAN_STRATEGY_SORT_COLUMNS.key());
    if (it != strategyParams.end()) {
        std::vector<std::string> orderByColumns;
        std::istringstream ss(it->second);
        std::string column;
        while (std::getline(ss, column, ',')) {
            orderByColumns.push_back(column);
        }

        auto layoutOptStrategy = getWriteConfig().getLayoutOptimizationStrategy();
        switch (layoutOptStrategy) {
            case HoodieClusteringConfig::LayoutOptimizationStrategy::ZORDER:
            case HoodieClusteringConfig::LayoutOptimizationStrategy::HILBERT:
                return std::make_optional(std::make_unique<RDDSpatialCurveSortPartitioner>(
                    static_cast<HoodieSparkEngineContext*>(getEngineContext()),
                    orderByColumns,
                    layoutOptStrategy,
                    getWriteConfig().getLayoutOptimizationCurveBuildMethod(),
                    HoodieAvroUtils::addMetadataFields(schema)
                ));
            case HoodieClusteringConfig::LayoutOptimizationStrategy::LINEAR:
                return std::make_optional(std::make_unique<RDDCustomColumnsSortPartitioner>(
                    orderByColumns,
                    HoodieAvroUtils::addMetadataFields(schema),
                    getWriteConfig().isConsistentLogicalTimestampEnabled()
                ));
            default:
                throw std::runtime_error(""Layout optimization strategy '"" + std::to_string(static_cast<int>(layoutOptStrategy)) + ""' is not supported"");
        }
    }
    return std::nullopt;
}",1
"auto bar = getSymbol(""bar"");
ASSERT_FALSE(isAnnotatedWith(bar, ""android.support.annotation.MyAnnotation""));
auto declaration = static_cast<MethodTree*>(bar.declaration());
ASSERT_TRUE(isGloballyAnnotatedWith(declaration, ""android.support.annotation.MyAnnotation""));
ASSERT_FALSE(isGloballyAnnotatedWith(declaration, ""org.bar.MyOtherAnnotation""));
}

TEST(ClassName, testGetAnnotationValue) {
    std::string myClass = ""org.sonar.java.resolve.targets.annotations.MyClass"";
    std::string myAnnotation = ""org.sonar.java.resolve.targets.annotations.MyAnnotation"";
    std::string myOtherAnnotation = ""org.bar.MyOtherAnnotation"";
    semanticModel = SETestUtils::getSemanticModel(""src/test/java/org/sonar/java/resolve/targets/annotations/MyClass.java"");

    auto foo = getSymbol(myClass, ""foo"");
    ASSERT_FALSE(isAnnotatedWith(foo, myAnnotation));
    auto fooDeclaration = static_cast<MethodTree*>(foo.declaration());
    ASSERT_TRUE(isGloballyAnnotatedWith(fooDeclaration, myAnnotation));
    auto fooAnnotationValues = valuesForGlobalAnnotation(fooDeclaration, myAnnotation);
    ASSERT_EQ(fooAnnotationValues.size(), 2);
    ASSERT_EQ(fooAnnotationValues[1].name(), ""value"");
    ASSERT_TRUE(dynamic_cast<Symbol*>(fooAnnotationValues[0].value()) != nullptr);

    auto bar = getSymbol(myClass, ""bar"");
    ASSERT_FALSE(isAnnotatedWith(foo, myAnnotation));
    auto barDeclaration = static_cast<MethodTree*>(bar.declaration());
    ASSERT_TRUE(isGloballyAnnotatedWith(barDeclaration, myAnnotation));
    auto barAnnotationValues = valuesForGlobalAnnotation(barDeclaration, myAnnotation);
    ASSERT_EQ(barAnnotationValues.size(), 1);
    ASSERT_EQ(barAnnotationValues[0].name(), ""value"");
    ASSERT_TRUE(dynamic_cast<NewArrayTree*>(barAnnotationValues[0].value()) != nullptr);

    auto qix = getSymbol(""org.sonar.java.resolve.targets.annotations.MyOtherClass"", ""qix"");
    ASSERT_FALSE(isAnnotatedWith(qix, myAnnotation));
    auto qixDeclaration = static_cast<MethodTree*>(qix.declaration());
    ASSERT_TRUE(isGloballyAnnotatedWith(qixDeclaration, myAnnotation));
    ASSERT_TRUE(valuesForGlobalAnnotation(qixDeclaration, myAnnotation).empty());

    ASSERT_FALSE(isAnnotatedWith(qix, myOtherAnnotation));
    ASSERT_FALSE(isGloballyAnnotatedWith(qixDeclaration, myOtherAnnotation));
    ASSERT_TRUE(valuesForGlobalAnnotation(qixDeclaration, myOther","#include <gtest/gtest.h>
#include <vector>
#include <string>

TEST(NullableAnnotationUtilsTest, TestGetAnnotationValue) {
  std::string myClass = ""org.sonar.java.resolve.targets.annotations.MyClass"";
  std::string myAnnotation = ""org.sonar.java.resolve.targets.annotations.MyAnnotation"";
  std::string myOtherAnnotation = ""org.bar.MyOtherAnnotation"";
  semanticModel = SETestUtils::getSemanticModel(""src/test/java/org/sonar/java/resolve/targets/annotations/MyClass.java"");

  Symbol* foo = getSymbol(myClass, ""foo"");
  EXPECT_FALSE(isAnnotatedWith(foo, myAnnotation));
  MethodTree* fooDeclaration = static_cast<MethodTree*>(foo->declaration());
  EXPECT_TRUE(isGloballyAnnotatedWith(fooDeclaration, myAnnotation));

  std::vector<SymbolMetadata::AnnotationValue> fooAnnotationValues = valuesForGlobalAnnotation(fooDeclaration, myAnnotation);
  EXPECT_EQ(fooAnnotationValues.size(), 2);
  EXPECT_EQ(fooAnnotationValues[1].name(), ""value"");
  EXPECT_TRUE(dynamic_cast<Symbol*>(fooAnnotationValues[0].value()) != nullptr);

  Symbol* bar = getSymbol(myClass, ""bar"");
  EXPECT_FALSE(isAnnotatedWith(foo, myAnnotation));
  MethodTree* barDeclaration = static_cast<MethodTree*>(bar->declaration());
  EXPECT_TRUE(isGloballyAnnotatedWith(barDeclaration, myAnnotation));
  std::vector<SymbolMetadata::AnnotationValue> barAnnotationValues = valuesForGlobalAnnotation(barDeclaration, myAnnotation);
  EXPECT_EQ(barAnnotationValues.size(), 1);
  EXPECT_EQ(barAnnotationValues[0].name(), ""value"");
  EXPECT_TRUE(dynamic_cast<NewArrayTree*>(barAnnotationValues[0].value()) != nullptr);

  Symbol* qix = getSymbol(""org.sonar.java.resolve.targets.annotations.MyOtherClass"", ""qix"");
  EXPECT_FALSE(isAnnotatedWith(qix, myAnnotation));
  MethodTree* qixDeclaration = static_cast<MethodTree*>(qix->declaration());
  EXPECT_TRUE(isGloballyAnnotatedWith(qixDeclaration, myAnnotation));
  EXPECT_TRUE(valuesForGlobalAnnotation(qixDeclaration, myAnnotation).empty());

  EXPECT_FALSE(isAnnotatedWith(qix, myOtherAnnotation));
  EXPECT_FALSE(isGloballyAnnotatedWith(qixDeclaration, myOtherAnnotation));
  EXPECT_TRUE(valuesForGlobalAnnotation(qixDeclaration, myOtherAnnotation).empty());
}",0
"#include <stdexcept>
#include <cerrno>
#include <system_error>

void throwSpecificException() {
    throw std::runtime_error(""Specific exception"");
}

struct FileNotFoundException : public std::runtime_error {
    FileNotFoundException() : std::runtime_error(""File not found"") {}
};

class ExceptionEnqueue {
public:
    void throwIOException() {
        throw FileNotFoundException();
    }
};

bool enqueueExitBlock() {
    throwSpecificException();
    return false;
}

bool enqueueExitBlock2(ExceptionEnqueue& ee) {
    try {
        ee.throwIOException();
    } catch (const FileNotFoundException&) {
        return true;
    }
    return false;
}

bool enqueueExitBlock3() {
    try {
        throwSpecificException();
    } catch (...) {
        throw;
    }
    int x = 0;
    return false;
}

bool enqueueExitBlock4() {
    try {
        throwSpecificException();
    } catch (...) {
        return true;
    }
    return true;
}","```cpp
#include <stdexcept>
#include <fstream>

class ExceptionEnqueue {
public:
    virtual ~ExceptionEnqueue() = default;
    virtual void throwIOException() = 0;

    static bool enqueueExitBlock() {
        throwSpecificException();
        return false;
    }

    static bool enqueueExitBlock2(ExceptionEnqueue* ee) {
        try {
            ee->throwIOException();
        } catch (const std::ifstream::failure&) {
            return true;
        }
        return false;
    }

    static bool enqueueExitBlock3() {
        try {
            throwSpecificException();
        } catch (...) {
            int x = 0;
            throw;
        }
        return false;
    }

    static bool enqueueExitBlock4() {
        try {
            throwSpecificException();
        } catch (...) {
            return true;
        }
        return true;
    }

private:
    static void throwSpecificException() {
        throw std::runtime_error("""");
    }
};
```",1
"long fileSize(const GcsPath& path) {
    return fileSize(std::vector<GcsPath>{path})[0];
}","long fileSize(const GcsPath& path) {
    return fileSize({path})[0];
}",1
"private:
void parseNullSafe(const ExtensionParameter& extensionParameter, ParameterDeclarer& parameter) {
    if (extensionParameter.isAnnotatedWith(typeid(NullSafe))) {
        if (extensionParameter.isRequired()) {
            throw IllegalParameterModelDefinitionException(
                format(""Parameter '%s' is required but annotated with '@%s', which is redundant"",
                       extensionParameter.getName(), typeid(NullSafe).name()));
        }
    }
}","void parseNullSafe(const ExtensionParameter& extensionParameter, ParameterDeclarer& parameter) {
    if (extensionParameter.isAnnotatedWith<NullSafe>()) {
        if (extensionParameter.isRequired()) {
            throw IllegalParameterModelDefinitionException(
                format(""Parameter '%s' is required but annotated with '@%s', which is redundant"",
                       extensionParameter.getName().c_str(), typeid(NullSafe).name())
            );
        }
    }
}",0
"writeClient.commit(newCommitTime, writeStatues);

auto hoodieTable = HoodieTable::create(metaClient, config, hadoopConf);

std::vector<HoodieRecord> records2 = index.tagLocation(writeRecords, jsc, hoodieTable);

assert(numRecords == std::count_if(records2.begin(), records2.end(),
    [](const HoodieRecord& rec) { return rec.isCurrentLocationKnown(); }));

std::vector<std::string> fileIds;
for (const auto& ws : writeStatues) {
    fileIds.push_back(ws.getFileId());
}

assert(std::count_if(records2.begin(), records2.end(),
    [](const HoodieRecord& rec) { return rec.getCurrentLocation().getFileId() == nullptr; }) == 0);

std::set<std::string> taggedFileIdsSet;
for (const auto& rec : records2) {
    taggedFileIdsSet.insert(rec.getCurrentLocation().getFileId());
}
std::vector<std::string> taggedFileIds(taggedFileIdsSet.begin(), taggedFileIdsSet.end());

std::set<std::string> fileIdSet(fileIds.begin(), fileIds.end());
std::set<std::string> taggedFileIdSet(taggedFileIds.begin(), taggedFileIds.end());
assert(taggedFileIdSet == fileIdSet);","writeClient.commit(newCommitTime, writeStatues);
auto hoodieTable = HoodieTable::create(metaClient, config, hadoopConf);
// Now tagLocation for these records, hbaseIndex should tag them
auto records2 = index.tagLocation(writeRecords, jsc, hoodieTable);
assert(std::count_if(records2.begin(), records2.end(),
                    [](const HoodieRecord& record) { return record.isCurrentLocationKnown(); }) == numRecords);

// check tagged records are tagged with correct fileIds
std::vector<std::string> fileIds;
std::transform(writeStatues.begin(), writeStatues.end(), std::back_inserter(fileIds),
               [](const WriteStatus& ws) { return ws.getFileId(); });
assert(std::count_if(records2.begin(), records2.end(),
                    [](const HoodieRecord& record) { return record.getCurrentLocation().getFileId() == nullptr; }) == 0);
std::vector<std::string> taggedFileIds;
{
    std::set<std::string> seen;
    for (const auto& record : records2) {
        auto fid = record.getCurrentLocation().getFileId();
        if (fid != nullptr && seen.insert(*fid).second) {
            taggedFileIds.push_back(*fid);
        }
    }
}

// both lists should match
assert(std::all_of(taggedFileIds.begin(), taggedFileIds.end(),
                  [&](const std::string& id) {
                      return std::find(fileIds.begin(), fileIds.end(), id) != fileIds.end();
                  }) &&
       std::all_of(fileIds.begin(), fileIds.end(),
                  [&](const std::string& id) {
                      return std::find(taggedFileIds.begin(), taggedFileIds.end(), id) != taggedFileIds.end();
                  }));",0
"return *this;
}

HoodieMemoryConfig build() {
    HoodieMemoryConfig config(props);
    setDefaultOnCondition(props, !props.containsKey(MAX_MEMORY_FRACTION_FOR_COMPACTION_PROP),
        MAX_MEMORY_FRACTION_FOR_COMPACTION_PROP, DEFAULT_MAX_MEMORY_FRACTION_FOR_COMPACTION);
    setDefaultOnCondition(props, !props.containsKey(MAX_MEMORY_FRACTION_FOR_MERGE_PROP),
        MAX_MEMORY_FRACTION_FOR_MERGE_PROP, DEFAULT_MAX_MEMORY_FRACTION_FOR_MERGE);
    long maxMemoryAllowedForMerge =
        SparkConfigUtils::getMaxMemoryAllowedForMerge(props.getProperty(MAX_MEMORY_FRACTION_FOR_MERGE_PROP));
    setDefaultOnCondition(props, !props.containsKey(MAX_MEMORY_FOR_MERGE_PROP), MAX_MEMORY_FOR_MERGE_PROP,
        std::to_string(maxMemoryAllowedForMerge));
    long maxMemoryAllowedForCompaction =
        SparkConfigUtils::getMaxMemoryAllowedForMerge(props.getProperty(MAX_MEMORY_FRACTION_FOR_COMPACTION_PROP));
    setDefaultOnCondition(props, !props.containsKey(MAX_MEMORY_FOR_COMPACTION_PROP), MAX_MEMORY_FOR_COMPACTION_PROP,
        std::to_string(maxMemoryAllowedForCompaction));
    setDefaultOnCondition(props, !props.containsKey(MAX_DFS_STREAM_BUFFER_SIZE_PROP), MAX_DFS_STREAM_BUFFER_SIZE_PROP,
        std::to_string(DEFAULT_MAX_DFS_STREAM_BUFFER_SIZE));
    setDefaultOnCondition(props, !props.containsKey(SPILLABLE_MAP_BASE_PATH_PROP), SPILLABLE_MAP_BASE_PATH_PROP,
        /* the argument for this call is missing in the snippet you provided */);
    return config;
}","```cpp
class HoodieMemoryConfig : public DefaultHoodieConfig {
public:
    HoodieMemoryConfig build() {
        HoodieMemoryConfig config(props);
        setDefaultOnCondition(props, !props.contains(MAX_MEMORY_FRACTION_FOR_COMPACTION_PROP),
            MAX_MEMORY_FRACTION_FOR_COMPACTION_PROP, DEFAULT_MAX_MEMORY_FRACTION_FOR_COMPACTION);
        setDefaultOnCondition(props, !props.contains(MAX_MEMORY_FRACTION_FOR_MERGE_PROP),
            MAX_MEMORY_FRACTION_FOR_MERGE_PROP, DEFAULT_MAX_MEMORY_FRACTION_FOR_MERGE);
        long long maxMemoryAllowedForMerge =
            SparkConfigUtils::getMaxMemoryAllowedForMerge(props.getProperty(MAX_MEMORY_FRACTION_FOR_MERGE_PROP));
        setDefaultOnCondition(props, !props.contains(MAX_MEMORY_FOR_MERGE_PROP), MAX_MEMORY_FOR_MERGE_PROP,
            std::to_string(maxMemoryAllowedForMerge));
        long long maxMemoryAllowedForCompaction =
            SparkConfigUtils::getMaxMemoryAllowedForMerge(props.getProperty(MAX_MEMORY_FRACTION_FOR_COMPACTION_PROP));
        setDefaultOnCondition(props, !props.contains(MAX_MEMORY_FOR_COMPACTION_PROP), MAX_MEMORY_FOR_COMPACTION_PROP,
            std::to_string(maxMemoryAllowedForCompaction));
        setDefaultOnCondition(props, !props.contains(MAX_DFS_STREAM_BUFFER_SIZE_PROP), MAX_DFS_STREAM_BUFFER_SIZE_PROP,
            std::to_string(DEFAULT_MAX_DFS_STREAM_BUFFER_SIZE));
        setDefaultOnCondition(props, !props.contains(SPILLABLE_MAP_BASE_PATH_PROP), SPILLABLE_MAP_BASE_PATH_PROP,
            props.getProperty(SPILLABLE_MAP_BASE_PATH_PROP, """"));

        return config;
    }
};
```",1
"return HF_VERSION_CLSAG;
}

uint64_t calculate_fee(bool use_per_byte_fee, const cryptonote::transaction &tx, size_t blob_size, uint64_t base_fee, uint64_t fee_quantization_mask)
{
  if (use_per_byte_fee)
    return calculate_fee_from_weight(base_fee, cryptonote::get_transaction_weight(tx, blob_size), fee_quantization_mask);
  else
    return calculate_fee(base_fee, blob_size);
}

bool get_short_payment_id(crypto::hash8 &payment_id8, const tools::wallet2::pending_tx &ptx, hw::device &hwdev)","uint64_t calculate_fee(bool use_per_byte_fee, const cryptonote::transaction& tx, size_t blob_size, uint64_t base_fee, uint64_t fee_quantization_mask)
{
    if (use_per_byte_fee)
        return calculate_fee_from_weight(base_fee, cryptonote::get_transaction_weight(tx, blob_size), fee_quantization_mask);
    else
        return calculate_fee(base_fee, blob_size);
}",1
"template <typename K>
void processTimer(
    const std::string& timerIdOrTimerFamilyId, TimeDomain timeDomain, Timer<K>* timer) {
    currentTimer = timer;
    currentTimeDomain = timeDomain;
    onTimerContext = OnTimerContext<K>(timer->getUserKey());
    std::string timerId =
        timerIdOrTimerFamilyId.rfind(TimerFamilyDeclaration::PREFIX, 0) == 0
        ? """"
        : timerIdOrTimerFamilyId;
    std::string timerFamilyId =
        timerIdOrTimerFamilyId.rfind(TimerFamilyDeclaration::PREFIX, 0) == 0
        ? timerIdOrTimerFamilyId
        : """";
    try {
        auto& windows = timer->getWindows();
        for (auto it = windows.begin(); it != windows.end(); ++it) {
            currentWindow = *it;
            doFnInvoker.invokeOnTimer(timerId, timerFamilyId, onTimerContext);
        }
    } catch (...) {
        currentTimer = nullptr;
        throw;
    }
    currentTimer = nullptr;
}","template <typename K>
void processTimer(const std::string& timerIdOrTimerFamilyId, TimeDomain timeDomain, Timer<K>& timer) {
    currentTimer = &timer;
    currentTimeDomain = timeDomain;
    onTimerContext = OnTimerContext<K>(timer.getUserKey());
    std::string timerId = timerIdOrTimerFamilyId.rfind(TimerFamilyDeclaration::PREFIX, 0) == 0
                          ? """"
                          : timerIdOrTimerFamilyId;
    std::string timerFamilyId = timerIdOrTimerFamilyId.rfind(TimerFamilyDeclaration::PREFIX, 0) == 0
                                ? timerIdOrTimerFamilyId
                                : """";
    try {
        auto windowIterator = timer.getWindows().begin();
        auto windowEnd = timer.getWindows().end();
        while (windowIterator != windowEnd) {
            currentWindow = *windowIterator;
            doFnInvoker.invokeOnTimer(timerId, timerFamilyId, onTimerContext);
            ++windowIterator;
        }
    } catch (...) {
        currentTimer = nullptr;
        throw;
    }
    currentTimer = nullptr;
}",1
"```cpp
char charAtO1 = s1.charAtInternal(o1++, s1Value);
char charAtO2 = s2.charAtInternal(o2++, s2Value);

#if __cpp_unicode_characters
if (isHighSurrogate(charAtO1) && isHighSurrogate(charAtO2) && (o1 < end)) {
    int codepointAtO1 = toCodePoint(charAtO1, s1.charAtInternal(o1++, s1Value));
    int codepointAtO2 = toCodePoint(charAtO2, s2.charAtInternal(o2++, s2Value));
    if ((codepointAtO1 != codepointAtO2) && (compareValue(codepointAtO1) != compareValue(codepointAtO2))) {
        return false;
    }
}
#endif

if (charAtO1 != charAtO2 &&
    toUpperCase(charAtO1) != toUpperCase(charAtO2) &&
    toLowerCase(charAtO1) != toLowerCase(charAtO2)) {
```","```cpp
char charAtO1 = s1.charAtInternal(o1++, s1Value);
char charAtO2 = s2.charAtInternal(o2++, s2Value);

if (isHighSurrogate(charAtO1) && isHighSurrogate(charAtO2) && (o1 < end)) {
    int codepointAtO1 = toCodePoint(charAtO1, s1.charAtInternal(o1++, s1Value));
    int codepointAtO2 = toCodePoint(charAtO2, s2.charAtInternal(o2++, s2Value));
    if ((codepointAtO1 != codepointAtO2) && (compareValue(codepointAtO1) != compareValue(codepointAtO2))) {
        return false;
    }
}

if (charAtO1 != charAtO2 &&
    toUpperCase(charAtO1) != toUpperCase(charAtO2) &&
    toLowerCase(charAtO1) != toLowerCase(charAtO2)) {
```",0
"}

#include <type_traits>
#include <functional>
#include <vector>
#include <memory>

class Method {
public:
    template<typename Annotation>
    bool isAnnotationPresent() const;
};

template<typename T>
using Predicate = std::function<bool(const T&)>;

class AnnotationPredicate {
public:
    static const AnnotationPredicate JSON_IGNORE;
    static const AnnotationPredicate DEFAULT_VALUE;

    AnnotationPredicate(Predicate<Method> pred) : predicate(std::move(pred)) {}

    bool apply(const Method& input) const {
        return predicate(input);
    }

private:
    Predicate<Method> predicate;
};

const AnnotationPredicate AnnotationPredicate::JSON_IGNORE(
    [](const Method& input) {
        return input.isAnnotationPresent<class JsonIgnore>();
    }
);

const AnnotationPredicate AnnotationPredicate::DEFAULT_VALUE(
    [](const Method& input) {
        // Suppose Default is a namespace or struct with nested annotation types
        struct Default {
            struct Value1 {};
            struct Value2 {};
            // ...add other nested annotation classes as needed
        };
        using AnnotationTypes = std::tuple<Default::Value1, Default::Value2>;
        bool present = false;
        std::apply([&](auto&&... annotationType) {
            ((present = present || input.isAnnotationPresent<std::decay_t<decltype(annotationType)>>()), ...);
        }, AnnotationTypes{});
        return present;
    }
);","#include <functional>
#include <type_traits>
#include <vector>
#include <memory>

class Method; // Forward declaration.
class JsonIgnore; // Forward declaration.
class Default; // Forward declaration.

class AnnotationPredicate {
public:
    using Predicate = std::function<bool(const Method&)>;

    static const AnnotationPredicate JSON_IGNORE;
    static const AnnotationPredicate DEFAULT_VALUE;

    AnnotationPredicate(Predicate predicate)
        : predicate_(std::move(predicate)) {}

    bool apply(const Method& input) const {
        return predicate_(input);
    }

private:
    Predicate predicate_;
};

const AnnotationPredicate AnnotationPredicate::JSON_IGNORE(
    [](const Method& input) -> bool {
        // Assume Method has: bool isAnnotationPresent(const std::type_info&)
        return input.isAnnotationPresent(typeid(JsonIgnore));
    }
);

const AnnotationPredicate AnnotationPredicate::DEFAULT_VALUE(
    [](const Method& input) -> bool {
        // Assume Default::getDeclaredClasses() returns std::vector<const std::type_info*>
        // and isAnnotation() checks if a type is an annotation.
        auto declaredClasses = Default::getDeclaredClasses();
        for (const std::type_info* klass : declaredClasses) {
            if (/*isAnnotation(*klass)*/true && input.isAnnotationPresent(*klass)) {
                return true;
            }
        }
        return false;
    }
);",1
"cfg.sourceLimit = 2000;
cfg.operation = Operation::UPSERT;
HoodieDeltaStreamer(cfg, jsc, dfs, hiveServer.getHiveConf()).sync();

TestHelpers::assertRecordCount(1950, datasetBasePath + ""/*/*.parquet"", sqlContext);
TestHelpers::assertDistanceCount(1950, datasetBasePath + ""/*/*.parquet"", sqlContext);
TestHelpers::assertDistanceCountWithExactValue(1950, datasetBasePath + ""/*/*.parquet"", sqlContext);

lastInstantForUpstreamTable = TestHelpers::assertCommitMetadata(""00001"", datasetBasePath, dfs, 2);
std::vector<Row> counts = TestHelpers::countsPerCommit(datasetBasePath + ""/*/*.parquet"", sqlContext);

assertEquals(1950, std::accumulate(counts.begin(), counts.end(), 0LL, [](long long sum, const Row& entry){
    return sum + entry.getLong(1);
}));

downstreamCfg =","cfg.sourceLimit = 2000;
cfg.operation = Operation::UPSERT;
HoodieDeltaStreamer(cfg, jsc, dfs, hiveServer.getHiveConf()).sync();
TestHelpers::assertRecordCount(1950, datasetBasePath + ""/*/*.parquet"", sqlContext);
TestHelpers::assertDistanceCount(1950, datasetBasePath + ""/*/*.parquet"", sqlContext);
TestHelpers::assertDistanceCountWithExactValue(1950, datasetBasePath + ""/*/*.parquet"", sqlContext);
lastInstantForUpstreamTable = TestHelpers::assertCommitMetadata(""00001"", datasetBasePath, dfs, 2);
auto counts = TestHelpers::countsPerCommit(datasetBasePath + ""/*/*.parquet"", sqlContext);
long sum = 0;
for (const auto& entry : counts) {
    sum += entry.getLong(1);
}
assertEquals(1950, sum);",0
"void testInGlobalWindowBatchSizeByteSize() {
    auto collection = pipeline
        .apply(""Input data"", Create::of(data))
        .apply(GroupIntoBatches::ofByteSize(BATCH_SIZE_BYTES))
        .setCoder(KvCoder::of(StringUtf8Coder::of(), IterableCoder::of(StringUtf8Coder::of())));
    PAssert::that(""Incorrect batch size in one or more elements"", collection)
        .satisfies([](const std::vector<KV<std::string, std::vector<std::string>>>& input) {
            auto checkBatchSizes = [](const std::vector<KV<std::string, std::vector<std::string>>>& listToCheck) {
                for (const auto& element : listToCheck) {
                    long byteSize = 0;
                    for (const auto& str : element.getValue()) {
                        if (byteSize >= BATCH_SIZE_BYTES) {
                            return false;
                        }
                        try {
                            byteSize += StringUtf8Coder::of()->getEncodedElementByteSize(str);
                        } catch (...) {
                            throw;
                        }
                    }
                }
                return true;
            };
            assert(checkBatchSizes(input));
            return;
        });
    PAssert::thatSingleton(""Incorrect collection size"", collection.apply(""Count"", Count::globally()))
        .isEqualTo(3L);
    pipeline.run();
}

void testInGlobalWindowBatchSizeByteSizeFn() {
    auto collection = pipeline
        .apply(""Input data"", Create::of(data))
        .apply(GroupIntoBatches::ofByteSize(
            BATCH_SIZE_BYTES,
            [](const std::string& s) {
                try {
                    return 2 * StringUtf8Coder::of()->getEncodedElementByteSize(s);
                } catch (...) {
                    throw;
                }
            }))
        .setCoder(KvCoder::of(StringUtf8Coder::of(), IterableCoder::of(StringUtf8Coder::of())));
    PAssert::that(""Incorrect batch size in one or more elements"", collection)
        .satisfies([](const std::vector<KV<std::string, std::vector<std::string>>>& input) {
            auto checkBatchSizes = [](const std::vector<KV<std::string, std::vector<std::string>>>& listToCheck) {
                for (const auto& element : listToCheck) {
                    long byteSize = 0;
                    for (const auto& str : element.get","#include <gtest/gtest.h>
#include <vector>
#include <string>
#include <utility>
#include <numeric>
#include <functional>

constexpr size_t BATCH_SIZE_BYTES = /* your batch size constant here */;
const std::vector<std::string> data = /* your input data here */;

struct KV {
    std::string key;
    std::vector<std::string> value;
};

size_t getEncodedElementByteSize(const std::string& str) {
    return str.size();
}

bool checkBatchSizes(const std::vector<KV>& listToCheck, size_t batchSizeBytes, std::function<size_t(const std::string&)> sizer) {
    for (const auto& element : listToCheck) {
        size_t byteSize = 0;
        for (const auto& str : element.value) {
            if (byteSize >= batchSizeBytes) {
                return false;
            }
            byteSize += sizer(str);
        }
    }
    return true;
}

// Mocks for pipeline-like API for example purposes
std::vector<KV> GroupIntoBatches_ofByteSize(const std::vector<std::string>& input, size_t batchSizeBytes, std::function<size_t(const std::string&)> sizer = getEncodedElementByteSize) {
    std::vector<KV> result;
    // Pseudo-batching logic for demonstration
    KV currentBatch{""batch"", {}};
    size_t currentSize = 0;
    for (const auto& s : input) {
        size_t sz = sizer(s);
        if (currentSize + sz > batchSizeBytes && !currentBatch.value.empty()) {
            result.push_back(currentBatch);
            currentBatch.value.clear();
            currentSize = 0;
        }
        currentBatch.value.push_back(s);
        currentSize += sz;
    }
    if (!currentBatch.value.empty()) {
        result.push_back(currentBatch);
    }
    return result;
}

TEST(GroupIntoBatchesTest, testInGlobalWindowBatchSizeByteSize) {
    auto collection = GroupIntoBatches_ofByteSize(data, BATCH_SIZE_BYTES);

    ASSERT_TRUE(checkBatchSizes(collection, BATCH_SIZE_BYTES, getEncodedElementByteSize));
    ASSERT_EQ(collection.size(), 3u);
}

TEST(GroupIntoBatchesTest, testInGlobalWindowBatchSizeByteSizeFn) {
    auto sizer = [](const std::string& s) { return 2 * getEncodedElementByteSize(s); };
    auto",1
"#include <atomic>
#include <condition_variable>
#include <chrono>
#include <functional>","#include <atomic>
#include <condition_variable>
#include <functional>
#include <future>
#include <mutex>
#include <thread>
#include <chrono>",0
"for (int i = 0; i < fields.size(); ++i) {
    QWidget* edit_line_view = new QWidget(mFieldsLayoutContainer);
    FieldEditText* newTextbox = edit_line_view->findChild<FieldEditText*>(""id_note_editText"");

    if (QSysInfo::productVersion().toInt() >= 23) {
        // Use custom implementation of context menu or selection handling
    }
}","for (int i = 0; i < fields.size(); i++) {
    QWidget* edit_line_view = new QWidget; // replace with appropriate instantiation of your UI element
    FieldEditText* newTextbox = edit_line_view->findChild<FieldEditText*>(""id_note_editText"");

    if (QSysInfo::productVersion().toInt() >= 6) { // example Qt 6+ version check
        // Use custom implementation for context menu customization
    }
}",0
"format = template.getFormat();
}

if (volume.getVolumeType() == Volume::Type::ROOT && diskOffering.getDiskSize() > 0 && format && format != ImageFormat::ISO) {
    throw InvalidParameterValueException(
        ""Failed to resize Root volume. The service offering of this Volume has been configured with a root disk size; ""
        ""on such case a Root Volume can only be resized when changing to another Service Offering with a Root disk size. ""
        ""For more details please check out the Official Resizing Volumes documentation.""
    );
}
newSize = cmd.getSize();
newHypervisorSnapshotReserve = volume.getHypervisorSnapshotReserve();","if (volume.getVolumeType() == Volume::Type::ROOT &&
    diskOffering.getDiskSize() > 0 &&
    format.has_value() &&
    format != ImageFormat::ISO) {
    throw InvalidParameterValueException(
        ""Failed to resize Root volume. The service offering of this Volume has been configured with a root disk size; ""
        ""on such case a Root Volume can only be resized when changing to another Service Offering with a Root disk size. ""
        ""For more details please check out the Official Resizing Volumes documentation.""
    );
}
newSize = cmd.getSize();
newHypervisorSnapshotReserve = volume.getHypervisorSnapshotReserve();",1
"#include ""ChannelHandlerContext.h""
#include ""ChannelOutboundHandlerAdapter.h""

using namespace io::opentelemetry::javaagent::instrumentation::netty::v4_1::client;

using HTTP_REQUEST = NettyClientSingletons::HTTP_REQUEST;
using instrumenter = NettyClientSingletons::instrumenter;","#include ""ChannelHandlerContext.h""
#include ""ChannelOutboundHandlerAdapter.h""
#include ""NettyClientSingletons.h""

using namespace io::opentelemetry::javaagent::instrumentation::netty::v4_1::client;

using HTTP_REQUEST = NettyClientSingletons::HTTP_REQUEST;
using instrumenter = NettyClientSingletons::instrumenter;",0
"#include <gtest/gtest.h>
#include <string>

class MVELExpressionLanguage {
public:
    MVELExpressionLanguage(MuleContext* context) : context_(context) {}
    void initialise() { /* ... */ }
    std::string evaluate(const std::string& expr, MuleEvent* event) {
        // ... implementation
        return """";
    }
private:
    MuleContext* context_;
};

class MuleEvent {
public:
    MuleEvent(const std::string& payload) : payload_(payload) {}
    class Message {
    public:
        Message(const std::string& payload) : payload_(payload) {}
        std::string getPayload() const { return payload_; }
        void setPayload(const std::string& payload) { payload_ = payload; }
    private:
        std::string payload_;
    };
    Message* getMessage() { return &message_; }
private:
    Message message_{payload_};
    std::string payload_;
};

MuleEvent* getTestEvent(const std::string& payload) {
    return new MuleEvent(payload);
}

TEST(MVELExpressionLanguageTests, testVariableAlias) {
    MVELExpressionLanguage mvel(muleContext);
    mvel.initialise();

    MuleEvent* event = getTestEvent(""foo"");
    ASSERT_EQ(""foo"", mvel.evaluate(""p"", event));
}

TEST(MVELExpressionLanguageTests, testAssignValueToVariableAlias) {
    MVELExpressionLanguage mvel(muleContext);
    mvel.initialise();

    MuleEvent* event = getTestEvent("""");
    mvel.evaluate(""p='bar'"", event);
    ASSERT_EQ(""bar"", event->getMessage()->getPayload());
}","#include <gtest/gtest.h>
#include <string>

class MuleEvent;
class MVELExpressionLanguage;

class ExpressionLanguageExtensionTestCase : public ::testing::Test {
protected:
    MuleContext* muleContext;

    MuleEvent* getTestEvent(const std::string& payload);

    void SetUp() override {
        // Setup muleContext or other state if necessary
    }
};

TEST_F(ExpressionLanguageExtensionTestCase, testVariableAlias) {
    MVELExpressionLanguage mvel(muleContext);
    mvel.initialise();

    MuleEvent* event = getTestEvent(""foo"");

    ASSERT_EQ(""foo"", mvel.evaluate(""p"", event));
}

TEST_F(ExpressionLanguageExtensionTestCase, testAssignValueToVariableAlias) {
    MVELExpressionLanguage mvel(muleContext);
    mvel.initialise();

    MuleEvent* event = getTestEvent("""");

    mvel.evaluate(""p='bar'"", event);
    ASSERT_EQ(""bar"", event->getMessage()->getPayload());
}",0
"#include <map>
#include <thread>
#include <memory>
#include <string>","#include <map>
#include <memory>
#include <thread>",0
"#include <typeinfo>
#include <typeindex>
#include <set>
#include <list>
#include <vector>
#include <unordered_set>
#include <iterator>
#include <algorithm>","#include <type_traits>
#include <typeinfo>
#include <set>
#include <list>
#include <vector>
#include <unordered_set>
#include <iterator>
#include <algorithm>",0
"setDefaultOnCondition(props, !props.contains(CLEANER_PARALLELISM), CLEANER_PARALLELISM, DEFAULT_CLEANER_PARALLELISM);
setDefaultOnCondition(props, !props.contains(COMPACTION_STRATEGY_PROP), COMPACTION_STRATEGY_PROP, DEFAULT_COMPACTION_STRATEGY);
setDefaultOnCondition(props, !props.contains(PAYLOAD_CLASS), PAYLOAD_CLASS, DEFAULT_PAYLOAD_CLASS);
setDefaultOnCondition(props, !props.contains(TARGET_IO_PER_COMPACTION_IN_MB_PROP), TARGET_IO_PER_COMPACTION_IN_MB_PROP, DEFAULT_TARGET_IO_PER_COMPACTION_IN_MB);","setDefaultOnCondition(props, !props.containsKey(CLEANER_PARALLELISM), CLEANER_PARALLELISM, DEFAULT_CLEANER_PARALLELISM);
setDefaultOnCondition(props, !props.containsKey(COMPACTION_STRATEGY_PROP), COMPACTION_STRATEGY_PROP, DEFAULT_COMPACTION_STRATEGY);
setDefaultOnCondition(props, !props.containsKey(PAYLOAD_CLASS), PAYLOAD_CLASS, DEFAULT_PAYLOAD_CLASS);
setDefaultOnCondition(props, !props.containsKey(TARGET_IO_PER_COMPACTION_IN_MB_PROP), TARGET_IO_PER_COMPACTION_IN_MB_PROP, DEFAULT_TARGET_IO_PER_COMPACTION_IN_MB);",0
"#include <string>
#include <regex>
#include <stdexcept>

class Utils {
public:
    static std::string getDbTableName(const std::string& schemaName) {
        if (!std::regex_match(schemaName, std::regex("".+_.+_.+""))) {
            throw std::invalid_argument(""schemaName does not match required format"");
        }
        std::string result = schemaName;
        size_t firstUnderscore = result.find('_');
        if (firstUnderscore != std::string::npos) {
            result[firstUnderscore] = '.';
        }
        size_t lastUnderscore = result.rfind('_');
        if (lastUnderscore != std::string::npos) {
            result = result.substr(0, lastUnderscore);
        }
        return result;
    }
};","#include <string>
#include <regex>
#include <stdexcept>

class TimestampDataPublisher {
public:
    static std::string getDbTableName(const std::string& schemaName) {
        if (!std::regex_match(schemaName, std::regex("".+_.+_.+""))) {
            throw std::invalid_argument(""schemaName does not match required format"");
        }
        std::string replaced = schemaName;
        size_t firstUnderscore = replaced.find('_');
        if (firstUnderscore != std::string::npos) {
            replaced[firstUnderscore] = '.';
        }
        size_t lastUnderscore = replaced.rfind('_');
        return replaced.substr(0, lastUnderscore);
    }
};",1
"return nullptr;
    }
}

class GroupZoomToBooleanConverter {
public:
    bool Convert(const std::vector<double>& values) {
        double zoom = values[0];
        double fontsize = values[1];
        double factor = zoom * fontsize;
        if (factor < 7.0) {
            return false;
        }
        return true;
    }

    std::vector<double> ConvertBack(bool value) {
        throw std::logic_error(""Not implemented"");
    }
};","class GroupZoomToBooleanConverter
{
public:
    bool Convert(const std::vector<double>& values)
    {
        double zoom = values[0];
        double fontsize = values[1];

        double factor = zoom * fontsize;
        if (factor < 7.0)
        {
            return false;
        }

        return true;
    }

    std::vector<double> ConvertBack(bool value)
    {
        throw std::logic_error(""NotImplementedException"");
    }
};",1
"indices.waitForRecovery(index);

auto retryer = RetryerBuilder<IndexRange>::newBuilder()
// .retryIfException([](const std::exception& input){ return dynamic_cast<const IndexClosedException*>(&input) == nullptr; })
    .withWaitStrategy(WaitStrategies::exponentialWait())
    .withStopStrategy(StopStrategies::stopAfterDelay(std::chrono::minutes(5)))
    .build();","indices.waitForRecovery(index);

auto retryer = RetryerBuilder<IndexRange>::newBuilder()
// .retryIfException([](const std::exception& input) { return dynamic_cast<const IndexClosedException*>(&input) == nullptr; })
    .withWaitStrategy(WaitStrategies::exponentialWait())
    .withStopStrategy(StopStrategies::stopAfterDelay(std::chrono::minutes(5)))
    .build();",1
"DirectDownloadCommand* getDirectDownloadCommandFromProtocol(
    DownloadProtocol protocol,
    const std::string& url,
    long long templateId,
    PrimaryDataStoreTO* destPool,
    const std::string& checksum,
    const std::map<std::string, std::string>& httpHeaders)
{
    int connectTimeout = DEFAULT_DIRECT_DOWNLOAD_CONNECT_TIMEOUT;
    int soTimeout = DEFAULT_DIRECT_DOWNLOAD_SOCKET_TIMEOUT;
    int connectionRequestTimeout = DEFAULT_DIRECT_DOWNLOAD_CONNECTION_REQUEST_TIMEOUT;

    if (protocol == DownloadProtocol::HTTP ||
        protocol == DownloadProtocol::HTTPS ||
        protocol == DownloadProtocol::METALINK)
    {
        try {
            connectTimeout = std::stoi(configDao.getValue(DirectDownloadConnectTimeout::key()));
        } catch (const std::invalid_argument& nfe) {
            s_logger.warn(""Unable to retrieve configuration: "" +
                DirectDownloadConnectTimeout::key() + "" value"");
        }
        try {
            soTimeout = std::stoi(configDao.getValue(DirectDownloadSocketTimeout::key()));
        } catch (const std::invalid_argument& nfe) {
            s_logger.warn(""Unable to retrieve configuration: "" +
                DirectDownloadSocketTimeout::key() + "" value"");
        }
    }

    if (protocol == DownloadProtocol::HTTPS) {
        try {
            connectionRequestTimeout = std::stoi(configDao.getValue(DirectDownloadConnectionRequestTimeout::key()));
        } catch (const std::invalid_argument& nfe) {
            s_logger.warn(""Unable to retrieve configuration: "" +
                DirectDownloadConnectionRequestTimeout::key() + "" value"");
        }
    }

    if (protocol == DownloadProtocol::HTTP) {
        return new HttpDirectDownloadCommand(url, templateId, destPool, checksum, httpHeaders, connectTimeout, soTimeout);
    } else if (protocol == DownloadProtocol::HTTPS) {
        return new HttpsDirectDownloadCommand(url, templateId, destPool, checksum, httpHeaders, connectTimeout, soTimeout, connectionRequestTimeout);
    } else if (protocol == DownloadProtocol::NFS) {
        return new NfsDirectDownloadCommand(url, templateId, destPool, checksum, httpHeaders);
    } else if (protocol == DownloadProtocol::METALINK) {
        return new MetalinkDirectDownloadCommand(url, templateId, destPool, checksum, httpHeaders, connectTimeout, soTimeout);
    } else {
        return nullptr;
    }
}","```cpp
DirectDownloadCommand* getDirectDownloadCommandFromProtocol(
    DownloadProtocol protocol,
    const std::string& url,
    long long templateId,
    PrimaryDataStoreTO* destPool,
    const std::string& checksum,
    const std::map<std::string, std::string>& httpHeaders
) {
    int connectTimeout = DEFAULT_DIRECT_DOWNLOAD_CONNECT_TIMEOUT;
    int soTimeout = DEFAULT_DIRECT_DOWNLOAD_SOCKET_TIMEOUT;
    int connectionRequestTimeout = DEFAULT_DIRECT_DOWNLOAD_CONNECTION_REQUEST_TIMEOUT;

    if (protocol == DownloadProtocol::HTTP ||
        protocol == DownloadProtocol::HTTPS ||
        protocol == DownloadProtocol::METALINK) {
        try {
            connectTimeout = std::stoi(configDao->getValue(DirectDownloadConnectTimeout::key()));
        } catch (const std::exception& nfe) {
            s_logger.warn(""Unable to retrieve configuration: "" + DirectDownloadConnectTimeout::key() + "" value"", nfe);
        }
        try {
            soTimeout = std::stoi(configDao->getValue(DirectDownloadSocketTimeout::key()));
        } catch (const std::exception& nfe) {
            s_logger.warn(""Unable to retrieve configuration: "" + DirectDownloadSocketTimeout::key() + "" value"", nfe);
        }
    }
    if (protocol == DownloadProtocol::HTTPS) {
        try {
            connectionRequestTimeout = std::stoi(configDao->getValue(DirectDownloadConnectionRequestTimeout::key()));
        } catch (const std::exception& nfe) {
            s_logger.warn(""Unable to retrieve configuration: "" + DirectDownloadConnectionRequestTimeout::key() + "" value"", nfe);
        }
    }
    if (protocol == DownloadProtocol::HTTP) {
        return new HttpDirectDownloadCommand(url, templateId, destPool, checksum, httpHeaders, connectTimeout, soTimeout);
    } else if (protocol == DownloadProtocol::HTTPS) {
        return new HttpsDirectDownloadCommand(url, templateId, destPool, checksum, httpHeaders, connectTimeout, soTimeout, connectionRequestTimeout);
    } else if (protocol == DownloadProtocol::NFS) {
        return new NfsDirectDownloadCommand(url, templateId, destPool, checksum, httpHeaders);
    } else if (protocol == DownloadProtocol::METALINK) {
        return new MetalinkDirectDownloadCommand(url, templateId, destPool, checksum, httpHeaders, connectTimeout, soTimeout);
    } else {
        return nullptr;
    }
}
```",1
"std::vector<RuntimeBeanReference> protocolRuntimeBeanReferences = toRuntimeBeanReferences(protocolConfigBeanNames);
if (!protocolRuntimeBeanReferences.empty()) {
    builder.addPropertyValue(""protocols"", protocolRuntimeBeanReferences);
}","if (!protocolRuntimeBeanReferences.empty()) {
    builder.addPropertyValue(""protocols"", protocolRuntimeBeanReferences);
}",1
"#include <string>
#include <vector>

class Dialog {
};

class Bundle {
};

class LinearLayoutManager {
};

class SomeClass {
public:
    void someMethod();
};

void SomeClass::someMethod() {
    Dialog dialog;
    Bundle bundle;
    LinearLayoutManager layoutManager;
    // ... rest of the logic
}","#include <string>
#include <memory>
#include <vector>
#include <utility>",0
"legacyCorrelationId = nullptr;
error = nullptr;
itemSequenceInfo = nullptr;
internalParameters = SmallMap<>();","this->legacyCorrelationId = nullptr;
this->error = nullptr;
this->itemSequenceInfo = nullptr;
this->internalParameters = SmallMap<>();",0
"if (newProject.getNewPackageOptions() == nullptr)
{
    auto onReady = [&]() {
        projServer_.createProject(
            newProject.getProjectFile(),
            newProject.getNewPackageOptions(),
            newProject.getNewShinyAppOptions(),
            newProject.getProjectTemplateOptions(),
            new SimpleRequestCallback<std::string>{
                [&](const std::string& foundProjectFile)
                {
                    if (!StringUtil::isNullOrEmpty(foundProjectFile))
                    {
                        // found an existing project file with different name than the
                        // parent folder; have to update here so that's what we end up
                        // opening
                        newProject.setProjectFile(foundProjectFile);
                    }
                    continuation.execute();
                }
            }
        );
    };

    if (newProject.getProjectTemplateOptions() != nullptr)
    {
        // NOTE: We provide built-in project templates for packages that may
        // not be currently installed; in those cases, verify that the package is
        // installed and if not attempt installation from CRAN first
        std::string pkg = newProject.getProjectTemplateOptions()->getDescription().getPackage();
        RStudioGinjector::INSTANCE->getDependencyManager()->withDependencies(
            ""Creating project"",
            ""Creating a project with "" + pkg,
            { Dependency::cranPackage(pkg) },
            false,
            [=](bool success) { onReady(); }
        );
    }
    else
    {
        onReady();
    }
}
else
{","```cpp
if (newProject.getNewPackageOptions() == nullptr)
{
    auto onReady = [&]() {
        projServer_.createProject(
            newProject.getProjectFile(),
            newProject.getNewPackageOptions(),
            newProject.getNewShinyAppOptions(),
            newProject.getProjectTemplateOptions(),
            SimpleRequestCallback<std::string>(
                [&](const std::string& foundProjectFile) {
                    if (!StringUtil::isNullOrEmpty(foundProjectFile))
                    {
                        newProject.setProjectFile(foundProjectFile);
                    }
                    continuation.execute();
                }
            )
        );
    };

    if (newProject.getProjectTemplateOptions() != nullptr)
    {
        std::string pkg = newProject.getProjectTemplateOptions()
                              ->getDescription()
                              .getPackage();
        RStudioGinjector::INSTANCE.getDependencyManager().withDependencies(
            ""Creating project"",
            ""Creating a project with "" + pkg,
            std::vector<Dependency>{ Dependency::cranPackage(pkg) },
            false,
            [onReady](bool success) { onReady(); }
        );
    }
    else
    {
        onReady();
    }
}
else
{
```",1
"objects[OBJECT_QUEUE_MANAGER] = rtqm;
objects[OBJECT_SECURITY_MANAGER] = std::make_shared<DefaultMuleSecurityManager>();
objects[INTERCEPTOR_MANAGER_REGISTRY_KEY] = std::make_shared<MockInterceptorManager>();
auto coreProfilingService = std::make_shared<MockCoreProfilingService>();
objects[MULE_PROFILING_SERVICE_KEY] = coreProfilingService;

mockProcessingStrategyProfilingChainWithoutTriggeringEvent(coreProfilingService);

muleContext = DefaultMuleContextFactory().createMuleContext(testServicesConfigurationBuilder,
                                                            SimpleConfigurationBuilder(objects));
testServicesConfigurationBuilder.configure(muleContext);","objects[OBJECT_QUEUE_MANAGER] = rtqm;
objects[OBJECT_SECURITY_MANAGER] = std::make_shared<DefaultMuleSecurityManager>();
objects[INTERCEPTOR_MANAGER_REGISTRY_KEY] = std::make_shared<NiceMock<InterceptorManager>>();
auto coreProfilingService = std::make_shared<NiceMock<CoreProfilingService>>();
objects[MULE_PROFILING_SERVICE_KEY] = coreProfilingService;
mockProcessingStrategyProfilingChainWithoutTriggeringEvent(coreProfilingService);
muleContext = DefaultMuleContextFactory().createMuleContext(testServicesConfigurationBuilder, SimpleConfigurationBuilder(objects));
testServicesConfigurationBuilder.configure(muleContext);",0
"return typedSelf();
}

B& withHttpClientConnectionManager(std::shared_ptr<HttpClientConnectionManager> connManager) {
    this->httpConnManager = connManager;
    return typedSelf();
}

B& withLogger(std::shared_ptr<Logger> logger) {
    this->logger = logger;
    return typedSelf();
}

void validate() {
    if (!getState()) {
        throw std::invalid_argument(""State is required for "" + std::string(typeid(*this).name()));
    }
    if (!getHttpClientBuilder()) {
        throw std::invalid_argument(""HttpClientBuilder is required for "" + std::string(typeid(*this).name()));
    }
    if (!getHttpConnManager()) {
        throw std::invalid_argument(""HttpConnManager is required for "" + std::string(typeid(*this).name()));
    }
}","template <typename S, typename D, typename B>
class AbstractHttpWriterBuilder {
public:
    B& withHttpClientConnectionManager(HttpClientConnectionManager* connManager) {
        httpConnManager = connManager;
        return typedSelf();
    }

    B& withLogger(std::shared_ptr<Logger> logger) {
        this->logger = logger;
        return typedSelf();
    }

    void validate() {
        Preconditions::checkNotNull(getState(), std::string(""State is required for "") + typeid(*this).name());
        Preconditions::checkNotNull(getHttpClientBuilder(), std::string(""HttpClientBuilder is required for "") + typeid(*this).name());
        Preconditions::checkNotNull(getHttpConnManager(), std::string(""HttpConnManager is required for "") + typeid(*this).name());
    }

protected:
    virtual B& typedSelf() = 0;
    virtual void* getState() = 0;
    virtual HttpClientBuilder* getHttpClientBuilder() = 0;
    virtual HttpClientConnectionManager* getHttpConnManager() = 0;

    HttpClientConnectionManager* httpConnManager = nullptr;
    std::shared_ptr<Logger> logger;
};",0
"}
 
protected:
bool copyFileToLocalDirectory(
    const std::string& remoteDirectoryPath,
    EvaluationContext localFileEvaluationContext,
    const std::string& remoteFile,
    const std::filesystem::path& localDirectory,
    Session<std::string>& session)
{
    if (remoteFile == ""bar"" && failWhenCopyingBar.exchange(false)) {
        throw std::ios_base::failure(""fail"");
    }","bool copyFileToLocalDirectory(
    const std::string& remoteDirectoryPath,
    EvaluationContext localFileEvaluationContext,
    const std::string& remoteFile,
    const std::filesystem::path& localDirectory,
    Session<std::string>& session) override
{
    if (remoteFile == ""bar"" && failWhenCopyingBar.exchange(false)) {
        throw std::ios_base::failure(""fail"");
    }
    // ...
}",0
"void setSessionAcknowledgeMode(const std::string& sessionAcknowledgeMode) {
    this->sessionAcknowledgeMode = sessionAcknowledgeMode;
}

std::string getComponentType() override {
    return ""jms:message-driven-channel-adapter"";
}","class JmsMessageDrivenEndpoint : public AbstractEndpoint {
public:
    void setListenerContainer(ListenerContainer* listenerContainer) {
        this->listenerContainer = listenerContainer;
    }

    void setSessionAcknowledgeMode(const std::string& sessionAcknowledgeMode) {
        this->sessionAcknowledgeMode = sessionAcknowledgeMode;
    }

    std::string getComponentType() const override {
        return ""jms:message-driven-channel-adapter"";
    }

private:
    ListenerContainer* listenerContainer;
    std::string sessionAcknowledgeMode;
};",0
"#include <gtest/gtest.h>

TEST(TestSuiteName, getContentMetadataWithKey) {
    auto location = Location::builder().globalName(CONTENT_METADATA_WITH_KEY_ID).addIndexPart(0).build();
    const auto metadataDescriptor = getSuccessComponentDynamicMetadata();
    const auto& typedModel = metadataDescriptor.getModel();
    assertExpectedOutput(typedModel, typeBuilder.anyType().build(), typeid(void));
}","```cpp
#include <gtest/gtest.h>

TEST(MetadataOperationTestCase, getContentMetadataWithKey) {
    location = Location::builder().globalName(CONTENT_METADATA_WITH_KEY_ID).addIndexPart(0).build();
    const ComponentMetadataDescriptor metadataDescriptor = getSuccessComponentDynamicMetadata();
    const ComponentModel& typedModel = metadataDescriptor.getModel();
    assertExpectedOutput(typedModel, typeBuilder.anyType().build(), typeid(void));
}
```",0
"/*******************************************************************************  
 * Copyright (c) 2004, 2020 IBM Corp. and others
 *
 * This program and the accompanying materials are made available under
 * the terms of the Eclipse Public License 2.0 which accompanies this","/*******************************************************************************
 * Copyright (c) 2004, 2020 IBM Corp. and others
 *
 * This program and the accompanying materials are made available under
 * the terms of the Eclipse Public License 2.0 which accompanies this",0
"#include <string>
#include <vector>
#include <cassert>
#include <stdexcept>

class Path {
public:
    explicit Path(const std::string& path_) : path_(path_) {}

    Path getParent() const;
    std::string getName() const;
    std::string toString() const { return path_; }
    struct Uri {
        std::string getScheme() const;
    };
    Uri toUri() const;

private:
    std::string path_;
};

namespace InLineFileSystem {
    constexpr const char* SCHEME = ""inlinefs"";
}
constexpr const char* SCHEME_SEPARATOR = ""://"";
constexpr const char* LOCAL_FILESYSTEM_SCHEME = ""file"";
constexpr const char* PATH_SEPARATOR = ""/"";

inline void checkArgument(bool condition, const std::string& msg = """") {
    if (!condition) throw std::invalid_argument(msg);
}

std::vector<std::string> split(const std::string& str, const std::string& delims) {
    std::vector<std::string> out;
    size_t start = 0, pos = 0;
    while ((pos = str.find_first_of(delims, start)) != std::string::npos) {
        if (pos > start) out.push_back(str.substr(start, pos - start));
        start = pos + 1;
    }
    if (start < str.size()) out.push_back(str.substr(start));
    return out;
}

void assertInlineFSPath(const Path& inlinePath) {
    std::string scheme = inlinePath.toUri().getScheme();
    checkArgument(scheme == InLineFileSystem::SCHEME);
}

Path getOuterFilePathFromInlinePath(const Path& inlineFSPath) {
    assertInlineFSPath(inlineFSPath);

    std::string baseFileScheme = inlineFSPath.getParent().getName();
    Path basePath = inlineFSPath.getParent().getParent();
    checkArgument(basePath.toString().find(SCHEME_SEPARATOR) != std::string::npos,
                  ""Invalid InLineFS path: "" + inlineFSPath.toString());

    std::string baseStr = basePath.toString();
    std::size_t idx = baseStr.find(SCHEME_SEPARATOR);
    std::string pathExceptScheme = baseStr.substr(idx + std::string(SCHEME_SEPARATOR).length());

    std::string fullPath = baseFileScheme + SCHEME_SEPARATOR +
        (baseFileScheme == LOCAL_FILESYSTEM_SCHEME ? PATH_SEPARATOR : """")","#include <string>
#include <vector>
#include <cassert>
#include <stdexcept>

class Path {
public:
    explicit Path(const std::string& p) : path_(p) {}

    std::string toString() const { return path_; }

    Path getParent() const {
        auto pos = path_.find_last_of(PATH_SEPARATOR);
        if (pos == std::string::npos || pos == 0) return Path("""");
        return Path(path_.substr(0, pos));
    }

    std::string getName() const {
        auto pos = path_.find_last_of(PATH_SEPARATOR);
        if (pos == std::string::npos) return path_;
        return path_.substr(pos + 1);
    }

    struct Uri {
        std::string getScheme() const {
            auto pos = path_.find(SCHEME_SEPARATOR);
            if (pos == std::string::npos) return """";
            return path_.substr(0, pos);
        }
        std::string path_;
    };

    Uri toUri() const {
        return Uri{path_};
    }

private:
    std::string path_;
};

namespace InLineFileSystem {
    const std::string SCHEME = ""inlinefs"";
}

const std::string SCHEME_SEPARATOR = ""://"";
const char PATH_SEPARATOR = '/';
const std::string LOCAL_FILESYSTEM_SCHEME = ""file"";

void checkArgument(bool cond, const std::string& msg = """") {
    if (!cond) throw std::invalid_argument(msg);
}

void assertInlineFSPath(const Path& inlinePath) {
    std::string scheme = inlinePath.toUri().getScheme();
    checkArgument(scheme == InLineFileSystem::SCHEME);
}

std::vector<std::string> split(const std::string& str, const std::string& delims) {
    std::vector<std::string> tokens;
    size_t start = 0, end = 0;
    while ((end = str.find_first_of(delims, start)) != std::string::npos) {
        if (end != start) tokens.push_back(str.substr(start, end - start));
        start = end + 1;
    }
    if (start < str.size()) tokens.push_back(str.substr(start));
    return tokens;
}

Path getOuterFilePathFromInlinePath(const Path& inlineFSPath) {
    assertInlineFSPath(inlineFSPath);

    std::string baseFileScheme = inlineFSPath.getParent().getName();",1
"#include ""hudi/common/model/OverwriteWithLatestAvroPayload.h""
#include ""hudi/common/table/timeline/versioning/TimelineLayoutVersion.h""
#include ""hudi/common/util/Option.h""
#include ""hudi/common/util/ValidationUtils.h""
#include ""hudi/exception/HoodieIOException.h""

#include <hdfs/hdfs.h>","#include ""HoodieTableType.h""
#include ""OverwriteWithLatestAvroPayload.h""
#include ""TimelineLayoutVersion.h""
#include ""Option.h""
#include ""ValidationUtils.h""
#include ""HoodieIOException.h""

#include <hdfs/hdfs.h>
#include <fstream>",0
"```cpp
#include <map>
#include <shared_mutex>

template<typename K, typename V>
class MyMap : public std::map<K, V> {
private:
    mutable std::shared_mutex mutex_;
    int maxCapacity;

protected:
    bool removeEldestEntry(const std::pair<const K, V>& eldest) {
        std::shared_lock lock(mutex_);
        return std::map<K, V>::size() > maxCapacity;
    }

public:
    bool containsKey(const K& key) const {
        std::shared_lock lock(mutex_);
        return std::map<K, V>::find(key) != std::map<K, V>::end();
    }

    V get(const K& key) const {
        std::shared_lock lock(mutex_);
        auto it = std::map<K, V>::find(key);
        if (it != std::map<K, V>::end()) {
            return it->second;
        } else {
            return V{};
        }
    }

    V put(const K& key, const V& value) {
        std::unique_lock lock(mutex_);
        V oldValue{};
        auto it = std::map<K, V>::find(key);
        if (it != std::map<K, V>::end()) {
            oldValue = it->second;
            it->second = value;
        } else {
            std::map<K, V>::insert({key, value});
        }
        return oldValue;
    }

    V remove(const K& key) {
        std::unique_lock lock(mutex_);
        V oldValue{};
        auto it = std::map<K, V>::find(key);
        if (it != std::map<K, V>::end()) {
            oldValue = it->second;
            std::map<K, V>::erase(it);
        }
        return oldValue;
    }

    int size() const {
        std::shared_lock lock(mutex_);
        return static_cast<int>(std::map<K, V>::size());
    }

    void clear() {
        std::unique_lock lock(mutex_);
        std::map<K, V>::clear();
    }

    int getMaxCapacity() const {
        std::shared_lock lock(mutex_);
        return maxCapacity;
    }

    void setMaxCapacity(int maxCapacity_) {
        std::unique_lock lock(mutex_);
        maxCapacity = maxCapacity_;
    }
};
```","#include <unordered_map>
#include <list>
#include <shared_mutex>

template<typename K, typename V>
class LRUCache {
public:
    using Key = K;
    using Value = V;

    explicit LRUCache(size_t capacity)
        : maxCapacity(capacity) {}

    bool containsKey(const Key& key) {
        std::shared_lock lock(mutex_);
        return cacheMap.find(key) != cacheMap.end();
    }

    Value get(const Key& key) {
        std::unique_lock lock(mutex_);
        auto it = cacheMap.find(key);
        if (it == cacheMap.end())
            return Value();
        cacheList.splice(cacheList.begin(), cacheList, it->second);
        return it->second->second;
    }

    Value put(const Key& key, const Value& value) {
        std::unique_lock lock(mutex_);
        auto it = cacheMap.find(key);
        if (it != cacheMap.end()) {
            Value oldValue = it->second->second;
            it->second->second = value;
            cacheList.splice(cacheList.begin(), cacheList, it->second);
            return oldValue;
        }
        cacheList.emplace_front(key, value);
        cacheMap[key] = cacheList.begin();
        if (cacheMap.size() > maxCapacity) {
            auto last = cacheList.end();
            --last;
            cacheMap.erase(last->first);
            cacheList.pop_back();
        }
        return Value();
    }

    Value remove(const Key& key) {
        std::unique_lock lock(mutex_);
        auto it = cacheMap.find(key);
        if (it == cacheMap.end())
            return Value();
        Value oldValue = it->second->second;
        cacheList.erase(it->second);
        cacheMap.erase(it);
        return oldValue;
    }

    size_t size() {
        std::shared_lock lock(mutex_);
        return cacheMap.size();
    }

    void clear() {
        std::unique_lock lock(mutex_);
        cacheMap.clear();
        cacheList.clear();
    }

    size_t getMaxCapacity() {
        std::shared_lock lock(mutex_);
        return maxCapacity;
    }

    void setMaxCapacity(size_t capacity) {
        std::unique_lock lock(mutex_);
        maxCapacity = capacity;
        while (cacheMap.size() > maxCapacity) {
            auto last = cacheList.end();
            --last;
            cacheMap.erase(last->first);
            cacheList.pop_back();",1
"static const DedupKeyOption DEFAULT_DEDUP_KEY_OPTION = DedupKeyOption::KEY;

class MRCompactorAvroKeyDedupJobRunner : public SuperClass {
private:
    const bool useSingleInputSchema;
public:
    MRCompactorAvroKeyDedupJobRunner(Dataset dataset, FileSystem fs, double priority)
        : SuperClass(dataset, fs, priority),
          useSingleInputSchema(dataset.jobProps().getPropAsBoolean(COMPACTION_JOB_AVRO_SINGLE_INPUT_SCHEMA, false))
    {
    }

    // override
};","```cpp
static constexpr DedupKeyOption DEFAULT_DEDUP_KEY_OPTION = DedupKeyOption::KEY;

class MRCompactorAvroKeyDedupJobRunner : public MRCompactorJobRunner {
private:
    const bool useSingleInputSchema;

public:
    MRCompactorAvroKeyDedupJobRunner(Dataset& dataset, FileSystem& fs, double priority)
        : MRCompactorJobRunner(dataset, fs, priority),
          useSingleInputSchema(dataset.jobProps().getPropAsBoolean(COMPACTION_JOB_AVRO_SINGLE_INPUT_SCHEMA, false))
    {}
};
```",0
"std::vector<WorkUnitState> getPreviousWorkUnitStates() const {
    return std::vector<WorkUnitState>(this->previousWorkUnitStates.begin(), this->previousWorkUnitStates.end());
}","std::vector<WorkUnitState> getPreviousWorkUnitStates() {
    return std::vector<WorkUnitState>(this->previousWorkUnitStates.begin(), this->previousWorkUnitStates.end());
}",0
"std::vector<std::shared_ptr<CommitStep>> getCommitSequence(const std::vector<std::shared_ptr<WorkUnitState>>& workUnits, const std::type_info& baseClass) {
    std::vector<std::shared_ptr<CommitStepCopyEntity>> steps;
    for (const auto& wus : workUnits) {
        if (typeid(*CopySource::copyEntityClass(wus)) == baseClass || std::type_index(typeid(*CopySource::copyEntityClass(wus))).before(std::type_index(baseClass))) {
            auto step = std::dynamic_pointer_cast<CommitStepCopyEntity>(CopySource::deserializeCopyEntity(wus));
            steps.push_back(step);
        }
    }
    auto commitStepSorter = [](const std::shared_ptr<CommitStepCopyEntity>& o1, const std::shared_ptr<CommitStepCopyEntity>& o2) {
        return o1->getPriority() < o2->getPriority();
    };
    std::sort(steps.begin(), steps.end(), commitStepSorter);

    std::vector<std::shared_ptr<CommitStep>> sequence;
    for (const auto& entity : steps) {
        sequence.push_back(entity->getStep());
    }
    return sequence;
}

void executeCommitSequence(const std::vector<std::shared_ptr<CommitStep>>& steps) {
    for (const auto& step : steps) {
        step->execute();
    }
}

Path findPathRoot(Path path) {
    while (path.getParent() != nullptr) {
        path = path.getParent();
    }
    return path;
}","#include <vector>
#include <algorithm>
#include <stdexcept>

std::vector<std::shared_ptr<CommitStep>> getCommitSequence(
    const std::vector<std::shared_ptr<WorkUnitState>>& workUnits,
    const std::type_info& baseType)
{
    std::vector<std::shared_ptr<CommitStepCopyEntity>> steps;
    for (const auto& wus : workUnits) {
        if (typeid(baseType) == typeid(*CopySource::copyEntityClass(wus)) ||
            dynamic_cast<const std::remove_reference_t<decltype(baseType)>*>(&(*CopySource::copyEntityClass(wus)))) {
            auto step = std::dynamic_pointer_cast<CommitStepCopyEntity>(CopySource::deserializeCopyEntity(wus));
            if (step) {
                steps.push_back(step);
            }
        }
    }

    std::sort(steps.begin(), steps.end(),
        [](const std::shared_ptr<CommitStepCopyEntity>& o1, const std::shared_ptr<CommitStepCopyEntity>& o2) {
            return o1->getPriority() < o2->getPriority();
        });

    std::vector<std::shared_ptr<CommitStep>> sequence;
    for (const auto& entity : steps) {
        sequence.push_back(entity->getStep());
    }

    return sequence;
}

void executeCommitSequence(const std::vector<std::shared_ptr<CommitStep>>& steps)
{
    for (const auto& step : steps) {
        step->execute();
    }
}

Path findPathRoot(Path path)
{
    while (path.getParent() != nullptr) {
        path = path.getParent();
    }
    return path;
}",1
"entry->uniqueGuards.Clear();

if (!isAllPropertyGuardsInvalidation)
{
    this->UpdateConstructorCacheInvalidationCount(count);
}

this->UpdateEntryPoints(propertyRecord, entry);
}

void ThreadContext::InvalidatePropertyGuards(Js::PropertyId propertyId)
{
    const Js::PropertyRecord* propertyRecord = GetPropertyName(propertyId);
    PropertyGuardDictionary& guards = this->recyclableData->propertyGuards;
    PropertyGuardEntry* entry = nullptr;
    if (guards.TryGetValueAndRemove(propertyRecord, &entry))
    {
        InvalidatePropertyGuardEntry(propertyRecord, entry, false);
    }
}

void ThreadContext::InvalidatePropertyGuardEntryForType(
    const Js::PropertyRecord* propertyRecord,
    PropertyGuardEntry* entry,
    bool isAllPropertyGuardsInvalidation,
    const Js::Type* type)
{
    Assert(entry != nullptr);
    Assert(type != nullptr);

    if (entry->sharedGuard != nullptr)
    {
        Js::PropertyGuard* guard = entry->sharedGuard;
        if (guard->GetValue() == reinterpret_cast<intptr_t>(type))
        {
            if (PHASE_TRACE1(Js::TracePropertyGuardsPhase) || PHASE_VERBOSE_TRACE1(Js::FixedMethodsPhase))
            {
                Output::Print(_u(""FixedFields: invalidating guard: name: %s, address: 0x%p, value: 0x%p, value address: 0x%p\n""),
                              propertyRecord->GetBuffer(), guard, guard->GetValue(), guard->GetAddressOfValue());
                Output::Flush();
            }
            if (PHASE_TESTTRACE1(Js::TracePropertyGuardsPhase) || PHASE_VERBOSE_TESTTRACE1(Js::FixedMethodsPhase))
            {
                Output::Print(_u(""FixedFields: invalidating guard: name: %s, value: 0x%p\n""),
                              propertyRecord->GetBuffer(), guard->GetValue());
                Output::Flush();
            }
            guard->Invalidate();
        }
    }

    uint count = 0;
    entry->uniqueGuards.MapAndRemoveIf([&count, propertyRecord, type](RecyclerWeakReference<Js::PropertyGuard>* guardWeakRef) -> bool
    {
        Js::PropertyGuard* guard = guardWeakRef->Get();
        if (guard != nullptr && guard->GetValue() == reinterpret_cast<intptr_t>(type))
        {","void ThreadContext::InvalidatePropertyGuardEntry(const Js::PropertyRecord* propertyRecord, PropertyGuardEntry* entry, bool isAllPropertyGuardsInvalidation)
{
    entry->uniqueGuards.Clear();

    if (!isAllPropertyGuardsInvalidation)
    {
        this->UpdateConstructorCacheInvalidationCount(count);
    }

    this->UpdateEntryPoints(propertyRecord, entry);
}

void ThreadContext::InvalidatePropertyGuards(Js::PropertyId propertyId)
{
    const Js::PropertyRecord* propertyRecord = GetPropertyName(propertyId);
    auto& guards = this->recyclableData->propertyGuards;
    PropertyGuardEntry* entry = nullptr;
    if (guards.TryGetValueAndRemove(propertyRecord, &entry))
    {
        InvalidatePropertyGuardEntry(propertyRecord, entry, false);
    }
}

void ThreadContext::InvalidatePropertyGuardEntryForType(const Js::PropertyRecord* propertyRecord, PropertyGuardEntry* entry, bool isAllPropertyGuardsInvalidation, const Js::Type* type)
{
    assert(entry != nullptr);
    assert(type != nullptr);

    if (entry->sharedGuard != nullptr)
    {
        Js::PropertyGuard* guard = entry->sharedGuard;
        if (guard->GetValue() == reinterpret_cast<intptr_t>(type))
        {
            if (PHASE_TRACE1(Js::TracePropertyGuardsPhase) || PHASE_VERBOSE_TRACE1(Js::FixedMethodsPhase))
            {
                Output::Print(_u(""FixedFields: invalidating guard: name: %s, address: 0x%p, value: 0x%p, value address: 0x%p\n""),
                              propertyRecord->GetBuffer(), guard, guard->GetValue(), guard->GetAddressOfValue());
                Output::Flush();
            }

            if (PHASE_TESTTRACE1(Js::TracePropertyGuardsPhase) || PHASE_VERBOSE_TESTTRACE1(Js::FixedMethodsPhase))
            {
                Output::Print(_u(""FixedFields: invalidating guard: name: %s, value: 0x%p\n""), propertyRecord->GetBuffer(), guard->GetValue());
                Output::Flush();
            }

            guard->Invalidate();
        }
    }

    uint count = 0;
    entry->uniqueGuards.MapAndRemoveIf([&count, propertyRecord, type](RecyclerWeakReference<Js::PropertyGuard>* guardWeakRef) -> bool
    {
        Js::PropertyGuard* guard =",1
"void copy(const FileConnectorConfig& config, FileSystem& fileSystem, const std::string& sourcePath,
          const std::string& targetPath, bool createParentDirectories = true,
          bool overwrite = false, const std::optional<std::string>& renameTo = std::nullopt) {
    doCopy(config, fileSystem, sourcePath, targetPath, createParentDirectories, overwrite, renameTo);
}","void copy(const FileConnectorConfig& config, FileSystem& fileSystem, const std::string& sourcePath,
          const std::string& targetPath, bool createParentDirectories = true,
          bool overwrite = false, const std::optional<std::string>& renameTo = std::nullopt) {
    BaseFileSystemOperations::doCopy(config, fileSystem, sourcePath, targetPath, createParentDirectories, overwrite, renameTo);
}",1
"sc.setParameters(""keyPairName"", keyPairName);

if (_accountMgr.isRootAdmin(caller->getId())) {
    if (cmd.getPodId() != nullptr) {
        sc.setParameters(""podId"", pod);

        if (state == nullptr) {","if (_accountMgr.isRootAdmin(caller->getId())) {
    if (cmd.getPodId() != nullptr) {
        sc.setParameters(""podId"", pod);

        if (state == nullptr) {",1
"void before() {
    flow = getTestFlow(muleContext);
    messageContext = DefaultEventContext::create(flow, TEST_CONNECTOR);
    muleEvent = Event::builder(messageContext)
                    .message(muleMessage)
                    .exchangePattern(REQUEST_RESPONSE)
                    .flow(flow)
                    .build();
}","void SetUp() override {
    flow = getTestFlow(muleContext);
    messageContext = DefaultEventContext::create(flow, TEST_CONNECTOR);
    muleEvent = Event::builder(messageContext).message(muleMessage).exchangePattern(REQUEST_RESPONSE).flow(flow).build();
}",1
"#include <map>
#include <string>

using namespace std;

// using directives analogous to Java static imports
using std::map;
using std::string;","#include ""io/opentelemetry/auto/instrumentation/httpurlconnection/HttpUrlConnectionTracer.h""
#include <unordered_map>
#include <string>

using namespace io::opentelemetry::auto::instrumentation::httpurlconnection;

auto singletonMap = [](const std::string& key, const std::string& value) {
    return std::unordered_map<std::string, std::string>{{key, value}};
};",0
"#include <elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.h>
#include <elasticsearch/action/admin/indices/open/OpenIndexRequest.h>
#include <elasticsearch/action/admin/indices/optimize/OptimizeRequest.h>
#include <elasticsearch/action/admin/indices/recovery/RecoveryRequest.h>
#include <elasticsearch/action/admin/indices/recovery/RecoveryResponse.h>
#include <elasticsearch/action/admin/indices/settings/put/UpdateSettingsRequest.h>
#include <elasticsearch/action/admin/indices/stats/IndexStats.h>
#include <elasticsearch/action/admin/indices/stats/IndicesStatsRequest.h>","#include ""elasticsearch/action/admin/indices/flush/FlushRequest.h""
#include ""elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.h""
#include ""elasticsearch/action/admin/indices/open/OpenIndexRequest.h""
#include ""elasticsearch/action/admin/indices/optimize/OptimizeRequest.h""
#include ""elasticsearch/action/admin/indices/recovery/RecoveryRequest.h""
#include ""elasticsearch/action/admin/indices/recovery/RecoveryResponse.h""
#include ""elasticsearch/action/admin/indices/settings/put/UpdateSettingsRequest.h""
#include ""elasticsearch/action/admin/indices/stats/IndexStats.h""
#include ""elasticsearch/action/admin/indices/stats/IndicesStatsRequest.h""",0
"auto customButtonsPreference = screen->findPreference(""custom_buttons_link"");
customButtonsPreference->setOnPreferenceClickListener([this](Preference* preference) {
    auto i = getPreferenceSubscreenIntent(this, ""com.ichi2.anki.prefs.custom_buttons"");
    startActivity(i);
    return true;
});","auto customButtonsPreference = screen->findPreference(""custom_buttons_link"");
customButtonsPreference->setOnPreferenceClickListener([this](Preference* preference) {
    auto i = getPreferenceSubscreenIntent(this, ""com.ichi2.anki.prefs.custom_buttons"");
    startActivity(i);
    return true;
});",0
"#include <gtest/gtest.h>
#include <filesystem>

class CompatCopyFileTest : public ::testing::Test {
};","#include <gtest/gtest.h>

class CompatCopyFileTest : public ::testing::Test {
};",1
"std::any o1 = foo();
std::any o2 = foo();
std::any o3 = foo();
std::string s1 = static_cast<std::string>(obj);
std::string s2 = s1;
A* a = new B();
A* as[1][1] = { { new B() } };
B* b;
fun(*b);
fun(static_cast<A&>(*b)); // Compliant - exception to distinguish the method to call
std::vector<B*> bees;
std::vector<A*>* aaas = reinterpret_cast<std::vector<A*>*>(&bees);
C c(static_cast<A*>(nullptr)); // Compliant - exception to distinguish the constructor to call
foo(static_cast<std::vector<std::vector<A*>>*>(static_cast<void*>(foo2())));
obj = static_cast<Unknown<std::string>*>(unknown);
std::vector<std::string> stringList = list.toArray(std::vector<std::string>{});","#include <vector>
#include <string>

class A {};
class B : public A {};
class C {
public:
    C(A* a) {}
};

void fun(A*) {}
void fun(B*) {}

std::vector<std::string> foo() { return {}; }
std::vector<std::vector<A>> foo2() { return {}; }
void* unknown;

int main() {
    auto o1 = foo();
    auto o2 = foo();
    auto o3 = foo();
    void* obj = nullptr;
    std::string s1 = *static_cast<std::string*>(obj);
    std::string s2 = s1;
    A* a = new B();
    B b;
    fun(&b);
    fun(static_cast<A*>(&b));
    std::vector<B> bees;
    std::vector<A*> aaas(bees.begin(), bees.end());
    C c(static_cast<A*>(nullptr));
    auto list = std::vector<std::string>();
    auto stringList = std::vector<std::string>(list.begin(), list.end());
}",1
"#include <string>
#include <memory>
#include <atomic>
#include <exception>
#include <stdexcept>

class Throwable : public std::exception {};

class ErrorType {};

class ErrorTypeRepository {
public:
    std::shared_ptr<ErrorType> lookupErrorType(const std::string& repr) {
        // Implement this method
        return nullptr;
    }
};

class MuleContext {
public:
    ErrorTypeRepository* getErrorTypeRepository() {
        // Implement this method
        return nullptr;
    }
};

class MuleException : public std::exception {
public:
    MuleException(const std::string& msg) : msg_(msg) {}
    const char* what() const noexcept override { return msg_.c_str(); }
private:
    std::string msg_;
};

class DefaultMuleException : public MuleException {
public:
    DefaultMuleException(const std::string& msg) : MuleException(msg) {}
};

class TypedException : public MuleException {
public:
    TypedException(std::exception_ptr original, std::shared_ptr<ErrorType> errorType)
        : MuleException(""TypedException""), errorType_(errorType), original_(original) {}
private:
    std::shared_ptr<ErrorType> errorType_;
    std::exception_ptr original_;
};

class Event {};

class Base {
protected:
    using ExceptionFactory = std::function<std::exception_ptr()>;
    ExceptionFactory exception;
    std::string error;
    std::atomic<int> count{0};
    MuleContext* muleContext;
public:
    virtual ~Base() = default;
    virtual Event process(Event event) {
        if (count == -1 || count-- > 0) {
            try {
                std::exception_ptr instantiatedException = exception();
                if (!error.empty()) {
                    auto* errorTypeRepository = muleContext->getErrorTypeRepository();
                    auto errorType = errorTypeRepository->lookupErrorType(buildFromStringRepresentation(error));
                    if (!errorType) {
                        throw DefaultMuleException(""Could not find error: "" + error);
                    }
                    throw TypedException(instantiatedException, errorType);
                } else {
                    if (!isTypedException(instantiatedException)) {
                        throw MuleException(""EXCEPTION_ERROR"");
                    }
                    std::rethrow_exception(instantiatedException);
                }
            } catch (const std::bad_alloc&) {
                throw DefaultMuleException(""Failed to instantiate exception class"");
            } catch (const std::exception&) {
                throw DefaultMuleException(""Failed to instantiate","#include <string>
#include <atomic>
#include <memory>
#include <exception>
#include <stdexcept>

class Throwable : public std::exception {
public:
    virtual const char* what() const noexcept override { return ""Throwable""; }
};

class TypedException : public Throwable {
public:
    TypedException(std::shared_ptr<Throwable> cause, std::shared_ptr<void> errorType)
        : cause_(cause), errorType_(errorType) {}
    virtual const char* what() const noexcept override { return ""TypedException""; }
private:
    std::shared_ptr<Throwable> cause_;
    std::shared_ptr<void> errorType_;
};

class DefaultMuleException : public std::runtime_error {
public:
    DefaultMuleException(const std::string& msg) : std::runtime_error(msg) {}
};

class ErrorType {};

class ErrorTypeRepository {
public:
    std::shared_ptr<ErrorType> lookupErrorType(const std::string& s) { return nullptr; }
};

class MuleContext {
public:
    std::shared_ptr<ErrorTypeRepository> getErrorTypeRepository() { return nullptr; }
};

class Event {};

class Processor {
public:
    virtual Event process(const Event& event) = 0;
    virtual ~Processor() = default;
};

#define EXCEPTION_ERROR ""Exception must be a TypedException""

void checkArgument(bool cond, const char* msg) {
    if (!cond) throw std::invalid_argument(msg);
}

std::string buildFromStringRepresentation(const std::string& s) {
    return s;
}

std::string format(const char* fmt, const std::string& val) {
    char buf[512];
    snprintf(buf, sizeof(buf), fmt, val.c_str());
    return std::string(buf);
}

class ThrowProcessor : public Processor {
private:
    using ExceptionFactory = std::function<std::shared_ptr<Throwable>()>;
    ExceptionFactory exception;
    std::string error;
    std::atomic<int> count{0};
    std::shared_ptr<MuleContext> muleContext;

public:
    Event process(const Event& event) override {
        if (count == -1 || count-- > 0) {
            try {
                auto instantiatedException = exception();
                if (!error.empty()) {
                    auto errorTypeRepository = muleContext->getErrorTypeRepository();
                    auto errorType = errorTypeRepository->lookupErrorType(buildFromStringRepresentation(error));
                    if (!errorType) {
                        throw DefaultMuleException(format(""Could not find",1
"case TYPE_DOUBLE: {
    double val = value.getDoubleValue();
    std::string wrapperFun;
    if (val == std::numeric_limits<double>::infinity()) {
        wrapperFun = BeamBigQuerySqlDialect::DOUBLE_POSITIVE_INF_FUNCTION;
    } else if (val == -std::numeric_limits<double>::infinity()) {
        wrapperFun = BeamBigQuerySqlDialect::DOUBLE_NEGATIVE_INF_FUNCTION;
    } else if (std::isnan(val)) {
        wrapperFun = BeamBigQuerySqlDialect::DOUBLE_NAN_FUNCTION;
    }

    RelDataType returnType =
        ZetaSqlCalciteTranslationUtils::toSimpleRelDataType(kind, rexBuilder());
    if (wrapperFun.empty()) {
        ret = rexBuilder().makeApproxLiteral(
            BigDecimal(val), returnType);
    } else if (wrapperFun == BeamBigQuerySqlDialect::DOUBLE_NAN_FUNCTION) {
        ret = rexBuilder().makeCall(
            SqlOperators::createZetaSqlFunction(wrapperFun, returnType.getSqlTypeName()),
            { rexBuilder().makeApproxLiteral(
                BigDecimal(static_cast<double>(rand()) / RAND_MAX), returnType) }
        );
    } else {
        ret = rexBuilder().makeCall(
            SqlOperators::createZetaSqlFunction(wrapperFun, returnType.getSqlTypeName())
        );
    }
    break;
}","```cpp
case TYPE_DOUBLE: {
    double val = value->getDoubleValue();
    std::string wrapperFun;
    if (val == std::numeric_limits<double>::infinity()) {
        wrapperFun = BeamBigQuerySqlDialect::DOUBLE_POSITIVE_INF_FUNCTION;
    } else if (val == -std::numeric_limits<double>::infinity()) {
        wrapperFun = BeamBigQuerySqlDialect::DOUBLE_NEGATIVE_INF_FUNCTION;
    } else if (std::isnan(val)) {
        wrapperFun = BeamBigQuerySqlDialect::DOUBLE_NAN_FUNCTION;
    }

    auto returnType = ZetaSqlCalciteTranslationUtils::toSimpleRelDataType(kind, rexBuilder());
    if (wrapperFun.empty()) {
        ret = rexBuilder()->makeApproxLiteral(BigDecimal(val), returnType);
    } else if (wrapperFun == BeamBigQuerySqlDialect::DOUBLE_NAN_FUNCTION) {
        // see BEAM-10550: workaround for NaN simplification
        ret = rexBuilder()->makeCall(
            SqlOperators::createZetaSqlFunction(wrapperFun, returnType->getSqlTypeName()),
            {rexBuilder()->makeApproxLiteral(BigDecimal(static_cast<double>(std::rand())/RAND_MAX), returnType)}
        );
    } else {
        ret = rexBuilder()->makeCall(
            SqlOperators::createZetaSqlFunction(wrapperFun, returnType->getSqlTypeName())
        );
    }
    break;
}
```",1
"auto messagingError = dynamic_cast<MessagingException*>(error);
auto failureEvent = messagingError->getEvent();

auto ctx = ErrorHandlerContext::from(failureEvent);

if (ctx == nullptr) {
    ctx = new ErrorHandlerContext();
    failureEvent = quickCopy(failureEvent, of(ERROR_HANDLER_CONTEXT, ctx));
}

ctx->configure(getParameterId(failureEvent), error, failureEvent, continueCallback, propagateCallback);
routingSink.get()->next(failureEvent);","```cpp
MessagingException* messagingError = dynamic_cast<MessagingException*>(error);
CoreEvent* failureEvent = messagingError->getEvent();

ErrorHandlerContext* ctx = ErrorHandlerContext::from(failureEvent);

if (ctx == nullptr) {
    ctx = new ErrorHandlerContext();
    failureEvent = quickCopy(failureEvent, of(ERROR_HANDLER_CONTEXT, ctx));
}

ctx->configure(getParameterId(failureEvent), error, failureEvent, continueCallback, propagateCallback);
routingSink->get()->next(failureEvent);
```",0
"catch (const std::exception& e) {
    if (!files.empty()) {
        throw PartialSuccessException(
            message,
            std::string(""Partially successful recursive 'mget' operation on "") +
            (remoteDirectory != nullptr ? remoteDirectory : ""Client Working Directory""),
            e,
            files,
            fileNames
        );
    } else if (dynamic_cast<const MessagingException*>(&e)) {
        throw;
    }
}","try {
    // ...
} catch (const std::exception& e) {
    if (!files.empty()) {
        throw PartialSuccessException(
            message,
            std::string(""Partially successful recursive 'mget' operation on "") +
                (remoteDirectory ? remoteDirectory : ""Client Working Directory""),
            e, files, fileNames
        );
    } else if (dynamic_cast<const MessagingException*>(&e)) {
        throw;
    }
    // ...
}",0
"for (Task* task : this->tasks) {
    task->shutdown();
}
for (Task* task : this->tasks) {
    task->awaitShutdown(1000);
}
for (Task* task : this->tasks) {
    if (task->cancel()) {
        log.info(""Task {} cancelled."", task->getTaskId());
    } else {
        log.info(""Task {} could not be cancelled."", task->getTaskId());
    }
}

private:
void persistTaskStateStore();","for (auto& task : this->tasks) {
    task.shutdown();
}

for (auto& task : this->tasks) {
    task.awaitShutdown(1000);
}

for (auto& task : this->tasks) {
    if (task.cancel()) {
        log.info(""Task {} cancelled."", task.getTaskId());
    } else {
        log.info(""Task {} could not be cancelled."", task.getTaskId());
    }
}",1
"void dispose() override {
    std::unique_ptr<AutoCloseable> bundleFactoryCloser(stageBundleFactory);
    std::unique_ptr<AutoCloseable> closable(stageContext);
    // DoFnOperator generates another ""bundle"" for the final watermark -- see BEAM-5816 for more context
    Operator::dispose();
    stageContext = nullptr;
}","```cpp
void dispose() override {
    {
        auto bundleFactoryCloser = stageBundleFactory;
        auto closable = stageContext;
        // DoFnOperator generates another ""bundle"" for the final watermark -- see BEAM-5816 for more context
        DoFnOperator<InputT, OutputT>::dispose();
    }
    stageContext = nullptr;
}
```",1
"#include <string>
#include <memory>

namespace org {
namespace springframework {
namespace integration {
namespace http {
namespace config {

class ParserContext {};

class AbstractBeanDefinition {};

class BeanDefinitionBuilder {
public:
    static std::shared_ptr<BeanDefinitionBuilder> rootBeanDefinition(const std::string&) {
        return std::make_shared<BeanDefinitionBuilder>();
    }
    std::shared_ptr<BeanDefinitionBuilder> addConstructorArgValue(const std::string&) { return shared_from_this(); }
    std::shared_ptr<BeanDefinitionBuilder> addPropertyReference(const std::string&, const std::string&) { return shared_from_this(); }
    std::shared_ptr<BeanDefinitionBuilder> addPropertyValue(const std::string&, const std::string&) { return shared_from_this(); }
    std::shared_ptr<AbstractBeanDefinition> getBeanDefinition() { return std::make_shared<AbstractBeanDefinition>(); }
};

class RootBeanDefinition : public AbstractBeanDefinition {};

class LiteralExpression {
public:
    LiteralExpression(const std::string&) {}
};

class ExpressionFactoryBean {};

class AbstractOutboundChannelAdapterParser {
public:
    virtual std::shared_ptr<AbstractBeanDefinition> parseHandler(XmlElement& element, ParserContext& parserContext) = 0;
};

class HttpRequestExecutingMessageHandler {};

class IntegrationNamespaceUtils {
public:
    static void setValueIfAttributeDefined(
        std::shared_ptr<BeanDefinitionBuilder> builder, XmlElement& element, const std::string& attributeName) {}
    static void setReferenceIfAttributeDefined(
        std::shared_ptr<BeanDefinitionBuilder> builder, XmlElement& element, const std::string& attributeName) {}
};

class StringUtils {
public:
    static bool hasText(const std::string& s) { return !s.empty(); }
};

class XmlElement {
public:
    std::string getAttribute(const std::string& name) const { return """"; }
    bool hasAttribute(const std::string& name) const { return false; }
};

class HttpOutboundChannelAdapterParser : public AbstractOutboundChannelAdapterParser {
protected:
    std::shared_ptr<AbstractBeanDefinition> parseHandler(XmlElement& element, ParserContext& parserContext) override {
        auto builder = BeanDefinitionBuilder::rootBeanDefinition(""org.springframework.integration.http.outbound.HttpRequestExecutingMessageHandler"");
        std::string url = element.getAttribute(""url"");
        if (StringUtils::hasText(url)) {
            auto expressionDef = BeanDefinitionBuilder::rootBeanDefinition(""org.springframework.expression.common.LiteralExpression","#include <string>

class Element {};
class ParserContext {};

class AbstractBeanDefinition {};
class BeanDefinitionBuilder {
public:
    static BeanDefinitionBuilder rootBeanDefinition(const std::string&) { return BeanDefinitionBuilder(); }
    AbstractBeanDefinition* getBeanDefinition() { return nullptr; }
};

class RootBeanDefinition : public AbstractBeanDefinition {};

class LiteralExpression {
public:
    LiteralExpression(const std::string&) {}
};

class ExpressionFactoryBean {};

class AbstractOutboundChannelAdapterParser {
};

class IntegrationNamespaceUtils {
};

class HttpRequestExecutingMessageHandler {};",0
"auto messageSenderTask = [&]() {
    bool sent = false;
    try {
        sent = channel.send(message);
    } catch (const std::exception& e) {
        // handle exception if needed
    }
};","```cpp
std::function<void()> messageSenderTask = [&]() {
    bool sent = false;
    try {
        sent = channel.send(message);
```",0
"#include ""org/apache/hudi/common/util/Option.h""
#include ""org/apache/hudi/utilities/deltastreamer/SourceFormatAdapter.h""
#include ""org/apache/hudi/utilities/schema/FilebasedSchemaProvider.h""
#include ""org/apache/hudi/utilities/testutils/UtilitiesTestBase.h""
#include ""org/apache/spark/api/java/JavaRDD.h""
#include ""org/apache/spark/sql/AnalysisException.h""","#include ""org/apache/hudi/common/util/Option.h""
#include ""org/apache/hudi/utilities/deltastreamer/SourceFormatAdapter.h""
#include ""org/apache/hudi/utilities/schema/FilebasedSchemaProvider.h""
#include ""org/apache/hudi/utilities/testutils/UtilitiesTestBase.h""
#include ""org/apache/spark/api/java/JavaRDD.h""
#include ""org/apache/spark/sql/AnalysisException.h""",1
"#include <QComboBox>
#include <QProgressBar>
#include <QTabWidget>
#include <QTabBar>
#include <QChartView>
#include ""ActivityTransitionAnimation.h""
#include ""AnkiStatsTaskHandler.h""","#include <QWebView>
#include <QComboBox>
#include <QProgressBar>
#include <QTabWidget>
#include <QTabBar>
#include ""ActivityTransitionAnimation.h""
#include ""AnkiStatsTaskHandler.h""
#include ""ChartView.h""",0
"#include ""Automattic/Jetpack/Tracking.h""
#include ""Automattic/Jetpack/Plugin/Tracking.h""
#include ""Automattic/Jetpack/Redirect.h""
#include ""Automattic/Jetpack/Jetpack_User_Agent_Info.h""","#include <Automattic/Jetpack/Terms_Of_Service.hpp>
#include <Automattic/Jetpack/Tracking.hpp>
#include <Automattic/Jetpack/Plugin/Tracking.hpp>
#include <Automattic/Jetpack/Redirect.hpp>
#include <Automattic/Jetpack/Jetpack_User_Agent_Info.hpp>

/*
Options:
*/",1
"} else if (ivl == 2) {
    return std::vector<int>{2, 3};
} else if (ivl < 7) {
    fuzz = static_cast<int>(ivl * 0.25);
} else if (ivl < 30) {
    fuzz = std::max(2, static_cast<int>(ivl * 0.15));
} else {
    fuzz = std::max(4, static_cast<int>(ivl * 0.05));
}
fuzz = std::max(fuzz, 1);
return std::vector<int>{ivl - fuzz, ivl + fuzz};

int _constrainedIvl(int ivl, const nlohmann::json& conf, double prev) {
    double newIvl = ivl;","```cpp
std::vector<int> someFunction(int ivl) {
    int fuzz;
    if (ivl == 1) {
        return {1, 1};
    } else if (ivl == 2) {
        return {2, 3};
    } else if (ivl < 7) {
        fuzz = static_cast<int>(ivl * 0.25);
    } else if (ivl < 30) {
        fuzz = std::max(2, static_cast<int>(ivl * 0.15));
    } else {
        fuzz = std::max(4, static_cast<int>(ivl * 0.05));
    }
    fuzz = std::max(fuzz, 1);
    return {ivl - fuzz, ivl + fuzz};
}

int _constrainedIvl(int ivl, const nlohmann::json& conf, double prev) {
    double newIvl = ivl;
    // ... (rest of the function)
}
```",0
#include <cassert>,#include <cassert>,0
"void commit()
{
    log.debug(""Commit called, will wait for committimeout : "" +
              std::to_string(commitTimeoutInNanos / MILLIS_TO_NANOS) + ""ms"");
    auto commitStartTime = std::chrono::steady_clock::now();
    while (
        (std::chrono::duration_cast<std::chrono::nanoseconds>(
             std::chrono::steady_clock::now() - commitStartTime).count() < commitTimeoutInNanos) &&
        (recordsAttempted.getCount() != (recordsSuccess.getCount() + recordsFailed.getCount())))
    {
        // Loop body
    }
}","log.debug(""Commit called, will wait for committimeout : "" + std::to_string(commitTimeoutInNanos / MILLIS_TO_NANOS) + ""ms"");
long long commitStartTime = std::chrono::steady_clock::now().time_since_epoch().count();
while (((std::chrono::steady_clock::now().time_since_epoch().count() - commitStartTime) < commitTimeoutInNanos) &&
       (recordsAttempted.getCount() != (recordsSuccess.getCount() + recordsFailed.getCount())))
{ /* ... */ }",1
"#include <memory>
#include <chrono>
#include <atomic>

template <typename T>
class Source {
  // Source interface methods
};

template <typename T, typename CheckpointMarkT>
class UnboundedSource {
public:
  class CheckpointMark {};
};

template <typename Key, typename Value>
class Cache {
  // Cache implementation
};

template <typename T>
class Reader {
  // Reader interface methods
};

template <typename T, typename CheckpointMarkT>
class MicrobatchSource : public Source<T> {
public:
  using Duration = std::chrono::milliseconds;

private:
  static std::atomic<Cache<MicrobatchSource<T, CheckpointMarkT>, std::shared_ptr<Reader<T>>>*> readerCache;

  std::shared_ptr<UnboundedSource<T, CheckpointMarkT>> source;
  Duration maxReadTime;
};

template <typename T, typename CheckpointMarkT>
std::atomic<Cache<MicrobatchSource<T, CheckpointMarkT>, std::shared_ptr<Reader<T>>>*> MicrobatchSource<T, CheckpointMarkT>::readerCache{nullptr};","#include <memory>
#include <chrono>

template <typename T>
class Source {
public:
    virtual ~Source() = default;
};

template <typename T>
class Reader {
public:
    virtual ~Reader() = default;
};

template <typename K, typename V>
class Cache {
    // Implementation omitted
};

template <typename T>
class UnboundedSource {
public:
    class CheckpointMark {
    public:
        virtual ~CheckpointMark() = default;
    };
    virtual ~UnboundedSource() = default;
};

template <typename T, typename CheckpointMarkT>
class MicrobatchSource : public Source<T> {
public:
    using Duration = std::chrono::milliseconds;

    MicrobatchSource(std::shared_ptr<UnboundedSource<T>> source, Duration maxReadTime)
        : source_(std::move(source)), maxReadTime_(maxReadTime) {}

private:
    inline static std::shared_ptr<Cache<MicrobatchSource<T, CheckpointMarkT>, std::shared_ptr<Reader<T>>>> readerCache_;

    std::shared_ptr<UnboundedSource<T>> source_;
    Duration maxReadTime_;
};",1
"#include <hudi/keygen/SimpleAvroKeyGenerator.h>
#include <hudi/metrics/MetricsReporterType.h>
#include <hudi/metrics/datadog/DatadogHttpClient.h>
#include <hudi/table/action/compact/CompactType.h>
#include <hudi/table/action/compact/strategy/CompactionStrategy.h>

#include <hbase/io/compress/Compression.h>","#include ""hudi/index/HoodieIndex.h""
#include ""hudi/keygen/SimpleAvroKeyGenerator.h""
#include ""hudi/metrics/MetricsReporterType.h""
#include ""hudi/metrics/datadog/DatadogHttpClient.h""
#include ""hudi/table/action/compact/CompactType.h""
#include ""hudi/table/action/compact/strategy/CompactionStrategy.h""

#include ""hadoop/hbase/io/compress/Compression.h""",0
"#include <fstream>
#include <stack>
#include <string>
#include <locale>
#include <codecvt>
#include <memory>

class JavaPreprocessor {
public:
    JavaPreprocessor(std::ostream* metadataOut, const std::string& inputFile, std::ostream* out, const std::string& outputFile)
        : inFile(inputFile)
    {
        std::string osname;
#if defined(_WIN32)
        osname = ""Windows"";
#elif defined(__MVS__)
        osname = ""z/OS"";
#else
        osname = ""Other"";
#endif

        std::string charset;
        if (strcasecmp(osname.c_str(), ""z/OS"") == 0) {
            charset = ""IBM-1047"";
        } else {
            charset = ""US-ASCII"";
        }

        inStack = std::stack<std::unique_ptr<std::istream>>();
        // out expects US-ASCII or IBM-1047 encoding
        this->out = out;

        if (metadataOut != nullptr) {
            this->metadataOut = metadataOut;
            (*this->metadataOut) << inputFile;
            (*this->metadataOut) << '\n';
        }
    }
private:
    std::stack<std::unique_ptr<std::istream>> inStack;
    std::string inFile;
    std::ostream* out;
    std::ostream* metadataOut;
};","#include <fstream>
#include <stack>
#include <filesystem>
#include <memory>
#include <string>
#include <locale>

class JavaPreprocessor {
public:
    JavaPreprocessor(std::ostream* metadataOut, const std::filesystem::path& inputFile, std::ostream& out, const std::filesystem::path& outputFile)
        : inFile(inputFile)
    {
        std::string osname;
#ifdef _WIN32
        osname = ""Windows"";
#elif defined(__MVS__)
        osname = ""z/OS"";
#else
        osname = ""Unix"";
#endif

        std::string charsetName;
        if (strcasecmp(osname.c_str(), ""z/OS"") == 0) {
            charsetName = ""IBM-1047"";
        } else {
            charsetName = ""US-ASCII"";
        }

        // In C++, setting charset is more involved, but we'll mock/approximate it:
        // For US-ASCII, the default ""C"" locale suffices.
        std::locale localeToUse;
        if (charsetName == ""IBM-1047"") {
            // No direct standard locale; fallback to classic locale.
            localeToUse = std::locale::classic();
        } else {
            localeToUse = std::locale::classic();
        }

        outPtr = &out;
        // Note: Normally, ofstream/ostreams cannot have their locale fully switched in a cross-platform way,
        // especially for IBM-1047; assume ASCII is sufficient.

        if (metadataOut) {
            metadataOutPtr = metadataOut;
            *metadataOutPtr << std::filesystem::absolute(inputFile).string();
            *metadataOutPtr << '\n';
        }
    }

private:
    std::stack<std::istream*> inStack;
    std::filesystem::path inFile;
    std::ostream* outPtr;
    std::ostream* metadataOutPtr{nullptr};
};",0
"#include <string>
#include <vector>
#include <map>
#include <memory>

class MuleContext;

class MuleProperties {
public:
    static constexpr const char* SYSTEM_PROPERTY_PREFIX = ""some.prefix.""; // Adjust as needed
};

class MuleUtil {
public:
    static constexpr bool TRUE = true;

    // Other members and methods as needed
};","#include <vector>
#include <map>
#include <string>

class MuleContext;

class MuleUtil {
public:
    static constexpr const char* SYSTEM_PROPERTY_PREFIX = ""your.system.property.prefix.""; // Adjust as needed

    // Other members...
};

using std::vector;
using std::map;
using std::string;",0
"try {
    if (workerVm != nullptr) {
        // detach volume and destroy worker vm
        // [DEL] workerVm->detachAllDisks();
        workerVm->destroy();
    }
} catch (const std::exception& e) {
} catch (...) {
}","if (workerVm != nullptr) {
    // Detach all disks (removed)
    workerVm->destroy();
}",1
"throw std::logic_error(""Already disposed"");
}

sinkProvider(*this, event);
}","if (disposed) {
    throw std::logic_error(""Already disposed"");
}

sinkProvider(*this, event);",0
"#include <string>
#include <vector>
#include <set>
#include <map>
#include <memory>
#include <stdexcept>
#include <algorithm>
#include <regex>
#include <cctype>","#include <set>
#include <string>
#include <algorithm>",0
"startWorker = ComponentContext::inject(startWorker);
if (onCreate) {
    Account owner = accountService.getActiveAccountById(kubernetesCluster.getAccountId());
    std::vector<std::string> keys = getServiceUserKeys(owner);
    startWorker.setKeys(keys);
    return startWorker.startKubernetesClusterOnCreate();
} else {
    // Start for Kubernetes cluster in 'Stopped' state. Resources are already provisioned, just need to be started
}","startWorker = ComponentContext::inject(startWorker);
if (onCreate) {
    Account owner = accountService.getActiveAccountById(kubernetesCluster.getAccountId());
    std::vector<std::string> keys = getServiceUserKeys(owner);
    startWorker.setKeys(keys);
    return startWorker.startKubernetesClusterOnCreate();
} else {
    // Start for Kubernetes cluster in 'Stopped' state. Resources are already provisioned, just need to be started
}",1
"#include <map>
#include <memory>
#include <string>","#include <map>
#include <string>
#include <memory>",0
"std::set<std::string> getSupportedExtensions() {
    checkDestroyed();
    auto classes = getExtensionClasses();
    std::set<std::string> result;
    for (const auto& entry : classes) {
        result.insert(entry.first);
    }
    return result;
}

std::set<T> getSupportedExtensionInstances() {","std::set<std::string> getSupportedExtensions() {
    checkDestroyed();
    auto classes = getExtensionClasses();
    std::set<std::string> keys;
    for (const auto& pair : classes) {
        keys.insert(pair.first);
    }
    return keys;
}",0
"if (modifiers.anyBitsIn(J9FieldFlagObject)) {
    if (valueTypeHelper.isFlattenableFieldSignature(J9ROMFieldShapeHelper::getSignature(localField))) {
        J9ClassPointer fieldClass = valueTypeHelper.findJ9ClassInFlattenedClassCacheWithFieldName(instanceClass, J9ROMFieldShapeHelper::getName(localField));
        if (valueTypeHelper.isJ9FieldIsFlattened(fieldClass, localField)) {
            UDATA size = 0;
            if (valueTypeHelper.isJ9ClassLargestAlignmentConstraintDouble(fieldClass)) {
                size = fieldClass.totalInstanceSize();
            }
        }
    }
}","```cpp
if (modifiers.anyBitsIn(J9FieldFlagObject)) {
    if (valueTypeHelper.isFlattenableFieldSignature(J9ROMFieldShapeHelper::getSignature(localField))) {
        J9ClassPointer fieldClass = valueTypeHelper.findJ9ClassInFlattenedClassCacheWithFieldName(instanceClass, J9ROMFieldShapeHelper::getName(localField));
        if (valueTypeHelper.isJ9FieldIsFlattened(fieldClass, localField)) {
            UDATA size = 0;
            if (valueTypeHelper.isJ9ClassLargestAlignmentConstraintDouble(fieldClass)) {
                size = fieldClass.totalInstanceSize();
            }
        }
    }
}
```",1
"class AbstractStompSessionManager {
public:
    void onSuccess(StompSession* stompSession) override {
        this->connecting = false;
        stompSession->setAutoReceipt(isAutoReceiptEnabled());
        this->connected = true;
        this->reconnectFuture = nullptr;
    }

    void scheduleReconnect() {
        try {
            this->reconnectFuture = this->stompClient->getTaskScheduler()->scheduleWithFixedDelay(
                [this]() {
                    connect();
                },
                this->recoveryInterval
            );
        } catch (const std::exception& e) {
            logger.error(""Failed to schedule reconnect"", e);
        }
    }

    void destroy() override {
        if (this->reconnectFuture != nullptr) {
            this->reconnectFuture->cancel(false);
            this->reconnectFuture = nullptr;
        }
        this->stompSessionListenableFuture->addCallback(
            new ListenableFutureCallback<StompSession*>()
        );
    }
private:
    bool connecting = false;
    bool connected = false;
    std::shared_ptr<ReconnectFuture> reconnectFuture = nullptr;
    StompClient* stompClient;
    std::chrono::milliseconds recoveryInterval;
    std::shared_ptr<ListenableFuture<StompSession*>> stompSessionListenableFuture;
};","```cpp
class AbstractStompSessionManager : public StompSessionManager {
protected:
    std::atomic<bool> connecting{false};
    std::atomic<bool> connected{false};
    std::shared_ptr<Future> reconnectFuture;
    std::shared_ptr<StompClient> stompClient;
    std::chrono::milliseconds recoveryInterval;
    std::shared_ptr<ListenableFuture<StompSession>> stompSessionListenableFuture;
    Logger logger;

    virtual bool isAutoReceiptEnabled() = 0;
    virtual void connect() = 0;

    class ConnectCallback : public ListenableFutureCallback<StompSession> {
        AbstractStompSessionManager* parent;
    public:
        ConnectCallback(AbstractStompSessionManager* p) : parent(p) {}
        void onSuccess(std::shared_ptr<StompSession> stompSession) override {
            parent->connecting = false;
            stompSession->setAutoReceipt(parent->isAutoReceiptEnabled());
            parent->connected = true;
            parent->reconnectFuture = nullptr;
        }
        void onFailure(const std::exception& e) override {
            // handle failure
        }
    };

    void scheduleReconnect() {
        try {
            reconnectFuture = stompClient->getTaskScheduler()->scheduleWithFixedDelay(
                [this]() {
                    connect();
                },
                recoveryInterval
            );
        } catch (const std::exception& e) {
            logger.error(""Failed to schedule reconnect"", e);
        }
    }

public:
    void destroy() {
        if (reconnectFuture) {
            reconnectFuture->cancel(false);
            reconnectFuture = nullptr;
        }
        stompSessionListenableFuture->addCallback(
            std::make_shared<ConnectCallback>(this)
        );
    }
};
```",1
"int blocksize;
// 2 Read the total size of the block
blocksize = inputStream.readInt();
this->logBlockSize = blocksize;
} else {
// 1 Read the total size of the block
blocksize = static_cast<int>(inputStream.readLong());","if (condition) {
    // 2 Read the total size of the block
    int blocksize = inputStream.readInt();
    this->logBlockSize = blocksize;
} else {
    // 1 Read the total size of the block
    int blocksize = static_cast<int>(inputStream.readLong());
}",1
"return EVENT_NAME + ""{"" + ""action="" + getActionName(action) + "", transactionStringId="" + transactionStringId + "", timestamp="" + std::to_string(timestamp) + ""}"";

static EnrichedNotificationInfo emptyInfo() {
    return EnrichedNotificationInfo(nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, std::unordered_map<std::string, SomeType>{}, nullptr, nullptr);
}","static EnrichedNotificationInfo emptyInfo() {
    return EnrichedNotificationInfo(nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, std::unordered_map<std::string, std::any>(), nullptr, nullptr);
}",0
"}
 
SnapshotInfo snapshotOnPrimary = snapshotStrategy.takeSnapshot(snapshot);

bool backupFlag = BackupSnapshotAfterTakingSnapshot.value() == nullptr ||
                  BackupSnapshotAfterTakingSnapshot.value();

if (backupFlag) {
    if (payload.getAsyncBackup()) {
        backupSnapshotExecutor.schedule(
            new BackupSnapshotTask(snapshotOnPrimary, snapshotBackupRetries - 1, snapshotStrategy),
            0, TimeUnit::SECONDS
        );
    } else {
        SnapshotInfo backupedSnapshot = snapshotStrategy.backupSnapshot(snapshotOnPrimary);
        if (backupedSnapshot != nullptr) {
            snapshotStrategy.postSnapshotCreation(snapshotOnPrimary);
        }
    }
} else {
    if (s_logger.isDebugEnabled()) {
        s_logger.debug(""skipping backup of snapshot to secondary due to configuration"");
    }
    if (!snapshotOnPrimary.markBackedUp()) {
        throw CloudRuntimeException(""Can't mark snapshot as backed up!"");
    }
}","```cpp
SnapshotInfo snapshotOnPrimary = snapshotStrategy.takeSnapshot(snapshot);
bool backupFlag = BackupSnapshotAfterTakingSnapshot::value() == nullptr ||
                  BackupSnapshotAfterTakingSnapshot::value();

if (backupFlag) {
    if (payload.getAsyncBackup()) {
        backupSnapshotExecutor.schedule(
            new BackupSnapshotTask(snapshotOnPrimary, snapshotBackupRetries - 1, snapshotStrategy),
            std::chrono::seconds(0)
        );
    } else {
        std::unique_ptr<SnapshotInfo> backupedSnapshot(snapshotStrategy.backupSnapshot(snapshotOnPrimary));
        if (backupedSnapshot) {
            snapshotStrategy.postSnapshotCreation(snapshotOnPrimary);
        }
    }
} else {
    if (s_logger.isDebugEnabled()) {
        s_logger.debug(""skipping backup of snapshot to secondary due to configuration"");
    }
    if (!snapshotOnPrimary.markBackedUp()) {
        throw CloudRuntimeException(""Can't mark snapshot as backed up!"");
    }
}
```",1
"#include <string>
#include <memory>
#include <unordered_map>
#include <mutex>
#include <queue>

class ContextAwareMeter;

static std::unordered_map<std::string, std::shared_ptr<ContextAwareMeter>> groupSuccessfulMeters;
static std::unordered_map<std::string, std::shared_ptr<ContextAwareMeter>> groupFailureMeters;

class JobStatusRetriever;
class DagStateStore;
template <typename T>
class Dag;
class JobExecutionPlan;

class BlockingQueueBase {};

template <typename T>
class BlockingQueue : public BlockingQueueBase {
    // Implementation omitted
};

class MyClass {
private:
    const std::shared_ptr<JobStatusRetriever> jobStatusRetriever;
    const std::shared_ptr<DagStateStore> dagStateStore;
    const std::shared_ptr<DagStateStore> failedDagStateStore;
    const std::shared_ptr<BlockingQueue<Dag<JobExecutionPlan>>> queue;
    const std::shared_ptr<BlockingQueue<std::string>> cancelQueue;
    const std::shared_ptr<BlockingQueue<std::string>> resumeQueue;

public:
    // Constructor
    MyClass(
        std::shared_ptr<JobStatusRetriever> jobStatusRetriever,
        std::shared_ptr<DagStateStore> dagStateStore,
        std::shared_ptr<DagStateStore> failedDagStateStore,
        std::shared_ptr<BlockingQueue<Dag<JobExecutionPlan>>> queue,
        std::shared_ptr<BlockingQueue<std::string>> cancelQueue,
        std::shared_ptr<BlockingQueue<std::string>> resumeQueue)
        : jobStatusRetriever(jobStatusRetriever),
          dagStateStore(dagStateStore),
          failedDagStateStore(failedDagStateStore),
          queue(queue),
          cancelQueue(cancelQueue),
          resumeQueue(resumeQueue)
    {}
};","```cpp
#include <map>
#include <memory>
#include <queue>
#include <string>
#include <mutex>

static std::map<std::string, std::shared_ptr<ContextAwareMeter>> groupSuccessfulMeters;
static std::map<std::string, std::shared_ptr<ContextAwareMeter>> groupFailureMeters;

class DagManager : public AbstractIdleService {
private:
    const std::shared_ptr<JobStatusRetriever> jobStatusRetriever;
    const std::shared_ptr<DagStateStore> dagStateStore;
    const std::shared_ptr<DagStateStore> failedDagStateStore;
    const std::shared_ptr<std::queue<std::shared_ptr<Dag<JobExecutionPlan>>>> queue;
    const std::shared_ptr<std::queue<std::string>> cancelQueue;
    const std::shared_ptr<std::queue<std::string>> resumeQueue;

public:
    // Constructor and other methods...
};
```",1
"#include <memory>
#include <vector>

class Logger {
public:
    static Logger getLogger(const char* name);
    // Logging methods...
};

class EventIndexer {
private:
    static Logger LOG;

    std::shared_ptr<StreamService> streamService;
    std::shared_ptr<Messages> messages;

public:
    EventIndexer(std::shared_ptr<StreamService> streamService, std::shared_ptr<Messages> messages)
        : streamService(streamService), messages(messages) {}

    void write(const std::vector<EventWithContext>& eventsWithContext);
};

Logger EventIndexer::LOG = Logger::getLogger(""EventIndexer"");","#include <memory>
#include <vector>

class Logger {
public:
    static Logger& getLogger(const char* /*name*/) {
        static Logger instance;
        return instance;
    }
};

class StreamService {};
class Messages {};
class EventWithContext {};

class EventIndexer {
private:
    static Logger& LOG;
    std::shared_ptr<StreamService> streamService;
    std::shared_ptr<Messages> messages;

public:
    EventIndexer(std::shared_ptr<StreamService> streamService, std::shared_ptr<Messages> messages)
        : streamService(std::move(streamService)), messages(std::move(messages)) {}

    void write(const std::vector<EventWithContext>& eventsWithContext) {
        // Implementation here
    }
};

Logger& EventIndexer::LOG = Logger::getLogger(""EventIndexer"");",0
"#ifdef ENABLE_PROFILE_INFO
bool FunctionBody::DoInterpreterProfileWithLock() const
{
    // Switch off profiling is asmJsFunction
    if (this->GetIsAsmJsFunction() || this->GetAsmJsModuleInfoWithLock())
    {
        return false;
    }
    else
    {
        return !PHASE_OFF(InterpreterProfilePhase, this) && DynamicProfileInfo::IsEnabled(this);
    }
}
#else
bool FunctionBody::DoInterpreterProfileWithLock() const
{
    return false;
}
#endif","```cpp
bool FunctionBody::DoInterpreterProfileWithLock() const
{
#if ENABLE_PROFILE_INFO
    // Switch off profiling if asmJsFunction
    if (this->GetIsAsmJsFunction() || this->GetAsmJsModuleInfoWithLock())
    {
        return false;
    }
    else
    {
        return !PHASE_OFF(InterpreterProfilePhase, this) && DynamicProfileInfo::IsEnabled(this);
    }
#else
    return false;
#endif
}
```",1
"#include <cstddef>
#include <memory>
#include <spdlog/spdlog.h>","#include <exception>
#include <memory>",0
"if (dw.isTestBin(marker.getResource()))
    continue;
std::cout << ""error marker "" << marker << std::endl;
return true;","if (dw.isTestBin(marker.getResource()))
    continue;

std::cout << ""error marker "" << marker << std::endl;
return true;",1
"#include <vector>
#include <string>
#include <stdexcept>","#include <vector>
#include <string>
#include <stdexcept>
#include <typeinfo>
#include <iostream>",0
"if (isJettyMode()) {
    out << ""<link rel=\""stylesheet\"" type=\""text/css\"" href=\""/static/css/carte.css\"" />"" << std::endl;
} else {
    out << StatusServletUtils::getPentahoStyles(root);
    out << ""<style>"" << std::endl;
    out << "".pentaho-table td, tr.cellTableRow, td.gwt-MenuItem, .toolbar-button:not(.toolbar-button-disabled) {"" << std::endl;
    out << ""  cursor: pointer;"" << std::endl;
}","if (isJettyMode()) {
    out << ""<link rel=\""stylesheet\"" type=\""text/css\"" href=\""/static/css/carte.css\"" />"" << std::endl;
} else {
    out << StatusServletUtils::getPentahoStyles(root);
    out << ""<style>"" << std::endl;
    out << "".pentaho-table td, tr.cellTableRow, td.gwt-MenuItem, .toolbar-button:not(.toolbar-button-disabled) {"" << std::endl;
    out << ""  cursor: pointer;"" << std::endl;
}",0
"#include <memory>
#include <functional>
#include <map>
#include <string>

class NativePreviewHandler {};
class Timer {};
class Window {};
class IsWidget {};
class Widget {};
class ProviderBase {};
class SingletonBase {};
class AppCommand {};
class Handler {};
class KeyCombination {};
class KeyboardShortcut {};

#define INJECT 
#define SINGLETON 

using namespace std;","#include ""Event/NativePreviewEvent.h""
#include ""Event/NativePreviewHandler.h""
#include ""Timer.h""
#include ""Window.h""
#include ""ui/IsWidget.h""
#include ""ui/Widget.h""
#include ""inject/Inject.h""
#include ""inject/Provider.h""
#include ""inject/Singleton.h""

#include ""core/client/Core.h""
#include ""core/client/command/AppCommand.h""
#include ""core/client/command/CommandBinder.h""
#include ""core/client/command/Handler.h""
#include ""core/client/command/KeyCombination.h""
#include ""core/client/command/KeyboardShortcut.h""",0
"auto log = std::make_shared<NiceMock<MockLogger>>(*log_ptr);
accessor.setPropertyValue(""messageLogger"", log);
ON_CALL(*log, isInfoEnabled()).WillByDefault(Return(true));
loggingHandler.handleMessage(GenericMessage<std::string>(""foo""));
EXPECT_CALL(*log, info(::testing::_)).Times(1);
EXPECT_CALL(*log, warn(::testing::_)).Times(0);

loggingHandler.setLevel(Level::WARN);
loggingHandler.handleMessage(GenericMessage<std::string>(""foo""));
EXPECT_CALL(*log, info(::testing::_)).Times(1);
EXPECT_CALL(*log, warn(::testing::_)).Times(1);","log = std::make_shared<MockLog>(*log);
accessor.setPropertyValue(""messageLogger"", log);
EXPECT_CALL(*log, isInfoEnabled()).WillRepeatedly(::testing::Return(true));
loggingHandler.handleMessage(GenericMessage<>(""foo""));
EXPECT_CALL(*log, info(::testing::_)).Times(1);
EXPECT_CALL(*log, warn(::testing::_)).Times(0);

loggingHandler.setLevel(Level::WARN);
loggingHandler.handleMessage(GenericMessage<>(""foo""));
EXPECT_CALL(*log, info(::testing::_)).Times(1);
EXPECT_CALL(*log, warn(::testing::_)).Times(1);",0
"ValueResolver* doParseDate(const std::any& value, const std::type_info& type) {
    if (value.type() == typeid(std::string)) {","```cpp
private:
  bool isParameterResolver(const std::set<ModelProperty>& modelProperties, const MetadataType& expectedType) {
    return IntrospectionUtils::isParameterResolver(modelProperties) || IntrospectionUtils::isParameterResolver(expectedType);
  }

  bool isTypedValue(const std::set<ModelProperty>& modelProperties, const MetadataType& expectedType) {
    return IntrospectionUtils::isTypedValue(modelProperties) || IntrospectionUtils::isTypedValue(expectedType);
  }

  bool isLiteral(const std::set<ModelProperty>& modelProperties, const MetadataType& expectedType) {
    return IntrospectionUtils::isLiteral(modelProperties) || IntrospectionUtils::isLiteral(expectedType);
  }
```",0
"```cpp
}

@PUT
@Path(""tables/{idOrName}"")
@AuditEvent(type = AuditEventTypes::LOOKUP_TABLE_UPDATE)
@ApiOperation(value = ""Update the given lookup table"")
public:
LookupTableApi updateTable(
    @ApiParam(name = ""idOrName"") @PathParam(""idOrName"") const std::string& idOrName,
    @Valid @ApiParam const LookupTableApi& toUpdate)
{
    checkLookupTableId(idOrName, toUpdate);
    checkPermission(RestPermissions::LOOKUP_TABLES_EDIT, toUpdate.id());
    LookupTableDto saved = dbTableService.save(toUpdate.toDto());
    clusterBus.post(LookupTablesUpdated::create(saved));
}
```","```cpp
LookupTableApi updateTable(const std::string& idOrName, const LookupTableApi& toUpdate) {
    checkLookupTableId(idOrName, toUpdate);
    checkPermission(RestPermissions::LOOKUP_TABLES_EDIT, toUpdate.id());
    LookupTableDto saved = dbTableService.save(toUpdate.toDto());
    clusterBus.post(LookupTablesUpdated::create(saved));
    return toUpdate;
}
```",0
"#include ""springframework/beans/BeanUtils.h""
#include ""springframework/beans/BeansException.h""
#include ""springframework/beans/PropertyValues.h""
#include ""springframework/beans/factory/*.h""
#include ""springframework/beans/factory/annotation/InjectionMetadata.h""
#include ""springframework/beans/factory/config/BeanPostProcessor.h""
#include ""springframework/beans/factory/config/ConfigurableListableBeanFactory.h""","#include <memory>
#include <stdexcept>
#include <typeinfo>",0
"PreferenceSettings = settings;
PreferenceSettings.PropertyChanged += PreferenceSettings_PropertyChanged;

bool areAnalyticsDisabled = false;
try
{
    // Dynamo, behind a proxy server, has been known to have issues loading the Analytics binaries.
    // Using the ""DisableAnalytics"" configuration setting, a user can skip loading analytics binaries altogether.
    auto exePath = std::filesystem::canonical(std::filesystem::path(typeid(*this).name())).string();
    auto assemblyConfig = OpenExeConfiguration(exePath);

    if (assemblyConfig)
    {
        auto disableAnalyticsValue = assemblyConfig->getAppSetting(""DisableAnalytics"");
        if (!disableAnalyticsValue.empty())
        {
            std::istringstream(disableAnalyticsValue) >> std::boolalpha >> areAnalyticsDisabled;
        }
    }
}
catch (...)
{
}

if (areAnalyticsDisabled)
{
    // If user skipped analytics from assembly configuration, do not try to launch the client at all
    // Skip call to instrumentation logger initialization.
}
else
{
    InitializeInstrumentationLogger();
}","PreferenceSettings = settings;
PreferenceSettings.PropertyChanged += PreferenceSettings_PropertyChanged;

bool areAnalyticsDisabled = false;
try
{
    // Load app settings from config file
    std::ifstream configFile(GetAssemblyConfigPath());
    if (configFile)
    {
        std::string line;
        while (std::getline(configFile, line))
        {
            // Simple parse for key-value pairs: ""DisableAnalytics = true""
            std::istringstream iss(line);
            std::string key, eq, value;
            if (iss >> key >> eq >> value)
            {
                if (key == ""DisableAnalytics"" && (value == ""true"" || value == ""1""))
                {
                    areAnalyticsDisabled = true;
                    break;
                }
            }
        }
    }
}
catch (...)
{
    // ignore any exception
}

if (areAnalyticsDisabled)
{
    // Skip call to instrumentation logger initialization.
}
else
{
    InitializeInstrumentationLogger();
}",1
"{
    if (VirtualMode)
    {
        ComCtl32::NMLVFINDITEMW* nmlvif = reinterpret_cast<ComCtl32::NMLVFINDITEMW*>(m.LParam);

        if ((nmlvif->lvfi.flags & ComCtl32::LVFI::PARAM) != 0)
        {
            m.Result = reinterpret_cast<LPARAM>(-1);
            return;
        }

        bool isTextSearch = ((nmlvif->lvfi.flags & ComCtl32::LVFI::STRING) != 0) ||
                            ((nmlvif->lvfi.flags & ComCtl32::LVFI::PARTIAL) != 0);

        bool isPrefixSearch = (nmlvif->lvfi.flags & ComCtl32::LVFI::PARTIAL) != 0;

        std::wstring text;
        if (isTextSearch && nmlvif->lvfi.psz != nullptr)
        {
            text = std::wstring(nmlvif->lvfi.psz);
        }

        POINT startingPoint = {0,0};
        if ((nmlvif->lvfi.flags & ComCtl32::LVFI::NEARESTXY) != 0)
        {
            startingPoint = nmlvif->lvfi.pt;
        }

        SearchDirectionHint dir = SearchDirectionHint::Down;
        if ((nmlvif->lvfi.flags & ComCtl32::LVFI::NEARESTXY) != 0)
        {
            dir = static_cast<SearchDirectionHint>(nmlvif->lvfi.vkDirection);
        }

        int startIndex = nmlvif->iStart;
        if (startIndex >= VirtualListSize)
        {
            startIndex = 0;
        }

        SearchForVirtualItemEventArgs sviEvent(
            isTextSearch,
            isPrefixSearch,
            false, // includeSubItemsInSearch
            text,
            startingPoint,
            dir,
            nmlvif->iStart
        );

        OnSearchForVirtualItem(sviEvent);
        if (sviEvent.Index != -1)
        {
            // ...
        }
    }
}","```cpp
if (VirtualMode) {
    auto* nmlvif = reinterpret_cast<ComCtl32::NMLVFINDITEMW*>(m.LParam);

    if ((nmlvif->lvfi.flags & ComCtl32::LVFI::PARAM) != 0) {
        m.Result = reinterpret_cast<LPARAM>(-1);
        return;
    }

    bool isTextSearch = ((nmlvif->lvfi.flags & ComCtl32::LVFI::STRING) != 0) ||
                        ((nmlvif->lvfi.flags & ComCtl32::LVFI::PARTIAL) != 0);

    bool isPrefixSearch = (nmlvif->lvfi.flags & ComCtl32::LVFI::PARTIAL) != 0;

    std::wstring text;
    if (isTextSearch && nmlvif->lvfi.psz != nullptr) {
        text = nmlvif->lvfi.psz;
    }

    POINT startingPoint = {0, 0};
    if ((nmlvif->lvfi.flags & ComCtl32::LVFI::NEARESTXY) != 0) {
        startingPoint = nmlvif->lvfi.pt;
    }

    SearchDirectionHint dir = SearchDirectionHint::Down;
    if ((nmlvif->lvfi.flags & ComCtl32::LVFI::NEARESTXY) != 0) {
        dir = static_cast<SearchDirectionHint>(nmlvif->lvfi.vkDirection);
    }

    int startIndex = nmlvif->iStart;
    if (startIndex >= VirtualListSize) {
        startIndex = 0;
    }

    SearchForVirtualItemEventArgs sviEvent(
        isTextSearch,
        isPrefixSearch,
        false, // includeSubItemsInSearch
        text,
        startingPoint,
        dir,
        nmlvif->iStart
    );

    OnSearchForVirtualItem(sviEvent);
    if (sviEvent.Index != -1) {
        // ...
    }
}
```",1
"return -1;
}

void addModelToCursor(long long modelId, const Models& models, MatrixCursor& rv, const std::vector<std::string>& columns) {
    const nlohmann::json& jsonObject = models.get(modelId);
    auto rb = rv.newRow();
    try {","```cpp
void addModelToCursor(long long modelId, const Models& models, MatrixCursor& rv, const std::vector<std::string>& columns) {
    const json& jsonObject = models.get(modelId);
    auto rb = rv.newRow();
    try {
```",0
"/ *
 *
 *   Removing a JobMetrics instance for a job will also remove the TaskMetrics
 *   of every tasks of the job. This is only used by job driver where there is no ForkMetrics.
 *
 * @param jobState the given JobState instance
 */","```cpp
/**
 *
 * 
 *   Removing a JobMetrics instance for a job will also remove the TaskMetrics
 *   of every tasks of the job. This is only used by job driver where there is no ForkMetrics.
 * 
 * @param jobState the given JobState instance
 */
```",0
"}

static GenericRecord generateGenericRecord(const std::string& rowKey, const std::string& riderName, const std::string& driverName, double timestamp) {
    return generateGenericRecord(rowKey, riderName, driverName, timestamp, false);
}

static GenericRecord generateGenericRecord(const std::string& rowKey, const std::string& riderName, const std::string& driverName, double timestamp, bool isDeleteRecord) {
    GenericRecord rec(avroSchema);
    rec.put(""_row_key"", rowKey);
    rec.put(""timestamp"", timestamp);","```cpp
static GenericRecord generateGenericRecord(const std::string& rowKey, const std::string& riderName, const std::string& driverName, double timestamp) {
    return generateGenericRecord(rowKey, riderName, driverName, timestamp, false);
}

static GenericRecord generateGenericRecord(const std::string& rowKey, const std::string& riderName, const std::string& driverName, double timestamp, bool isDeleteRecord) {
    GenericRecord rec(avroSchema);
    rec.put(""_row_key"", rowKey);
    rec.put(""timestamp"", timestamp);
    // ... (rest of code goes here)
    return rec;
}
```",0
"addExtraConfig(vm, caller, extraConfig);

if (cmd.getCopyImageTagsToVm()) {
    auto templateObj = _templateDao.findById(templateId);
    auto templateType = (templateObj->getFormat() == ImageFormat::ISO) ? ResourceTag::ResourceObjectType::ISO : ResourceTag::ResourceObjectType::Template;
    auto resourceTags = resourceTagDao.listBy(templateId, templateType);
    for (const auto& resourceTag : resourceTags) {
        ResourceTagVO copyTag(
            resourceTag.getKey(),
            resourceTag.getValue(),
            resourceTag.getAccountId(),
            resourceTag.getDomainId(),
            vm.getId(),
            ResourceTag::ResourceObjectType::UserVm,
            resourceTag.getCustomer(),
            vm.getUuid()
        );
        resourceTagDao.persist(copyTag);
    }
}

return vm;","```cpp
if (cmd.getCopyImageTagsToVm()) {
    ResourceTag::ResourceObjectType templateType = (_templateDao.findById(templateId)->getFormat() == ImageFormat::ISO)
        ? ResourceTag::ResourceObjectType::ISO
        : ResourceTag::ResourceObjectType::Template;
    auto resourceTags = resourceTagDao.listBy(templateId, templateType);
    for (const auto& resourceTag : resourceTags) {
        ResourceTagVO copyTag(resourceTag.getKey(), resourceTag.getValue(), resourceTag.getAccountId(),
                              resourceTag.getDomainId(), vm->getId(), ResourceTag::ResourceObjectType::UserVm,
                              resourceTag.getCustomer(), vm->getUuid());
        resourceTagDao.persist(copyTag);
    }
}
```",1
"sb,
RES.cellTableStyle().lineActions(),
selectionModel_.getSelectedSet().size() > 1
    ? constants_.selectionSuffix("""")
    : constants_.lineSuffix(""""));","sb,
RES.cellTableStyle().lineActions(),
selectionModel_->getSelectedSet().size() > 1
    ? constants_->selectionSuffix("""")
    : constants_->lineSuffix("""") );",1
"}
if (assertPass) {
    for (auto& instrumentationModule : ServiceLoader::load<InstrumentationModule>(agentClassLoader)) {
        try {
            std::vector<std::string> helperClassNames = instrumentationModule->helperClassNames();
            if (!helperClassNames.empty()) {
                HelperInjector(
                    MuzzleGradlePluginUtil::className(),","for (auto& instrumentationModule : ServiceLoader<InstrumentationModule>::load(agentClassLoader)) {
    try {
        auto helperClassNames = instrumentationModule.helperClassNames();
        if (!helperClassNames.empty()) {
            HelperInjector(
                typeid(MuzzleGradlePluginUtil).name(),
                // ... additional arguments here as needed
            );
        }
    } catch (...) {
        // handle exception as appropriate
    }
}",0
"[[deprecated]]
void setUsePayloadAsParameterSource(bool usePayloadAsParameterSource) {
    this->executor.setUsePayloadAsParameterSource(usePayloadAsParameterSource);
}","[[deprecated]]
void setUsePayloadAsParameterSource(bool usePayloadAsParameterSource) {
    executor.setUsePayloadAsParameterSource(usePayloadAsParameterSource);
}",0
"return false;
    }
    auto rstr = rightString->GetString();
    auto lstr = leftString->GetString();

    if (lstr == rstr)
    {
        return true;
    }

    if (wmemcmp(lstr, rstr, leftString->GetLength()) == 0)
    {
        T::ShareStringBuffer(leftString, rightString);
        return true;
    }
    return false;
}

void JavascriptString::ShareStringBuffer(JavascriptString* leftString, JavascriptString* rightString)
{
    auto rstr = rightString->GetString();
    auto lstr = leftString->GetString();

    Assert(leftString->GetLength() == rightString->GetLength());
    Assert(wmemcmp(lstr, rstr, leftString->GetLength()) == 0);

    if (leftString->IsSubstring() || rightString->IsSubstring())
    {
        return;
    }

    bool leftIsPropertyString = VirtualTableInfo<Js::PropertyString>::HasVirtualTable(leftString);

    if (leftIsPropertyString)
    {
        bool rightIsLiteralStringWithPropertyStringPtr = VirtualTableInfo<Js::LiteralStringWithPropertyStringPtr>::HasVirtualTable(rightString);
        auto leftPropertyString = static_cast<Js::PropertyString*>(leftString);
        if (rightIsLiteralStringWithPropertyStringPtr)
        {
            auto rightStringWithPtr = static_cast<Js::LiteralStringWithPropertyStringPtr*>(rightString);
            rightStringWithPtr->SetPropertyString(leftPropertyString);
        }
        else if (leftPropertyString->GetPropertyRecord()->GetBuffer() == lstr)
        {
            leftString->SetBuffer(rstr);
        }
        else
        {
            rightString->SetBuffer(lstr);
        }
        return;
    }

    bool leftIsLiteralStringWithPropertyStringPtr = VirtualTableInfo<Js::LiteralStringWithPropertyStringPtr>::HasVirtualTable(leftString);

    if (leftIsLiteralStringWithPropertyStringPtr)
    {
        bool rightIsLiteralStringWithPropertyStringPtr = VirtualTableInfo<Js::LiteralStringWithPropertyStringPtr>::HasVirtualTable(rightString);
        auto leftStringWithPtr = static_cast<Js::LiteralStringWithPropertyStringPtr*>(leftString);

        if (rightIsLiteralStringWithPropertyStringPtr)
        {
            auto rightStringWithPtr = static_cast<Js::LiteralStringWithPropertyStringPtr*>(rightString);

            if (leftStringWith","switch (case_num)
{
case 2:
    return false;
}

{
    const wchar_t* rstr = rightString->GetString();
    const wchar_t* lstr = leftString->GetString();

    if (lstr == rstr)
    {
        return true;
    }

    if (wmemcmp(lstr, rstr, leftString->GetLength()) == 0)
    {
        T::ShareStringBuffer(leftString, rightString);
        return true;
    }
    return false;
}

void JavascriptString::ShareStringBuffer(JavascriptString* leftString, JavascriptString* rightString)
{
    const wchar_t* rstr = rightString->GetString();
    const wchar_t* lstr = leftString->GetString();

    assert(leftString->GetLength() == rightString->GetLength());
    assert(wmemcmp(lstr, rstr, leftString->GetLength()) == 0);

    if (leftString->IsSubstring() || rightString->IsSubstring())
    {
        return;
    }

    bool leftIsPropertyString = VirtualTableInfo<Js::PropertyString>::HasVirtualTable(leftString);

    if (leftIsPropertyString)
    {
        bool rightIsLiteralStringWithPropertyStringPtr = VirtualTableInfo<Js::LiteralStringWithPropertyStringPtr>::HasVirtualTable(rightString);
        PropertyString* leftPropertyString = static_cast<Js::PropertyString*>(leftString);
        if (rightIsLiteralStringWithPropertyStringPtr)
        {
            Js::LiteralStringWithPropertyStringPtr* rightStringWithPtr = static_cast<Js::LiteralStringWithPropertyStringPtr*>(rightString);
            rightStringWithPtr->SetPropertyString(leftPropertyString);
        }
        else if (leftPropertyString->GetPropertyRecord()->GetBuffer() == lstr)
        {
            leftString->SetBuffer(rstr);
        }
        else
        {
            rightString->SetBuffer(lstr);
        }
        return;
    }

    bool leftIsLiteralStringWithPropertyStringPtr = VirtualTableInfo<Js::LiteralStringWithPropertyStringPtr>::HasVirtualTable(leftString);

    if (leftIsLiteralStringWithPropertyStringPtr)
    {
        bool rightIsLiteralStringWithPropertyStringPtr = VirtualTableInfo<Js::LiteralStringWithPropertyStringPtr>::HasVirtualTable(rightString);
        Js::LiteralStringWithPropertyStringPtr* leftStringWithPtr = static_cast<Js::LiteralStringWithPropertyStringPtr*>(leftString);",1
"#include <avro/Specific.hh>
#include <avro/Generic.hh>","#include <avro/Specific.hh>
#include <avro/Generic.hh>",0
"void setTimer(
    const StateNamespace& namespace_,
    const std::string& timerId,
    const Instant& timestamp,
    const Instant& OutputTimestamp,
    TimeDomain timeDomain) 
{
    timers.put(
        timerId,
        namespace_,
        TimerData::of(timerId, namespace_, timestamp, OutputTimestamp, timeDomain)
    );
    timerStillPresent.put(timerId, namespace_, true);
}","void setTimer(
    const StateNamespace& namespace_,
    const std::string& timerId,
    const Instant& timestamp,
    const Instant& outputTimestamp,
    TimeDomain timeDomain) 
{
    timers.put(
        timerId,
        namespace_,
        TimerData::of(timerId, namespace_, timestamp, outputTimestamp, timeDomain)
    );
    timerStillPresent.put(timerId, namespace_, true);
}",1
"#include <string>
#include <memory>
#include <functional>
#include <atomic>
#include ""ApplicationContext.h""
#include ""DirectChannel.h""
#include ""Message.h""
#include ""MessageHandler.h""
#include ""Foo.h""
#include ""TestUtils.h""

void testWithServiceSuperclassAnnotatedMethodOverridePE() {
    std::unique_ptr<ConfigurableApplicationContext> ac =
        std::make_unique<ClassPathXmlApplicationContext>(""GatewayInterfaceTests2-context.xml"", typeid(*this));
    DirectChannel* channel = ac->getBean<DirectChannel>(""requestChannelFoo"");
    auto fooMethod = Foo::getMethod(""foo"", {""std::string""});
    std::atomic<bool> called(false);
    MessageHandler handler = [&](const Message& message) {
        assertThat(std::any_cast<std::string>(message.getHeaders().get(""name"")), equalTo(""foo""));
        assertThat(
            std::any_cast<std::string>(message.getHeaders().get(""string"")),
            equalTo(""public abstract void org.springframework.integration.gateway.GatewayInterfaceTests$Foo.foo(java.lang.String)"")
        );
        assertThat(
            std::any_cast<Method>(message.getHeaders().get(""object"")),
            equalTo(fooMethod)
        );
        assertThat(std::any_cast<std::string>(message.getPayload()), equalTo(""foo""));
        called.store(true);
    };
    channel->subscribe(handler);
}","#include <memory>
#include <string>
#include <atomic>
#include <functional>
#include ""ApplicationContext.h""
#include ""DirectChannel.h""
#include ""MessageHandler.h""
#include ""Foo.h""
#include ""assertThat.h""
#include ""equalTo.h""

void testWithServiceSuperclassAnnotatedMethodOverridePE() {
    auto ac = std::make_shared<ClassPathXmlApplicationContext>(
        ""GatewayInterfaceTests2-context.xml"", typeid(*this)
    );
    auto channel = ac->getBean<DirectChannel>(""requestChannelFoo"");
    const auto fooMethod = &Foo::foo;
    std::atomic_bool called{false};
    MessageHandler handler = [&](const Message& message) {
        assertThat(message.getHeaders().get(""name""), equalTo(""foo""));
        assertThat(message.getHeaders().get(""string""),
                   equalTo(""public abstract void org.springframework.integration.gateway.GatewayInterfaceTests$Foo.foo(java.lang.String)""));
        assertThat(message.getHeaders().get(""object""), equalTo(fooMethod));
        assertThat(message.getPayload(), equalTo(""foo""));
        called.store(true);
    };
    channel->subscribe(handler);
}",1
"#include <connectivity/ConnectivityTestingStrategy.h>
#include <context/notification/MuleContextListener.h>
#include <util/UUID.h>
#include <deployment/model/api/artifact/ArtifactContext.h>
#include <deployment/model/api/plugin/ArtifactPlugin.h>
#include <deployment/model/api/plugin/ArtifactPluginDescriptor.h>
#include <dsl/api/config/ArtifactConfiguration.h>
#include <module/artifact/classloader/MuleDeployableArtifactClassLoader.h>
#include <module/deployment/internal/artifact/ArtifactContextBuilder.h>
#include <module/deployment/internal/artifact/TemporaryArtifact.h>
#include <module/deployment/internal/artifact/TemporaryArtifactBuilder.h>","#include <string>
#include <memory>
#include <vector>
#include <set>
#include <map>
#include <utility>
#include ""ConnectivityTestingService.h""
#include ""ConnectivityTestingStrategy.h""
#include ""MuleContextListener.h""
#include ""UUID.h""
#include ""ArtifactContext.h""
#include ""ArtifactPlugin.h""
#include ""ArtifactPluginDescriptor.h""
#include ""ArtifactConfiguration.h""
#include ""MuleDeployableArtifactClassLoader.h""
#include ""ArtifactContextBuilder.h""
#include ""TemporaryArtifact.h""
#include ""TemporaryArtifactBuilder.h""",0
"auto dubboShutdownHook = getDubboShutdownHook();
std::atexit(dubboShutdownHook);
dispatch(DubboShutdownHookRegisteredEvent(dubboShutdownHook));
ShutdownHookCallbacks::INSTANCE.addCallback([this]() {
    AbstractRegistryFactory::destroyAll();
    this->destroyProtocols();
});","```cpp
void DubboShutdownHook::registerHook() {
    DubboShutdownHook* dubboShutdownHook = getDubboShutdownHook();
    std::atexit([dubboShutdownHook]() {
        dispatch(DubboShutdownHookRegisteredEvent(dubboShutdownHook));
    });
    ShutdownHookCallbacks::INSTANCE.addCallback([this]() {
        AbstractRegistryFactory::destroyAll();
        this->destroyProtocols();
    });
}
```",1
"void scrollHandler_(
    const std::unordered_map<int, bool>& boundsV,
    const std::unordered_map<int, bool>& boundsH,
    bool ignoreResize,
    const std::function<void(AnalyticsEvent&)>& listener,
    const Event& e)
{
    this->triggerScrollEvents_(
        boundsV,
        ((e.top + e.height) * 100.0) /
            (ignoreResize ? e.initialScrollHeight : e.scrollHeight),
        VAR_V_SCROLL_BOUNDARY,
        listener
    );
    this->triggerScrollEvents_(
        boundsH,
        ((e.left + e.width) * 100.0) /
            (ignoreResize ? e.initialScrollWidth : e.scrollWidth),
        VAR_H_SCROLL_BOUNDARY,
        listener
    );
}","void scrollHandler_(
    const std::unordered_map<int, bool>& boundsV,
    const std::unordered_map<int, bool>& boundsH,
    bool ignoreResize,
    const std::function<void(const AnalyticsEvent&)>& listener,
    const Event& e) 
{
    double vPercent = ((e.top + e.height) * 100.0) /
        (ignoreResize ? e.initialScrollHeight : e.scrollHeight);
    this->triggerScrollEvents_(
        boundsV,
        vPercent,
        VAR_V_SCROLL_BOUNDARY,
        listener
    );

    double hPercent = ((e.left + e.width) * 100.0) /
        (ignoreResize ? e.initialScrollWidth : e.scrollWidth);
    this->triggerScrollEvents_(
        boundsH,
        hPercent,
        VAR_H_SCROLL_BOUNDARY,
        listener
    );
}",1
"deploymentService.setDomainFactory(testDomainFactory);
deploymentService.start();

assertDeploymentSuccess(domainDeploymentListener, EMPTY_DOMAIN);
assertTrue(""Unable to remove anchor file"", removeDomainAnchorFile(EMPTY_DOMAIN));
assertUndeploymentSuccess(domainDeploymentListener, EMPTY_DOMAIN);
assertAppFolderIsDeleted(EMPTY_DOMAIN);

}

TEST(DeploymentServiceTest, undeploysDomainCompletelyEvenOnDisposingException)
{
    addPackedDomainFromResource(EMPTY_DOMAIN_ZIP_PATH);

    TestDomainFactory testDomainFactory(new MuleDomainClassLoaderRepository());
    testDomainFactory.setFailOnDisposeApplication();
    deploymentService.setDomainFactory(testDomainFactory);
    deploymentService.start();

    assertDeploymentSuccess(domainDeploymentListener, EMPTY_DOMAIN);
    assertTrue(""Unable to remove anchor file"", removeDomainAnchorFile(EMPTY_DOMAIN));
    assertUndeploymentSuccess(domainDeploymentListener, EMPTY_DOMAIN);
    assertAppFolderIsDeleted(EMPTY_DOMAIN);
}

TEST(DeploymentServiceTest, deploysIncompleteZipDomainOnStartup)
{
    addPackedDomainFromResource(INCOMPLETE_DOMAIN_ZIP_PATH);

    deploymentService.start();

    assertDeploymentFailure(domainDeploymentListener, INCOMPLETE_DOMAIN);

    addPackedDomainFromResource(DeploymentServiceTestCase::DUMMY_DOMAIN_ZIP_PATH);

    assertDeploymentSuccess(domainDeploymentListener, DUMMY_DOMAIN);

    assertDomainFolderIsMaintained(INCOMPLETE_DOMAIN);
    auto zombie = *deploymentService.getZombieDomains().begin();
    ASSERT_EQ(""Wrong URL tagged as zombie."", INCOMPLETE_DOMAIN, 
              std::filesystem::path(zombie.first->getFile()).parent_path().filename().string());
}","deploymentService.setDomainFactory(testDomainFactory);
deploymentService.start();

assertDeploymentSuccess(domainDeploymentListener, EMPTY_DOMAIN);

assertTrue(""Unable to remove anchor file"", removeDomainAnchorFile(EMPTY_DOMAIN));

assertUndeploymentSuccess(domainDeploymentListener, EMPTY_DOMAIN);

assertAppFolderIsDeleted(EMPTY_DOMAIN);

TEST_F(DeploymentServiceTestCase, undeploysDomainCompletelyEvenOnDisposingException)
{
    addPackedDomainFromResource(EMPTY_DOMAIN_ZIP_PATH);

    TestDomainFactory testDomainFactory(new MuleDomainClassLoaderRepository());
    testDomainFactory.setFailOnDisposeApplication();
    deploymentService.setDomainFactory(testDomainFactory);
    deploymentService.start();

    assertDeploymentSuccess(domainDeploymentListener, EMPTY_DOMAIN);

    assertTrue(""Unable to remove anchor file"", removeDomainAnchorFile(EMPTY_DOMAIN));

    assertUndeploymentSuccess(domainDeploymentListener, EMPTY_DOMAIN);

    assertAppFolderIsDeleted(EMPTY_DOMAIN);
}

TEST_F(DeploymentServiceTestCase, deploysIncompleteZipDomainOnStartup)
{
    addPackedDomainFromResource(INCOMPLETE_DOMAIN_ZIP_PATH);

    deploymentService.start();

    assertDeploymentFailure(domainDeploymentListener, INCOMPLETE_DOMAIN);

    // Deploys another app to confirm that DeploymentService has execute the updater thread
    addPackedDomainFromResource(DeploymentServiceTestCase::DUMMY_DOMAIN_ZIP_PATH);

    assertDeploymentSuccess(domainDeploymentListener, DUMMY_DOMAIN);

    // Check that the failed application folder is still there
    assertDomainFolderIsMaintained(INCOMPLETE_DOMAIN);
    auto zombie = *deploymentService.getZombieDomains().begin();
    ASSERT_EQ(""Wrong URL tagged as zombie."", INCOMPLETE_DOMAIN, std::filesystem::path(zombie.first->getFile()).parent_path().filename().string());
}",0
"void testCloseStream(
    std::unique_ptr<AbstractServerConnectionFactory> scf,
    std::function<std::unique_ptr<AbstractClientConnectionFactory>(int)> ccf
) {
    scf->setSingleUse(true);
    scf->setDeserializer(std::make_unique<ByteArrayRawSerializer>());
    auto gateway = std::make_unique<TcpInboundGateway>();
    gateway->setConnectionFactory(scf.get());
    auto bf = mock<ConfigurableBeanFactory>();
    gateway->setBeanFactory(bf);
    gateway->start();
    TestingUtilities::waitListening(*scf, 20000L);
    int port = scf->getPort();
    auto channel = std::make_shared<DirectChannel>();
    gateway->setRequestChannel(channel);
    auto bridge = std::make_unique<BridgeHandler>();
    bridge->setBeanFactory(bf);
    bridge->afterPropertiesSet();
    auto consumer = std::make_unique<ConsumerEndpointFactoryBean>();
    consumer->setInputChannel(channel);
    consumer->setBeanFactory(bf);
    consumer->setHandler(bridge.get());
    consumer->afterPropertiesSet();
    consumer->start();
    auto client = ccf(port);
    std::condition_variable cv;
    std::mutex mtx;
    bool latch = false;
    client->registerListener([&](const auto&) {
        std::lock_guard<std::mutex> lock(mtx);
        latch = true;
        cv.notify_one();
        return false;
    });
    client->afterPropertiesSet();
    client->start();
    auto connection = client->getConnection();
    connection->send(GenericMessage<std::string>(""foo""));
    connection->shutdownOutput();
    {
        std::unique_lock<std::mutex> lock(mtx);
        if (!cv.wait_for(lock, std::chrono::seconds(10), [&](){ return latch; })) {
            assert(false);
        }
    }
    gateway->stop();
    client->stop();
}

void readFully(std::istream& is, std::vector<char>& buff) {
    for (size_t i = 0; i < buff.size(); ++i) {
        is.read(&buff[i], 1);
    }
}","#include <thread>
#include <chrono>
#include <functional>
#include <atomic>
#include <future>
#include <condition_variable>
#include <mutex>
#include <cstring>
#include <cassert>
#include <memory>

class AbstractServerConnectionFactory {
public:
    virtual ~AbstractServerConnectionFactory() = default;
    virtual void setSingleUse(bool) = 0;
    virtual void setDeserializer(std::shared_ptr<class ByteArrayRawSerializer>) = 0;
    virtual void start() = 0;
    virtual int getPort() const = 0;
    virtual void stop() = 0;
};

class AbstractClientConnectionFactory {
public:
    virtual ~AbstractClientConnectionFactory() = default;
    virtual void registerListener(std::function<bool(const std::string&)>) = 0;
    virtual void afterPropertiesSet() = 0;
    virtual void start() = 0;
    virtual void stop() = 0;
    virtual class TcpConnectionSupport* getConnection() = 0;
};

class TcpConnectionSupport {
public:
    virtual ~TcpConnectionSupport() = default;
    virtual void send(const std::string&) = 0;
    virtual void shutdownOutput() = 0;
};

class TcpNetServerConnectionFactory : public AbstractServerConnectionFactory {
public:
    TcpNetServerConnectionFactory(int port);
    // implement all abstract methods...
};

class TcpNetClientConnectionFactory : public AbstractClientConnectionFactory {
public:
    TcpNetClientConnectionFactory(const std::string&, int port);
    // implement all abstract methods...
};

class TcpNioServerConnectionFactory : public AbstractServerConnectionFactory {
public:
    TcpNioServerConnectionFactory(int port);
    // implement all abstract methods...
};

class TcpNioClientConnectionFactory : public AbstractClientConnectionFactory {
public:
    TcpNioClientConnectionFactory(const std::string&, int port);
    // implement all abstract methods...
};

class ByteArrayRawSerializer {};

class TcpInboundGateway {
public:
    void setConnectionFactory(std::shared_ptr<AbstractServerConnectionFactory>);
    void setBeanFactory(void*); // placeholder
    void setRequestChannel(std::shared_ptr<class DirectChannel>);
    void start();
    void stop();
};

class DirectChannel {};

class BridgeHandler {
public:
    void setBeanFactory(void*);
    void afterPropertiesSet();
};

class ConsumerEndpointFactoryBean {
public:
    void setInputChannel(std::shared_ptr<DirectChannel>);
    void setBeanFactory(void*);
    void setHandler(std::shared_ptr<BridgeHandler>);
    void",1
"return WSC_CATEGORY;
}

protected:
SoapClient getConnection(MetadataContext& context) {
    auto conn = context.getConnection<SoapClient>();
    if (!conn) {
        throw MetadataResolvingException(""Could not obtain connection to retrieve metadata"", CONNECTION_FAILURE);
    }
    return *conn;
}","protected:
    SoapClient* getConnection(MetadataContext& context) {
        auto connection = context.getConnection<SoapClient>();
        if (!connection) {
            throw MetadataResolvingException(""Could not obtain connection to retrieve metadata"", CONNECTION_FAILURE);
        }
        return connection;
    }",1
"auto beamSQLRowType = CalciteUtils::toBeamRowType(this->getRowType());
for (const auto& tuple : tuples) {
    std::vector<std::any> fieldsValue;
    for (size_t i = 0; i < tuple.size(); ++i) {
        fieldsValue.push_back(
            BeamTableUtils::autoCastField(
                beamSQLRowType.getFieldsType()[i], tuple[i].getValue()
            )
        );
    }
    rows.push_back(BeamRecord(beamSQLRowType, fieldsValue));
}
return inputPCollections.getPipeline().apply(stageName, Create::of(rows));","```cpp
BeamSqlRecordType beamSQLRowType = CalciteUtils::toBeamRowType(this->getRowType());
for (const auto& tuple : tuples) {
    std::vector<Object> fieldsValue;
    for (size_t i = 0; i < tuple.size(); ++i) {
        fieldsValue.push_back(
            BeamTableUtils::autoCastField(
                beamSQLRowType.getFieldsType()[i], tuple[i].getValue()
            )
        );
    }
    rows.push_back(BeamRecord(beamSQLRowType, fieldsValue));
}

return inputPCollections.getPipeline().apply(stageName, Create::of(rows));
```",1
"paneInfo = paneInfo;
shard = shard;
numShards = numShards;

auto tempDirectory = getWriteOperation().tempDirectory.get();
outputFile = tempDirectory.resolve(id, StandardResolveOptions::RESOLVE_FILE);
verifyNotNull(
    outputFile, ""FileSystems are not allowed to return null from resolve: %s"", tempDirectory);

const auto& factory = getWriteOperation().getSink().writableByteChannelFactory;
std::string channelMimeType = firstNonNull(factory.getMimeType(), mimeType);

LOG.debug(""Opening {} for write with MIME type {}."", outputFile, channelMimeType);
auto tempChannel = FileSystems::create(outputFile, channelMimeType);
try {
    channel = factory.create(tempChannel);
} catch (const std::exception& e) {
    closeChannelAndThrow(tempChannel, outputFile, e);
}

LOG.debug(""Preparing write to {}."", outputFile);
try {
    prepareWrite(channel);
} catch (const std::exception& e) {
    LOG.error(""Preparing write to {} failed, closing channel."", outputFile, e);
    closeChannelAndThrow(channel, outputFile, e);
}

LOG.debug(""Writing header to {}."", outputFile);
try {
    writeHeader();
} catch (const std::exception& e) {
    LOG.error(""Writing header to {} failed, closing channel."", outputFile, e);
    closeChannelAndThrow(channel, outputFile, e);
}

LOG.debug(""Starting write of bundle {} to {}."", id, outputFile);

void cleanup() {
    if (outputFile) {
        FileSystems::deleteFiles(
            {outputFile}, StandardMoveOptions::IGNORE_MISSING_FILES
        );
    }
}

FileResult close() {
    checkState(outputFile, ""FileResult.close cannot be called with a null outputFile"");

    LOG.debug(""Writing footer to {}."", outputFile);
    try {
        writeFooter();
    } catch (const std::exception& e) {
        LOG.error(""Writing footer to {} failed, closing channel."", outputFile, e);
        closeChannelAndThrow(channel, outputFile, e);
    }

    LOG.debug(""Finishing write to {}."", outputFile);
    try {
        finishWrite();
    } catch (const std::exception& e) {
        closeChannelAndThrow(channel, outputFile, e);
        LOG.error(""Finishing write to {} failed, closing channel."", outputFile, e);
    }

    checkState(
        channel.isOpen(),","```cpp
class FileBasedSink {
public:
    class Writer {
    public:
        Writer(WriteOperation* writeOperation, const std::string& id,
               const ::google::protobuf::Message* window,
               const PaneInfo& paneInfo, int shard, int numShards, const std::string& mimeType)
            : writeOperation_(writeOperation),
              id_(id),
              window_(window),
              paneInfo_(paneInfo),
              shard_(shard),
              numShards_(numShards),
              mimeType_(mimeType),
              outputFile_(),
              channel_(nullptr)
        {
            auto tempDirectory = writeOperation_->getTempDirectory();
            outputFile_ = tempDirectory->resolve(id, StandardResolveOptions::RESOLVE_FILE);
            verifyNotNull(outputFile_, ""FileSystems are not allowed to return null from resolve: %s"", tempDirectory);

            auto* factory = writeOperation_->getSink()->writableByteChannelFactory;
            std::string channelMimeType = firstNonNull(factory->getMimeType(), mimeType_);

            LOG_DEBUG(""Opening {} for write with MIME type {}."", outputFile_->toString(), channelMimeType);

            std::unique_ptr<WritableByteChannel> tempChannel(FileSystems::create(*outputFile_, channelMimeType));
            try {
                channel_ = factory->create(std::move(tempChannel));
            } catch (const std::exception& e) {
                closeChannelAndThrow(tempChannel.get(), *outputFile_, e);
            }

            LOG_DEBUG(""Preparing write to {}."", outputFile_->toString());
            try {
                prepareWrite(channel_.get());
            } catch (const std::exception& e) {
                LOG_ERROR(""Preparing write to {} failed, closing channel. {}"", outputFile_->toString(), e.what());
                closeChannelAndThrow(channel_.get(), *outputFile_, e);
            }

            LOG_DEBUG(""Writing header to {}."", outputFile_->toString());
            try {
                writeHeader();
            } catch (const std::exception& e) {
                LOG_ERROR(""Writing header to {} failed, closing channel. {}"", outputFile_->toString(), e.what());
                closeChannelAndThrow(channel_.get(), *outputFile_, e);
            }

            LOG_DEBUG(""Starting write of bundle {} to {}."", id_, outputFile_->toString());
        }

        void cleanup() {
            if (outputFile_) {
                FileSystems::deleteFiles({ *outputFile_ }, { StandardMove",1
"return config.withValue(GEARPUMP_SERIALIZERS, ConfigValueFactory::fromMap(serializers));
}

template<typename K, typename V>
class StreamingViewAsMap : public PTransform<PCollection<KV<K, V>>, PCollectionView<std::map<K, V>>> {
public:
    StreamingViewAsMap(View::AsMap<K, V> /*transform*/) {}
    PCollectionView<std::map<K, V>> expand(PCollection<KV<K, V>> input) override {
        auto view = PCollectionViews::mapView(
            input.getPipeline(),
            input.getWindowingStrategy(),
            input.getCoder());
        auto inputCoder = dynamic_cast<KvCoder<K, V>*>(input.getCoder());
        try {
            inputCoder->getKeyCoder()->verifyDeterministic();
        } catch (const Coder::NonDeterministicException&) {
            // ignore
        }
        return input
            .apply(Combine::globally(new Concatenate<KV<K, V>>())->withoutDefaults())
            .apply(CreateGearpumpPCollectionView<KV<K, V>, std::map<K, V>>::of(view));
    }
protected:
    std::string getKindString() const override {
        return ""StreamingViewAsMap"";
    }
};

template<typename K, typename V>
class StreamingViewAsMultimap : public PTransform<PCollection<KV<K, V>>, PCollectionView<std::map<K, std::vector<V>>>> {
public:
    StreamingViewAsMultimap(View::AsMultimap<K, V> /*transform*/) {}
    PCollectionView<std::map<K, std::vector<V>>> expand(PCollection<KV<K, V>> input) override {
        auto view = PCollectionViews::multimapView(
            input.getPipeline(),
            input.getWindowingStrategy(),
            input.getCoder());
        auto inputCoder = dynamic_cast<KvCoder<K, V>*>(input.getCoder());
        try {
            inputCoder->getKeyCoder()->verifyDeterministic();
        } catch (const Coder::NonDeterministicException&) {
            // ignore
        }
        return input
            .apply(Combine::globally(new Concatenate<KV<K, V>>())->withoutDefaults())
            .apply(CreateGearpumpPCollectionView<KV<K, V>, std::map<K, std::vector<V>>>::of(view));
    }
protected:
    std::string getKindString() const override {
        return ""StreamingViewAsMultimap"";
    }
};","#include <vector>
#include <list>
#include <map>
#include <memory>
#include <stdexcept>
#include <iterator>

template<typename T>
using Iterable = std::vector<T>;

template<typename K, typename V>
using Map = std::map<K, V>;

template<typename T>
using List = std::vector<T>;

template<typename T>
using SingletonList = std::vector<T>;

template<typename K, typename V>
using KV = std::pair<K, V>;

// Forward declarations
template<typename T> class PCollection;
template<typename T> class PCollectionView;
template<typename InT, typename OutT> class PTransform;
template<typename T> class Coder;
template<typename T> class CoderRegistry;
template<typename T> class DoFn;
template<typename T, typename ViewT> class CreateGearpumpPCollectionView;
template<typename T> class CombineFn;
template<typename InT, typename OutT> class CombineGlobally;
template<typename InT, typename OutT> class CombineGloballyAsSingletonView;

// Dummy struct for pipeline
struct Pipeline {};
struct WindowingStrategy {};

template<typename T>
class PCollection {
public:
    Pipeline* getPipeline() { return nullptr; }
    WindowingStrategy* getWindowingStrategy() { return nullptr; }
    std::shared_ptr<Coder<T>> getCoder() { return nullptr; }
    template <typename TransformT>
    auto apply(TransformT&& transform) -> decltype(transform.expand(*this)) {
        return transform.expand(*this);
    }
};

template<typename T>
class PCollectionView {};

class PCollectionViews {
public:
    template<typename K, typename V>
    static std::shared_ptr<PCollectionView<Map<K, V>>> mapView(
        Pipeline*,
        WindowingStrategy*,
        std::shared_ptr<Coder<KV<K, V>>>) {
        return std::make_shared<PCollectionView<Map<K, V>>>();
    }
    template<typename K, typename V>
    static std::shared_ptr<PCollectionView<Map<K, Iterable<V>>>> multimapView(
        Pipeline*,
        WindowingStrategy*,
        std::shared_ptr<Coder<KV<K, V>>>) {
        return std::make_shared<PCollectionView<Map<K, Iterable<V>>>>();
    }
    template<typename T>
    static std::shared_ptr<PCollectionView<Iterable<T>>> iterableView(
        Pipeline*, WindowingStrategy*, std::shared_ptr<Coder<T>>) {
        return std::make_shared<PCollectionView<Iterable",1
"```cpp
case CONTEXT_MENU_DECK_OPTIONS:
    // set currently selected deck as clicked item
    mCurrentDid = std::stol(mDeckList[mContextMenuPosition][""did""]);
    getCol()->getDecks()->select(mCurrentDid);
    if (mFragmented) {
        loadStudyOptionsFragment(mCurrentDid, nullptr);
    }
    // open deck options
    if (getCol()->getDecks()->isDyn(mCurrentDid)) {
        // open cram options if filtered deck
        Intent i(this, CramDeckOptions);
        i.putExtra(""cramInitialConfig"", static_cast<const char*>(nullptr));
    }
    break;
```","```cpp
switch (contextMenuId) {
    case CONTEXT_MENU_DECK_OPTIONS:
        // set currently selected deck as clicked item
        mCurrentDid = std::stoll(mDeckList[mContextMenuPosition][""did""]);
        getCol()->getDecks()->select(mCurrentDid);
        if (mFragmented) {
            loadStudyOptionsFragment(mCurrentDid, nullptr);
        }
        // open deck options
        if (getCol()->getDecks()->isDyn(mCurrentDid)) {
            // open cram options if filtered deck
            Intent i(this, CramDeckOptions);
            i.putExtra(""cramInitialConfig"", static_cast<std::string*>(nullptr));
```",0
"if (closed) {
    throw std::ios_base::failure(""Channel is closed"");
}
int read = 0;
// O length read must be supported
if (dst.has_array()) {
    read = inputStream.read(dst.array().data() + dst.position() + dst.array_offset(), dst.remaining());
}
if (read > 0) {
    dst.position(dst.position() + read);
}
return read;","if (closed) {
    throw std::ios_base::failure(""Channel is closed"");
}
int read = 0;
// Assuming dst is a std::vector<char> or similar and inputStream is std::istream.
if (dst.data()) {
    std::streamsize pos = dst_position; // dst_position tracks ""position"" like ByteBuffer.
    std::streamsize remaining = dst.size() - pos;
    read = static_cast<int>(inputStream.readsome(dst.data() + pos, remaining));
}
if (read > 0) {
    dst_position += read;
}
return read;",1
"#include ""org/apache/hudi/common/model/HoodieRecord.h""
#include ""org/apache/hudi/common/model/HoodieRecordLocation.h""
#include ""org/apache/hudi/common/model/HoodieTableType.h""
#include ""org/apache/hudi/common/table/HoodieTableConfig.h""
#include ""org/apache/hudi/common/table/HoodieTableMetaClient.h""
#include ""org/apache/hudi/common/table/timeline/HoodieTimeline.h""
#include ""org/apache/hudi/common/table/view/HoodieTableFileSystemView.h""","#include ""hudi/common/fs/FSUtils.h""
#include ""hudi/common/model/HoodieRecord.h""
#include ""hudi/common/model/HoodieRecordLocation.h""
#include ""hudi/common/model/HoodieTableType.h""
#include ""hudi/common/table/HoodieTableConfig.h""
#include ""hudi/common/table/HoodieTableMetaClient.h""
#include ""hudi/common/table/timeline/HoodieTimeline.h""
#include ""hudi/common/table/view/HoodieTableFileSystemView.h""",0
"void onInit() override {
    BaseClass::onInit();
    bool resultFactorySpecified = !this->getResultFactoryName().empty() || !this->getResultType().empty();
    if (resultFactorySpecified) {
        alwaysUseResultFactory = true;
    }
    this->evaluationContext = ExpressionUtils::createStandardEvaluationContext(this->getBeanFactory());
    if (this->templates == nullptr) {
        TransformerFactory* transformerFactory;","void onInit() override {
    AbstractTransformer::onInit();
    bool resultFactorySpecified = !this->getResultFactoryName().empty() || !this->getResultType().empty();
    if (resultFactorySpecified) {
        alwaysUseResultFactory = true;
    }
    this->evaluationContext = ExpressionUtils::createStandardEvaluationContext(this->getBeanFactory());
    if (this->templates == nullptr) {
        TransformerFactory* transformerFactory;
        // ...
    }
}",1
"private std::atomic<GroovyObjectCustomizer*> customizer;

private VariableResolver* variableResolver;

public:
    void setSendTimeout(long long sendTimeout) {
        this->sendTimeout = sendTimeout;
    }","class GroovyControlBusFactoryBean : public AbstractSimpleMessageHandlerFactoryBean {
private:
    std::atomic<GroovyObjectCustomizer*> customizer{nullptr};
    VariableResolver* variableResolver{nullptr};
    std::optional<long long> sendTimeout;

public:
    void setSendTimeout(std::optional<long long> sendTimeout) {
        this->sendTimeout = sendTimeout;
    }
};",0
"#include <set>
#include <vector>
#include <map>","#include <set>
#include <list>
#include <map>
#include ""JavaKeyword.h""
#include ""AbstractTypedTree.h""
#include ""VariableTreeImpl.h""",0
"std::string group = qs[GROUP_KEY];
if (!group.empty()) {
    std::vector<std::string> parts = COMMA_SPLIT_PATTERN.split(group);
    if (parts.size() > 1 || group == ""*"") {
        return doRefer(Cluster::getCluster(""mergeable""), registry, type, url);
    }
}
Cluster* cluster = Cluster::getCluster(qs[CLUSTER_KEY]);
return doRefer(cluster, registry, type, url);

template <typename T>
Invoker<T> doRefer(Cluster* cluster, Registry* registry, std::type_index type, const URL& url);","```cpp
Invoker<T>* refer(Registry* registry, const std::type_info& type, const URL& url) {
    std::string group = qs[GROUP_KEY];
    if (!group.empty()) {
        if (split(group, ',').size() > 1 || group == ""*"") {
            return doRefer(Cluster::getCluster(""mergeable""), registry, type, url);
        }
    }
    Cluster* cluster = Cluster::getCluster(qs[CLUSTER_KEY]);
    return doRefer(cluster, registry, type, url);
}

template <typename T>
Invoker<T>* doRefer(Cluster* cluster, Registry* registry, const std::type_info& type, const URL& url) {
    // implementation
}
```",1
"#include <netty/channel/ChannelHandlerContext.h>
#include <netty/channel/ChannelOutboundHandlerAdapter.h>
#include <netty/channel/ChannelPromise.h>
#include <netty/handler/codec/http/HttpRequest.h>
#include ""AttributeKeys.h""
#include <opentelemetry/context/Scope.h>
#include <opentelemetry/trace/Span.h>
#include ""NettyHttpClientTracer.h""

using namespace io::netty::channel;
using namespace io::netty::handler::codec::http;
using namespace opentelemetry::context;
using namespace opentelemetry::trace;

class NettyHttpClientHandler : public ChannelOutboundHandlerAdapter {
public:
    void write(ChannelHandlerContext* ctx, void* msg, ChannelPromise* promise) override {
        HttpRequest* httpRequest = dynamic_cast<HttpRequest*>(msg);
        if (httpRequest != nullptr) {
            auto span = NettyHttpClientTracer::TRACER.startSpan(""HTTP "" + httpRequest->method().name());
            Scope scope(span);
            ctx->attr(AttributeKeys::CLIENT_SPAN).set(span);
            ctx->write(msg, promise);
            return;
        }
        ctx->write(msg, promise);
    }
};","#include <netty/channel/ChannelHandlerContext.h>
#include <netty/channel/ChannelOutboundHandlerAdapter.h>
#include <netty/channel/ChannelPromise.h>
#include <netty/handler/codec/http/HttpRequest.h>
#include <opentelemetry/auto/instrumentation/netty/v4_0/AttributeKeys.h>
#include <opentelemetry/context/Scope.h>
#include <opentelemetry/trace/Span.h>
#include <opentelemetry/auto/instrumentation/netty/v4_0/client/NettyHttpClientTracer.h>",0
"return fields;
}

long updateCardCurrentDid(Card* card) {
    if (card == nullptr) {
        return -1;
    }
    mLastDid = card->getDid();
    card->setDid(mCurrentDid);
    return mCurrentDid;
}","long updateCardCurrentDid(Card* card) {
    if (card == nullptr) {
        return -1;
    }
    mLastDid = card->getDid();
    card->setDid(mCurrentDid);
    return mCurrentDid;
}",0
"HoodieMergeHandle(HoodieWriteConfig* config,
                  const std::string& commitTime,
                  HoodieTable<T>* hoodieTable,
                  const std::map<std::string, HoodieRecord<T>>& keyToNewRecords,
                  const std::string& fileId,
                  HoodieBaseFile* dataFileToBeMerged)
    : HoodieBaseHandle(config, commitTime, fileId, hoodieTable),
      keyToNewRecords(keyToNewRecords),
      useWriterSchema(true)
{
    auto firstKey = keyToNewRecords.begin()->first;
    this->partitionPath = keyToNewRecords.at(firstKey).getPartitionPath();
    init(fileId, this->partitionPath, dataFileToBeMerged);
}

static Schema createHoodieWriteSchema(const Schema& originalSchema);","template <typename T>
class HoodieMergeHandle : public HoodieWriteHandle<T> {
public:
    HoodieMergeHandle(
        const HoodieWriteConfig& config,
        const std::string& commitTime,
        HoodieTable<T>* hoodieTable,
        const std::map<std::string, HoodieRecord<T>>& keyToNewRecords,
        const std::string& fileId,
        const HoodieBaseFile& dataFileToBeMerged)
        : HoodieWriteHandle<T>(config, commitTime, fileId, hoodieTable),
          keyToNewRecords(keyToNewRecords),
          useWriterSchema(true)
    {
        auto firstKey = keyToNewRecords.begin()->first;
        partitionPath = keyToNewRecords.at(firstKey).getPartitionPath();
        init(fileId, partitionPath, dataFileToBeMerged);
    }

    static Schema createHoodieWriteSchema(const Schema& originalSchema);

private:
    std::string partitionPath;
    std::map<std::string, HoodieRecord<T>> keyToNewRecords;
    bool useWriterSchema;
};",0
"#include <optional>
#include <ctime>
#include <chrono>
#include <iostream>
#include <fstream>
#include <memory>","#include <optional>
#include <chrono>
#include <ctime>
#include <iostream>
#include <fstream>",0
"try {
    sourceInput.processRawMessage(rawMessage);
    channel.basicAck(deliveryTag, false);
} catch (const std::exception& e) {
    LOG.error(""Error while trying to process AMQP message"", e);
    if (channel.isOpen()) {
        channel.basicNack(deliveryTag, false, requeueInvalid);

        if (LOG.isDebugEnabled()) {
            if (requeueInvalid) {
                LOG.debug(""Re-queue message with delivery tag {}"", deliveryTag);
            } else {
                LOG.debug(""Message with delivery tag {} not re-queued"", deliveryTag);
            }
        }
    }
}","```cpp
try {
    sourceInput.processRawMessage(rawMessage);
    channel.basicAck(deliveryTag, false);
} catch (const std::exception& e) {
    LOG.error(""Error while trying to process AMQP message: {}"", e.what());
    if (channel.isOpen()) {
        channel.basicNack(deliveryTag, false, requeueInvalid);

        if (LOG.isDebugEnabled()) {
            if (requeueInvalid) {
                LOG.debug(""Re-queue message with delivery tag {}"", deliveryTag);
            } else {
                LOG.debug(""Message with delivery tag {} not re-queued"", deliveryTag);
            }
        }
    }
}
```",1
"#include <string>
#include <unordered_map>
#include <stdexcept>
#include <functional>

using namespace std;

inline string format(const string& fmt, const string& arg) {
    size_t pos = fmt.find(""%s"");
    if (pos == string::npos) return fmt;
    return fmt.substr(0, pos) + arg + fmt.substr(pos + 2);
}

class MuleRuntimeException : public runtime_error {
public:
    explicit MuleRuntimeException(const string& msg) : runtime_error(msg) {}
};

class NamedObject {
public:
    virtual string getName() const = 0;
};

class ParameterGroupModel {
    // Implementation details as needed
};

namespace MuleExtensionUtils {
    inline bool isExpression(const string& value) {
        // Provide proper implementation
        return false;
    }
}

namespace ParameterExtractor {
    inline string extractValue(const string& rawValue) {
        // Provide proper implementation
        return rawValue;
    }
}","#include <stdexcept>
#include <string>
#include <map>
#include <functional>

using std::string;
using std::runtime_error;
using std::map;
using std::function;

struct NamedObject {};
struct ParameterGroupModel {};

inline string format(const char* fmt, const string& arg) {
    size_t size = snprintf(nullptr, 0, fmt, arg.c_str()) + 1;
    std::unique_ptr<char[]> buf(new char[size]);
    snprintf(buf.get(), size, fmt, arg.c_str());
    return string(buf.get(), buf.get() + size - 1);
}

inline runtime_error createStaticMessage(const string& msg) {
    return runtime_error(msg);
}

inline bool isExpression(const string& str) {
    // Implement according to MuleExtensionUtils.isExpression
    return false;
}

inline string extractValue(const string& param) {
    // Implement according to ParameterExtractor.extractValue
    return param;
}",0
"#include <string>

class FileCreateUtils {
private:
    static inline const std::string WRITE_TOKEN = ""1-0-1"";
    static inline const std::string BASE_FILE_EXTENSION = HoodieTableConfig::BASE_FILE_FORMAT.defaultValue().getFileExtension();
};","#include <string>

class FileCreateUtils {
private:
    static inline const std::string WRITE_TOKEN = ""1-0-1"";
    static inline const std::string BASE_FILE_EXTENSION = "".parquet"";
};",1
"virtual bool getUsesProvidedSparkContext() const = 0;
virtual void setUsesProvidedSparkContext(bool value) = 0;

virtual std::vector<std::string> getFilesToStage() const = 0;
virtual void setFilesToStage(const std::vector<std::string>& value) = 0;

struct EmptyPathList {
    std::vector<std::string> create() const {
        return std::vector<std::string>();
    }
};","class SparkPipelineOptions {
public:
    virtual bool getUsesProvidedSparkContext() const = 0;
    virtual void setUsesProvidedSparkContext(bool value) = 0;

    // List of local files to make available to workers.
    virtual std::vector<std::string> getFilesToStage() const = 0;
    virtual void setFilesToStage(const std::vector<std::string>& value) = 0;

    // Returns an empty path list, to avoid handling null.
    struct EmptyPathList {
        std::vector<std::string> create(/*PipelineOptions options*/) const {
            return std::vector<std::string>();
        }
    };

    virtual ~SparkPipelineOptions() = default;
};",1
"success = false;
}
if (success) {
    _resourceTagDao.removeByIdAndType(ipId, ResourceTag::ResourceObjectType::PublicIpAddress);
}
return success;
}","```cpp
bool success = false;

if (someCondition) {
    success = true;
} else {
    success = false;
}

if (success) {
    _resourceTagDao.removeByIdAndType(ipId, ResourceTag::ResourceObjectType::PublicIpAddress);
}
return success;
```",1
"template <typename R>
DataStream<R> flatMap(const FlatMapFunction<T, R>& flatMapFunction) {
    return DataStream<R>(*this, FlatMapOperator<T, R>(flatMapFunction));
}

DataStream<T> filter(const FilterFunction<T>& filterFunction) {
    return DataStream<T>(*this, FilterOperator<T>(filterFunction));
}","template<typename T>
class DataStream : public Stream<T> {
public:
    template<typename R>
    DataStream<R> flatMap(const FlatMapFunction<T, R>& flatMapFunction) {
        return DataStream<R>(this, FlatMapOperator<T, R>(flatMapFunction));
    }

    DataStream<T> filter(const FilterFunction<T>& filterFunction) {
        return DataStream<T>(this, FilterOperator<T>(filterFunction));
    }
};",0
"```cpp
    }
    dataMan.forceIndexChanges();
    result.totalMetadata++;
} catch (const std::exception& t) {
    errors.push_back(HarvestError(this->context, t));
    log.error(""Unable to process record from csw ("" + this->params.getName() + "")"");
    log.error(""   Record failed: "" + ri.uuid + "". Error is: "" + std::string(t.what()));
    log.error(t);
} catch (...) {
    errors.push_back(HarvestError(this->context, std::runtime_error(""Unknown error"")));
    log.error(""Unable to process record from csw ("" + this->params.getName() + "")"");
    log.error(""   Record failed: "" + ri.uuid + "". Error is: Unknown error"");
} finally {
    result.originalMetadata++;
}
}

/**
 * Remove records no longer on the remote CSW server
 *
 * @param records
 * @throws Exception
 */
HarvestResult cleanupRemovedRecords(const std::set<std::string>& records) {
    if (cancelMonitor.get()) {
        return result;
    }

    for (const auto& uuid : localUuids.getUUIDs()) {
        if (records.find(uuid) == records.end()) {
            std::string id = localUuids.getID(uuid);
            log.debug(""  - Removing old metadata with local id:"" + id);
            metadataManager.deleteMetadata(context, id);
            result.locallyRemoved++;
        }
    }
    dataMan.forceIndexChanges();

    return result;
}

void addMetadata(const RecordInfo& ri, int ownerId, int groupId, const std::string& uuid) {
    // ...
}
```","```cpp
for (auto& ri : records) {

    try {
        dataMan.forceIndexChanges();
        result.totalMetadata++;
    } catch (const std::exception& t) {
        errors.emplace_back(HarvestError(context, t));
        log.error(""Unable to process record from csw ("" + params.getName() + "")"");
        log.error(""   Record failed: "" + ri.uuid + "". Error is: "" + std::string(t.what()));
        log.error(t);
    } catch (...) {
        errors.emplace_back(HarvestError(context, std::current_exception()));
        log.error(""Unable to process record from csw ("" + params.getName() + "")"");
        log.error(""   Record failed: "" + ri.uuid + "". Error is: unknown exception"");
    } finally {
        result.originalMetadata++;
    }
}
// forceIndexChanges is already called per record above

log.debug(""End of alignment for : "" + params.getName());


// Remove records no longer on remote CSW server
HarvestResult cleanupRemovedRecords(const std::set<std::string>& records) {

    if (cancelMonitor.get()) {
        return result;
    }

    for (const auto& uuid : localUuids.getUUIDs()) {
        if (records.find(uuid) == records.end()) {
            std::string id = localUuids.getID(uuid);
            log.debug(""  - Removing old metadata with local id:"" + id);
            metadataManager.deleteMetadata(context, id);
            result.locallyRemoved++;
        }
    }
    dataMan.forceIndexChanges();

    return result;
}



void addMetadata(const RecordInfo& ri, int ownerId, int groupId, const std::string& uuid) {
    // ...
}
```",1
"return result;
}

virtual bool addNewDisk(NicProfile* nicProfile, Network* network, VirtualMachineProfile* vm, DeployDestination* dest) override {
    if (_networkModel->getUserDataUpdateProvider(network)->getProvider() == Provider::VirtualRouter &&
        vm->getVirtualMachine()->getType() == VirtualMachine::Type::User) {
        VirtualMachine* uvm = vm->getVirtualMachine();
        UserVmVO* destVm = _userVmDao->findById(uvm->getId());
        VirtualMachineProfile* profile = nullptr;

        if (destVm != nullptr) {
            destVm->setHostId(dest->getHost()->getId());
            _userVmDao->update(uvm->getId(), destVm);
            profile = new VirtualMachineProfileImpl(destVm);
            profile->setDisks(vm->getDisks());
            profile->setNics(vm->getNics());
            profile->setVmData(vm->getVmData());
        } else {
            profile = vm;
        }

        updateUserVmData(nicProfile, network, profile);
        if (destVm != nullptr) {
            destVm->setHostId(uvm->getHostId());
            _userVmDao->update(uvm->getId(), destVm);
        }
    }
    return true;
}

virtual bool saveUserData(Network* network, NicProfile* nic, VirtualMachineProfile* vm) override {
    if (!canHandle(network, nullptr)) {","bool addNewDisk(NicProfile* nicProfile, Network* network, VirtualMachineProfile* vm, DeployDestination* dest) {
    if (_networkModel->getUserDataUpdateProvider(network)->getProvider() == Provider::VirtualRouter &&
        vm->getVirtualMachine()->getType() == VirtualMachine::Type::User) {

        VirtualMachine* uvm = vm->getVirtualMachine();
        UserVmVO* destVm = _userVmDao->findById(uvm->getId());
        VirtualMachineProfile* profile = nullptr;

        if (destVm != nullptr) {
            destVm->setHostId(dest->getHost()->getId());
            _userVmDao->update(uvm->getId(), destVm);
            profile = new VirtualMachineProfileImpl(destVm);
            profile->setDisks(vm->getDisks());
            profile->setNics(vm->getNics());
            profile->setVmData(vm->getVmData());
        } else {
            profile = vm;
        }

        updateUserVmData(nicProfile, network, profile);

        if (destVm != nullptr) {
            destVm->setHostId(uvm->getHostId());
            _userVmDao->update(uvm->getId(), destVm);
        }

        if (profile != vm) {
            delete profile;
        }
    }
    return true;
}",1
"#include <windows.h>
#include <string>
#include <vector>
#include <cassert>

class MyClass {
private:
    std::wstring NativeGetItemText(int index) {
        LRESULT maxLen = SendMessageW(this->hwnd, CB_GETLBTEXTLEN, (WPARAM)index, 0);
        if (maxLen == LB_ERR) {
            return L"""";
        }

        std::vector<wchar_t> text(static_cast<size_t>(maxLen) + 1);
        LRESULT actualLen = SendMessageW(this->hwnd, CB_GETLBTEXT, (WPARAM)index, (LPARAM)text.data());
        assert(actualLen != LB_ERR);
        return std::wstring(text.data(), static_cast<size_t>(actualLen));
    }

    HWND hwnd;
};","```cpp
#include <string>
#include <vector>
#include <cassert>

int SendMessageW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); // assume declared elsewhere

std::wstring NativeGetItemText(int index)
{
    int maxLen = static_cast<int>(SendMessageW(this, CB_GETLBTEXTLEN, index, 0));
    if (maxLen == LB_ERR)
    {
        return L"""";
    }

    std::vector<wchar_t> text(maxLen + 1);
    int actualLen = static_cast<int>(SendMessageW(this, CB_GETLBTEXT, index, reinterpret_cast<LPARAM>(text.data())));
    assert(actualLen != LB_ERR); // Should have validated the index above
    return std::wstring(text.data(), actualLen);
}
```",1
"Message* pollMessageFromGroup(const Object& groupId) {
    std::string key = getKey(groupId);

    std::optional<UUID> messageId;
    jdbcTemplate.query(
        getQuery(LIST_MESSAGEIDS_BY_GROUP_KEY),
        {key, region},
        [&](ResultSet& rs) {
            if (rs.next()) {
                messageId = UUID::fromString(rs.getString(1));
            }
        }
    );

    if (messageId) {
        Message* message = this->getMessage(*messageId);
        this->removeMessageFromGroup(groupId, message);
        return message;
    }
    return nullptr;
}

std::vector<UUID> getMessageIdsForGroup(const Object& groupId) {
    std::string key = getKey(groupId);

    std::vector<UUID> messageIds;
    jdbcTemplate.query(
        getQuery(LIST_MESSAGEIDS_BY_GROUP_KEY),
        {key, region},
        [&](ResultSet& rs) {
            while (rs.next()) {
                messageIds.push_back(UUID::fromString(rs.getString(1)));
            }
        }
    );
    return messageIds;
}

std::vector<MessageGroup>::iterator iterator() {
    return messageGroups.begin();
}","```cpp
Message pollMessageFromGroup(const Object& groupId) {
    std::string key = getKey(groupId);

    std::optional<UUID> messageId = jdbcTemplate.queryOne<UUID>(
        getQuery(LIST_MESSAGEIDS_BY_GROUP_KEY),
        {key, region},
        [](auto& rs) -> std::optional<UUID> {
            if (rs.next()) {
                return UUID::fromString(rs.getString(1));
            }
            return std::nullopt;
        }
    );
    if (messageId) {
        Message message = this->getMessage(*messageId);
        this->removeMessageFromGroup(groupId, message);
        return message;
    }
    return Message(); // or appropriate null/empty Message
}

std::vector<UUID> getMessageIdsForGroup(const Object& groupId) {
    std::string key = getKey(groupId);
    std::vector<UUID> messageIds;

    jdbcTemplate.query(
        getQuery(LIST_MESSAGEIDS_BY_GROUP_KEY),
        {key, region},
        [&](auto& rs) {
            while (rs.next()) {
                messageIds.push_back(UUID::fromString(rs.getString(1)));
            }
        }
    );
    return messageIds;
}
```",1
"} else {
    try {
        interfaceClass = std::type_index(typeid(interfaceName));
    } catch (const std::exception& e) {
        throw std::logic_error(e.what());
    }
}","```cpp
#include <stdexcept>
#include <string>

std::string interfaceName = /*...*/;
try {
    // Assuming getContextClassLoader() retrieves some loader function/object to dynamically load classes.
    // In C++, you'd typically use a plugin system or manual mapping instead.
    // Here's a placeholder for dynamic class loading:
    auto interfaceClass = load_class(interfaceName, getContextClassLoader());
} catch (const std::exception& e) {
    throw std::logic_error(e.what());
}
```",0
"#include <string>

class URL {
public:
    URL setPath(const std::string& path) const;
    std::string toServiceString() const;
    // ... other methods
};

class MetadataReport {
public:
    virtual MetadataReport* getMetadataReport(const URL& url) = 0;
};

class MyMetadataReport : public MetadataReport {
public:
    MetadataReport* getMetadataReport(const URL& url) override {
        URL newUrl = url.setPath(typeid(MetadataReport).name());
        std::string key = newUrl.toServiceString();
        // Lock the registry access process to ensure a single instance of the registry
        return nullptr;
    }
};","```cpp
MetadataReport* getMetadataReport(URL url) override {
    url = url.setPath(typeid(MetadataReport).name())
             .removeParameters(Constants::EXPORT_KEY, Constants::REFER_KEY);
    std::string key = url.toServiceString();
    // Lock the registry access process to ensure a single instance of the registry
}
```",1
"verifyDirectives(Constants::REQUIRE_BUNDLE, ""visibility:|resolution:"", SYMBOLICNAME, ""bsn"");
verifyDirectives(Constants::FRAGMENT_HOST, ""extension:"", SYMBOLICNAME, ""bsn"");
verifyDirectives(Constants::PROVIDE_CAPABILITY, ""effective:|uses:"", nullptr, nullptr);
verifyDirectives(Constants::REQUIRE_CAPABILITY, ""effective:|resolution:|filter:|cardinality:"", nullptr, nullptr);
verifyDirectives(Constants::BUNDLE_SYMBOLICNAME, ""singleton:|fragment-attachment:|mandatory:"", SYMBOLICNAME, ""bsn"");

verifyManifestFirst();","verifyDirectives(Constants::REQUIRE_BUNDLE, ""visibility:|resolution:"", SYMBOLICNAME, ""bsn"");
verifyDirectives(Constants::FRAGMENT_HOST, ""extension:"", SYMBOLICNAME, ""bsn"");
verifyDirectives(Constants::PROVIDE_CAPABILITY, ""effective:|uses:"", nullptr, nullptr);
verifyDirectives(Constants::REQUIRE_CAPABILITY, ""effective:|resolution:|filter:|cardinality:"", nullptr, nullptr);
verifyDirectives(Constants::BUNDLE_SYMBOLICNAME, ""singleton:|fragment-attachment:|mandatory:"", SYMBOLICNAME, ""bsn"");

verifyManifestFirst();",1
"static bool haveSuccessfulCommits(const HoodieTableMetaClient& metaClient) {
    return !metaClient.getCommitsTimeline().filterCompletedInstants().empty();
}

static Schema getTableAvroSchema(const HoodieFlinkTableBase& table, const Configuration& conf, bool includeMetadataFields) {
    TableSchemaResolver schemaUtil(table.getMetaClient(), conf.getBoolean(FlinkOptions::CHANGELOG_ENABLED));
    return schemaUtil.getTableAvroSchema(includeMetadataFields);
}","#include <stdexcept>

class StreamerUtil {
public:
    static bool haveSuccessfulCommits(const HoodieTableMetaClient& metaClient) {
        return !metaClient.getCommitsTimeline().filterCompletedInstants().empty();
    }

    static Schema getTableAvroSchema(const HoodieFlinkTableBase& table, const Configuration& conf, bool includeMetadataFields) {
        TableSchemaResolver schemaUtil(
            table.getMetaClient(),
            conf.getBoolean(FlinkOptions::CHANGELOG_ENABLED)
        );
        return schemaUtil.getTableAvroSchema(includeMetadataFields);
    }
};",1
"#include <gtest/gtest.h>

TEST(EventTest, testMatchOnNoArgs) {
    ReflectionEntryPointResolver resolver;
    auto event = Event::builder(DefaultEventContext::create(flowConstruct, fromSingleComponent(TEST_CONNECTOR))).message(of(nullptr)).build();
    MuleEventContext eventContext(flowConstruct, event);
}","TEST(ReflectionEntryPointResolverTestCase, testMatchOnNoArgs) {
    ReflectionEntryPointResolver resolver;
    auto event = Event::builder(DefaultEventContext::create(flowConstruct, fromSingleComponent(TEST_CONNECTOR)))
        .message(of(nullptr))
        .build();
    // This should fail because the Kiwi::bite() method has a void return type, and by default
    // void methods are ignored
    MuleEventContext eventContext(flowConstruct, event);
}",0
"#include <string>
#include <vector>
#include <map>","#include <string>
#include <vector>",0
"#include <atomic>
#include <memory>
#include <condition_variable>
#include <mutex>

std::atomic<ServerSocket*> serverSocket{nullptr};
std::counting_semaphore<1> latch(0);
std::counting_semaphore<1> semaphore(0);
std::atomic<bool> done{false};","#include <atomic>
#include <memory>
#include <mutex>
#include <condition_variable>
#include <semaphore>
#include <thread>

std::atomic<std::shared_ptr<ServerSocket>> serverSocket;
std::counting_semaphore<1> latch(0);
std::binary_semaphore semaphore(0);
std::atomic<bool> done{false};",0
"#include <random>
#include <map>
#include <string>
#include <netinet/in.h>
#include <ifaddrs.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <net/if.h>
#include <unistd.h>","#include <iostream>
#include <string>
#include <map>
#include <random>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netdb.h>
#include <ifaddrs.h>
#include <net/if.h>
#include <unistd.h>",1
"void initPolicyContext() {
    auto artifactBuilder =
        newBuilder()->setArtifactType(APP)
        ->setArtifactProperties(std::unordered_map<std::string, Any>(parametrization.getParameters()))
        ->setArtifactName(parametrization.getId())
        ->setConfigurationFiles(getResourcePaths(template.getDescriptor().getConfigResourceFiles()))
        ->setExecutionClassloader(template.getArtifactClassLoader()->getClassLoader())
        ->setServiceRepository(serviceRepository)
        ->setClassLoaderRepository(classLoaderRepository)
        ->setArtifactPlugins(artifactPlugins)
        ->setExtensionManagerFactory(std::make_shared<PolicyTemplateExtensionManagerFactory>(
            application, extensionModelLoaderRepository, artifactPlugins, std::make_shared<DefaultExtensionManagerFactory>()
        ));

    artifactBuilder->withServiceConfigurator(
        [&](auto customizationService) {
            customizationService->overrideDefaultServiceImpl(
                MuleProperties::OBJECT_POLICY_MANAGER_STATE_HANDLER,
                application->getMuleContext()->getRegistry()
                    ->lookupObject(MuleProperties::OBJECT_POLICY_MANAGER_STATE_HANDLER)
            );
        }
    );

    try {
        policyContext = artifactBuilder->build();
        policyContext->getMuleContext()->start();
    } catch (const MuleException& e) {
        throw std::logic_error(""Cannot create artifact context for the policy instance: "" + std::string(e.what()));
    }
}","void initPolicyContext() {
    auto artifactBuilder = newBuilder()
        .setArtifactType(APP)
        .setArtifactProperties(std::unordered_map<std::string, std::string>(parametrization.getParameters()))
        .setArtifactName(parametrization.getId())
        .setConfigurationFiles(getResourcePaths(template_.getDescriptor().getConfigResourceFiles()))
        .setExecutionClassloader(template_.getArtifactClassLoader().getClassLoader())
        .setServiceRepository(serviceRepository)
        .setClassLoaderRepository(classLoaderRepository)
        .setArtifactPlugins(artifactPlugins)
        .setExtensionManagerFactory(std::make_shared<PolicyTemplateExtensionManagerFactory>(
            application,
            extensionModelLoaderRepository,
            artifactPlugins,
            std::make_shared<DefaultExtensionManagerFactory>()
        ));

    artifactBuilder.withServiceConfigurator([&](auto& customizationService) {
        customizationService.overrideDefaultServiceImpl(
            MuleProperties::OBJECT_POLICY_MANAGER_STATE_HANDLER,
            application.getMuleContext()->getRegistry()
                ->lookupObject(MuleProperties::OBJECT_POLICY_MANAGER_STATE_HANDLER));
    });

    try {
        policyContext = artifactBuilder.build();
        policyContext->getMuleContext()->start();
    } catch (const MuleException& e) {
        throw std::logic_error(""Cannot create artifact context for the policy instance"");
    }
}",1
"#include <string>

static const std::string DEFAULT_METRICS_REPORTING_GRAPHITE_EVENTS_VALUE_AS_KEY = std::to_string(false);
static const std::string METRICS_REPORTING_GRAPHITE_SENDING_TYPE = METRICS_CONFIGURATIONS_PREFIX + ""reporting.graphite.sending.type"";
static const std::string METRICS_REPORTING_GRAPHITE_PREFIX = METRICS_CONFIGURATIONS_PREFIX + ""reporting.graphite.prefix"";
static const std::string DEFAULT_METRICS_REPORTING_GRAPHITE_PREFIX = """";
static const std::string DEFAULT_METRICS_REPORTING_GRAPHITE_SENDING_TYPE = ""TCP"";","```cpp
#include <string>

struct ConfigurationKeys {
    static constexpr const char* DEFAULT_METRICS_REPORTING_GRAPHITE_EVENTS_VALUE_AS_KEY = ""false"";
    static constexpr const char* METRICS_CONFIGURATIONS_PREFIX = """"; // Define this to the appropriate value

    static const std::string METRICS_REPORTING_GRAPHITE_SENDING_TYPE;
    static const std::string METRICS_REPORTING_GRAPHITE_PREFIX;
    static constexpr const char* DEFAULT_METRICS_REPORTING_GRAPHITE_PREFIX = """";
    static constexpr const char* DEFAULT_METRICS_REPORTING_GRAPHITE_SENDING_TYPE = ""TCP"";
};

const std::string ConfigurationKeys::METRICS_REPORTING_GRAPHITE_SENDING_TYPE =
    std::string(ConfigurationKeys::METRICS_CONFIGURATIONS_PREFIX) + ""reporting.graphite.sending.type"";

const std::string ConfigurationKeys::METRICS_REPORTING_GRAPHITE_PREFIX =
    std::string(ConfigurationKeys::METRICS_CONFIGURATIONS_PREFIX) + ""reporting.graphite.prefix"";
```",0
"#include ""plugin/streams/Stream.h""
#include ""plugin/streams/StreamRule.h""
#include ""plugin/streams/StreamRuleType.h""
#include ""rest/resources/streams/responses/SingleStreamRuleSummaryResponse.h""
#include ""rest/resources/streams/responses/StreamRuleListResponse.h""
#include ""rest/resources/streams/responses/StreamRuleTypeResponse.h""
#include ""rest/resources/streams/rules/requests/CreateStreamRuleRequest.h""
#include ""shared/rest/resources/RestResource.h""
#include ""shared/security/RestPermissions.h""
#include ""streams/StreamRuleService.h""
#include ""streams/StreamService.h""","#include ""plugin/database/ValidationException.h""
#include ""plugin/streams/Stream.h""
#include ""plugin/streams/StreamRule.h""
#include ""plugin/streams/StreamRuleType.h""
#include ""rest/resources/streams/responses/SingleStreamRuleSummaryResponse.h""
#include ""rest/resources/streams/responses/StreamRuleListResponse.h""
#include ""rest/resources/streams/responses/StreamRuleTypeResponse.h""
#include ""rest/resources/streams/rules/requests/CreateStreamRuleRequest.h""
#include ""shared/rest/resources/RestResource.h""
#include ""shared/security/RestPermissions.h""
#include ""streams/StreamRuleService.h""
#include ""streams/StreamService.h""",0
"#include <map>
#include <vector>
#include <string>
#include <memory>

class Logger {
public:
    static Logger getLogger(const std::string& className);
};

class LogManager {
public:
    static Logger getLogger(const std::string& className) {
        return Logger::getLogger(className);
    }
};

class Configuration {};
class Path {};
class HoodieTableMetaClient {};
class JobConf {};
class Job {
public:
    static std::shared_ptr<Job> getInstance(JobConf* job);
};
class HoodieHiveUtils {
public:
    static bool isIncrementalUseDatabase(std::shared_ptr<Job> job);
};

class InputPathHandler {
public:
    static const Logger LOG;

private:
    const Configuration* conf;
    std::map<std::string, std::shared_ptr<HoodieTableMetaClient>> tableMetaClientMap; // tableName to metadata mapping for all Hoodie tables(both incremental & snapshot)
    std::map<std::shared_ptr<HoodieTableMetaClient>, std::vector<std::shared_ptr<Path>>> groupedIncrementalPaths;
    std::vector<std::shared_ptr<Path>> snapshotPaths;
    std::vector<std::shared_ptr<Path>> nonHoodieInputPaths;
    bool isIncrementalUseDatabase;

public:
    InputPathHandler(const Configuration* conf, const std::vector<std::shared_ptr<Path>>& inputPaths, const std::vector<std::string>& incrementalTables, JobConf* job)
        : conf(conf),
          isIncrementalUseDatabase(HoodieHiveUtils::isIncrementalUseDatabase(Job::getInstance(job)))
    {
        parseInputPaths(inputPaths, incrementalTables);
    }

private:
    void parseInputPaths(const std::vector<std::shared_ptr<Path>>& inputPaths, const std::vector<std::string>& incrementalTables) {
        // Implementation goes here
    }
};

const Logger InputPathHandler::LOG = LogManager::getLogger(""InputPathHandler"");","```cpp
#include <map>
#include <vector>
#include <string>
#include <memory>

class InputPathHandler {
public:
    static Logger LOG;

private:
    Configuration conf;
    std::map<std::string, std::shared_ptr<HoodieTableMetaClient>> tableMetaClientMap;
    std::map<std::shared_ptr<HoodieTableMetaClient>, std::vector<Path>> groupedIncrementalPaths;
    std::vector<Path> snapshotPaths;
    std::vector<Path> nonHoodieInputPaths;
    bool isIncrementalUseDatabase;

public:
    InputPathHandler(const Configuration& conf,
                     const std::vector<Path>& inputPaths,
                     const std::vector<std::string>& incrementalTables,
                     const JobConf& job)
        : conf(conf),
          isIncrementalUseDatabase(HoodieHiveUtils::isIncrementalUseDatabase(Job::getInstance(job)))
    {
        parseInputPaths(inputPaths, incrementalTables);
    }

    // Other functions...
};
```",1
"void findAccountServiceOfferingId(long accountId) {
    std::string accountRouterOffering = VirtualNetworkApplianceManager::VirtualRouterServiceOffering::valueIn(accountId);
    std::string globalRouterOffering = VirtualNetworkApplianceManager::VirtualRouterServiceOffering::value();
    if (!accountRouterOffering.empty()) {
        verifyServiceOfferingByUuid(accountRouterOffering);
    }
    if (!serviceOfferingId.has_value() && globalRouterOffering != accountRouterOffering) {
        verifyServiceOfferingByUuid(globalRouterOffering);
    }
}

void verifyServiceOfferingByUuid(const std::string& offeringUuid) {
    logger.debug(""Verifying router service offering with uuid : "" + offeringUuid);
    auto serviceOffering = serviceOfferingDao.findByUuid(offeringUuid);
    if (serviceOffering && serviceOffering->isSystemUse()) {
        bool isLocalStorage = ConfigurationManagerImpl::SystemVMUseLocalStorage::valueIn(dest.getDataCenter().getId());
        if (isLocalStorage == serviceOffering->isUseLocalStorage()) {
            logger.debug(
                fmt::format(""Service offering {} (uuid: {}) will be used on virtual router"", 
                            serviceOffering->getName(), serviceOffering->getUuid()));
            serviceOfferingId = serviceOffering->getId();
        }
    }
}

void findServiceOfferingId() {
    serviceOfferingId = networkOfferingDao.findById(guestNetwork.getNetworkOfferingId())->getServiceOfferingId();
    if (!serviceOfferingId.has_value()) {
        findAccountServiceOfferingId(guestNetwork.getAccountId());
    }
    if (!serviceOfferingId.has_value()) {
        findDefaultServiceOfferingId();
    }
}","```cpp
#include <string>
#include <memory>

class RouterDeploymentDefinition {
protected:
    std::optional<long> serviceOfferingId;
    std::shared_ptr<ServiceOfferingDao> serviceOfferingDao;
    std::shared_ptr<NetworkOfferingDao> networkOfferingDao;
    GuestNetwork guestNetwork;
    Dest dest;
    Logger logger;

    void findAccountServiceOfferingId(long accountId) {
        std::string accountRouterOffering = VirtualNetworkApplianceManager::VirtualRouterServiceOffering::valueIn(accountId);
        std::string globalRouterOffering = VirtualNetworkApplianceManager::VirtualRouterServiceOffering::value();
        if (!accountRouterOffering.empty()) {
            verifyServiceOfferingByUuid(accountRouterOffering);
        }
        if (!serviceOfferingId.has_value() && globalRouterOffering != accountRouterOffering) {
            verifyServiceOfferingByUuid(globalRouterOffering);
        }
    }

private:
    void verifyServiceOfferingByUuid(const std::string& offeringUuid) {
        logger.debug(""Verifying router service offering with uuid : "" + offeringUuid);
        auto serviceOffering = serviceOfferingDao->findByUuid(offeringUuid);
        if (serviceOffering && serviceOffering->isSystemUse()) {
            bool isLocalStorage = ConfigurationManagerImpl::SystemVMUseLocalStorage::valueIn(dest.getDataCenter().getId());
            if (isLocalStorage == serviceOffering->isUseLocalStorage()) {
                logger.debug(
                    ""Service offering "" + serviceOffering->getName() +
                    "" (uuid: "" + serviceOffering->getUuid() +
                    "") will be used on virtual router""
                );
                serviceOfferingId = serviceOffering->getId();
            }
        }
    }

protected:
    void findServiceOfferingId() {
        serviceOfferingId = networkOfferingDao->findById(guestNetwork.getNetworkOfferingId())->getServiceOfferingId();
        if (!serviceOfferingId.has_value()) {
            findAccountServiceOfferingId(guestNetwork.getAccountId());
        }
        if (!serviceOfferingId.has_value()) {
            findDefaultServiceOfferingId();
        }
    }
};
```",1
"#include <gtest/gtest.h>
#include <string>
#include <map>
#include <memory>

TEST(FlowConfigTest, testPartialUpdate) {
    FlowId flowId;
    flowId.setFlowGroup(TEST_GROUP_NAME).setFlowName(TEST_FLOW_NAME);

    std::map<std::string, std::string> flowProperties;
    flowProperties[""param1""] = ""value1"";
    flowProperties[""param2""] = ""value2"";
    flowProperties[""param3""] = ""value3"";

    FlowConfig flowConfig;
    flowConfig.setId(FlowId().setFlowGroup(TEST_GROUP_NAME).setFlowName(TEST_FLOW_NAME))
              .setTemplateUris(TEST_TEMPLATE_URI)
              .setSchedule(Schedule().setCronSchedule(TEST_SCHEDULE).setRunImmediately(false))
              .setProperties(StringMap(flowProperties));

    _client.updateFlowConfig(flowConfig);

    std::string patchJson = R""({""schedule"":{""$set"":{""runImmediately"":true}},""properties"":{""$set"":{""param2"":""value4""},""$delete"":[""param3""]}})"";
    DataMap dataMap = DataMapUtils::readMap(IOUtils::toInputStream(patchJson));
    PatchRequest<FlowConfig> flowConfigPatch = PatchRequest<FlowConfig>::createFromPatchDocument(dataMap);

    PatchApplier::applyPatch(flowConfig, flowConfigPatch);

    _client.updateFlowConfig(flowConfig);

    FlowConfig retrievedFlowConfig = _client.getFlowConfig(flowId);

    ASSERT_TRUE(retrievedFlowConfig.getSchedule().isRunImmediately());
    ASSERT_EQ(retrievedFlowConfig.getProperties().get(""param1""), ""value1"");
    ASSERT_EQ(retrievedFlowConfig.getProperties().get(""param2""), ""value4"");
    ASSERT_FALSE(retrievedFlowConfig.getProperties().containsKey(""param3""));
}","#include <gtest/gtest.h>
#include <string>
#include <map>
#include <memory>

TEST(FlowConfigV2Test, testPartialUpdate) {
    FlowId flowId;
    flowId.setFlowGroup(TEST_GROUP_NAME);
    flowId.setFlowName(TEST_FLOW_NAME);

    std::map<std::string, std::string> flowProperties;
    flowProperties[""param1""] = ""value1"";
    flowProperties[""param2""] = ""value2"";
    flowProperties[""param3""] = ""value3"";

    FlowConfig flowConfig;
    flowConfig.setId(FlowId().setFlowGroup(TEST_GROUP_NAME).setFlowName(TEST_FLOW_NAME))
              .setTemplateUris(TEST_TEMPLATE_URI)
              .setSchedule(Schedule().setCronSchedule(TEST_SCHEDULE).setRunImmediately(false))
              .setProperties(StringMap(flowProperties));

    // Set some initial config
    _client.updateFlowConfig(flowConfig);

    // Change param2 to value4, delete param3
    std::string patchJson = R""({""schedule"":{""$set"":{""runImmediately"":true}},""properties"":{""$set"":{""param2"":""value4""},""$delete"":[""param3""]}})"";
    DataMap dataMap = DataMapUtils::readMap(IOUtils::toInputStream(patchJson));
    auto flowConfigPatch = PatchRequest<FlowConfig>::createFromPatchDocument(dataMap);

    PatchApplier::applyPatch(flowConfig, flowConfigPatch);

    _client.updateFlowConfig(flowConfig);

    FlowConfig retrievedFlowConfig = _client.getFlowConfig(flowId);

    ASSERT_TRUE(retrievedFlowConfig.getSchedule().isRunImmediately());
    ASSERT_EQ(retrievedFlowConfig.getProperties().get(""param1""), ""value1"");
    ASSERT_EQ(retrievedFlowConfig.getProperties().get(""param2""), ""value4"");
    ASSERT_FALSE(retrievedFlowConfig.getProperties().containsKey(""param3""));
}",1
"drawMark();
view->loadUrl(""javascript:onPageFinished();"");
}
bool onRenderProcessGone(WebView* view, RenderProcessGoneDetail* detail) override
{
    if (mCard == nullptr || mCard != view) {
        // Unexpected WebView Renderer terminated.
        Timber::wtf(""Unexpected WebView Renderer terminated. Crashed: %d"", detail->didCrash());
        return false;
    }

    Timber::e(""WebView Renderer process terminated. Crashed: %d"", detail->didCrash());

    destroyWebView(mCard);
    if (auto parent = dynamic_cast<ViewGroup*>(mCardFrame->getParent())) {
        parent->removeView(mCardFrame);
    }
    mCard = nullptr;
    mCardFrame = nullptr;

    int errorCauseId = detail->didCrash() ? R::string::webview_crash_unknown : R::string::webview_crash_oom;
    std::string errorCauseString = getResources()->getString(errorCauseId);

    if (!canRecoverFromWebViewRendererCrash()) {
        Timber::e(""Unrecoverable WebView Render crash"");
        std::string errorMessage = getResources()->getString(R::string::webview_crash_fatal, errorCauseString);
        UIUtils::showThemedToast(this, errorMessage, false);
        finishWithoutAnimation();
        return true;
    }

    if (webViewRendererLastCrashedOnCard(mCurrentCard->getId())) {
        Timber::e(""Web Renderer crash loop on card: %lld"", mCurrentCard->getId());
        std::string cardInformation = std::to_string(mCurrentCard->getId());
        std::string errorMessage = getResources()->getString(
            R::string::webview_crash_loop, cardInformation, errorCauseString);
        UIUtils::showThemedToast(this, errorMessage, false);
        finishWithoutAnimation();
        return true;
    } else {
        lastCrashingCardId = mCurrentCard->getId();
    }

    std::string nonFatalError = getResources()->getString(R::string::webview_crash_nonfatal, errorCauseString);
    UIUtils::showThemedToast(this, nonFatalError, false);

    mCardFrame = inflateNewView<View>(R::id::flashcard);
    if (auto parent = dynamic_cast<ViewGroup*>(mCardFrame->getParent())) {
        parent->addView(mCardFrame);
    }","```cpp
class AbstractFlashcardViewer : public NavigationDrawerActivity {
protected:
    WebView* mCard = nullptr;
    QWidget* mCardFrame = nullptr;
    Card* mCurrentCard = nullptr;
    std::optional<long> lastCrashingCardId;
    bool mPrefFullscreenReview;

    //... other members ...

    void setupWebView(WebView* view) {
        // signal-slot or callback mechanism for pageFinished
        connect(view, &WebView::loadFinished, this, [=](bool){
            drawMark();
            view->page()->runJavaScript(""onPageFinished();"");
        });

        // Handle WebView renderer crash (pseudo-handler, as in Qt or platform-dependent):
        view->setRenderProcessGoneHandler([this, view](const RenderProcessGoneDetail& detail) -> bool {
            if (mCard == nullptr || mCard != view) {
                // Unexpected view crashed.
                qWarning() << QString(""Unexpected WebView Renderer terminated. Crashed: %1"").arg(detail.didCrash());
                return false;
            }

            qCritical() << QString(""WebView Renderer process terminated. Crashed: %1"").arg(detail.didCrash());

            destroyWebView(mCard);
            if (mCardFrame && mCardFrame->parentWidget()) {
                auto parent = dynamic_cast<QWidget*>(mCardFrame->parentWidget());
                if (parent) {
                    parent->layout()->removeWidget(mCardFrame);
                }
            }
            mCard = nullptr;
            mCardFrame = nullptr;

            int errorCauseId = detail.didCrash() ? R::string::webview_crash_unknown : R::string::webview_crash_oom;
            QString errorCauseString = getResources()->getString(errorCauseId);

            if (!canRecoverFromWebViewRendererCrash()) {
                qCritical() << ""Unrecoverable WebView Render crash"";
                QString errorMessage = getResources()->getString(R::string::webview_crash_fatal, errorCauseString);
                UIUtils::showThemedToast(this, errorMessage, false);
                finishWithoutAnimation();
                return true;
            }

            if (webViewRendererLastCrashedOnCard(mCurrentCard->getId())) {
                qCritical() << QString(""Web Renderer crash loop on card: %1"").arg(mCurrentCard->getId());
                QString cardInformation = QString::number(mCurrentCard->getId());
                QString errorMessage = getResources()->getString(R::",1
"```cpp
class ConsumeOperation {
public:
    // The consume operation expects an XML body and a set of headers and attachments if required.

    // Consumes an operation from a SOAP Web Service.

};
```","```cpp
class ConsumeOperation {
private:
    SoapRequestGenerator requestGenerator;
    SoapResponseGenerator responseGenerator;

public:
    ConsumeOperation() : requestGenerator(), responseGenerator() {}

    // The rest of the class definition goes here
};
```",0
"link.href = src;
std::string scriptProtocol = link.protocol;
std::string docLoadProtocol = document.location.protocol;
if (docLoadProtocol == scriptProtocol) {
    return true;
}
if (scriptProtocol == ""http:"" ||
    scriptProtocol == ""https:"" ||
    scriptProtocol == ""ftp:"" ||
    scriptProtocol == ""blob:"" ||
    scriptProtocol == ""file:"" ||
    scriptProtocol == ""data:"") {
    return true;
}
return false;","std::string getProtocol(const std::string& url) {
    size_t pos = url.find(':');
    if (pos == std::string::npos) return """";
    return url.substr(0, pos + 1);
}

bool allowAutoBootstrap(const std::string& docLocationHref, const std::string& src) {
    std::string scriptProtocol = getProtocol(src);
    std::string docLoadProtocol = getProtocol(docLocationHref);

    if (docLoadProtocol == scriptProtocol) {
        return true;
    }
    if (scriptProtocol == ""http:"" ||
        scriptProtocol == ""https:"" ||
        scriptProtocol == ""ftp:"" ||
        scriptProtocol == ""blob:"" ||
        scriptProtocol == ""file:"" ||
        scriptProtocol == ""data:"") {
        return true;
    }
    return false;
}",1
"auto pagesByDistance = this->getPagesByDistance_();

auto preloadAllPages = [&]() {
    for (size_t distance = 0; distance < pagesByDistance.size(); ++distance) {
        const auto& pageIds = pagesByDistance[distance];
        for (const auto& pageId : pageIds) {
            auto page = this->getPageById(pageId);
            page->setDistance(distance);
        }
    }
};

this->mutateElement([&]() {
    if (
        !isExperimentOn(this->win, ""amp-story-load-first-page-only"") ||
        !prioritizeActivePage
    ) {
        preloadAllPages();
        return;
    }

    auto activePageId = devAssert(pagesByDistance[0][0]);
    std::shared_ptr<std::promise<void>> promise = std::make_shared<std::promise<void>>();
    auto page = this->getPageById(activePageId);
    page->setDistance(0);

    page->signals().whenSignal(CommonSignals::LOAD_END).then([=]() {
        preloadAllPages();
    });
    page->signals().whenSignal(EventType::SWITCH_PAGE).then([promise]() {
        promise->set_exception(std::make_exception_ptr(std::runtime_error(""SWITCH_PAGE"")));
    });

    try {
        promise->get_future().get();
    } catch (...) {
        // catch and ignore
    }
});","```cpp
void AmpStory::someMethod() {
    auto pagesByDistance = getPagesByDistance_();

    auto preloadAllPages = [&]() {
        for (size_t distance = 0; distance < pagesByDistance.size(); ++distance) {
            for (const auto& pageId : pagesByDistance[distance]) {
                auto page = getPageById(pageId);
                page->setDistance(static_cast<int>(distance));
            }
        }
    };

    mutateElement([&]() {
        if (!isExperimentOn(win, ""amp-story-load-first-page-only"") || !prioritizeActivePage) {
            preloadAllPages();
            return;
        }

        const auto& activePageId = devAssert(pagesByDistance[0][0]);
        auto page = getPageById(activePageId);
        page->setDistance(0);

        std::shared_ptr<std::promise<void>> p = std::make_shared<std::promise<void>>();
        auto f = p->get_future();

        page->signals().whenSignal(CommonSignals::LOAD_END)
            .then([preloadAllPages, p]() { preloadAllPages(); p->set_value(); });

        page->signals().whenSignal(EventType::SWITCH_PAGE)
            .then([p]() { p->set_exception(std::make_exception_ptr(std::runtime_error(""switched page""))); });

        try {
            f.get();
        } catch (...) {
            // handle exception if needed
        }
    });
}
```",1
"static const std::string DELETE_MESSAGE_GROUP = ""DELETE from %PREFIX%MESSAGE_GROUP where GROUP_KEY=? and REGION=?"";

static const std::string CREATE_MESSAGE_IN_GROUP = ""INSERT into %PREFIX%MESSAGE_GROUP(MESSAGE_ID, REGION, CREATED_DATE, GROUP_KEY, MARKED, COMPLETE, LAST_RELEASED_SEQUENCE)""
    "" values (?, ?, ?, ?, 0, 0, 0)"";

static const std::string LIST_GROUP_KEYS = ""SELECT distinct GROUP_KEY as CREATED from %PREFIX%MESSAGE_GROUP where REGION=?"";","static const std::string DELETE_MESSAGE_GROUP = ""DELETE from %PREFIX%MESSAGE_GROUP where GROUP_KEY=? and REGION=?"";

static const std::string CREATE_MESSAGE_IN_GROUP =
    ""INSERT into %PREFIX%MESSAGE_GROUP(MESSAGE_ID, REGION, CREATED_DATE, GROUP_KEY, MARKED, COMPLETE, LAST_RELEASED_SEQUENCE)""
    "" values (?, ?, ?, ?, 0, 0, 0)"";

static const std::string LIST_GROUP_KEYS =
    ""SELECT distinct GROUP_KEY as CREATED from %PREFIX%MESSAGE_GROUP where REGION=?"";",0
"class IStartConfiguration {
public:
    virtual ~IStartConfiguration() = default;
    virtual TaskProcessMode getProcessMode() const = 0;
    virtual void setProcessMode(TaskProcessMode mode) = 0;
};

class IStartConfiguration2 : public IStartConfiguration {
public:
    virtual ~IStartConfiguration2() = default;
    virtual bool getIsHeadless() const = 0;
    virtual void setIsHeadless(bool headless) = 0;
};","class IStartConfiguration {
public:
    virtual ~IStartConfiguration() = default;
    virtual TaskProcessMode getProcessMode() const = 0;
    virtual void setProcessMode(TaskProcessMode mode) = 0;
};

class IStartConfiguration2 : public IStartConfiguration {
public:
    virtual bool getIsHeadless() const = 0;
    virtual void setIsHeadless(bool value) = 0;
};",1
"#include <vector>
#include <map>
#include <iterator>
#include <future>
#include <thread>
#include <memory>
#include <algorithm>","#include <cassert>
#include <algorithm>
#include <vector>
#include <map>
#include <future>
#include <thread>
#include <memory>",0
"#include <vector>
#include <string>
#include <unordered_map>
#include <memory>
#include <sstream>
#include <iomanip>
#include <ctime>
#include <mutex>
#include <thread>

class BoundedPartitionAwareCompactionStrategy : public DayBasedCompactionStrategy {
private:
    static thread_local std::unique_ptr<std::tm> dateFormatTm;

    std::string formatDate(const std::tm& timeStruct) const {
        std::ostringstream oss;
        oss << std::put_time(&timeStruct, DayBasedCompactionStrategy::DATE_PARTITION_FORMAT.c_str());
        return oss.str();
    }

    const std::tm& getOrCreateDateFormatTm() const {
        if (!dateFormatTm)
            dateFormatTm = std::make_unique<std::tm>();
        return *dateFormatTm;
    }

public:
    std::vector<HoodieCompactionOperation> orderAndFilter(
        const HoodieWriteConfig& writeConfig,
        const std::vector<HoodieCompactionOperation>& operations,
        const std::vector<HoodieCompactionPlan>& pendingCompactionPlans) override
    {
        std::time_t offsetTime = getDateAtOffsetFromToday(
            -1 * writeConfig.getTargetPartitionsPerDayBasedCompaction());
        std::tm offsetTm;
#ifdef _WIN32
        localtime_s(&offsetTm, &offsetTime);
#else
        localtime_r(&offsetTime, &offsetTm);
#endif
        std::string earliestPartitionPathToCompact = formatDate(offsetTm);

        std::unordered_map<std::string, std::vector<HoodieCompactionOperation>> grouped;
        for (const auto& op : operations) {
            grouped[op.getPartitionPath()].push_back(op);
        }

        std::vector<HoodieCompactionOperation> filtered;
        for (const auto& entry : grouped) {
            if (entry.first <= earliestPartitionPathToCompact) {
                filtered.insert(filtered.end(), entry.second.begin(), entry.second.end());
            }
        }
        return filtered;
    }
};

thread_local std::unique_ptr<std::tm> BoundedPartitionAwareCompactionStrategy::dateFormatTm;","#include <vector>
#include <map>
#include <string>
#include <memory>
#include <mutex>
#include <thread>
#include <iomanip>
#include <sstream>
#include <chrono>
#include <locale>

class BoundedPartitionAwareCompactionStrategy : public DayBasedCompactionStrategy {
private:
    static thread_local std::unique_ptr<std::ostringstream> dateFormat;

    static std::string formatDate(const std::tm& tm) {
        if (!dateFormat) {
            dateFormat = std::make_unique<std::ostringstream>();
        } else {
            dateFormat->str("""");
            dateFormat->clear();
        }
        dateFormat->imbue(std::locale(""C""));
        dateFormat->setf(std::ios::fixed, std::ios::floatfield);
        dateFormat->precision(0);
        dateFormat->write("""", 0); // no-op, resets buffer
        // Replace ""%Y-%m-%d"" with DayBasedCompactionStrategy::DATE_PARTITION_FORMAT as needed
        char buf[32];
        std::strftime(buf, sizeof(buf), DayBasedCompactionStrategy::DATE_PARTITION_FORMAT, &tm);
        return std::string(buf);
    }

public:
    std::vector<HoodieCompactionOperation> orderAndFilter(
            const HoodieWriteConfig& writeConfig,
            const std::vector<HoodieCompactionOperation>& operations,
            const std::vector<HoodieCompactionPlan>& pendingCompactionPlans) override
    {
        auto earliestTm = getDateAtOffsetFromToday(-1 * writeConfig.getTargetPartitionsPerDayBasedCompaction());
        std::string earliestPartitionPathToCompact = formatDate(earliestTm);

        std::map<std::string, std::vector<HoodieCompactionOperation>> partitionGroups;
        for (const auto& op : operations) {
            partitionGroups[op.getPartitionPath()].push_back(op);
        }

        std::vector<HoodieCompactionOperation> result;
        for (const auto& entry : partitionGroups) {
            if (entry.first <= earliestPartitionPathToCompact) {
                result.insert(result.end(), entry.second.begin(), entry.second.end());
            }
        }
        return result;
    }
};

thread_local std::unique_ptr<std::ostringstream> BoundedPartitionAwareCompactionStrategy::dateFormat = nullptr;",1
"```cpp
BytesBoundedBatch batch(this->memSizeLimit, this->expireInMilliSecond);
LOG.debug(""Batch "" + std::to_string(batch.getId()) + "" is generated"");

std::future<RecordMetadata>* future = nullptr;
try {
    future = batch.tryAppend(record, callback, this->largeMessagePolicy);
} catch (const RecordTooLargeException& e) {
    throw std::runtime_error(std::string(""Failed due to a message that was too large: "") + e.what());
}

// The future might be null, since the largeMessagePolicy might be set to DROP
if (future == nullptr) {
    assert(largeMessagePolicy == LargeMessagePolicy::DROP);
    LOG.error(""Batch "" + std::to_string(batch.getId()) + "" is silently marked as complete, dropping a huge record: ""
              + record.toString());
    future = new std::future<RecordMetadata>(std::async(std::launch::deferred, [](){ return RecordMetadata(0); }));
    callback.onSuccess(WriteResponse::EMPTY);
}
```","```cpp
BytesBoundedBatch batch(this->memSizeLimit, this->expireInMilliSecond);
LOG.debug(""Batch "" + std::to_string(batch.getId()) + "" is generated"");
std::future<RecordMetadata>* future = nullptr;
try {
    future = batch.tryAppend(record, callback, this->largeMessagePolicy);
} catch (const RecordTooLargeException& e) {
    throw std::runtime_error(std::string(""Failed due to a message that was too large: "") + e.what());
}

// The future might be null, since the largeMessagePolicy might be set to DROP
if (future == nullptr) {
    assert(largeMessagePolicy == LargeMessagePolicy::DROP);
    LOG.error(""Batch "" + std::to_string(batch.getId()) + "" is silently marked as complete, dropping a huge record: "" + record);
    future = new std::future<RecordMetadata>(std::async(std::launch::deferred, []() { return RecordMetadata(0); }));
    callback->onSuccess(WriteResponse::EMPTY);
}
```",0
"{
    try
    {
        ExchangeImpl exchange;
        if (event.isAllowNonBlocking())
        {
            const ReplyToHandler* originalReplyToHandler = event.getReplyToHandler();

            event = DefaultMuleEvent(
                event,
                new ReplyToHandlerImpl(
                    [originalReplyToHandler](MuleEvent event, MuleMessage returnMessage, void* replyTo) {
                        try {
                            originalReplyToHandler->processReplyTo(event, returnMessage, replyTo);
                        } catch (const std::exception& e) {
                            processExceptionReplyTo(MessagingException(event, e), replyTo);
                        }
                    },
                    [originalReplyToHandler](MessagingException exception, void* replyTo) {
                        originalReplyToHandler->processExceptionReplyTo(exception, replyTo);
                    }
                )
            );
        }

        MuleEvent responseEvent = sendThroughCxf(event, exchange);

        if (responseEvent == nullptr || !responseEvent->equals(NonBlockingVoidMuleEvent::getInstance()))
        {
            return processResponse(event, exchange, responseEvent);
        }

        return NonBlockingVoidMuleEvent::getInstance();
    }
    catch (const MuleException& e)
    {
        logger.warn(""Could not dispatch message to CXF!"", e);
        throw;
    }
}

private:
MuleEvent processResponse(MuleEvent event, Exchange& exchange, MuleEvent responseEvent)
{
    if (responseEvent == nullptr || VoidMuleEvent::getInstance()->equals(responseEvent)
        || !event.getExchangePattern().hasResponse())
    {
        return nullptr;
    }

    MuleMessage muleResMsg = responseEvent.getMessage();
    muleResMsg.setPayload(getResponseOutputHandler(exchange));

    Message* faultMsg = exchange.getOutFaultMessage();
    if (faultMsg != nullptr)
    {
        Exception* ex = faultMsg->getContent<Exception>();
        if (ex != nullptr)
        {
            ExceptionPayload* exceptionPayload = new DefaultExceptionPayload(*ex);
            event.getMessage().setExceptionPayload(exceptionPayload);
            muleResMsg.setOutboundProperty(HttpConnector::HTTP_STATUS_PROPERTY, 500);
        }
    }

    return responseEvent;
}

private:
MuleEvent sendThroughCxf(MuleEvent event, Exchange& exchange)
{
    MessageImpl* m = new MessageImpl();
    m->setExchange(exchange);

    MuleMessage muleReqMsg = event.getMessage();
    std::string method = muleReqMsg.getInboundProperty(HttpConnector::","```cpp
MuleEvent* CxfInboundMessageProcessor::process(MuleEvent* event)
{
    try
    {
        ExchangeImpl* exchange = new ExchangeImpl();

        if (event->isAllowNonBlocking())
        {
            ReplyToHandler* originalReplyToHandler = event->getReplyToHandler();

            event = new DefaultMuleEvent(event, new ReplyToHandlerImpl([=](MuleEvent* e, MuleMessage* returnMessage, void* replyTo)
            {
                try
                {
                    originalReplyToHandler->processReplyTo(e, returnMessage, replyTo);
                }
                catch (const std::exception& ex)
                {
                    processExceptionReplyTo(new MessagingException(e, ex), replyTo);
                }
            },
            [=](MessagingException* exception, void* replyTo)
            {
                originalReplyToHandler->processExceptionReplyTo(exception, replyTo);
            }));
        }

        MuleEvent* responseEvent = sendThroughCxf(event, exchange);

        if (responseEvent == nullptr || responseEvent != NonBlockingVoidMuleEvent::getInstance())
        {
            return processResponse(event, exchange, responseEvent);
        }

        return NonBlockingVoidMuleEvent::getInstance();
    }
    catch (const MuleException& e)
    {
        logger->warn(""Could not dispatch message to CXF!"", e);
        throw;
    }
}

MuleEvent* CxfInboundMessageProcessor::processResponse(MuleEvent* event, Exchange* exchange, MuleEvent* responseEvent)
{
    if (responseEvent == nullptr || VoidMuleEvent::getInstance() == responseEvent || !event->getExchangePattern()->hasResponse())
    {
        return nullptr;
    }

    MuleMessage* muleResMsg = responseEvent->getMessage();
    muleResMsg->setPayload(getResponseOutputHandler(exchange));

    Message* faultMsg = exchange->getOutFaultMessage();
    if (faultMsg != nullptr)
    {
        std::exception_ptr ex = faultMsg->getContent<std::exception_ptr>();
        if (ex)
        {
            ExceptionPayload* exceptionPayload = new DefaultExceptionPayload(ex);
            event->getMessage()->setExceptionPayload(exceptionPayload);
            muleResMsg->setOutboundProperty(HttpConnector::HTTP_STATUS_PROPERTY, 500);
        }
    }
    return responseEvent;
}

MuleEvent* CxfInboundMessageProcessor::sendThroughCxf(MuleEvent* event, Exchange* exchange)
{
    MessageImpl*",1
"ObjectId put(const Object &object, const ActorId &ownerActorId, bool isArrowData) {
    if (dynamic_cast<const NativeRayObject*>(&object) != nullptr) {
        throw std::invalid_argument(""Trying to put a NativeRayObject. Please use putRaw instead."");
    }
    if (isArrowData) {
        return putRaw(ObjectSerializer::serializeArrow(object), ownerActorId);
    } else {
        return putRaw(ObjectSerializer::serialize(object), ownerActorId);
    }
}","ObjectId put(const Object& object, const ActorId& ownerActorId, bool isArrowData) {
    if (dynamic_cast<const NativeRayObject*>(&object) != nullptr) {
        throw std::invalid_argument(
            ""Trying to put a NativeRayObject. Please use putRaw instead."");
    }
    if (isArrowData) {
        return putRaw(ObjectSerializer::serializeArrow(object), ownerActorId);
    } else {
        return putRaw(ObjectSerializer::serialize(object), ownerActorId);
    }
}",1
"#include <atomic>
#include <memory>
#include <cstdint>
#include <latch>

class Task {
private:
    std::atomic_bool* shutdownRequested;
    std::latch* shutdownLatch;

    void* taskContext;
    void* taskState;
    void* jobId;
    void* taskId;
    void* taskStateTracker;
    void* taskExecutor;
    void* countDownLatch;
    void* closer;
    void* extractor;
    void* converter;
    void* rowChecker;
    void* taskMode;
    void* recordsPulled;
    int64_t lastRecordPulledTimestampMillis;
    void* watermarkingStrategy;
    void* watermarkManager;
    void* watermarkTracker;
    void* watermarkStorage;

public:
    Task()
        : taskContext(nullptr),
          taskState(nullptr),
          jobId(nullptr),
          taskId(nullptr),
          taskStateTracker(nullptr),
          taskExecutor(nullptr),
          countDownLatch(nullptr),
          closer(nullptr),
          extractor(nullptr),
          converter(nullptr),
          rowChecker(nullptr),
          taskMode(nullptr),
          recordsPulled(nullptr),
          lastRecordPulledTimestampMillis(0),
          shutdownRequested(nullptr),
          shutdownLatch(nullptr),
          watermarkingStrategy(nullptr),
          watermarkManager(nullptr),
          watermarkTracker(nullptr),
          watermarkStorage(nullptr)
    {}
};","```cpp
class Task {
private:
    TaskContext* taskContext;
    TaskState* taskState;
    std::string* jobId;
    std::string* taskId;
    TaskStateTracker* taskStateTracker;
    TaskExecutor* taskExecutor;
    std::atomic<bool>* shutdownRequested;
    std::count_down_latch* shutdownLatch;
    CountDownLatch* countDownLatch;
    Closer* closer;
    Extractor* extractor;
    Converter* converter;
    RowChecker* rowChecker;
    TaskMode* taskMode;
    std::atomic<int64_t>* recordsPulled;
    int64_t lastRecordPulledTimestampMillis;
    WatermarkingStrategy* watermarkingStrategy;
    WatermarkManager* watermarkManager;
    WatermarkTracker* watermarkTracker;
    WatermarkStorage* watermarkStorage;

public:
    Task() 
        : taskContext(nullptr),
          taskState(nullptr),
          jobId(nullptr),
          taskId(nullptr),
          taskStateTracker(nullptr),
          taskExecutor(nullptr),
          shutdownRequested(nullptr),
          shutdownLatch(nullptr),
          countDownLatch(nullptr),
          closer(nullptr),
          extractor(nullptr),
          converter(nullptr),
          rowChecker(nullptr),
          taskMode(nullptr),
          recordsPulled(nullptr),
          lastRecordPulledTimestampMillis(0),
          watermarkingStrategy(nullptr),
          watermarkManager(nullptr),
          watermarkTracker(nullptr),
          watermarkStorage(nullptr) 
    {}
};
```",1
"```cpp
}
auto interceptor2 = prepareInterceptor(ProcessorInterceptor{});
startFlowWithInterceptors(interceptor1, interceptor2);

Event result = process(flow, eventBuilder().message(Message::of("""")).build());
ASSERT_THAT(result.getMessage().getPayload().getValue(), Eq(TEST_PAYLOAD));
ASSERT_THAT(result.getError().has_value(), Eq(false));

if (useMockInterceptor) {
    InOrder inOrder(processor, interceptor1, interceptor2);

    inOrder.verify(interceptor1).before(_, mapArgWithEntry(""param"", """"), argThat(interceptionHasPayloadValue("""")));
    inOrder.verify(interceptor1).around(_, mapArgWithEntry(""param"", """"), _, _);
    inOrder.verify(interceptor2).before(_, mapArgWithEntry(""param"", """"), argThat(interceptionHasPayloadValue("""")));
    inOrder.verify(interceptor2).around(_, mapArgWithEntry(""param"", """"), argThat(interceptionHasPayloadValue("""")), _);
    inOrder.verify(processor).process(argThat(hasPayloadValue("""")));
    inOrder.verify(interceptor2).after(_, argThat(interceptionHasPayloadValue("""")), Eq(empty()));
    inOrder.verify(interceptor1).after(_, argThat(interceptionHasPayloadValue(TEST_PAYLOAD)), Eq(empty()));

    ASSERT_THAT(result.getParameters().entrySet().size(), Eq(0));
    verifyParametersResolvedAndDisposed(1);
}
}

TEST(YourTestSuite, SecondInterceptorMutatesEventAroundAfterProceed) {
    auto interceptor1 = prepareInterceptor(ProcessorInterceptor{});
    auto interceptor2 = prepareInterceptor(ProcessorInterceptor{
        // You can add override here as needed in C++
        std::function<std::future<InterceptionEvent>(ComponentLocation,
                                                     std::map<std::string, std::any>,
                                                     /*...*/)>{}
    });
```","```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <future>
#include <map>
#include <memory>
#include <string>

using namespace ::testing;

constexpr auto TEST_PAYLOAD = ""test_payload"";

class Message {
public:
    static Message of(const std::string& value) { return Message(value); }
    const std::string& getPayload() const { return payload_; }
private:
    explicit Message(const std::string& payload) : payload_(payload) {}
    std::string payload_;
};

class Event {
public:
    Message& getMessage() { return message_; }
    const Message& getMessage() const { return message_; }
    class Error {
    public:
        bool isPresent() const { return false; }
    };
    const Error& getError() const { return error_; }
    const std::map<std::string, std::string>& getParameters() const { return parameters_; }
private:
    Message message_ = Message("""");
    Error error_;
    std::map<std::string, std::string> parameters_;
};

class ComponentLocation {};
class InterceptionEvent {};
class Processor {
public:
    virtual ~Processor() = default;
    virtual Event process(const Event&) = 0;
};

class ProcessorInterceptor {
public:
    virtual ~ProcessorInterceptor() = default;
    virtual std::future<InterceptionEvent> before(ComponentLocation*, const std::map<std::string, std::string>&, const InterceptionEvent&) { return std::future<InterceptionEvent>{}; }
    virtual std::future<InterceptionEvent> around(ComponentLocation*, const std::map<std::string, std::string>&, std::function<std::future<InterceptionEvent>()>, InterceptionEvent) { return std::future<InterceptionEvent>{}; }
    virtual std::future<void> after(ComponentLocation*, InterceptionEvent, std::optional<int>) { return std::future<void>{}; }
};

std::unique_ptr<ProcessorInterceptor> prepareInterceptor(std::unique_ptr<ProcessorInterceptor> interceptor) {
    // mock/spy/prepare logic here
    return interceptor;
}

std::unique_ptr<Event> eventBuilder() {
    return std::make_unique<Event>();
}

void startFlowWithInterceptors(ProcessorInterceptor* i1, ProcessorInterceptor* i2) {}

Event process(Processor* flow, Event event) {
    return flow->process(event);
}

// GMock matchers/helpers
MATCHER_P(hasPayloadValue, value, """") {",0
"std::string url;
long sessionExpireInMin;
CloseableHttpClient* httpClient;
SessionManager* sessionManager;
ExecutorService* executorService;

this->username = username;
this->password = password;","AzkabanClient(const std::string& username,
              const std::string& password,
              const std::string& url,
              long sessionExpireInMin,
              std::shared_ptr<HttpClient> httpClient,
              std::shared_ptr<SessionManager> sessionManager,
              std::shared_ptr<ExecutorService> executorService)
    : username(username),
      password(password),
      url(url),
      sessionExpireInMin(sessionExpireInMin),
      httpClient(httpClient),
      sessionManager(sessionManager),
      executorService(executorService) {}",1
"bool removeHandler(MessageHandler* handler) {
    return handlerSet.erase(handler) > 0;
}",virtual bool removeHandler(MessageHandler* handler) = 0;,0
"if (!appending && std::rename(tempFile.c_str(), localFile.c_str()) != 0) {
    throw MessagingException(""Failed to rename local file"");
}
if (this->options.count(Option::PRESERVE_TIMESTAMP) > 0
    || fileExistsMode == FileExistsMode::REPLACE_IF_MODIFIED) {
    setLastModified(localFile, getModified(fileInfo));
}
else if (fileExistsMode == FileExistsMode::REPLACE_IF_MODIFIED) {
    logger.debug(""Local file '"" + localFile + ""' has the same modified timestamp, ignored"");
    if (this->command == Command::MGET) {
        localFile.clear();
    }
}
else if (fileExistsMode != FileExistsMode::IGNORE) {
    throw MessageHandlingException(message, ""Local file "" + localFile + "" already exists"");
}","if (!appending && std::rename(tempFile.c_str(), localFile.c_str()) != 0) {
    throw std::runtime_error(""Failed to rename local file"");
}
if (this->options.count(Option::PRESERVE_TIMESTAMP) > 0
        || fileExistsMode == FileExistsMode::REPLACE_IF_MODIFIED) {
    setLastModified(localFile, getModified(fileInfo));
}
else if (fileExistsMode == FileExistsMode::REPLACE_IF_MODIFIED) {
    logger.debug(""Local file '"" + localFile + ""' has the same modified timestamp, ignored"");
    if (this->command == Command::MGET) {
        localFile.clear();
    }
}
else if (fileExistsMode != FileExistsMode::IGNORE) {
    throw MessageHandlingException(message, ""Local file "" + localFile + "" already exists"");
}",1
"#include <vector>
#include <typeinfo>

class DynamicPort {
public:
    DynamicPort(const std::string& name) : name_(name) {}
private:
    std::string name_;
};

class SocketsExtension {};
class HttpConnector {};

class ExtensionFunctionalTestCase {
public:
    virtual std::vector<const std::type_info*> getAnnotatedExtensionClasses() { return {}; }
    virtual std::vector<std::string> getConfigFiles() { return {}; }
};

class SecureHttpPollingFunctionalTestCase : public ExtensionFunctionalTestCase {
public:
    DynamicPort port1{""port1""};

    std::vector<const std::type_info*> getAnnotatedExtensionClasses() override {
        return { &typeid(SocketsExtension), &typeid(HttpConnector) };
    }

    std::vector<std::string> getConfigFiles() override {
        // Implementation goes here
        return {};
    }
};","#include <vector>
#include <string>

class DynamicPort {
public:
    DynamicPort(const std::string& name) : name_(name) {}
private:
    std::string name_;
};

class ExtensionFunctionalTestCase {
public:
    virtual std::vector<const std::type_info*> getAnnotatedExtensionClasses() { return {}; }
    virtual std::vector<std::string> getConfigFiles() { return {}; }
    virtual ~ExtensionFunctionalTestCase() = default;
};

class SocketsExtension {};
class HttpConnector {};

class SecureHttpPollingFunctionalTestCase : public ExtensionFunctionalTestCase {
public:
    DynamicPort port1 = DynamicPort(""port1"");

    std::vector<const std::type_info*> getAnnotatedExtensionClasses() override {
        return { &typeid(SocketsExtension), &typeid(HttpConnector) };
    }

    std::vector<std::string> getConfigFiles() override {
        // Implement as needed
        return {};
    }
};",0
"std::all_of(
    keySet.begin(), keySet.end(),
    [](const std::string& key) {
        return key.rfind(SamzaRunnerOverrideConfigs::BEAM_RUNNER_CONFIG_PREFIX, 0) == 0;
    }
);

static std::map<std::string, std::string> createUserConfig(const SamzaPipelineOptions& options) {
    const std::string& configFilePath = options.getConfigFilePath();
    std::map<std::string, std::string> config;

    if (!configFilePath.empty()) {
        std::filesystem::path configFile(configFilePath);
        if (!std::filesystem::exists(configFile)) {
            throw std::invalid_argument(""Config file "" + configFilePath + "" does not exist"");
        }
        PropertiesConfigFactory configFactory;
        std::string configUri = std::filesystem::absolute(configFile).u8string();
        auto fileConfig = configFactory.getConfig(configUri);
        config.insert(fileConfig.begin(), fileConfig.end());
    }

    return config;
}","```cpp
#include <string>
#include <map>
#include <filesystem>
#include <stdexcept>
#include <utility>

class SamzaPipelineOptions {
public:
    std::string getConfigFilePath() const;
    // ... other methods ...
};

class PropertiesConfigFactory {
public:
    std::map<std::string, std::string> getConfig(const std::filesystem::path& configUri) const;
};

std::map<std::string, std::string> createUserConfig(const SamzaPipelineOptions& options) {
    const std::string configFilePath = options.getConfigFilePath();
    std::map<std::string, std::string> config;

    if (!configFilePath.empty()) {
        std::filesystem::path configFile(configFilePath);
        if (!std::filesystem::exists(configFile)) {
            throw std::invalid_argument(""Config file "" + configFilePath + "" does not exist"");
        }
        PropertiesConfigFactory configFactory;
        config.insert(
            configFactory.getConfig(std::filesystem::canonical(configFile)).begin(),
            configFactory.getConfig(std::filesystem::canonical(configFile)).end()
        );
    }

    return config;
}
```",1
"#include <grpcpp/support/channel_arguments.h>
#include <opentelemetry/sdk/trace/tracer_provider.h>
#include <opentelemetry/context/context.h>
#include <opentelemetry/context/scope.h>
#include <opentelemetry/version/version.h>
#include <opentelemetry/trace/span.h>
#include <opentelemetry/trace/span_end_options.h>","#include <grpcpp/grpcpp.h>
#include <opentelemetry/sdk/trace/tracer.h>
#include <opentelemetry/context/context.h>
#include <opentelemetry/instrumentation/instrumentation_version.h>
#include <opentelemetry/trace/span.h>
#include <opentelemetry/trace/end_span_options.h>",0
"```cpp
#include <string>
#include <map>
#include <memory>

class OracleDbConnection : public DefaultDbConnection
{
public:
    static const std::string ATTR_TYPE_NAME_PARAM;
    static const std::string ATTR_NO_PARAM;
    static const std::string QUERY_TYPE_ATTRS;

private:
    void* createArrayMethod;
    bool initialized;
};

const std::string OracleDbConnection::ATTR_TYPE_NAME_PARAM = ""ATTR_TYPE_NAME"";
const std::string OracleDbConnection::ATTR_NO_PARAM = ""ATTR_NO"";
const std::string OracleDbConnection::QUERY_TYPE_ATTRS = ""SELECT ATTR_NO, ATTR_TYPE_NAME FROM ALL_TYPE_ATTRS WHERE TYPE_NAME = ? AND ATTR_TYPE_NAME IN ('CLOB', 'BLOB')"";
```","#include <string>
#include <map>
#include <memory>

class Method; // Placeholder, or use proper C++ reflection/wrapper if required

class DefaultDbConnection
{
    // Assuming DefaultDbConnection has relevant methods and members
};

class OracleDbConnection : public DefaultDbConnection
{
public:
    static const std::string ATTR_TYPE_NAME_PARAM;
    static const std::string ATTR_NO_PARAM;
    static const std::string QUERY_TYPE_ATTRS;

private:
    Method* createArrayMethod;
    bool initialized;

public:
    OracleDbConnection()
        : createArrayMethod(nullptr), initialized(false)
    {
    }
    // Additional methods and logic as required
};

const std::string OracleDbConnection::ATTR_TYPE_NAME_PARAM = ""ATTR_TYPE_NAME"";
const std::string OracleDbConnection::ATTR_NO_PARAM = ""ATTR_NO"";
const std::string OracleDbConnection::QUERY_TYPE_ATTRS = ""SELECT ATTR_NO, ATTR_TYPE_NAME FROM ALL_TYPE_ATTRS WHERE TYPE_NAME = ? AND ATTR_TYPE_NAME IN ('CLOB', 'BLOB')"";",0
"#include <map>
#include <string>

using std::map;
using std::string;

using TEXT_MAP_INJECT = int; // Placeholder; replace with actual enum or constant as needed

#include ""datadog/opentracing/DDSpan.h""
#include ""datadog/trace/context/TraceScope.h""
#include ""datadog/trace/instrumentation/api/AgentPropagation.h""
#include ""datadog/trace/instrumentation/api/AgentPropagationGetter.h""","#include <map>
#include <string>

using namespace std;",1
"assertAppsDir(NONE, {incompleteAppFileBuilder.getId()}, true);

assertZombieApplication(incompleteAppFileBuilder.getId(), 1, true);

reset(applicationDeploymentListener);","```cpp
// Maintains app dir created
assertAppsDir(NONE, {incompleteAppFileBuilder.getId()}, true);
assertZombieApplication(incompleteAppFileBuilder.getId(), 1, true);

reset(applicationDeploymentListener);
```",0
"projectTestSetup.runbundles.clear();
projectTestSetup.runpath.clear();
projectTestSetup.properties.clear();
projectTestSetup.runfw.clear();

projectTestSetup.extraSystemPackages = std::as_const(projectTestSetup.extraSystemPackages);
projectTestSetup.extraSystemCapabilities = std::as_const(projectTestSetup.extraSystemCapabilities);

std::atexit([](){
    // ... your shutdown hook code here ...
});","```cpp
projectTestSetup.runbundles.clear();
projectTestSetup.runpath.clear();
projectTestSetup.properties.clear();
projectTestSetup.runfw.clear();

projectTestSetup.extraSystemPackages = std::map<std::string, std::string>(projectTestSetup.extraSystemPackages);
projectTestSetup.extraSystemCapabilities = std::map<std::string, std::string>(projectTestSetup.extraSystemCapabilities);

std::atexit([]() {
    // ...
});
```",1
"#include <regex>
#include <map>
#include <string>

static const std::regex PATTERN_PATH{R""([/\-$._0-9a-zA-Z]+)""};
static const std::regex PATTERN_NAME_HAS_SYMBOL{R""([:*,\s/\-._0-9a-zA-Z]+)""};
static const std::regex PATTERN_KEY{R""([*,\-\._0-9a-zA-Z]+)""};
static std::map<std::string, std::string> legacyProperties;","#include <regex>
#include <map>
#include <string>

class AbstractConfig {
protected:
    static const std::regex PATTERN_PATH;
    static const std::regex PATTERN_NAME_HAS_SYMBOL;
    static const std::regex PATTERN_KEY;
    static std::map<std::string, std::string> legacyProperties;
};

const std::regex AbstractConfig::PATTERN_PATH{R""([/\-\$._0-9a-zA-Z]+)""};
const std::regex AbstractConfig::PATTERN_NAME_HAS_SYMBOL{R""([:*,\s/\-._0-9a-zA-Z]+)""};
const std::regex AbstractConfig::PATTERN_KEY{R""([*,\-\._0-9a-zA-Z]+)""};
std::map<std::string, std::string> AbstractConfig::legacyProperties;",1
"template <typename T>
class MetadataResult {
public:
    virtual T get(MetadataAware* processor) = 0;
    virtual ~MetadataResult() = default;
};

class MyClass {
public:
    std::map<std::string, std::shared_ptr<const MetadataCache>> getCaches() const {
        return caches;
    }
private:
    std::map<std::string, std::shared_ptr<const MetadataCache>> caches;
};","#include <map>
#include <memory>

class MetadataCache;

class MuleMetadataManager : public MetadataManager
{
public:
    std::map<std::string, std::shared_ptr<MetadataCache>> getCaches() const
    {
        return caches;
    }

private:
    std::map<std::string, std::shared_ptr<MetadataCache>> caches;
};",0
"const Method dump_heapDumpToFile;
const Method dump_JavaDump;
const Method dump_javaDumpToFile;
const Method dump_queryDumpOptions;
const Method dump_resetDumpOptions;
const Method dump_setDumpOptions;
const Method dump_SnapDump;","```cpp
class OpenJ9DiagnosticsMXBeanImpl : public OpenJ9DiagnosticsMXBean {
private:
    const Method* dump_heapDumpToFile;
    const Method* dump_JavaDump;
    const Method* dump_javaDumpToFile;
    const Method* dump_queryDumpOptions;
    const Method* dump_resetDumpOptions;
    const Method* dump_setDumpOptions;
    const Method* dump_SnapDump;
};
```",0
"void doStop() override {
    ParentClass::doStop();
}

void handleMessage(std::shared_ptr<Message> message) override {
    std::deque<std::shared_ptr<ExecutorChannelInterceptor>> interceptorStack;
    try {
        if (this->channelInterceptors != nullptr
            && dynamic_cast<ExecutorChannelInterceptorAware*>(this->inputChannel.get()) != nullptr
            && static_cast<ExecutorChannelInterceptorAware*>(this->inputChannel.get())->hasExecutorInterceptors()) {
            message = applyBeforeHandle(message, interceptorStack);
            if (message == nullptr) {
                return;
            }
        }
        this->handler->handleMessage(message);
        if (!interceptorStack.empty()) {
            triggerAfterMessageHandled(message, nullptr, interceptorStack);
        }
    } catch (const std::exception& ex) {
        if (!interceptorStack.empty()) {
            triggerAfterMessageHandled(message, std::make_exception_ptr(ex), interceptorStack);
        }
        auto* mex = dynamic_cast<const MessagingException*>(&ex);
        if (mex) {
            throw;
        }
        std::string description = ""Failed to handle "" + message->toString() + "" to "" + this->toString() + "" in "" + this->handler->toString();
        throw MessageDeliveryException(message, description, ex);
    } catch (...) {
        if (!interceptorStack.empty()) {
            std::string description = ""Failed to handle "" + message->toString() + "" to "" + this->toString() + "" in "" + this->handler->toString();
            triggerAfterMessageHandled(message,
                std::make_exception_ptr(MessageDeliveryException(message, description, std::current_exception())),
                interceptorStack);
        }
        throw;
    }
}

std::shared_ptr<Message> applyBeforeHandle(std::shared_ptr<Message> message,
    std::deque<std::shared_ptr<ExecutorChannelInterceptor>>& interceptorStack) {
    for (const auto& interceptor : *this->channelInterceptors) {
        if (auto executorInterceptor = std::dynamic_pointer_cast<ExecutorChannelInterceptor>(interceptor)) {
            message = executorInterceptor->beforeHandle(message, this->inputChannel, this->handler);
            if (message == nullptr) {
                if (logger.isDebugEnabled()) {
                    logger.debug(typeid(*executorInterceptor).name() + std::string("" returned null from beforeHandle, i.e. precluding the send.""));
                }
                triggerAfterMessageHandled(nullptr, nullptr, interceptorStack);","void PollingConsumer::handleMessage(std::shared_ptr<Message> message) {
    std::deque<ExecutorChannelInterceptor*> interceptorStack;
    try {
        if (this->channelInterceptors &&
            dynamic_cast<ExecutorChannelInterceptorAware*>(this->inputChannel.get()) &&
            static_cast<ExecutorChannelInterceptorAware*>(this->inputChannel.get())->hasExecutorInterceptors()) {
            message = applyBeforeHandle(message, interceptorStack);
            if (!message) {
                return;
            }
        }
        this->handler->handleMessage(message);
        if (!interceptorStack.empty()) {
            triggerAfterMessageHandled(message, nullptr, interceptorStack);
        }
    }
    catch (const std::exception& ex) {
        if (!interceptorStack.empty()) {
            triggerAfterMessageHandled(message, std::make_exception_ptr(ex), interceptorStack);
        }
        const MessagingException* mex = dynamic_cast<const MessagingException*>(&ex);
        if (mex) {
            throw;
        }
        std::string description = ""Failed to handle "" + message->toString() + "" to "" + this->toString() + "" in "" + this->handler->toString();
        throw MessageDeliveryException(message, description, std::make_exception_ptr(ex));
    }
    catch (...) {
        try {
            throw;
        }
        catch (const std::exception& ex) {
            if (!interceptorStack.empty()) {
                std::string description = ""Failed to handle "" + message->toString() + "" to "" + this->toString() + "" in "" + this->handler->toString();
                triggerAfterMessageHandled(message,
                    std::make_exception_ptr(MessageDeliveryException(message, description, std::make_exception_ptr(ex))),
                    interceptorStack);
            }
            throw;
        }
        catch (...) {
            if (!interceptorStack.empty()) {
                std::string description = ""Failed to handle "" + message->toString() + "" to "" + this->toString() + "" in "" + this->handler->toString();
                triggerAfterMessageHandled(message,
                    std::make_exception_ptr(MessageDeliveryException(message, description, std::current_exception())),
                    interceptorStack);
            }
            throw;
        }
    }
}

std::shared_ptr<Message> PollingConsumer::applyBeforeHandle(std::shared_ptr<Message> message, std::deque<ExecutorChannelInterceptor*>& interceptorStack) {
    for (auto& interceptor : *(this->channelInterceptors)) {
        auto* executorInterceptor = dynamic",1
"#include <filesystem>
#include <vector>
#include <unordered_map>
#include <unordered_set>","#include <filesystem>
#include <fstream>
#include <unordered_map>
#include <unordered_set>
#include <vector>",0
"std::vector<Extension> discovered = extensionDiscoverer.discover(classLoader);
LOGGER.info(""Discovered {} extensions"", discovered.size());
std::for_each(discovered.begin(), discovered.end(),
    [this](const Extension& extension) { registerExtension(extension); });
return extensionRegistry.getExtensions();","```cpp
std::vector<Extension> discovered = extensionDiscoverer.discover(classLoader);
LOGGER.info(""Discovered {} extensions"", discovered.size());

std::for_each(discovered.begin(), discovered.end(),
    [this](const Extension& extension) { registerExtension(extension); });

return extensionRegistry.getExtensions();
```",0
"HoodieTimer restoreTimer;
restoreTimer.startTimer();

auto restoreInstant = table.getRestoreTimeline()
    .filterInflightsAndRequested()
    .filter([&](const HoodieInstant& instant) { return instant.getTimestamp() == instantTime; })
    .firstInstant();

if (!restoreInstant.isPresent()) {
    throw HoodieRollbackException(""No pending restore instants found to execute restore"");
}

try {
    std::vector<HoodieInstant> instantsToRollback = getInstantsToRollback(restoreInstant.get());
    ValidationUtils::checkArgument(
        restoreInstant.get().getState() == HoodieInstant::State::REQUESTED ||
        restoreInstant.get().getState() == HoodieInstant::State::INFLIGHT
    );
    std::unordered_map<std::string, std::vector<HoodieRollbackMetadata>> instantToMetadata;
    if (restoreInstant.get().isRequested()) {
        table.getActiveTimeline().transitionRestoreRequestedToInflight(restoreInstant.get());
    }

    for (const auto& instant : instantsToRollback) {
        instantToMetadata[instant.getTimestamp()] = { rollbackInstant(instant) };
        LOG.info(""Deleted instant "" + instant.toString());
    }

    // Assume finishRestore returns a value as needed by your context
    return finishRestore(
        instantToMetadata,
        instantsToRollback,
        restoreTimer.endTimer()
    );
} catch (const std::ios_base::failure& io) {
    throw HoodieRestoreException(""unable to Restore instant "" + restoreInstant.get().toString(), io);
}

std::vector<HoodieInstant> getInstantsToRollback(const HoodieInstant& restoreInstant) {
    std::vector<HoodieInstant> instantsToRollback;
    HoodieRestorePlan restorePlan = RestoreUtils::getRestorePlan(table.getMetaClient(), restoreInstant);
    for (const HoodieInstantInfo& instantInfo : restorePlan.getInstantsToRollback()) {
        auto rollbackInstantOpt = table.getActiveTimeline().getWriteTimeline()
            .filter([&](const HoodieInstant& instant) {
                return instant.getTimestamp() == instantInfo.getCommitTime() &&
                       instant.getAction() == instantInfo.getAction();
            })
            .firstInstant();
        if (rollbackInstantOpt.isPresent()) {
            instantsToRollback.push_back(rollbackInstantOpt.get());
        } else {
            LOG.warn(""Ignoring already rolledback instant "" + instantInfo.toString());
        }
    }
    return instantsToRollback","```cpp
HoodieTimer restoreTimer;
restoreTimer.startTimer();

auto restoreInstantOpt = table.getRestoreTimeline()
    .filterInflightsAndRequested()
    .filter([&](const HoodieInstant& instant) { return instant.getTimestamp() == instantTime; })
    .firstInstant();

if (!restoreInstantOpt.has_value()) {
    throw HoodieRollbackException(""No pending restore instants found to execute restore"");
}

try {
    std::vector<HoodieInstant> instantsToRollback = getInstantsToRollback(restoreInstantOpt.value());
    ValidationUtils::checkArgument(
        restoreInstantOpt.value().getState() == HoodieInstant::State::REQUESTED ||
        restoreInstantOpt.value().getState() == HoodieInstant::State::INFLIGHT
    );
    std::unordered_map<std::string, std::vector<HoodieRollbackMetadata>> instantToMetadata;
    if (restoreInstantOpt.value().isRequested()) {
        table.getActiveTimeline().transitionRestoreRequestedToInflight(restoreInstantOpt.value());
    }

    for (const auto& instant : instantsToRollback) {
        instantToMetadata[instant.getTimestamp()] = { rollbackInstant(instant) };
        LOG.info(""Deleted instant "" + instant.toString());
    }

    return finishRestore(
        instantToMetadata,
        instantsToRollback,
        restoreTimer.endTimer()
    );
} catch (const IOException& io) {
    throw HoodieRestoreException(""unable to Restore instant "" + restoreInstantOpt.value().toString(), io);
}

std::vector<HoodieInstant> getInstantsToRollback(const HoodieInstant& restoreInstant) {
    std::vector<HoodieInstant> instantsToRollback;
    HoodieRestorePlan restorePlan = RestoreUtils::getRestorePlan(table.getMetaClient(), restoreInstant);
    for (const HoodieInstantInfo& instantInfo : restorePlan.getInstantsToRollback()) {
        auto rollbackInstantOpt = table.getActiveTimeline().getWriteTimeline()
            .filter([&](const HoodieInstant& instant) {
                return instant.getTimestamp() == instantInfo.getCommitTime() &&
                       instant.getAction() == instantInfo.getAction();
            }).firstInstant();
        if (rollbackInstantOpt.has_value()) {
            instantsToRollback.push_back(rollbackInstantOpt.value());
        } else {
            LOG.warn(""Ignoring already rolledback instant "" + instantInfo.toString());
        }
    }
    return instantsToRollback;
}

virtual HoodieRollbackMetadata rollbackInstant(const Hoodie",1
"void onResume() override {
    // Timber.d(""onResume()"");
}","void onResume() override {
    Timber::d(""onResume()"");
}",0
"#include <cassert>
#include ""Latch.h""
#include ""AbstractMuleContextTestCase.h""","#include <cassert>
#include ""Latch.h""
#include ""AbstractMuleContextTestCase.h""",0
"reset(applicationDeploymentListener);

std::filesystem::path configFile = std::filesystem::path(appsDir) / DUMMY_APP_PATH / MULE_CONFIG_XML_FILE;
auto ftime = std::filesystem::last_write_time(configFile);
std::filesystem::last_write_time(configFile, ftime + std::chrono::seconds(1));

assertDeploymentSuccess(applicationDeploymentListener, DUMMY_APP);","std::filesystem::path configFile = std::filesystem::path(appsDir) / DUMMY_APP_PATH / MULE_CONFIG_XML_FILE;
auto ftime = std::filesystem::last_write_time(configFile);
std::filesystem::last_write_time(configFile, ftime + std::chrono::seconds(1));

assertDeploymentSuccess(applicationDeploymentListener, DUMMY_APP);",0
"class FormatConfig
{
public:
    FormatConfig(PanmirrorUIToolsFormat* formatTools)
        : formatTools_(formatTools),
          config_(formatTools_->parseFormatConfig(getEditorCode(), true))
    {
    }

    bool hasChanged()
    {
        PanmirrorPandocFormatConfig config = formatTools_->parseFormatConfig(getEditorCode(), true);
        return !PanmirrorPandocFormatConfig::areEqual(config, config_);
    }

    bool requiresReload()
    {
        PanmirrorPandocFormatConfig config = formatTools_->parseFormatConfig(getEditorCode(), true);
        return !PanmirrorPandocFormatConfig::editorBehaviorConfigEqual(config, config_);
    }

private:
    PanmirrorUIToolsFormat* formatTools_;
    PanmirrorPandocFormatConfig config_;
};","class FormatConfig
{
public:
    FormatConfig(PanmirrorUIToolsFormat* formatTools)
        : formatTools_(formatTools),
          config_(formatTools_->parseFormatConfig(getEditorCode(), true))
    {
    }

    bool hasChanged() const
    {
        auto config = formatTools_->parseFormatConfig(getEditorCode(), true);
        return !PanmirrorPandocFormatConfig::areEqual(config, config_);
    }

    bool requiresReload() const
    {
        auto config = formatTools_->parseFormatConfig(getEditorCode(), true);
        return !PanmirrorPandocFormatConfig::editorBehaviorConfigEqual(config, config_);
    }

private:
    PanmirrorUIToolsFormat* const formatTools_;
    const PanmirrorPandocFormatConfig config_;
};",0
"void flushIfNeeded(const FlushPredicate& flushPredicate) {
    std::map<std::string, FileState> toRemove;
    {
        std::lock_guard<std::mutex> lock(this->mutex_);
        auto iterator = fileStates.begin();
        while (iterator != fileStates.end()) {
            auto& key = iterator->first;
            auto& state = iterator->second;
            if (flushPredicate.shouldFlush(key, state.firstWrite, state.lastWrite)) {
                toRemove.insert({key, state});
                iterator = fileStates.erase(iterator);
            } else {
                ++iterator;
            }
        }
    }
    doFlush(toRemove);
}","void flushIfNeeded(const FlushPredicate& flushPredicate) {
    std::map<std::string, FileState> toRemove;
    {
        std::lock_guard<std::mutex> lock(thisMutex);
        for (auto it = fileStates.begin(); it != fileStates.end(); ) {
            auto& key = it->first;
            auto& state = it->second;
            if (flushPredicate.shouldFlush(key, state.firstWrite, state.lastWrite)) {
                toRemove.emplace(key, std::move(state));
                it = fileStates.erase(it);
            } else {
                ++it;
            }
        }
    }
    doFlush(toRemove);
}",0
"void onActivityResult(int requestCode, int resultCode, Intent* data) override {
    BaseClass::onActivityResult(requestCode, resultCode, data);
}","#include <vector>
#include <string>

class Preferences : public AppCompatPreferenceActivity {
public:
    std::vector<std::string> getNames() {
        return names;
    }

protected:
    void onActivityResult(int requestCode, int resultCode, Intent* data) override {
        AppCompatPreferenceActivity::onActivityResult(requestCode, resultCode, data);
    }

private:
    std::vector<std::string> names;
};",0
"static LongRunningIntegrationTest longTests;

Log4j2LevelAdjuster adjuster = Log4j2LevelAdjuster::trace().categories({""org.springframework.integration.ip""});

void testGoodNetSingle() {","static LongRunningIntegrationTest longTests;

Log4j2LevelAdjuster adjuster = Log4j2LevelAdjuster::trace()
    .categories(""org.springframework.integration.ip"");

void testGoodNetSingle() {
    // ...
}",1
"return downloadState;
}

VMTemplateStoragePoolVO(long poolId, long templateId, const std::string& configuration)
    : poolId(poolId),
      templateId(templateId),
      downloadState(Status::NOT_DOWNLOADED),
      state(ObjectInDataStoreStateMachine::State::Allocated),
      markedForGC(false),
      deploymentOption(configuration) {
}

VMTemplateStoragePoolVO(long poolId, long templateId, const std::chrono::system_clock::time_point& lastUpdated, int downloadPercent, Status downloadState, const std::string& localDownloadPath,
                       const std::string& errorString, const std::string& jobId, const std::string& installPath, long templateSize, const std::string& configuration)
    : poolId(poolId),
      templateId(templateId),
      lastUpdated(lastUpdated),
      downloadPercent(downloadPercent),
      downloadState(downloadState),
      localDownloadPath(localDownloadPath),
      errorString(errorString),
      jobId(jobId),
      installPath(installPath),
      templateSize(templateSize),
      deploymentOption(configuration) {
}","```cpp
class VMTemplateStoragePoolVO : public VMTemplateStorageResourceAssoc {
public:
    VMTemplateStoragePoolVO(long poolId, long templateId, const std::string& configuration)
        : poolId(poolId),
          templateId(templateId),
          downloadState(Status::NOT_DOWNLOADED),
          state(ObjectInDataStoreStateMachine::State::Allocated),
          markedForGC(false),
          deploymentOption(configuration) 
    {
    }

    VMTemplateStoragePoolVO(long poolId, long templateId, const std::chrono::system_clock::time_point& lastUpdated, int downloadPercent,
                            Status downloadState, const std::string& localDownloadPath, const std::string& errorString,
                            const std::string& jobId, const std::string& installPath, long templateSize, const std::string& configuration)
        : poolId(poolId),
          templateId(templateId),
          lastUpdated(lastUpdated),
          downloadPercent(downloadPercent),
          downloadState(downloadState),
          localDownloadPath(localDownloadPath),
          errorString(errorString),
          jobId(jobId),
          installPath(installPath),
          templateSize(templateSize),
          deploymentOption(configuration)
    {
    }

private:
    long poolId;
    long templateId;
    std::chrono::system_clock::time_point lastUpdated;
    int downloadPercent;
    Status downloadState;
    std::string localDownloadPath;
    std::string errorString;
    std::string jobId;
    std::string installPath;
    long templateSize;
    ObjectInDataStoreStateMachine::State state;
    bool markedForGC;
    std::string deploymentOption;
};
```",1
"IR::Instr*
Lowerer::LowerCatch(IR::Instr* instr)
{
    IR::Opnd* catchObj = instr->UnlinkDst();
    IR::RegOpnd* catchParamReg = IR::RegOpnd::New(TyMachPtr, this->m_func);
    catchParamReg->SetReg(CATCH_OBJ_REG);

    instr->SetDst(catchParamReg);

    instr->InsertAfter(IR::Instr::New(Js::OpCode::MOV, catchObj, catchParamReg, this->m_func));

    return instr->m_prev;
}

IR::Instr*
Lowerer::LowerLeave(IR::Instr* leaveInstr, IR::LabelInstr* targetInstr, bool fromFinalLower, bool isOrphanedLeave)
{
    if (isOrphanedLeave)
    {
        Assert(this->m_func->IsLoopBodyInTry());
        leaveInstr->m_opcode = LowererMD::MDUncondBranchOpcode;
        return leaveInstr->m_prev;
    }

    IR::Instr* instrPrev = leaveInstr->m_prev;
    IR::LabelOpnd* labelOpnd = IR::LabelOpnd::New(targetInstr, this->m_func);
    m_lowererMD.LowerEHRegionReturn(leaveInstr, labelOpnd);

    if (fromFinalLower)
    {
        instrPrev = leaveInstr->m_prev;
    }
    leaveInstr->Remove();
    return instrPrev;
}","IR::Instr *
Lowerer::LowerCatch(IR::Instr * instr)
{
    IR::Opnd *catchObj = instr->UnlinkDst();
    auto *catchParamReg = IR::RegOpnd::New(TyMachPtr, this->m_func);
    catchParamReg->SetReg(CATCH_OBJ_REG);

    instr->SetDst(catchParamReg);

    instr->InsertAfter(IR::Instr::New(Js::OpCode::MOV, catchObj, catchParamReg, this->m_func));

    return instr->m_prev;
}

IR::Instr *
Lowerer::LowerLeave(IR::Instr * leaveInstr, IR::LabelInstr * targetInstr, bool fromFinalLower, bool isOrphanedLeave)
{
    if (isOrphanedLeave)
    {
        Assert(this->m_func->IsLoopBodyInTry());
        leaveInstr->m_opcode = LowererMD::MDUncondBranchOpcode;
        return leaveInstr->m_prev;
    }

    IR::Instr * instrPrev = leaveInstr->m_prev;
    auto *labelOpnd = IR::LabelOpnd::New(targetInstr, this->m_func);
    m_lowererMD.LowerEHRegionReturn(leaveInstr, labelOpnd);

    if (fromFinalLower)
    {
        instrPrev = leaveInstr->m_prev;
    }
    leaveInstr->Remove();
    return instrPrev;
}",1
"auto connection = self::connection();

auto calypso_env = self::get_calypso_env();
if (!calypso_env.empty()) {
    args[""calypso_env""] = calypso_env;
}

auto api_url = iframe ? connection->api_url(""authorize_iframe"") : connection->api_url(""authorize"");

return add_query_arg(args, api_url);","auto connection = self::connection();

auto calypso_env = self::get_calypso_env();

if (!calypso_env.empty()) {
    args[""calypso_env""] = calypso_env;
}

std::string api_url = iframe ? connection.api_url(""authorize_iframe"") : connection.api_url(""authorize"");

return add_query_arg(args, api_url);",1
"return FlowId().setFlowGroup(flowGroup).setFlowName(flowName);
}

static long getFlowExecutionId(const Dag<JobExecutionPlan>& dag) {
    return std::stol(dag.getNodes()[0].getValue().getJobSpec().getConfigAsProperties()
        .at(ConfigurationKeys::FLOW_EXECUTION_ID_KEY));
}

static long getFlowExecId(const Dag<JobExecutionPlan>& dag) {
    const Config& jobConfig = dag.getStartNodes()[0].getValue().getJobSpec().getConfig();
    return jobConfig.getLong(ConfigurationKeys::FLOW_EXECUTION_ID_KEY);
}","```cpp
static long getFlowExecutionId(Dag<JobExecutionPlan>& dag) {
    return std::stol(dag.getNodes()[0].getValue().getJobSpec().getConfigAsProperties()
        .at(ConfigurationKeys::FLOW_EXECUTION_ID_KEY));
}

static long getFlowExecId(Dag<JobExecutionPlan>& dag) {
    Config jobConfig = dag.getStartNodes()[0].getValue().getJobSpec().getConfig();
    return jobConfig.getLong(ConfigurationKeys::FLOW_EXECUTION_ID_KEY);
}
```",1
"return JsNoError;
});

CHAKRA_API JsErrorCode JsHasOwnProperty(JsValueRef object, JsPropertyIdRef propertyId, bool* hasOwnProperty)
{
    return ContextAPIWrapper<true>([&](Js::ScriptContext* scriptContext, TTDRecorder& _actionEntryPopper) -> JsErrorCode {
        PERFORM_JSRT_TTD_RECORD_ACTION(scriptContext, RecordJsRTHasOwnProperty, (Js::PropertyRecord*)propertyId, object);

        VALIDATE_INCOMING_OBJECT(object, scriptContext);
        VALIDATE_INCOMING_PROPERTYID(propertyId);
        PARAM_NOT_NULL(hasOwnProperty);
        *hasOwnProperty = false;

        *hasOwnProperty = Js::JavascriptOperators::OP_HasOwnProperty(
            object, 
            static_cast<Js::PropertyRecord*>(propertyId)->GetPropertyId(), 
            scriptContext
        ) != 0;

        return JsNoError;
    });
}","CHAKRA_API JsHasOwnProperty(JsValueRef object, JsPropertyIdRef propertyId, bool *hasOwnProperty)
{
    return ContextAPIWrapper<true>([&](Js::ScriptContext *scriptContext, TTDRecorder& _actionEntryPopper) -> JsErrorCode {
        PERFORM_JSRT_TTD_RECORD_ACTION(scriptContext, RecordJsRTHasOwnProperty, static_cast<Js::PropertyRecord *>(propertyId), object);

        VALIDATE_INCOMING_OBJECT(object, scriptContext);
        VALIDATE_INCOMING_PROPERTYID(propertyId);
        PARAM_NOT_NULL(hasOwnProperty);
        *hasOwnProperty = false;

        *hasOwnProperty = Js::JavascriptOperators::OP_HasOwnProperty(
            object,
            static_cast<Js::PropertyRecord *>(propertyId)->GetPropertyId(),
            scriptContext
        ) != 0;

        return JsNoError;
    });
}",1
"}
 
Assert(nullptr != exoticToPrim);
ThreadContext* threadContext = requestContext->GetThreadContext();
result = threadContext->ExecuteImplicitCall(
    exoticToPrim,
    ImplicitCall_ToPrimitive,
    [=]() -> Js::Var
    {
        // Stack object should have a pre-op bail on implicit call.  We shouldn't see them here.
        Assert(!ThreadContext::IsOnStack(recyclableObject));

        // Let result be the result of calling the [[Call]] internal method of exoticToPrim, with input as thisArgument and (hint) as argumentsList.
        return CALL_FUNCTION(threadContext, exoticToPrim, CallInfo(CallFlags_Value, 2), recyclableObject, hintString);
    }
);

if (!result)
{
    // There was an implicit call and implicit calls are disabled. This would typically cause a bailout.
    Assert(threadContext->IsDisableImplicitCall());
    return requestContext->GetLibrary()->GetNull();
}

Assert(!CrossSite::NeedMarshalVar(result, requestContext));
// If result is an ECMAScript language value and Type(result) is not Object, then return result.
if (TaggedInt::Is(result) || !JavascriptOperators::IsObjectType(JavascriptOperators::GetTypeId(result)))
{","```cpp
if (exoticToPrim != nullptr)
{
    Assert(exoticToPrim != nullptr);
    ThreadContext* threadContext = requestContext->GetThreadContext();
    result = threadContext->ExecuteImplicitCall(
        exoticToPrim,
        ImplicitCall_ToPrimitive,
        [=]() -> Js::Var
        {
            Assert(!ThreadContext::IsOnStack(recyclableObject));
            return CALL_FUNCTION(threadContext, exoticToPrim, CallInfo(CallFlags_Value, 2), recyclableObject, hintString);
        }
    );

    if (!result)
    {
        Assert(threadContext->IsDisableImplicitCall());
        return requestContext->GetLibrary()->GetNull();
    }

    Assert(!CrossSite::NeedMarshalVar(result, requestContext));
    if (TaggedInt::Is(result) || !JavascriptOperators::IsObjectType(JavascriptOperators::GetTypeId(result)))
    {
```",1
"template <typename InT, typename DestT, typename OutT>
static WriteFiles<InT, DestT, OutT> to(
    FileBasedSink<OutT, DestT>* sink,
    std::function<OutT(const InT&)> formatFunction) {
    if (sink == nullptr) {
        throw std::invalid_argument(""sink"");
    }
    return WriteFiles<InT, DestT, OutT>(
        sink,
        formatFunction,
        nullptr, // runner-determined sharding
        nullptr,
        false,
        DEFAULT_MAX_NUM_WRITERS_PER_BUNDLE);
}

template <typename UserT, typename DestinationT, typename OutputT>
WriteFiles<UserT, DestinationT, OutputT>::WriteFiles(
    FileBasedSink<OutputT, DestinationT>* sink,
    std::function<OutputT(const UserT&)> formatFunction,
    PTransform<PCollection<UserT>, PCollectionView<int>>* computeNumShards,
    ValueProvider<int>* numShardsProvider,
    bool windowedWrites,
    int maxNumWritersPerBundle)
    : sink(sink),
      formatFunction([&]{
          if (!formatFunction) throw std::invalid_argument(""formatFunction"");
          return formatFunction;
      }()),
      computeNumShards(computeNumShards),
      numShardsProvider(numShardsProvider),
      windowedWrites(windowedWrites)
{
    // constructor body if needed
}","template <typename InT, typename DestT, typename OutT>
class WriteFiles : public PTransform<PCollection<InT>, PDone> {
public:
    static WriteFiles<InT, DestT, OutT> to(
        FileBasedSink<OutT, DestT>* sink,
        std::function<OutT(const InT&)> formatFunction) {
        assert(sink != nullptr);
        return WriteFiles<InT, DestT, OutT>(
            sink,
            formatFunction,
            nullptr, // runner-determined sharding
            nullptr,
            false,
            DEFAULT_MAX_NUM_WRITERS_PER_BUNDLE
        );
    }

private:
    WriteFiles(
        FileBasedSink<OutT, DestT>* sink,
        std::function<OutT(const InT&)> formatFunction,
        PTransform<PCollection<InT>, PCollectionView<int>>* computeNumShards,
        ValueProvider<int>* numShardsProvider,
        bool windowedWrites,
        int maxNumWritersPerBundle)
        : sink_(sink),
          formatFunction_(formatFunction),
          computeNumShards_(computeNumShards),
          numShardsProvider_(numShardsProvider),
          windowedWrites_(windowedWrites),
          maxNumWritersPerBundle_(maxNumWritersPerBundle) {}

    FileBasedSink<OutT, DestT>* sink_;
    std::function<OutT(const InT&)> formatFunction_;
    PTransform<PCollection<InT>, PCollectionView<int>>* computeNumShards_;
    ValueProvider<int>* numShardsProvider_;
    bool windowedWrites_;
    int maxNumWritersPerBundle_;
};",1
"void onCancel(const GrpcStatus& status) override {
    if (getState().allowSendReset()) {
        getState().setResetSend();
        getTransportSubscriber().onCancel(status);
    }
}","virtual void onCancel(const GrpcStatus& status) override {
    if (getState().allowSendReset()) {
        getState().setResetSend();
        getTransportSubscriber().onCancel(status);
    }
}",1
"#include <string>
#include <atomic>

class RayServeReplica {
private:
    static inline auto LOGGER = spdlog::get(""RayServeReplica"");

    std::string DeploymentTag;
    std::string replicaTag;
    DeploymentConfig config;
    std::atomic<int> numOngoingRequests{0};
};","#include <string>
#include <atomic>
#include <memory>

class DeploymentConfig;

class RayServeReplica {
private:
    static inline const std::string LOGGER = ""RayServeReplica"";
    
    std::string DeploymentTag;
    std::string replicaTag;
    std::shared_ptr<DeploymentConfig> config;
    std::atomic<int> numOngoingRequests{0};
};",1
"Path makeTempPath(const std::string& partitionPath, int taskPartitionId, const std::string& fileName, int stageId, long taskAttemptId) {
    Path path(config.getBasePath(), HoodieTableMetaClient::TEMPFOLDER_NAME);
    return Path(path.toString(), FSUtils::makeTempDataFileName(partitionPath, commitTime, taskPartitionId, fileName, stageId, taskAttemptId));
}","Path makeTempPath(const std::string& partitionPath, int taskPartitionId, const std::string& fileName, int stageId, long taskAttemptId) {
    Path path(config.getBasePath(), HoodieTableMetaClient::TEMPFOLDER_NAME);
    return Path(path.toString(),
        FSUtils::makeTempDataFileName(partitionPath, commitTime, taskPartitionId, fileName, stageId, taskAttemptId));
}",1
"this->props.setProperty(
    ConfigurationKeys::JOB_TRACKING_URL_KEY, 
    conf.get(AZKABAN_LINK_JOBEXEC_URL).value_or("""")
);

if (props.containsKey(JOB_TYPE) && JOB_TYPES_WITH_AUTOMATIC_TOKEN.count(props.getProperty(JOB_TYPE))) {
    LOG.info(""Job type "" + props.getProperty(JOB_TYPE) + "" provides Hadoop tokens automatically. Using provided tokens."");
    if (const char* tokenFileLoc = std::getenv(HADOOP_TOKEN_FILE_LOCATION); tokenFileLoc != nullptr) {
        this->props.setProperty(MAPREDUCE_JOB_CREDENTIALS_BINARY, tokenFileLoc);
    }
} else {
    LOG.info(
        fmt::format(""Job type {} does not provide Hadoop tokens. Negotiating Hadoop tokens."",
                    props.getProperty(JOB_TYPE))
    );
    std::filesystem::path tokenFile = TokenUtils::getHadoopTokens(State(props));
    std::string tokenFilePath = tokenFile.string();
    std::setenv(HADOOP_TOKEN_FILE_LOCATION, tokenFilePath.c_str(), 1);
    std::setenv(MAPREDUCE_JOB_CREDENTIALS_BINARY, tokenFilePath.c_str(), 1);
    this->props.setProperty(MAPREDUCE_JOB_CREDENTIALS_BINARY, tokenFilePath);
    this->props.setProperty(""env."" + std::string(HADOOP_TOKEN_FILE_LOCATION), tokenFilePath);
}

std::vector<std::shared_ptr<TagBase>> tags;","```cpp
this->props.setProperty(
    ConfigurationKeys::JOB_TRACKING_URL_KEY, conf.get(AZKABAN_LINK_JOBEXEC_URL) ? conf.get(AZKABAN_LINK_JOBEXEC_URL) : """");

if (props.containsKey(JOB_TYPE) && JOB_TYPES_WITH_AUTOMATIC_TOKEN.count(props.getProperty(JOB_TYPE)) > 0) {
    LOG.info(""Job type "" + props.getProperty(JOB_TYPE) + "" provides Hadoop tokens automatically. Using provided tokens."");

    const char* tokenLoc = std::getenv(HADOOP_TOKEN_FILE_LOCATION.c_str());
    if (tokenLoc != nullptr) {
        this->props.setProperty(MAPREDUCE_JOB_CREDENTIALS_BINARY, tokenLoc);
    }
} else {
    LOG.info(fmt::format(""Job type {} does not provide Hadoop tokens. Negotiating Hadoop tokens."",
        props.getProperty(JOB_TYPE)));

    File tokenFile = TokenUtils::getHadoopTokens(State(props));
    std::string tokenPath = tokenFile.getAbsolutePath();

    std::setenv(HADOOP_TOKEN_FILE_LOCATION.c_str(), tokenPath.c_str(), 1);
    std::setenv(MAPREDUCE_JOB_CREDENTIALS_BINARY.c_str(), tokenPath.c_str(), 1);

    this->props.setProperty(MAPREDUCE_JOB_CREDENTIALS_BINARY, tokenPath);
    this->props.setProperty(""env."" + HADOOP_TOKEN_FILE_LOCATION, tokenPath);
}

std::vector<std::shared_ptr<TagBase>> tags;
```",1
"#include <cstdint>

std::uint64_t getTotalPhysicalMemory() {
#ifdef _WIN32
    MEMORYSTATUSEX status;
    status.dwLength = sizeof(status);
    GlobalMemoryStatusEx(&status);
    return static_cast<std::uint64_t>(status.ullTotalPhys);
#elif defined(__APPLE__)
    int64_t mem = 0;
    size_t len = sizeof(mem);
    sysctlbyname(""hw.memsize"", &mem, &len, nullptr, 0);
    return static_cast<std::uint64_t>(mem);
#elif defined(__linux__)
    struct sysinfo info;
    if (sysinfo(&info) == 0) {
        return static_cast<std::uint64_t>(info.totalram) * info.mem_unit;
    }
    return 0;
#else
    return 0;
#endif
}",virtual uint64_t getTotalPhysicalMemorySize() const = 0;,0
"}
return map;
}

JpmRepo* getLibrary() {
    if (libraryx == nullptr) {
        HttpClient* client = registry->getPlugin<HttpClient>();
        libraryx = JSONRPCProxy::createRPC<JpmRepo>(
            client,
            URI(""http://repo.jpm4j.org/"" + JSONRPCProxy::JSONRPC_2_0 + ""jpm"")
        );
    }
    return libraryx;
}

bool doJpm(const URI& uri) {
    std::smatch m;
    std::string uriStr = uri.toString();
    if (std::regex_match(uriStr, m, JPM_REVISION_URL_PATTERN_P)) {
        try {
            std::vector<uint8_t> sha1 = Hex::toByteArray(m.str(""sha""));
            auto* revision = getLibrary()->getRevision(sha1);
            if (revision != nullptr) {
                Archive a = Program::valueOf(revision->groupId, revision->artifactId)
                    .version(revision->version)
                    .archive(""jar"", revision->classifier);
                index.push_back(a);
                return true;
            }
        } catch (const std::exception& e) {
            reporter->exception(e, ""Cannot drop JPM "", uri);
        }
    }
    return false;
}","JpmRepo* getLibrary() {
    if (libraryx == nullptr) {
        HttpClient* client = registry.getPlugin<HttpClient>();
        libraryx = JSONRPCProxy::createRPC<JpmRepo>(
            client,
            std::make_unique<URI>(""http://repo.jpm4j.org/"" + std::string(JSONRPCProxy::JSONRPC_2_0) + ""jpm"")
        );
    }
    return libraryx;
}

bool doJpm(const URI& uri) {
    std::smatch m;
    std::regex pattern(JPM_REVISION_URL_PATTERN_P);
    if (std::regex_match(uri.toString(), m, pattern)) {
        try {
            std::vector<uint8_t> sha1 = Hex::toByteArray(m.str(""sha""));
            auto revision = getLibrary()->getRevision(sha1);
            if (revision != nullptr) {
                Archive a = Program::valueOf(revision->groupId, revision->artifactId)
                                .version(revision->version)
                                .archive(""jar"", revision->classifier);
                index.insert(a);
                return true;
            }
        } catch (const std::exception& e) {
            reporter.exception(e, ""Cannot drop JPM "", uri);
        }
    }
    return false;
}",0
"#include <set>
#include <string>

class MyClass {
public:
    std::set<std::string> getCellMenuPlugins() {
        return cellMenuPlugins;
    }
private:
    std::set<std::string> cellMenuPlugins;
};","#include <set>
#include <string>

class UtilRest {
public:
    std::set<std::string> getCellMenuPlugins() {
        return cellMenuPlugins;
    }

private:
    std::set<std::string> cellMenuPlugins;
};",0
"BigtableSource* splitAtFraction(double fraction) {
    std::lock_guard<std::mutex> lock(mutex_);
    ByteKey splitKey;
    try {
        splitKey = rangeTracker.getRange().interpolateKey(fraction);
    } catch (const std::invalid_argument&) {
        logger.info(""%s: Failed to interpolate key for fraction %s."", rangeTracker.getRange().toString().c_str(), std::to_string(fraction).c_str());
        return nullptr;
    }
    logger.debug(""%s: Successfully interpolated key for fraction %s."", rangeTracker.getRange().toString().c_str(), std::to_string(fraction).c_str());
    // Additional code to create and return a BigtableSource would go here
    return nullptr;
}","BigtableSource* splitAtFraction(double fraction) {
    std::lock_guard<std::mutex> lock(mutex_);
    ByteKey splitKey;
    try {
        splitKey = rangeTracker.getRange().interpolateKey(fraction);
    } catch (const std::invalid_argument& e) {
        logger.info(""%s: Failed to interpolate key for fraction %f."", rangeTracker.getRange().toString().c_str(), fraction);
        return nullptr;
    }
    logger.debug(""%s: Successfully interpolated key at fraction %f."", rangeTracker.getRange().toString().c_str(), fraction);
    // ... (rest of function as needed)
}",1
"```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <string>
#include <memory>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <cstdlib>

// Forward declarations or include appropriate C++ headers for types/classes below
class HttpListener {};
class HttpListenerBuilder {};
class HttpListenerConfig {};
class DefaultHttpListenerConfig {};
class HttpListenerConnectionManager {};
class ServerAddress {};
class TlsContextFactory {};
class Flow {};

using ::testing::_;
using ::testing::Return;
using ::testing::NiceMock;

class DynamicPort {
public:
    DynamicPort(const std::string&) {
        // Assign a random free port for testing purposes
        port_ = 10000 + (std::rand() % 50000);
    }
    int getValue() const {
        return port_;
    }
private:
    int port_;
};

class HttpListenerBuilderTestCase : public ::testing::Test {
protected:
    static std::unique_ptr<struct sockaddr_in> TEST_URL;
    static constexpr const char* PATH = ""somePath"";
    static constexpr const char* HOST = ""localhost"";
    static constexpr const char* IP = ""127.0.0.1"";

    DynamicPort port = DynamicPort(""port"");

    std::shared_ptr<NiceMock<TlsContextFactory>> mockTlsContextFactory;
    std::shared_ptr<NiceMock<DefaultHttpListenerConfig>> mockListenerConfig;
    std::shared_ptr<NiceMock<Flow>> mockFlow;

    static void SetUpTestSuite() {
        // For demonstration, TEST_URL as sockaddr_in analog
        TEST_URL = std::make_unique<sockaddr_in>();
        TEST_URL->sin_family = AF_INET;
        TEST_URL->sin_port = htons(80);
        inet_pton(AF_INET, IP, &(TEST_URL->sin_addr));
    }

    void SetUp() override {
        mockTlsContextFactory = std::make_shared<NiceMock<TlsContextFactory>>();
        mockListenerConfig = std::make_shared<NiceMock<DefaultHttpListenerConfig>>();
        mockFlow = std::make_shared<NiceMock<Flow>>();
    }
};

std::unique_ptr<struct sockaddr_in> HttpListenerBuilderTestCase::TEST_URL = nullptr;
constexpr const char* HttpListenerBuilderTestCase::PATH;
constexpr const char* HttpListenerBuilderTestCase::HOST;
constexpr const char* HttpListenerBuilderTestCase::IP;

```","#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <string>
#include <memory>

using ::testing::_;
using ::testing::Return;
using ::testing::NiceMock;

class TlsContextFactory {};
class DefaultHttpListenerConfig {};
class Flow {};

class DynamicPort {
public:
    explicit DynamicPort(const std::string& name) : port_name(name), value_(1000) {}
    int value() const { return value_; }
    std::string port_name;
private:
    int value_;
};

class HttpListenerBuilderTestCase : public ::testing::Test {
protected:
    static std::unique_ptr<std::string> TEST_URL;
    static const std::string PATH;
    static const std::string HOST;
    static const std::string IP;

    DynamicPort port{""port""};

    std::shared_ptr<NiceMock<TlsContextFactory>> mockTlsContextFactory = std::make_shared<NiceMock<TlsContextFactory>>();
    std::shared_ptr<NiceMock<DefaultHttpListenerConfig>> mockListenerConfig = std::make_shared<NiceMock<DefaultHttpListenerConfig>>();
    std::shared_ptr<NiceMock<Flow>> mockFlow = std::make_shared<NiceMock<Flow>>();

    static void SetUpTestSuite() {
        // Equivalent static initialization can be placed here if needed
    }
};

std::unique_ptr<std::string> HttpListenerBuilderTestCase::TEST_URL;
const std::string HttpListenerBuilderTestCase::PATH = ""somePath"";
const std::string HttpListenerBuilderTestCase::HOST = ""localhost"";
const std::string HttpListenerBuilderTestCase::IP = ""127.0.0.1"";",1
"auto gridEntry = GetGridEntryFromRow(selectedRow);
if (gridEntry != nullptr)
{
    gridEntry->AccessibilityObject->InternalRaiseAutomationNotification(
        Automation::AutomationNotificationKind::Other,
        Automation::AutomationNotificationProcessing::CurrentThenMostRecent,
        SR::PropertyGridViewGridEntryExpandedStateDescription
    );
}

try
{","auto gridEntry = GetGridEntryFromRow(selectedRow);
if (gridEntry != nullptr)
{
    gridEntry->AccessibilityObject->InternalRaiseAutomationNotification(
        Automation::AutomationNotificationKind::Other,
        Automation::AutomationNotificationProcessing::CurrentThenMostRecent,
        SR::PropertyGridViewGridEntryExpandedStateDescription
    );
}

try
{",1
"```cpp
Class* loadClass(Module* module, const std::string& className) {
    Class* localClass = nullptr;

    if ((bootstrapClassLoader == nullptr) || (this == bootstrapClassLoader)) {
        localClass = VMAccess::findClassOrNull(className, bootstrapClassLoader);
    } else {
        try {
            localClass = loadClassHelper(className, false, false, module);
        } catch (const ClassNotFoundException&) {
            // returns nullptr if the class can't be found
        }
    }
    return localClass;
}
```","```cpp
Class* loadClass(Module* module, const std::string& className) {
    Class* localClass = nullptr;

    if ((bootstrapClassLoader == nullptr) || (this == bootstrapClassLoader)) {
        localClass = VMAccess::findClassOrNull(className, bootstrapClassLoader);
    } else {
        try {
            localClass = loadClassHelper(className, false, false, module);
        } catch (const ClassNotFoundException&) {
            // returns nullptr if the class can't be found
        }
    }
    return localClass;
}
```",1
"this->readBlocksLazily = readBlocksLazily;
this->reverseLogReader = reverseLogReader;
this->bufferSize = bufferSize;
this->prevReadersInOpenState = std::vector<std::shared_ptr<HoodieLogFileReader>>();
if (!logFiles.empty()) {
    HoodieLogFile nextLogFile = logFiles.front();
    logFiles.erase(logFiles.begin());
    this->currentReader = std::make_shared<HoodieLogFileReader>(fs, nextLogFile, readerSchema, bufferSize, readBlocksLazily, false);
}","this->readBlocksLazily = readBlocksLazily;
this->reverseLogReader = reverseLogReader;
this->bufferSize = bufferSize;
this->prevReadersInOpenState = std::vector<std::shared_ptr<HoodieLogFileReader>>();
if (!logFiles.empty()) {
    HoodieLogFile nextLogFile = logFiles.front();
    logFiles.erase(logFiles.begin());
    this->currentReader = std::make_shared<HoodieLogFileReader>(fs, nextLogFile, readerSchema, bufferSize, readBlocksLazily, false);
}",1
"{
    auto it = methods.find(operation.getName());
    Element* method = (it != methods.end()) ? &it->second : nullptr;
    if (method == nullptr)
    {
        continue;
    }","Element* method = methods[operation.getName()];

if (method == nullptr)
{
    continue;
}",0
"#include <vector>
#include <deque>
#include <algorithm>","#include <vector>
#include <deque>
#include <algorithm>",0
"```cpp
static std::vector<FunctionArg> wrap(const std::vector<std::any> &args, Language language) {
    std::vector<FunctionArg> ret;
    for (const auto &arg : args) {
        ObjectId id;
        std::shared_ptr<NativeRayObject> value;
        if (arg.type() == typeid(RayObject)) {
            id = std::any_cast<RayObject>(arg).getId();
        } else {
            value = ObjectSerializer::serialize(arg);
            if (value->data.size() > LARGEST_SIZE_PASS_BY_VALUE) {
                // Do nothing since we are not support pass by reference in direct call.
            }
        }
        if (language == Language::PYTHON) {
            // (assume rest of function continues...)
        }
    }
    // (assume return and rest of function logic is implemented as needed)
    return ret;
}
```","```cpp
#include <vector>
#include <stdexcept>

enum class Language { PYTHON, JAVA };

const size_t LARGEST_SIZE_PASS_BY_VALUE = /* set appropriately */;

class ObjectId {
  // implementation
};

class NativeRayObject {
public:
    std::vector<uint8_t> data;
    // implementation
};

class RayObject {
public:
    ObjectId getId() const;
    // implementation
};

class FunctionArg {
public:
    static FunctionArg FromObjectId(const ObjectId &id, Language language);
    static FunctionArg FromNativeRayObject(const NativeRayObject &value);
    // implementation
};

class ObjectSerializer {
public:
    static NativeRayObject serialize(const void* arg);
    // implementation
};

template<typename ArgType>
FunctionArg wrapArg(const ArgType& arg, Language language) {
    ObjectId id;
    NativeRayObject value;
    if constexpr (std::is_base_of<RayObject, ArgType>::value) {
        id = arg.getId();
        if (language == Language::PYTHON) {
            return FunctionArg::FromObjectId(id, language);
        } else {
            return FunctionArg::FromObjectId(id, language);
        }
    } else {
        value = ObjectSerializer::serialize(&arg);
        if (value.data.size() > LARGEST_SIZE_PASS_BY_VALUE) {
            // Do nothing since we are not support pass by reference in direct call.
        }
        if (language == Language::PYTHON) {
            return FunctionArg::FromNativeRayObject(value);
        } else {
            return FunctionArg::FromNativeRayObject(value);
        }
    }
}

template<typename... Args>
std::vector<FunctionArg> wrap(const std::tuple<Args...>& args, Language language) {
    std::vector<FunctionArg> ret;
    std::apply([&ret, language](const auto&... elems) {
        (ret.push_back(wrapArg(elems, language)), ...);
    }, args);
    return ret;
}
```",1
"return file;
}

FindResultContext::FindResultContext()
{
    findResults_ = std::vector<FindResult>();
}

int FindResultContext::getMaxLineWidth() const
{
    return maxLineWidth_;
}","FindResultContext()
    : findResults_()
{
}",1
"```cpp
WindowedSplitResult calculateRestrictionSize(
    const WindowedSplitResult& splitResult,
    const std::string& errorContext) 
{
    double fullSize =
        splitResult.getResidualInUnprocessedWindowsRoot() == nullptr &&
        splitResult.getPrimaryInFullyProcessedWindowsRoot() == nullptr
            ? 0
            : doFnInvoker.invokeGetSize(
                DelegatingArgumentProvider<InputT, OutputT>(
                    processContext, errorContext,
                    [&] { return currentRestriction; },
                    [&] { return doFnInvoker.invokeNewTracker(this); }
                )
            );

    double primarySize =
        splitResult.getPrimarySplitRoot() == nullptr
            ? 0
            : doFnInvoker.invokeGetSize(
                DelegatingArgumentProvider<InputT, OutputT>(
                    processContext, errorContext,
                    [&] { 
                        auto value = splitResult.getPrimarySplitRoot()->getValue();
                        return std::get<0>(std::get<1>(value)); 
                    },
                    [&] { return doFnInvoker.invokeNewTracker(this); }
                )
            );

    double residualSize =
        splitResult.getResidualSplitRoot() == nullptr
            ? 0
            : doFnInvoker.invokeGetSize(
                DelegatingArgumentProvider<InputT, OutputT>(
                    processContext, errorContext,
                    [&] { 
                        auto value = splitResult.getResidualSplitRoot()->getValue();
                        return std::get<0>(std::get<1>(value)); 
                    },
                    [&] { return doFnInvoker.invokeNewTracker(this); }
                )
            );

    return WindowedSplitResult::forRoots(
        splitResult.getPrimaryInFullyProcessedWindowsRoot() == nullptr
            ? nullptr
            : WindowedValue::of(
                make_kv(splitResult.getPrimaryInFullyProcessedWindowsRoot()->getValue(), fullSize),
                splitResult.getPrimaryInFullyProcessedWindowsRoot()->getTimestamp(),
                splitResult.getPrimaryInFullyProcessedWindowsRoot()->getWindows(),
                splitResult.getPrimaryInFullyProcessedWindowsRoot()->getPane()
            ),
        splitResult.getPrimarySplitRoot() == nullptr
            ? nullptr
            : WindowedValue::of(
                make_kv(splitResult.getPrimarySplitRoot()->getValue(), primarySize),
                splitResult.getPrimarySplitRoot()->getTimestamp(),
                splitResult.getPrimarySplitRoot()->getWindows(),
                splitResult.getPrimarySplitRoot()->getPane()
            ),
        splitResult.getResidual","template <typename InputT, typename RestrictionT, typename PositionT, typename WatermarkEstimatorStateT, typename OutputT>
WindowedSplitResult calculateRestrictionSize(
    const WindowedSplitResult& splitResult, const std::string& errorContext) {
    double fullSize =
        splitResult.getResidualInUnprocessedWindowsRoot() == nullptr
                && splitResult.getPrimaryInFullyProcessedWindowsRoot() == nullptr
            ? 0
            : doFnInvoker->invokeGetSize(
                DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext)
                    .withRestriction([this]() { return currentRestriction; })
                    .withRestrictionTracker([this](auto&& self) { return doFnInvoker->invokeNewTracker(self); })
              );
    double primarySize =
        splitResult.getPrimarySplitRoot() == nullptr
            ? 0
            : doFnInvoker->invokeGetSize(
                DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext)
                  .withRestriction([&]() {
                    auto val = splitResult.getPrimarySplitRoot()->getValue();
                    return std::get<1>(std::get<1>(val)).first; // as per ((KV<?, KV<?, ?>>)...).getValue().getKey()
                  })
                  .withRestrictionTracker([this](auto&& self) { return doFnInvoker->invokeNewTracker(self); })
              );
    double residualSize =
        splitResult.getResidualSplitRoot() == nullptr
            ? 0
            : doFnInvoker->invokeGetSize(
                DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext)
                  .withRestriction([&]() {
                    auto val = splitResult.getResidualSplitRoot()->getValue();
                    return std::get<1>(std::get<1>(val)).first;
                  })
                  .withRestrictionTracker([this](auto&& self) { return doFnInvoker->invokeNewTracker(self); })
              );
    return WindowedSplitResult::forRoots(
        splitResult.getPrimaryInFullyProcessedWindowsRoot() == nullptr
            ? nullptr
            : WindowedValue::of(
                std::make_pair(splitResult.getPrimaryInFullyProcessedWindowsRoot()->getValue(), fullSize),
                splitResult.getPrimaryInFullyProcessedWindowsRoot()->getTimestamp(),
                splitResult.getPrimaryInFullyProcessedWindowsRoot()->getWindows(),
                splitResult.getPrimaryInFullyProcessedWindowsRoot()->getPane()),
        splitResult.getPrimarySplit",1
"void onSaveInstanceState(Bundle& outState) override {
    outState.putAll(getTempModel().toBundle());
    outState.putLong(""modelId"", mModelId);
    outState.putLong(""noteId"", mNoteId);
    outState.putInt(""ordId"", mOrdId);
    SuperClass::onSaveInstanceState(outState);
}","void onSaveInstanceState(Bundle& outState) override {
    outState.putAll(getTempModel().toBundle());
    outState.putLong(""modelId"", mModelId);
    outState.putLong(""noteId"", mNoteId);
    outState.putInt(""ordId"", mOrdId);
    AnkiActivity::onSaveInstanceState(outState);
}",0
"class RepositionField : public TaskDelegate<void, bool> {
private:
    Model& mModel;
    nlohmann::json mField;
    int mIndex;
public:
    RepositionField(Model& model, const nlohmann::json& field, int index)
        : mModel(model), mField(field), mIndex(index) {}
};","template<typename VoidType, typename ResultType>
class TaskDelegate {
    // ...
};

class Model;
class JSONObject;

class RepositionField : public TaskDelegate<void, bool> {
private:
    Model* mModel;
    JSONObject* mField;
    int mIndex;
public:
    RepositionField(Model* model, JSONObject* field, int index)
        : mModel(model), mField(field), mIndex(index) {}
    // ...
};",0
"#include <string>
#include <optional>

class Config {
public:
    [[deprecated(""Use getString instead."")]]
    std::string getProperty(const std::string& name, const std::string& defaultValue) {
        return getRawProperty(name, defaultValue);
    }

    std::optional<std::string> getString(const std::string& name) {
        return getRawProperty(name, std::nullopt);
    }

    std::string getString(const std::string& name, const std::string& defaultValue) {
        return getRawProperty(name, defaultValue);
    }

    // next method(s) would go here...

private:
    // Example stub; adapt as needed for actual implementation
    std::string getRawProperty(const std::string& name, const std::string& defaultValue) {
        // ...
        return defaultValue;
    }

    std::optional<std::string> getRawProperty(const std::string& name, std::nullopt_t) {
        // ...
        return std::nullopt;
    }
};","```cpp
#include <optional>
#include <string>

class Config {
public:
    // Deprecated: Use getString instead.
    std::string getProperty(const std::string& name, const std::string& defaultValue) {
        return getRawProperty(name, defaultValue);
    }

    // Returns string property or std::nullopt if not configured.
    std::optional<std::string> getString(const std::string& name) {
        auto result = getRawPropertyOpt(name);
        if (result.has_value())
            return result;
        return std::nullopt;
    }

    // Returns string property or defaultValue if not configured.
    std::string getString(const std::string& name, const std::string& defaultValue) {
        return getRawProperty(name, defaultValue);
    }

protected:
    virtual std::string getRawProperty(const std::string& name, const std::string& defaultValue) = 0;
    virtual std::optional<std::string> getRawPropertyOpt(const std::string& name) = 0;
};
```",1
"auto persistedOrderingVal = getNestedFieldVal(static_cast<GenericRecord*>(currentValue),
    properties.getProperty(HoodiePayloadProps::PAYLOAD_ORDERING_FIELD_PROP_KEY), true);

auto incomingOrderingVal = getNestedFieldVal(static_cast<GenericRecord*>(incomingRecord),
    properties.getProperty(HoodiePayloadProps::PAYLOAD_ORDERING_FIELD_PROP_KEY), true);

return !persistedOrderingVal || (*static_cast<Comparable*>(persistedOrderingVal)).compareTo(incomingOrderingVal) <= 0;","```cpp
#include <any>
#include <string>
#include <map>
#include <memory>

class GenericRecord {};
class HoodiePayloadProps {
public:
    static constexpr const char* PAYLOAD_ORDERING_FIELD_PROP_KEY = ""payload.ordering.field"";
};

class Properties {
public:
    std::string getProperty(const std::string& key) const {
        auto it = props.find(key);
        return it != props.end() ? it->second : """";
    }
    std::map<std::string, std::string> props;
};

class ComparableAny {
public:
    virtual ~ComparableAny() = default;
    virtual int compareTo(const ComparableAny& other) const = 0;
};

std::shared_ptr<ComparableAny> getNestedFieldVal(
    const GenericRecord* record,
    const std::string& fieldName,
    bool someFlag
);

class DefaultHoodieRecordPayload /*: public OverwriteWithLatestAvroPayload*/ {
public:
    bool preCombine(const GenericRecord* currentValue,
                    const GenericRecord* incomingRecord,
                    const Properties& properties) {
        auto persistedOrderingVal = getNestedFieldVal(
            currentValue,
            properties.getProperty(HoodiePayloadProps::PAYLOAD_ORDERING_FIELD_PROP_KEY),
            true
        );
        auto incomingOrderingVal = getNestedFieldVal(
            incomingRecord,
            properties.getProperty(HoodiePayloadProps::PAYLOAD_ORDERING_FIELD_PROP_KEY),
            true
        );
        if (!persistedOrderingVal) {
            return true;
        }
        return persistedOrderingVal->compareTo(*incomingOrderingVal) <= 0;
    }
};
```",1
"#include ""FlowConstruct.h""
#include ""Pipeline.h""
#include ""FlowCallStack.h""
#include ""InternalMessage.h""
#include ""ProcessingDescriptor.h""
#include ""SecurityContext.h""
#include ""TransformerException.h""","#include ""ReplyToHandler.h""
#include ""FlowConstruct.h""
#include ""Pipeline.h""
#include ""FlowCallStack.h""
#include ""InternalMessage.h""
#include ""ProcessingDescriptor.h""
#include ""SecurityContext.h""
#include ""TransformerException.h""",0
"#include <iostream>
#include <ostream>
#include <string>","#include <iostream>
#include <ostream>
#include <memory>
#include <string>",0
"return nullptr;
}

static Workspace* getWorkspace(std::filesystem::path workspaceDir, const std::string& bndDir) {
    workspaceDir = std::filesystem::absolute(workspaceDir);","static Workspace* getWorkspace(std::filesystem::path workspaceDir, const std::string& bndDir) {
    workspaceDir = std::filesystem::absolute(workspaceDir);

    // the cnf directory can actually be a
    // file that redirects
    return nullptr;
}",0
"OpenIndicesInfo open() {
    std::set<IndexStatistics> indicesStats = indices.getIndicesStats();

    std::unordered_map<std::string, IndexInfo> indexInfos;","```cpp
class IndicesResource : public RestResource {
public:
    OpenIndicesInfo open() {
        std::set<IndexStatistics> indicesStats = indices.getIndicesStats();

        std::map<std::string, IndexInfo> indexInfos;
        // ...
    }
};
```",1
"}
}

/**
 * List HL7v2 messages in HL7v2 Stores with optional filter.
 *
 * This transform is optimized for splitting of message.list calls for large batches of
 * historical data and assumes rather continuous stream of sendTimes.
 *
 * Note on Benchmarking: By default, this will make more queries than necessary when used with
 * very small data sets (or very sparse data sets in the sendTime dimension). If you are looking
 * to get an accurate benchmark be sure to use sufficient volume of data with messages that span
 * sendTimes over a realistic time range (days)
 *
 * Implementation includes overhead for:
 *
 * 1. two api calls to determine the min/max sendTime of the HL7v2 store at invocation time.
 * 2. initial splitting into non-overlapping time ranges (default daily) to achieve
 *    parallelization in separate messages.list calls.
 *
 * If your use case doesn't lend itself to daily splitting, you can can control initial splitting
 * with ListHL7v2Messages::withInitialSplitDuration(std::chrono::duration)
 */
class ListHL7v2Messages : public PTransform<PBegin, PCollection<HL7v2Message>> {
public:
    ListHL7v2Messages(
        std::shared_ptr<ValueProvider<std::vector<std::string>>> hl7v2Stores,
        std::shared_ptr<ValueProvider<std::string>> filter)
        : hl7v2Stores_(std::move(hl7v2Stores)),
          filter_(std::move(filter)),
          initialSplitDuration_(std::chrono::hours(24)) {}

private:
    std::shared_ptr<ValueProvider<std::vector<std::string>>> hl7v2Stores_;
    std::shared_ptr<ValueProvider<std::string>> filter_;
    std::chrono::duration<int64_t> initialSplitDuration_;
};","#include <vector>
#include <string>
#include <memory>
#include <functional>
#include <optional>
#include <chrono>

template <typename T>
class ValueProvider {
public:
    virtual T get() const = 0;
    virtual ~ValueProvider() = default;
};

template <typename T>
class StaticValueProvider : public ValueProvider<T> {
    T value;
public:
    StaticValueProvider(const T& v) : value(v) {}
    T get() const override { return value; }
};

class HL7v2Message {};

template <typename InputT, typename OutputT>
class PTransform {
public:
    virtual OutputT expand(const InputT& input) const = 0;
    virtual ~PTransform() = default;
};

class PBegin {};
template <typename T>
class PCollection {};

class ListHL7v2Messages : public PTransform<PBegin, PCollection<HL7v2Message>> {
private:
    std::shared_ptr<ValueProvider<std::vector<std::string>>> hl7v2Stores;
    std::shared_ptr<ValueProvider<std::string>> filter;
    std::optional<std::chrono::milliseconds> initialSplitDuration;

public:
    ListHL7v2Messages(
        std::shared_ptr<ValueProvider<std::vector<std::string>>> hl7v2Stores_,
        std::shared_ptr<ValueProvider<std::string>> filter_
    )
    : hl7v2Stores(std::move(hl7v2Stores_)), filter(std::move(filter_)), initialSplitDuration(std::nullopt)
    {}

    // Additional methods (e.g., withInitialSplitDuration) would be here

    PCollection<HL7v2Message> expand(const PBegin& input) const override {
        // Implementation goes here
        return PCollection<HL7v2Message>();
    }

    ListHL7v2Messages& withInitialSplitDuration(std::chrono::milliseconds duration) {
        initialSplitDuration = duration;
        return *this;
    }
};",1
"```cpp
#include <optional>
#include <vector>
#include <string>
#include <algorithm>

class HoodieTimeline {
public:
    static constexpr int LESSER_OR_EQUAL = 0;
    static constexpr int LESSER = -1;

    static int compareTimestamps(const std::string& t1, const std::string& t2, int comparisonType) {
        if (comparisonType == LESSER_OR_EQUAL) {
            return t1 <= t2;
        } else if (comparisonType == LESSER) {
            return t1 < t2;
        }
        return false;
    }
};

class FileSlice {
public:
    std::string getBaseInstantTime() const;
};

class MyClass {
public:
    std::vector<FileSlice> getAllFileSlices() const;

    std::optional<FileSlice> getLatestFileSliceBeforeOrOn(const std::string& maxCommitTime) {
        auto slices = getAllFileSlices();
        auto it = std::find_if(slices.begin(), slices.end(),
            [&](const FileSlice& slice) {
                return HoodieTimeline::compareTimestamps(
                    slice.getBaseInstantTime(),
                    maxCommitTime,
                    HoodieTimeline::LESSER_OR_EQUAL);
            });
        if (it != slices.end()) {
            return *it;
        }
        return std::nullopt;
    }

    /**
    * Obtain the latest file slice, upto a commitTime i.e < maxInstantTime
    * @param maxInstantTime Max Instant Time
    * @return
    */
    std::optional<FileSlice> getLatestFileSliceBefore(const std::string& maxInstantTime) {
        auto slices = getAllFileSlices();
        auto it = std::find_if(slices.begin(), slices.end(),
            [&](const FileSlice& slice) {
                return HoodieTimeline::compareTimestamps(
                    slice.getBaseInstantTime(),
                    maxInstantTime,
                    HoodieTimeline::LESSER);
            });
        if (it != slices.end()) {
            return *it;
        }
        return std::nullopt;
    }

    std::optional<FileSlice> getLatestFileSliceInRange(const std::vector<std::string>& commitRange) {
        auto slices = getAllFileSlices();
        auto it = std::find_if(slices.begin(), slices.end(),
            [&](const FileSlice& slice) {
                return std::find(commitRange.begin(), commitRange.end(), slice.getBaseInstantTime()) != commitRange.end();
            });
        if (it","#include <optional>
#include <vector>
#include <string>
#include <algorithm>

class FileSlice {
public:
    const std::string& getBaseInstantTime() const;
};

class HoodieTimeline {
public:
    static constexpr int LESSER_OR_EQUAL = 0;
    static constexpr int LESSER = -1;

    static bool compareTimestamps(const std::string& t1, const std::string& t2, int op);
};

class HoodieFileGroup {
public:
    std::vector<FileSlice> getAllFileSlices() const;

    std::optional<FileSlice> getLatestFileSliceBeforeOrOn(const std::string& maxCommitTime) const {
        const auto& slices = getAllFileSlices();
        auto it = std::find_if(slices.begin(), slices.end(),
            [&](const FileSlice& slice) {
                return HoodieTimeline::compareTimestamps(slice.getBaseInstantTime(),
                                                        maxCommitTime,
                                                        HoodieTimeline::LESSER_OR_EQUAL);
            });
        if (it != slices.end()) {
            return *it;
        }
        return std::nullopt;
    }

    std::optional<FileSlice> getLatestFileSliceBefore(const std::string& maxInstantTime) const {
        const auto& slices = getAllFileSlices();
        auto it = std::find_if(slices.begin(), slices.end(),
            [&](const FileSlice& slice) {
                return HoodieTimeline::compareTimestamps(slice.getBaseInstantTime(),
                                                        maxInstantTime,
                                                        HoodieTimeline::LESSER);
            });
        if (it != slices.end()) {
            return *it;
        }
        return std::nullopt;
    }

    std::optional<FileSlice> getLatestFileSliceInRange(const std::vector<std::string>& commitRange) const {
        const auto& slices = getAllFileSlices();
        auto it = std::find_if(slices.begin(), slices.end(),
            [&](const FileSlice& slice) {
                return std::find(commitRange.begin(), commitRange.end(),
                                 slice.getBaseInstantTime()) != commitRange.end();
            });
        if (it != slices.end()) {
            return *it;
        }
        return std::nullopt;
    }
};",1
"void setUseContinuations(bool useContinuations) {
    this->useContinuations = useContinuations;
}

int getAcceptors() const {
    return acceptors;
}

void setAcceptors(int acceptors) {
    this->acceptors = acceptors;
}

template<typename TServlet, typename TReceiver>
ConnectorHolder<TServlet, TReceiver> registerJettyEndpoint(MessageReceiver* receiver, InboundEndpoint* endpoint) {
    // Make sure that there is a connector for the requested endpoint.
    // ...
}","public:
    int getAcceptors() const {
        return acceptors;
    }

    void setAcceptors(int acceptors) {
        this->acceptors = acceptors;
    }",1
"if (!Identity_Crisis::validate_sync_error_idc_option()) {
    connection->disconnect_site(true);
} else {
    connection->disconnect_site(false);
}

void jetpack_site_disconnected() {
    Identity_Crisis::clear_all_idc_options();
    Sender::get_instance()->uninstall();
}","```cpp
void p(bool update_activated_state) {
    // let's make sure to not disconnect the production site.
    connection.disconnect_site(!Identity_Crisis::validate_sync_error_idc_option());

    if (update_activated_state) {
        Jetpack_Options::update_option(""activated"", 4);
    }
}

static void jetpack_site_disconnected() {
    Identity_Crisis::clear_all_idc_options();
    Sender::get_instance()->uninstall();
}
```",1
"#include <stdexcept>
#include <string>
#include <chrono>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <locale>","#include <stdexcept>
#include <string>
#include <ctime>
#include <chrono>",0
"```cpp
#include <gtest/gtest.h>
#include <atomic>
#include <thread>
#include <future>
#include <mutex>
#include <condition_variable>
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>

TEST(MyTest, testNioNegotiate) {
    std::atomic<struct sockaddr_in*> serverSocket(nullptr);
    std::promise<void> latch_promise;
    std::shared_future<void> latch(latch_promise.get_future());
    std::atomic<bool> done(false);

    std::thread serverThread([&] {
        try {
            int server_fd = socket(AF_INET, SOCK_STREAM, 0);
            sockaddr_in server_addr{};
            server_addr.sin_family = AF_INET;
            server_addr.sin_addr.s_addr = INADDR_ANY;
            server_addr.sin_port = 0; // 0 means any available port

            bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));

            socklen_t addrlen = sizeof(server_addr);
            getsockname(server_fd, (struct sockaddr*)&server_addr, &addrlen);

            serverSocket.store(new sockaddr_in(server_addr));
            listen(server_fd, 1);

            latch_promise.set_value();

            int client_sock = accept(server_fd, nullptr, nullptr);
            int i = 100;

            // ... rest of the logic ...
            close(client_sock);
            close(server_fd);
        } catch (...) {}
    });

    latch.wait();

    // ... rest of the logic, for example client connection ...

    ASSERT_EQ(std::string(""Reply2""), mOut.getPayload());
    done.store(true);
    ccf.stop();
    int tmp_fd = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in* server_addr = serverSocket.load();
    if (server_addr) {
        connect(tmp_fd, (struct sockaddr*)server_addr, sizeof(sockaddr_in));
        close(tmp_fd);
        delete server_addr;
    }
    serverThread.join();
}
```","```cpp
#include <atomic>
#include <thread>
#include <future>
#include <condition_variable>
#include <mutex>
#include <memory>
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>

void testNioNegotiate() {
    std::shared_ptr<int> serverSocket(new int(0), [](int* fd) { if (*fd > 0) close(*fd); delete fd; });
    std::promise<void> latchPromise;
    std::future<void> latch = latchPromise.get_future();
    std::atomic<bool> done{false};

    std::thread([&]() {
        try {
            int server_fd = socket(AF_INET, SOCK_STREAM, 0);
            if (server_fd < 0) return;

            sockaddr_in address{};
            address.sin_family = AF_INET;
            address.sin_addr.s_addr = INADDR_ANY;
            address.sin_port = 0; // assigned by OS

            if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) return;

            if (listen(server_fd, 1) < 0) return;

            // Store the server fd
            *serverSocket = server_fd;
            latchPromise.set_value();

            sockaddr_in client_addr{};
            socklen_t client_len = sizeof(client_addr);
            int client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_len);
            if (client_fd < 0) return;

            int i = 100;
            // ... continue with socket communication ...
            close(client_fd);
        } catch (...) {}
    }).detach();

    latch.wait();
    // ... main test logic ...
    done = true;
    // ccf.stop();
    if (*serverSocket > 0) close(*serverSocket);
}
```",0
"private:
    std::string jobId;
    std::string taskId;
    std::string taskKey;
    std::optional<std::string> taskAttemptId;
    long long startTime = 0;

public:
    const std::optional<std::string>& getTaskAttemptId() const { return taskAttemptId; }","#include <string>
#include <optional>

class TaskState : public WorkUnitState {
private:
    std::string jobId;
    std::string taskId;
    std::string taskKey;
    std::optional<std::string> taskAttemptId;
    long startTime = 0;

public:
    const std::optional<std::string>& getTaskAttemptId() const {
        return taskAttemptId;
    }
};",0
"#include <gtest/gtest.h>
#include <optional>
#include <string>

class MetricsConfig {
public:
    void setProtocol(const std::string& protocol) {
        this->protocol = protocol;
    }
    bool operator==(const MetricsConfig& other) const {
        return protocol == other.protocol;
    }
private:
    std::string protocol;
};

class ConfigManager {
public:
    void setMetrics(const MetricsConfig& config) {
        metrics = config;
    }
    std::optional<MetricsConfig> getMetrics() const {
        return metrics;
    }
private:
    std::optional<MetricsConfig> metrics;
};

TEST(ConfigManagerTest, tesMetricsConfig) {
    MetricsConfig config;
    config.setProtocol(""prometheus"");
    ConfigManager configManager;
    configManager.setMetrics(config);
    ASSERT_TRUE(configManager.getMetrics().has_value());
    ASSERT_EQ(config, configManager.getMetrics().value());
}","#include <gtest/gtest.h>
#include <optional>

class MetricsConfig {
public:
    void setProtocol(const std::string& protocol) { this->protocol = protocol; }
    bool operator==(const MetricsConfig& other) const { return protocol == other.protocol; }
private:
    std::string protocol;
};

class ConfigManager {
public:
    void setMetrics(const MetricsConfig& config) { metrics = config; }
    std::optional<MetricsConfig> getMetrics() const { return metrics; }
private:
    std::optional<MetricsConfig> metrics;
};

TEST(ConfigManagerTest, tesMetricsConfig) {
    MetricsConfig config;
    config.setProtocol(""prometheus"");
    ConfigManager configManager;
    configManager.setMetrics(config);
    ASSERT_TRUE(configManager.getMetrics().has_value());
    ASSERT_EQ(config, configManager.getMetrics().value());
}",1
"IO::store(
    ""#"" ""\n#   "" + 
    to_upper(name).replace('.', ' ') + 
    ""\n#\n"",
    getFile(pdir, Project::BNDFILE)
);

projects.refresh();
Project* p = getProject(name);

IO::mkdirs(p->getTarget());
IO::mkdirs(p->getOutput());","IO::store(""#\n#   "" + toUpperCase(name).replace('.', ' ') + ""\n#\n"", getFile(pdir, Project::BNDFILE));
projects.refresh();
Project* p = getProject(name);

IO::mkdirs(p->getTarget());
IO::mkdirs(p->getOutput());",1
"```cpp
#include <unordered_map>
#include <string>
#include <vector>
#include <memory>

class Element {
public:
    bool hasAttribute(const std::string& name) const;
    std::string getAttribute(const std::string& name) const;
    std::unordered_map<std::string, std::shared_ptr<void>>& data();
};

using ActionInfoDef = /* define appropriately */;
using ActionMapType = std::unordered_map<std::string, std::vector<ActionInfoDef>>;

const std::string ACTION_MAP_ = ""__action_map__"";

std::unique_ptr<ActionMapType> parseActionMap(const std::string& action, Element* node);

std::unique_ptr<ActionMapType> getActionMap_(Element* node, const std::string& actionEventType) {
    auto& data = node->data();
    auto it = data.find(ACTION_MAP_);
    ActionMapType* actionMap = nullptr;
    if (it == data.end()) {
        bool hasActionEvent = node->hasAttribute(""on"");
        bool hasAction = node->hasAttribute(""action"");
        if (hasActionEvent) {
            std::string action = node->getAttribute(""on"");
            auto parsed = parseActionMap(action, node);
            actionMap = parsed.get();
            data[ACTION_MAP_] = std::move(parsed);
            data[""action-map""] = &ACTION_MAP_;
        } else if (hasAction) {
            std::string action = node->getAttribute(""action"");
            auto parsed = parseActionMap(actionEventType + "":"" + action, node);
            actionMap = parsed.get();
            data[ACTION_MAP_] = std::move(parsed);
        }
    } else {
        actionMap = static_cast<ActionMapType*>(it->second.get());
    }
    if (actionMap) {
        return std::make_unique<ActionMapType>(*actionMap);
    }
    return nullptr;
}
```","```cpp
#include <string>
#include <unordered_map>
#include <vector>

struct Element {
    std::unordered_map<std::string, std::string> attributes;
    std::unordered_map<std::string, void*> properties;

    bool hasAttribute(const std::string& name) const {
        return attributes.find(name) != attributes.end();
    }
    std::string getAttribute(const std::string& name) const {
        auto it = attributes.find(name);
        return it != attributes.end() ? it->second : """";
    }
    void setProperty(const std::string& name, void* value) {
        properties[name] = value;
    }
    void* getProperty(const std::string& name) const {
        auto it = properties.find(name);
        return it != properties.end() ? it->second : nullptr;
    }
};

using ActionInfoDef = std::unordered_map<std::string, std::string>;
using ActionMap = std::unordered_map<std::string, std::vector<ActionInfoDef>>;

ActionMap* parseActionMap(const std::string& action, Element* node);

const std::string ACTION_MAP_ = ""action_map"";

ActionMap* getActionMap_(Element* node, const std::string& actionEventType) {
    ActionMap* actionMap = static_cast<ActionMap*>(node->getProperty(ACTION_MAP_));
    if (!actionMap) {
        bool hasActionEvent = node->hasAttribute(""on"");
        bool hasAction = node->hasAttribute(""action"");
        if (hasActionEvent) {
            std::string action = node->getAttribute(""on"");
            actionMap = parseActionMap(action, node);
            node->setProperty(ACTION_MAP_, actionMap);
            node->setProperty(""action-map"", reinterpret_cast<void*>(&ACTION_MAP_));
        } else if (hasAction) {
            std::string action = node->getAttribute(""action"");
            actionMap = parseActionMap(actionEventType + "":"" + action, node);
        }
    }
    return actionMap;
}
```",1
"#include <string>

class HoodieTestDataGenerator {
public:
    static constexpr int BYTES_PER_RECORD = static_cast<int>(1.2 * 1024);
    static constexpr int BLOOM_FILTER_BYTES = 323495;
    static const std::string DEFAULT_FIRST_PARTITION_PATH;
    static const std::string DEFAULT_SECOND_PARTITION_PATH;
};

const std::string HoodieTestDataGenerator::DEFAULT_FIRST_PARTITION_PATH = ""2016/03/15"";
const std::string HoodieTestDataGenerator::DEFAULT_SECOND_PARTITION_PATH = ""2015/03/16"";","#include <cmath>
#include <string>

class HoodieTestDataGenerator {
public:
    static constexpr int BYTES_PER_RECORD = static_cast<int>(1.2 * 1024);
    static constexpr int BLOOM_FILTER_BYTES = 323495;
    static const std::string DEFAULT_FIRST_PARTITION_PATH;
    static const std::string DEFAULT_SECOND_PARTITION_PATH;
};

const std::string HoodieTestDataGenerator::DEFAULT_FIRST_PARTITION_PATH = ""2016/03/15"";
const std::string HoodieTestDataGenerator::DEFAULT_SECOND_PARTITION_PATH = ""2015/03/16"";",1
"#include <chrono>
#include <stdexcept>","#include <chrono>
#include <stdexcept>
#include <map>
#include <string>
#include <memory>

// No equivalent for gobblin.admin.AdminWebServer

// No direct equivalent for org.apache.commons.configuration.ConfigurationConverter;
// PropertiesConfiguration would be modeled as std::map<std::string, std::string>

// Logger would be handled by a logging library, e.g., spdlog or boost::log",0
"}
catch (...)
{
    if (result != NonBlockingVoidMuleEvent::getInstance() && fireNotification)
    {
        fireNotification(notificationManager, event.getFlowConstruct(), result != nullptr ? result : event,
                         messageProcessor, exceptionThrown, MessageProcessorNotification::MESSAGE_PROCESSOR_POST_INVOKE);
    }
    throw;
}","if (result != NonBlockingVoidMuleEvent::getInstance() && fireNotification)
{
    fireNotification(notificationManager,
                     event.getFlowConstruct(),
                     result != nullptr ? result : event,
                     messageProcessor,
                     exceptionThrown,
                     MessageProcessorNotification::MESSAGE_PROCESSOR_POST_INVOKE);
}",0
"void visitBinaryExpression(const BinaryExpressionTree& tree) override {
    checkDeferredConstraint();
}

void visitAssignmentExpression(const AssignmentExpressionTree& tree) override {
    checkDeferredConstraint();
}

void visitUnaryExpression(const UnaryExpressionTree& tree) override {
    checkDeferredConstraint();
}

void visitTypeCast(const TypeCastTree& tree) override {
    checkDeferredConstraint();
}

private:
void checkDeferredConstraint() {
    SymbolicValue* sv = programState.peekValue();
    if (auto* dsv = dynamic_cast<DeferredStatusHolderSV*>(sv)) {
        addZeroConstraint(sv, dsv->deferredStatus);
    }
}

void addZeroConstraint(SymbolicValue* sv, Status status) {
    programState = programState.addConstraint(sv, ZeroConstraint(status));
}","class DivisionByZeroCheck : public SECheck {
public:
    void visitBinaryExpression(const BinaryExpressionTree& tree) override {
        checkDeferredConstraint();
    }

    void visitAssignmentExpression(const AssignmentExpressionTree& tree) override {
        checkDeferredConstraint();
    }

    void visitUnaryExpression(const UnaryExpressionTree& tree) override {
        checkDeferredConstraint();
    }

    void visitTypeCast(const TypeCastTree& tree) override {
        checkDeferredConstraint();
    }

private:
    void checkDeferredConstraint() {
        SymbolicValue* sv = programState.peekValue();
        if (auto* dsv = dynamic_cast<DeferredStatusHolderSV*>(sv)) {
            addZeroConstraint(sv, dsv->deferredStatus);
        }
    }

    void addZeroConstraint(SymbolicValue* sv, Status status) {
        programState = programState.addConstraint(sv, ZeroConstraint(status));
    }

    ProgramState programState;
};",0
"#include <vector>
#include <memory>

class ParameterModel {};
class ValueProviderModel {};
class Reference {};
class Config {};

class ParameterGroupDeclaration {};
class ParameterizedDeclaration {};
class SourceDeclaration {};","#include <memory>
#include <vector>
#include <string>",0
"if (wbbFilename != nullptr) {
    wbbFilename->addSelectionListener(new SelectionAdapterFileDialogTextVar(
        log,
        wFilename,
        transMeta,
        SelectionAdapterOptions(
            SelectionOperation::FILE,
            std::vector<std::string>{ FilterType::CSV_TXT, FilterType::CSV, FilterType::TXT, FilterType::ALL },
            FilterType::CSV_TXT,
            std::vector<std::string>{ ProviderFilterType::LOCAL },
            false
        )
    ));
}","if (wbbFilename != nullptr) {
    wbbFilename->addSelectionListener(new SelectionAdapterFileDialogTextVar(
        log, wFilename, transMeta,
        SelectionAdapterOptions(
            SelectionOperation::FILE,
            { FilterType::CSV_TXT, FilterType::CSV, FilterType::TXT, FilterType::ALL },
            FilterType::CSV_TXT,
            { ProviderFilterType::LOCAL },
            false
        )
    ));
}",1
"Log4jConfigurationHelper::updateLog4jConfiguration(
    typeid(GobblinApplicationMaster), Log4jConfigurationHelper::LOG4J_CONFIGURATION_FILE_NAME);

std::string containerIdEnv = std::getenv(ApplicationConstants::Environment::CONTAINER_ID.key().c_str());
ContainerId containerId = ConverterUtils::toContainerId(containerIdEnv);

GobblinApplicationMaster* applicationMaster = new GobblinApplicationMaster(
    cmd.getOptionValue(GobblinYarnConfigurationKeys::APPLICATION_NAME_OPTION_NAME),
    containerId, ConfigFactory::load(), YarnConfiguration());

applicationMaster->start();
} catch (const ParseException& pe) {
    printUsage(options);","```cpp
Log4jConfigurationHelper::updateLog4jConfiguration(
    typeid(GobblinApplicationMaster), Log4jConfigurationHelper::LOG4J_CONFIGURATION_FILE_NAME);

std::string containerIdStr = std::getenv(ApplicationConstants::Environment::CONTAINER_ID.key().c_str());
ContainerId containerId = ConverterUtils::toContainerId(containerIdStr);

GobblinApplicationMaster applicationMaster(
    cmd.getOptionValue(GobblinYarnConfigurationKeys::APPLICATION_NAME_OPTION_NAME),
    containerId,
    ConfigFactory::load(),
    YarnConfiguration());

applicationMaster.start();
```",0
"#include <string>
#include <vector>
#include <map>
#include <memory>
#include <algorithm>","#include <string>
#include <vector>
#include <map>
#include <memory>
#include <algorithm>
#include ""URL.h""
#include ""CommonConstants.h""
#include ""Logger.h""
#include ""LoggerFactory.h""
#include ""CollectionUtils.h""
#include ""Invoker.h""
#include ""FrameworkModel.h""
#include ""FrameworkServiceRepository.h""",0
"Session* const session_;
Synctex* const synctex_;
Provider<FileMRUList>* const pMruList_;
UserPrefs* userPrefs_;
UserState* const userState_;
ConsoleEditorProvider* const consoleEditorProvider_;
RnwWeaveRegistry* const rnwWeaveRegistry_;","private:
    Session* const session_;
    Synctex* const synctex_;
    std::shared_ptr<FileMRUList> const pMruList_;
    UserPrefs* userPrefs_;
    UserState* const userState_;
    ConsoleEditorProvider* const consoleEditorProvider_;
    RnwWeaveRegistry* const rnwWeaveRegistry_;",0
"#include <memory>

class AvroSource {
};

class HiveIncrPullSource : public AvroSource {
private:
    static inline std::shared_ptr<Logger> log = LogManager::getLogger(""HiveIncrPullSource"");
};","#include <memory>

class HiveIncrPullSource : public AvroSource {
public:
    static inline std::shared_ptr<Logger> log = LogManager::getLogger(""HiveIncrPullSource"");
};",1
"#include <vector>
#include <memory>
#include <map>
#include <set>
#include <tuple>

class PortModel {};
class NodeModel {};

class MyClass {
private:
    std::vector<std::shared_ptr<PortModel>> inPorts;
    std::vector<std::shared_ptr<PortModel>> outPorts;
    std::map<int, std::tuple<int, NodeModel*>> inputNodes;
    std::map<int, std::set<std::tuple<int, NodeModel*>>> outputNodes;

public:
    static constexpr double NodeHeaderHeight = 25.0;

    // public members
    // The unique name that was created the node by
};","#include <vector>
#include <memory>
#include <unordered_map>
#include <unordered_set>
#include <utility>

class PortModel;

class NodeModel;

class Node
{
private:
    std::vector<PortModel*> inPorts;
    std::vector<PortModel*> outPorts;

    std::unordered_map<int, std::pair<int, NodeModel*>> inputNodes;
    std::unordered_map<int, std::unordered_set<std::pair<int, NodeModel*>>> outputNodes;

public:
    static constexpr double NodeHeaderHeight = 25.0;

    // ...
};",1
"#include <memory>
#include <mutex>
#include <condition_variable>
#include <atomic>","#include <mutex>
#include <condition_variable>
#include <memory>",0
"#include <string>
#include <vector>
#include <memory>
#include <filesystem>
#include <chrono>
#include <thread>
#include <atomic>
#include <functional>
#include <sstream>

class Logger {
public:
    static void Log(const std::string& message);
};

class PreferenceSettings {
public:
    static inline int BackupInterval = 60000; // example value, ms
};

class PathManager {
public:
    std::string BackupDirectory;
};

class WorkspaceModel {
public:
    virtual ~WorkspaceModel() = default;
    virtual bool HasUnsavedChanges() const = 0;
    virtual const std::string& FileName() const = 0;
    virtual const std::string& Guid() const = 0;
    virtual void SaveAs(const std::string& path, void* /*maybe null*/) = 0;
};

class HomeWorkspaceModel : public WorkspaceModel {
    // Implementation...
};

class Timer {
public:
    Timer(std::function<void(void*)> func) : action(std::move(func)), isRunning(false) {}

    ~Timer() {
        Stop();
    }

    void Change(int dueTimeMs, int periodMs) {
        Stop();
        isRunning = true;
        worker = std::thread([this, dueTimeMs, periodMs]() {
            std::this_thread::sleep_for(std::chrono::milliseconds(dueTimeMs));
            while (isRunning) {
                action(nullptr);
                std::this_thread::sleep_for(std::chrono::milliseconds(periodMs));
            }
        });
    }

    void Stop() {
        if (isRunning) {
            isRunning = false;
            if (worker.joinable())
                worker.join();
        }
    }

private:
    std::function<void(void*)> action;
    std::atomic<bool> isRunning;
    std::thread worker;
};

class MyApp {
public:
    std::vector<std::shared_ptr<WorkspaceModel>> Workspaces;
    PathManager pathManager;
    std::unique_ptr<Timer> backupFilesTimer;

    void SaveBackupFiles(void* state) {
        for (auto& workspace : Workspaces) {
            if (!workspace->HasUnsavedChanges())
                continue;

            std::string fileName;
            if (workspace->FileName().empty()) {
                fileName = ""recent_new_file_"" + workspace->Guid();
                std::string ext = (dynamic_cast<HomeWorkspaceModel*>(workspace.get()) != nullptr) ? "".DYN"" : "".DYF"";
                fileName +=","```cpp
#include <string>
#include <vector>
#include <memory>
#include <filesystem>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <functional>
#include <thread>
#include <atomic>

class WorkspaceModel {
public:
    virtual ~WorkspaceModel() = default;
    virtual bool HasUnsavedChanges() const = 0;
    virtual std::string FileName() const = 0;
    virtual std::string Guid() const = 0;
    virtual void SaveAs(const std::string& savePath, void* /* unused */) = 0;
};

class HomeWorkspaceModel : public WorkspaceModel {};

class PathManager {
public:
    std::string BackupDirectory;
};

class Logger {
public:
    static void Log(const std::string& msg) {
        // Implement actual logging here
    }
};

struct PreferenceSettings {
    static inline std::chrono::milliseconds BackupInterval{60000};
};

class Timer {
public:
    Timer(std::function<void()> func)
        : stopFlag(false)
    {
        thread = std::thread([this, func]() {
            while (!stopFlag) {
                std::unique_lock<std::mutex> lock(mutex);
                if(cv.wait_for(lock, interval, [this]() { return stopFlag.load(); }))
                    break;
                func();
            }
        });
    }

    void Change(std::chrono::milliseconds due, std::chrono::milliseconds interval_)
    {
        interval = interval_;
        // Optionally, could wait for 'due' time before the first call.
    }

    ~Timer() {
        stopFlag = true;
        cv.notify_all();
        if (thread.joinable()) thread.join();
    }

private:
    std::thread thread;
    std::atomic<bool> stopFlag;
    std::mutex mutex;
    std::condition_variable cv;
    std::chrono::milliseconds interval{60000};
};

class Model {
protected:
    std::vector<std::shared_ptr<WorkspaceModel>> Workspaces;
    PathManager pathManager;
    std::unique_ptr<Timer> backupFilesTimer;

    void SaveBackupFiles()
    {
        for (const auto& workspace : Workspaces)
        {
            if (!workspace->HasUnsavedChanges())
                continue;

            std::string fileName;
            if (workspace->FileName().empty())
            {
                fileName = ""recent_new_file_"" + workspace->Guid();
                std::string ext = (dynamic_cast<HomeWorkspaceModel*>(workspace.get()) != nullptr) ?",1
"col.getDb().getDatabase().beginTransaction();
try {
    sched.deferReset();
    // collect undo information
    std::unique_ptr<Undoable> undo = revertToProvidedState(BURY_CARD, card);
    switch (type) {
        case BURY_CARD:
            // then bury
            sched.buryCards({ card.getId() });
            break;
        case BURY_NOTE:
            // then bury
            sched.buryNote(note.getId());
            break;
        case SUSPEND_CARD:
            // collect undo information
            Card suspendedCard = card.clone();
            undo = std::make_unique<UndoSuspendCard>(suspendedCard);
            // suspend card
            if (card.getQueue() == Consts::QUEUE_TYPE_SUSPENDED) {
                sched.unsuspendCards({ card.getId() });","col.getDb().getDatabase().beginTransaction();
try {
    sched.deferReset();
    // collect undo information
    auto undo = revertToProvidedState(BURY_CARD, card);
    switch (type) {
        case BURY_CARD:
            // then bury
            sched.buryCards({ card.getId() });
            break;
        case BURY_NOTE:
            // then bury
            sched.buryNote(note.getId());
            break;
        case SUSPEND_CARD: {
            // collect undo information
            Card suspendedCard = card.clone();
            undo = std::make_shared<UndoSuspendCard>(suspendedCard);
            // suspend card
            if (card.getQueue() == Consts::QUEUE_TYPE_SUSPENDED) {
                sched.unsuspendCards({ card.getId() });
            }
            break;
        }
    }
}",1
"bool isUp() override {
    const auto& indexSets = findAllMongoIndexSets();
    return std::all_of(indexSets.begin(), indexSets.end(),
        [](const MongoIndexSet& indexSet) {
            return !indexSet.getConfig().isWritable() || indexSet.isUp();
        });
}","bool isUp() override {
    const auto& indexSets = findAllMongoIndexSets();
    return std::all_of(indexSets.begin(), indexSets.end(),
        [](const MongoIndexSet& indexSet) {
            return !indexSet.getConfig().isWritable() || indexSet.isUp();
        }
    );
}",0
"auto data_type = std::any_cast<int>(typeRecord[METADATA_TYPE_ID_COLUMN]);
auto type_name = std::any_cast<std::string>(typeRecord[METADATA_TYPE_NAME_COLUMN]);

std::unique_ptr<ResolvedDbType> resolvedDbType = nullptr;

if (data_type == Types::CLOB)
{
    resolvedDbType = std::make_unique<ClobResolvedDataType>(data_type, type_name);
}
else
{
    resolvedDbType = std::make_unique<ResolvedDbType>(data_type, type_name);
}

if (!isUserDefinedType(*resolvedDbType))
{","ResolvedDbType* resolvedDbType = nullptr;

if (static_cast<int>(typeRecord[METADATA_TYPE_ID_COLUMN]) == Types::CLOB)
{
    resolvedDbType = new ClobResolvedDataType(static_cast<int>(typeRecord[METADATA_TYPE_ID_COLUMN]),
                                              std::any_cast<std::string>(typeRecord[METADATA_TYPE_NAME_COLUMN]));
}
else
{
    resolvedDbType = new ResolvedDbType(static_cast<int>(typeRecord[METADATA_TYPE_ID_COLUMN]),
                                        std::any_cast<std::string>(typeRecord[METADATA_TYPE_NAME_COLUMN]));
}

if (!isUserDefinedType(*resolvedDbType))
{",1
"#include <unordered_map>
#include <string>

class LifecycleAdapter {
    // Base class definition
};

class FrameworkExt {
    // Interface definition
};

class ServiceRepository : public LifecycleAdapter, public FrameworkExt {
public:
    static constexpr const char* NAME = ""repository"";
};","#include <string>
#include <set>
#include <unordered_map>
#include <memory>

class FrameworkExt {};

class LifecycleAdapter {};

std::string interfaceFromServiceKey(const std::string& serviceKey);
std::string versionFromServiceKey(const std::string& serviceKey);

class ServiceRepository : public LifecycleAdapter, public FrameworkExt {
public:
    static constexpr const char* NAME = ""repository"";
};",0
"std::string recordKey = partitionRecordKeyPair.second;
std::string partitionPath = partitionRecordKeyPair.first;

auto files = indexFileFilter.getMatchingFilesAndPartition(partitionPath, recordKey);
std::vector<std::pair<std::string, HoodieKey>> result;
for (const auto& partitionFileIdPair : files) {
    result.emplace_back(
        partitionFileIdPair.second,
        HoodieKey(recordKey, partitionFileIdPair.first)
    );
}
// This is within a function where you would ""flatMap"", typical usage may vary depending on surrounding code.


// Tagging for global index should only consider the record key.

std::unordered_map<std::string, std::pair<HoodieKey, HoodieRecordLocation>> keyMap;
auto keyFilenamePairs = keyFilenamePairRDD.collect();
for (const auto& e : keyFilenamePairs) {
    keyMap[e.first.getRecordKey()] = std::make_pair(e.first, e.second);
}

std::vector<HoodieRecord<T>> toReturn;
auto records = recordRDD.collect();
for (const auto& rec : records) {
    auto it = keyMap.find(rec.getRecordKey());
    if (it != keyMap.end()) {
        auto& value = it->second;
        toReturn.emplace_back(
            getTaggedRecord(HoodieRecord(value.first, rec.getData()), Option<HoodieRecordLocation>::of(value.second))
        );
    } else {
        toReturn.emplace_back(
            getTaggedRecord(rec, Option<HoodieRecordLocation>::empty())
        );
    }
}

// Return as needed, e.g., wrap toReturn into a 'RDD'-like collection if required.","std::vector<std::pair<std::string, HoodieKey>> mapPartitionRecordKeyPair(
    const std::pair<std::string, std::string>& partitionRecordKeyPair) {
    const std::string& partitionPath = partitionRecordKeyPair.first;
    const std::string& recordKey = partitionRecordKeyPair.second;
    std::vector<std::pair<std::string, std::string>> partitionFileIdPairs =
        indexFileFilter.getMatchingFilesAndPartition(partitionPath, recordKey);

    std::vector<std::pair<std::string, HoodieKey>> result;
    result.reserve(partitionFileIdPairs.size());
    for (const auto& partitionFileIdPair : partitionFileIdPairs) {
        result.emplace_back(
            partitionFileIdPair.second,
            HoodieKey(recordKey, partitionFileIdPair.first)
        );
    }
    return result;
}

template <typename T>
std::vector<std::shared_ptr<HoodieRecord<T>>> tagLocationBacktoRecords(
    const std::vector<std::pair<HoodieKey, HoodieRecordLocation>>& keyFilenamePairVec,
    const std::vector<std::shared_ptr<HoodieRecord<T>>>& recordVec)
{
    std::unordered_map<std::string, std::pair<HoodieKey, HoodieRecordLocation>> keyMap;
    for (const auto& e : keyFilenamePairVec) {
        keyMap[e.first.getRecordKey()] = std::make_pair(e.first, e.second);
    }
    std::vector<std::shared_ptr<HoodieRecord<T>>> toReturn;
    toReturn.reserve(recordVec.size());
    for (const auto& rec : recordVec) {
        auto it = keyMap.find(rec->getRecordKey());
        if (it != keyMap.end()) {
            const auto& value = it->second;
            toReturn.push_back(
                std::make_shared<HoodieRecord<T>>(
                    getTaggedRecord(
                        HoodieRecord<T>(value.first, rec->getData()),
                        Option<HoodieRecordLocation>::of(value.second)
                    )
                )
            );
        } else {
            toReturn.push_back(
                std::make_shared<HoodieRecord<T>>(
                    getTaggedRecord(*rec, Option<HoodieRecordLocation>::empty())
                )
            );
        }
    }
    return toReturn;
}",1
"class AbstractCorrelatingMessageHandler : public AbstractMessageProducingHandler,
                                         public DisposableBean,
                                         public IntegrationEvaluationContextAware,
                                         public ApplicationEventPublisherAware
{
protected:
    static inline Log logger = LogFactory::getLog(typeid(AbstractCorrelatingMessageHandler).name());
};","class AbstractCorrelatingMessageHandler : public AbstractMessageProducingHandler,
                                         public DisposableBean,
                                         public IntegrationEvaluationContextAware,
                                         public ApplicationEventPublisherAware
{
protected:
    static Log logger;
};",0
"static constexpr bool DEFAULT_SOURCE_OBTAIN_TABLE_PROPS_FROM_CONFIG_STORE = false;
static const std::string QUERY_BASED_SOURCE = ""query_based_source"";
static const std::string WORK_UNIT_STATE_VERSION_KEY = ""source.querybased.workUnitState.version"";
static const std::string IS_LAST_WORK_UNIT = ""is.last.work.unit"";","static constexpr bool DEFAULT_SOURCE_OBTAIN_TABLE_PROPS_FROM_CONFIG_STORE = false;
static const std::string QUERY_BASED_SOURCE = ""query_based_source"";
static const std::string WORK_UNIT_STATE_VERSION_KEY = ""source.querybased.workUnitState.version"";
static const std::string IS_LAST_WORK_UNIT = ""is.last.work.unit"";",1
"```cpp
void add(const Annotation& annotation, const std::string& name, const std::string& value) {
    if (value.empty())
        return;

    Processor next;
    std::unordered_map<std::string, std::string> properties;

    for (const auto& entry : annotation.entrySet()) {
        const auto& key = entry.first;
        const auto& val = entry.second;
        if (key.rfind(""#"", 0) == 0) { // key starts with '#'
            if (key == ""#uses"") {
                if (auto arr = std::get_if<std::vector<std::shared_ptr<TypeRef>>>(&val)) {
                    if (!arr->empty()) {
                        std::set<std::string> fqnSet;
                        for (const auto& typePtr : *arr) {
                            if (typePtr) {
                                auto pkgRef = typePtr->getPackageRef();
                                fqnSet.insert(pkgRef.getFQN());
                            }
                        }
                        std::string converted;
                        for (auto it = fqnSet.begin(); it != fqnSet.end(); ++it) {
                            if (it != fqnSet.begin()) converted += "","";
                            converted += *it;
                        }
                        properties[key] = converted;
                        continue;
                    }
                }
            }
            // Default conversion for entry
            properties[key] = convert(val);
        }
    }

    next.addProperties(std::move(properties));
    next.setProperty(""@class"", current.getFQN());
    next.setProperty(""@class-short"", current.getClassName().getShortName());
}
```","```cpp
void add(const Annotation& annotation, const std::string& name, const std::string& value) {
    if (value.empty())
        return;

    Processor next;
    std::unordered_map<std::string, std::string> properties;

    for (const auto& entry : annotation) {
        const std::string& key = entry.first;
        const auto& val = entry.second;
        if (key.starts_with(""#"")) {
            if (key == ""#uses"") {
                if (const auto* arr = std::any_cast<const std::vector<std::any>>(&val)) {
                    if (!arr->empty()) {
                        if (std::any_cast<const TypeRef>(&(*arr)[0])) {
                            std::set<std::string> fqns;
                            for (const auto& v : *arr) {
                                const TypeRef* tref = std::any_cast<const TypeRef>(&v);
                                if (tref) {
                                    fqns.insert(tref->getPackageRef().getFQN());
                                }
                            }
                            std::string joined;
                            for (auto it = fqns.begin(); it != fqns.end(); ) {
                                joined += *it;
                                if (++it != fqns.end()) joined += "","";
                            }
                            properties[key] = joined;
                            continue;
                        }
                    }
                }
            }
            // default
            properties[key] = convert(val);
        }
    }

    next.addProperties(properties);
    next.setProperty(""@class"", current->getFQN());
    next.setProperty(""@class-short"", current->getClassName().getShortName());
}
```",1
"protected:
    void doSetUp() {
        capturedEvents = std::make_unique<std::list<Event>>();
        ReconnectableConnectionProvider::fail = false;
        FallibleReconnectableSource::fail = false;
    }

    void doTearDown() {
        capturedEvents.reset();
        ReconnectableConnectionProvider::fail = false;
        FallibleReconnectableSource::fail = false;
    }","void doSetUp() override {
    capturedEvents = std::make_shared<std::list<Event>>();
    ReconnectableConnectionProvider::fail = false;
    FallibleReconnectableSource::fail = false;
}

void doTearDown() override {
    capturedEvents = nullptr;
    ReconnectableConnectionProvider::fail = false;
    FallibleReconnectableSource::fail = false;
}",0
"return listBuilder.build();
}

std::string getConditionHitsCounterName() const {
    return conditionHitsCounterName;
}

std::string getConditionMissesCounterName() const {
    return conditionMissesCounterName;
}

std::string getConditionTimerName() const {
    return conditionTimerName;
}

std::string getExecutionTimerName() const {
    return executionTimerName;
}

std::string getConverterTimerName() const {
    return converterTimerName;
}

std::string getCompleteTimerName() const {
    return completeTimerName;
}

long getExceptionCount() const {
    return exceptions.get();
}","```cpp
std::string getConditionHitsCounterName() const {
    return conditionHitsCounterName;
}

std::string getConditionMissesCounterName() const {
    return conditionMissesCounterName;
}

std::string getConditionTimerName() const {
    return conditionTimerName;
}

std::string getExecutionTimerName() const {
    return executionTimerName;
}

std::string getConverterTimerName() const {
    return converterTimerName;
}

std::string getCompleteTimerName() const {
    return completeTimerName;
}

long getExceptionCount() const {
    return exceptions.get();
}
```",0
"std::vector<Schema::Field> parentFields;

Schema::Field commitTimeField(
    HoodieRecord::COMMIT_TIME_METADATA_FIELD,
    METADATA_FIELD_SCHEMA,
    """",
    nullptr
);
Schema::Field commitSeqnoField(
    HoodieRecord::COMMIT_SEQNO_METADATA_FIELD,
    METADATA_FIELD_SCHEMA,
    """",
    nullptr
);
Schema::Field recordKeyField(
    HoodieRecord::RECORD_KEY_METADATA_FIELD,
    METADATA_FIELD_SCHEMA,
    """",
    nullptr
);
Schema::Field partitionPathField(
    HoodieRecord::PARTITION_PATH_METADATA_FIELD,
    METADATA_FIELD_SCHEMA,
    """",
    nullptr
);
Schema::Field fileNameField(
    HoodieRecord::FILENAME_METADATA_FIELD,
    METADATA_FIELD_SCHEMA,
    """",
    nullptr
);

parentFields.push_back(commitTimeField);
parentFields.push_back(commitSeqnoField);","std::vector<Schema::Field> parentFields;

Schema::Field commitTimeField(
    HoodieRecord::COMMIT_TIME_METADATA_FIELD, METADATA_FIELD_SCHEMA, """", nullptr);
Schema::Field commitSeqnoField(
    HoodieRecord::COMMIT_SEQNO_METADATA_FIELD, METADATA_FIELD_SCHEMA, """", nullptr);
Schema::Field recordKeyField(
    HoodieRecord::RECORD_KEY_METADATA_FIELD, METADATA_FIELD_SCHEMA, """", nullptr);
Schema::Field partitionPathField(
    HoodieRecord::PARTITION_PATH_METADATA_FIELD, METADATA_FIELD_SCHEMA, """", nullptr);
Schema::Field fileNameField(
    HoodieRecord::FILENAME_METADATA_FIELD, METADATA_FIELD_SCHEMA, """", nullptr);

parentFields.push_back(commitTimeField);
parentFields.push_back(commitSeqnoField);",1
"for (size_t i = 0; i < columnState_.getNames().size(); ++i)
{
    auto name = columnState_.getNames()[i];
    if (name != MAIN_SOURCE_NAME)
    {
        if (userPrefs_.enableAdditionalColumns().getGlobalValue())
        {
            add(name, false);
        }
        else
        {
            auto paneConfig = userPrefs_.panes().getValue();
            userPrefs_.panes().setGlobalValue(PaneConfig::create(
                JsArrayUtil::copy(paneConfig.getQuadrants()),
                paneConfig.getTabSet1(),
                paneConfig.getTabSet2(),
                paneConfig.getHiddenTabSet(),
                paneConfig.getConsoleLeftOnTop(),
                paneConfig.getConsoleRightOnTop(),
                0
            ));
            consolidateColumns(1);
            return;
        }
    }
}","for (int i = 0; i < columnState_.getNames().size(); ++i)
{
    std::string name = columnState_.getNames()[i];

    if (name != MAIN_SOURCE_NAME)
    {
        if (userPrefs_.enableAdditionalColumns().getGlobalValue())
        {
            add(name, false);
        }
        else
        {
            PaneConfig paneConfig = userPrefs_.panes().getValue();
            userPrefs_.panes().setGlobalValue(PaneConfig::create(
                JsArrayUtil::copy(paneConfig.getQuadrants()),
                paneConfig.getTabSet1(),
                paneConfig.getTabSet2(),
                paneConfig.getHiddenTabSet(),
                paneConfig.getConsoleLeftOnTop(),
                paneConfig.getConsoleRightOnTop(),
                0
            ));
            consolidateColumns(1);
            return;
        }
    }
}",0
".setHeader(FileHeaders::ORIGINAL_FILE, this->file)
.build();
BaseClass::sendMessage(message);
updateLastReceive();
}

protected:
void publish(const std::string& message) {","void sendMessage(const Message& message) override {
    auto msg = MessageBuilder::withPayload(message.getPayload())
        .setHeader(FileHeaders::ORIGINAL_FILE, this->file)
        .build();
    MessageProducerSupport::sendMessage(msg);
    updateLastReceive();
}",0
"void undo() {
    mUndo.pop();
    mUndo.apply();
    if (undoEmpty() && mAnkiActivity != nullptr) {
        mAnkiActivity->supportInvalidateOptionsMenu();
    }
}","void undo() {
    mUndo.pop();
    mUndo.apply();
    if (undoEmpty() && mAnkiActivity != nullptr) {
        mAnkiActivity->supportInvalidateOptionsMenu();
    }
}",0
"Span* startScope(Span* span, STORAGE storage) {
    Context* serverSpanContext = Context::current()->withValue(CONTEXT_SERVER_SPAN_KEY, span);
    Context* newContext = withSpan(span, serverSpanContext);
    attachServerContext(newContext, storage);
    return withScopedContext(newContext);
}

void end(Span* span, int responseStatus) {
    setStatus(span, responseStatus);
    span->end();
}

void endExceptionally(Span* span, std::exception_ptr throwable) {
    endExceptionally(span, throwable, 500);
}

void endExceptionally(Span* span, std::exception_ptr throwable, int responseStatus) {
    if (responseStatus == 200) {
        responseStatus = 500;
    }
    onError(span, unwrapThrowable(throwable));
    end(span, responseStatus);
}

Span* getCurrentSpan() {
    return tracer.getCurrentSpan();
}

Span* getServerSpan(STORAGE storage) {
    Context* attachedContext = getServerContext(storage);
    return attachedContext == nullptr ? nullptr : CONTEXT_SERVER_SPAN_KEY.get(attachedContext);
}

virtual Context* getServerContext(STORAGE storage) = 0;","```cpp
template<typename REQUEST, typename CONNECTION, typename STORAGE>
class HttpServerTracer {
public:
    virtual ~HttpServerTracer() = default;

    Scope* startScope(Span* span, STORAGE storage) {
        Context* serverSpanContext = Context::current()->withValue(CONTEXT_SERVER_SPAN_KEY, span);
        Context* newContext = withSpan(span, serverSpanContext);
        attachServerContext(newContext, storage);
        return withScopedContext(newContext);
    }

    void end(Span* span, int responseStatus) {
        setStatus(span, responseStatus);
        span->end();
    }

    void endExceptionally(Span* span, std::exception_ptr throwable) {
        endExceptionally(span, throwable, 500);
    }

    void endExceptionally(Span* span, std::exception_ptr throwable, int responseStatus) {
        if (responseStatus == 200) {
            responseStatus = 500;
        }
        onError(span, unwrapThrowable(throwable));
        end(span, responseStatus);
    }

    Span* getCurrentSpan() {
        return tracer->getCurrentSpan();
    }

    Span* getServerSpan(STORAGE storage) {
        Context* attachedContext = getServerContext(storage);
        return attachedContext == nullptr ? nullptr : CONTEXT_SERVER_SPAN_KEY.get(attachedContext);
    }

    virtual Context* getServerContext(STORAGE storage) = 0;

protected:
    virtual void onConnection(Span* span, CONNECTION connection) {
        SemanticAttributes::NET_PEER_IP::set(span, peerHostIP(connection));
        const int* port = peerPort(connection);
        // etc...
    }

    // Assume the following are provided in the base or utility:
    virtual void attachServerContext(Context* context, STORAGE storage) = 0;
    virtual Scope* withScopedContext(Context* context) = 0;
    virtual Context* withSpan(Span* span, Context* context) = 0;
    virtual void setStatus(Span* span, int responseStatus) = 0;
    virtual void onError(Span* span, std::exception_ptr throwable) = 0;
    virtual std::exception_ptr unwrapThrowable(std::exception_ptr throwable) = 0;

    // Tracer and context key assumed available:
    Tracer* tracer;
    ContextKey<Span*> CONTEXT_SERVER_SPAN_KEY;
};
```",1
"#include <gtest/gtest.h>
#include <set>
#include <map>
#include <memory>
#include <vector>
#include <string>
#include <chrono>","#include <gtest/gtest.h>
#include <map>
#include <set>
#include <vector>
#include <string>
#include <chrono>",1
"#include <vector>
#include <stdexcept>
#include <memory>
#include <thread>
#include <mutex>

class HoodieSerializationException : public std::runtime_error {
public:
    explicit HoodieSerializationException(const std::string& msg)
        : std::runtime_error(msg) {}
    HoodieSerializationException(const std::string& msg, const std::exception& ex)
        : std::runtime_error(msg + std::string("": "") + ex.what()) {}
};

// Dummy Kryo-like interface for C++ illustration.
// Replace methods with actual serialization/deserialization as needed.
class Kryo {
public:
    template <typename T>
    std::vector<uint8_t> serialize(const T& obj) {
        // Replace with actual serialization logic.
        throw HoodieSerializationException(""Serialization not implemented"");
    }
    template <typename T>
    T deserialize(const std::vector<uint8_t>& data) {
        // Replace with actual deserialization logic.
        throw HoodieSerializationException(""Deserialization not implemented"");
    }
};

class KryoSerializerInstance {
public:
    KryoSerializerInstance() : kryo_(std::make_shared<Kryo>()) {}
    template <typename T>
    std::vector<uint8_t> serialize(const T& obj) {
        return kryo_->serialize(obj);
    }
    template <typename T>
    T deserialize(const std::vector<uint8_t>& data) {
        return kryo_->deserialize<T>(data);
    }
private:
    std::shared_ptr<Kryo> kryo_;
};

class SerializationUtils {
public:
    template <typename T>
    static std::vector<uint8_t> serialize(const T& obj) {
        return serializerRef().get()->serialize(obj);
    }

    template <typename T>
    static T deserialize(const std::vector<uint8_t>& objectData) {
        return serializerRef().get()->deserialize<T>(objectData);
    }
private:
    static std::unique_ptr<KryoSerializerInstance>& serializerRef() {
        thread_local std::unique_ptr<KryoSerializerInstance> instance(new KryoSerializerInstance());
        return instance;
    }
};","#include <vector>
#include <stdexcept>
#include <memory>
#include <mutex>
#include <sstream>
#include <thread>

class HoodieSerializationException : public std::runtime_error {
public:
    explicit HoodieSerializationException(const std::string& msg)
        : std::runtime_error(msg) {}
    HoodieSerializationException(const std::string& msg, const std::exception& cause)
        : std::runtime_error(msg + "": "" + cause.what()) {}
};

// Simple interface for serializable objects
class Serializable {
public:
    virtual ~Serializable() = default;
    virtual void serialize(std::ostream&) const = 0;
    virtual void deserialize(std::istream&) = 0;
};

// Internal serializer instance (for demonstration; add thread safety as needed)
class SerializerInstance {
public:
    std::vector<uint8_t> serialize(const Serializable& obj) {
        std::ostringstream oss(std::ios::binary);
        obj.serialize(oss);
        std::string str = oss.str();
        return std::vector<uint8_t>(str.begin(), str.end());
    }

    template <typename T>
    std::unique_ptr<T> deserialize(const std::vector<uint8_t>& data) {
        std::istringstream iss(
            std::string(reinterpret_cast<const char*>(data.data()), data.size()), std::ios::binary);
        std::unique_ptr<T> obj = std::make_unique<T>();
        obj->deserialize(iss);
        return obj;
    }
};

class SerializationUtils {
private:
    static thread_local std::unique_ptr<SerializerInstance> serializerRef;

    static SerializerInstance& getInstance() {
        if (!serializerRef) {
            serializerRef = std::make_unique<SerializerInstance>();
        }
        return *serializerRef;
    }

public:
    static std::vector<uint8_t> serialize(const Serializable& obj) {
        try {
            return getInstance().serialize(obj);
        } catch (const std::exception& ex) {
            throw HoodieSerializationException(""unable to serialize object"", ex);
        }
    }

    template <typename T>
    static std::unique_ptr<T> deserialize(const std::vector<uint8_t>& objectData) {
        try {
            return getInstance().template deserialize<T>(objectData);
        } catch (const std::bad_cast& ex) {
            throw HoodieSerializationException(""cannot cast class"", ex);
        } catch (const std::exception& ex) {
            throw HoodieSerializationException(""unable to deserialize to object"", ex);
        }",1
"throw std::runtime_error(this->toString());

checkAccess(handle.getDefiningClass(), handle.getFieldName(), handle.getModifiers(), nullptr, skipAccessCheckPara);
}

void checkAccess(const std::type_info& clazz) {","```cpp
if (!skipAccessCheckPara) {
    throw std::invalid_argument(this->toString());
}

checkAccess(handle.getDefiningClass(), handle.getFieldName(), handle.getModifiers(), nullptr, skipAccessCheckPara);

void checkAccess(const std::type_info& clazz) {
    // implementation
}
```",0
"#include <gtest/gtest.h>
#include <memory>
#include <fstream>

TEST(ServiceProviderTest, testServiceProviderProvidesService) {
    Builder b;
    b.addClasspath(IO::getFile(""bin_test""));
    b.setPrivatePackage(""test.annotationheaders.spi.provider"");
    b.build();
    b.getJar()
     .getManifest()
     .write(std::cout);
    ASSERT_TRUE(b.check());

    auto& mainAttributes = b.getJar()
      .getManifest()
      .getMainAttributes();

    Header req = Header::parseHeader(mainAttributes.getValue(Constants::REQUIRE_CAPABILITY));
    ASSERT_EQ(2, req.size());

    assertExtender(req, ""osgi.serviceloader.registrar"");
    assertEE(req);

    Parameters cap = OSGiHeader::parseHeader(mainAttributes.getValue(Constants::PROVIDE_CAPABILITY));
    ASSERT_EQ(3, cap.size());

    Attrs* p = cap.get(""osgi.service"");
    ASSERT_NE(nullptr, p);
    ASSERT_NE(nullptr, p->getTyped(""objectClass""));
    auto objectClasses = p->getTyped(Attrs::LIST_STRING, ""objectClass"");
    ASSERT_NE(objectClasses.end(), std::find(objectClasses.begin(), objectClasses.end(), ""test.annotationheaders.spi.SPIService""));
    ASSERT_EQ(""active"", p->get(""effective:""));
}","```cpp
#include <gtest/gtest.h>
#include <fstream>
#include <memory>
#include <string>
#include ""Builder.h""
#include ""IO.h""
#include ""Header.h""
#include ""Constants.h""
#include ""OSGiHeader.h""
#include ""Attrs.h""

TEST(SPIAnnotationsTest, testServiceProviderProvidesService) {
    Builder b;
    b.addClasspath(IO::getFile(""bin_test""));
    b.setPrivatePackage(""test.annotationheaders.spi.provider"");
    b.build();
    b.getJar()
        .getManifest()
        .write(std::cout);
    ASSERT_TRUE(b.check());

    auto& mainAttributes = b.getJar()
        .getManifest()
        .getMainAttributes();

    Header req = Header::parseHeader(mainAttributes.getValue(Constants::REQUIRE_CAPABILITY));
    ASSERT_EQ(2, req.size());

    assertExtender(req, ""osgi.serviceloader.registrar"");
    assertEE(req);

    Parameters cap = OSGiHeader::parseHeader(mainAttributes.getValue(Constants::PROVIDE_CAPABILITY));
    ASSERT_EQ(3, cap.size());

    Attrs* p = cap.get(""osgi.service"");
    ASSERT_NE(nullptr, p);
    ASSERT_NE(nullptr, p->getTyped(""objectClass""));
    auto objectClasses = p->getTyped<Attrs::ListString>(""objectClass"");
    ASSERT_NE(objectClasses.end(), std::find(objectClasses.begin(), objectClasses.end(), ""test.annotationheaders.spi.SPIService""));
    ASSERT_EQ(""active"", p->get(""effective:""));
}
```",1
"HoodieTimelineArchiveLog archiveLog(config, table);
archiveLog.archiveIfRequired(context);
autoCleanOnCommit();
if (operationType != nullptr && operationType != WriteOperationType::CLUSTER && operationType != WriteOperationType::COMPACT) {
    syncTableMetadata();
}
} catch (const std::ios_base::failure& ioe) {
    throw HoodieIOException(ioe.what(), ioe);
}","try {
    HoodieTimelineArchiveLog archiveLog(config, table);
    archiveLog.archiveIfRequired(context);
    autoCleanOnCommit();
    if (operationType != nullptr && operationType != WriteOperationType::CLUSTER && operationType != WriteOperationType::COMPACT) {
        syncTableMetadata();
    }
} catch (const IOException& ioe) {
    throw HoodieIOException(ioe.what(), ioe);
}",0
"kill[block] = blockKill;
gen[block] = blockGen;
}
liveVariables.analyzeCFG(liveVariables.in, kill, gen);
if (!liveVariables.out[liveVariables.cfg.reversedBlocks()[0]].empty()) {
    throw std::logic_error(""Out of exit block should be empty"");
}","liveVariables.analyzeCFG(liveVariables.in, kill, gen);
if (!liveVariables.out[liveVariables.cfg.reversedBlocks()[0]].empty()) {
    throw std::logic_error(""Out of exit block should be empty"");
}",0
"std::map<FileStatus, long long> filesToNumBlocksRollback;
filesToNumBlocksRollback.emplace(metaClient.getFs().getFileStatus(writer->getLogFile().getPath()), 1LL);
return std::make_pair(
    rollbackRequest.getPartitionPath(),
    HoodieRollbackStat::newBuilder()
        .withPartitionPath(rollbackRequest.getPartitionPath())
        .withRollbackBlockAppendResults(filesToNumBlocksRollback)
        .build()
);
default:
    throw std::runtime_error(""Unknown Rollback action "" + rollbackRequest.str());","std::map<FileStatus, long long> filesToNumBlocksRollback;
filesToNumBlocksRollback.emplace(metaClient.getFs().getFileStatus(writer->getLogFile().getPath()), 1LL);
return std::make_pair(
    rollbackRequest.getPartitionPath(),
    HoodieRollbackStat::newBuilder()
        .withPartitionPath(rollbackRequest.getPartitionPath())
        .withRollbackBlockAppendResults(filesToNumBlocksRollback)
        .build()
);",1
"#include <string>
#include <memory>
#include <cassert>
#include <atomic>

class Region {
public:
    // assume necessary methods
};

class Cache {
public:
    // assume necessary methods
};

class Logger {
public:
    bool isDebugEnabled() const { return true; }
    void debug(const std::string& msg) const {}
};

class RegionAttributesFactoryBean {
public:
    void setIgnoreJTA(bool ignoreJta) {}
    void afterPropertiesSet() {}
    void* getObject() { return nullptr; }
};

template<typename K, typename V>
class RegionFactoryBean {
public:
    void setBeanName(const std::string& name) {}
    void setAttributes(void* attributes) {}
    void setCache(Cache* cache) {}
    void afterPropertiesSet() {}
};

class AbstractKeyValueMessageStore {
    // ...
};

class InitializingBean {
public:
    virtual void afterPropertiesSet() = 0;
};

class GemfireMessageStore : public AbstractKeyValueMessageStore, public InitializingBean {
private:
    static constexpr const char* MESSAGE_STORE_REGION_NAME = ""messageStoreRegion"";
    std::atomic<Region*> messageStoreRegion{nullptr};
    Cache* cache;
    std::atomic<bool> ignoreJta{true};
    Logger logger;

public:
    GemfireMessageStore(Region* messageStoreRegionArg)
        : cache(nullptr)
    {
        messageStoreRegion.store(messageStoreRegionArg);
    }

    GemfireMessageStore(Cache* cacheArg)
        : cache(cacheArg)
    {
        assert(cache != nullptr && ""'cache' must not be null"");
    }

    void setIgnoreJta(bool ignore) {
        ignoreJta.store(ignore);
    }

    void afterPropertiesSet() override {
        if (messageStoreRegion.load() != nullptr) {
            return;
        }

        if (logger.isDebugEnabled()) {
            logger.debug(std::string(""creating message store region as '"") + MESSAGE_STORE_REGION_NAME + ""'"");
        }

        RegionAttributesFactoryBean attributesFactoryBean;
        attributesFactoryBean.setIgnoreJTA(ignoreJta.load());
        attributesFactoryBean.afterPropertiesSet();

        RegionFactoryBean<void, void> messageRegionFactoryBean;
        messageRegionFactoryBean.setBeanName(MESSAGE_STORE_REGION_NAME);
        messageRegionFactoryBean.setAttributes(attributesFactoryBean.getObject());
        messageRegionFactoryBean.setCache(cache);
        messageRegionFactoryBean.afterPropertiesSet();
    }
};","#include <memory>
#include <string>
#include <cassert>

class Region {
    // Implement region functionality as needed
};

class Cache {
    // Implement cache functionality as needed
};

class AbstractKeyValueMessageStore {
    // Implement base class functionality as needed
};

class InitializingBean {
public:
    virtual void afterPropertiesSet() = 0;
};

class RegionAttributesFactoryBean {
public:
    void setIgnoreJTA(bool ignoreJta) {
        ignore_jta = ignoreJta;
    }
    void afterPropertiesSet() {}

    // Replace with appropriate return type if needed
    void* getObject() { return nullptr; }

private:
    bool ignore_jta = true;
};

class RegionFactoryBean {
public:
    void setBeanName(const std::string& name) {
        bean_name = name;
    }
    void setAttributes(void* attrs) {}
    void setCache(std::shared_ptr<Cache> cachePtr) {
        cache = cachePtr;
    }
    void afterPropertiesSet() {}

private:
    std::string bean_name;
    std::shared_ptr<Cache> cache;
};

class Logger {
public:
    bool isDebugEnabled() const { return true; }
    void debug(const std::string& msg) const {}
};

class GemfireMessageStore : public AbstractKeyValueMessageStore, public InitializingBean {
public:
    static constexpr const char* MESSAGE_STORE_REGION_NAME = ""messageStoreRegion"";

    GemfireMessageStore(std::shared_ptr<Region> messageStoreRegion)
        : messageStoreRegion(messageStoreRegion)
        , cache(nullptr)
        , ignoreJta(true) {}

    GemfireMessageStore(std::shared_ptr<Cache> cache)
        : messageStoreRegion(nullptr)
        , cache(cache)
        , ignoreJta(true) {
        assert(cache != nullptr && ""'cache' must not be null"");
    }

    void setIgnoreJta(bool ignoreJtaVal) {
        ignoreJta = ignoreJtaVal;
    }

    void afterPropertiesSet() override {
        if (messageStoreRegion) {
            return;
        }
        if (logger.isDebugEnabled()) {
            logger.debug(std::string(""creating message store region as '"") + MESSAGE_STORE_REGION_NAME + ""'"");
        }

        RegionAttributesFactoryBean attributesFactoryBean;
        attributesFactoryBean.setIgnoreJTA(ignoreJta);
        attributesFactoryBean.afterPropertiesSet();
        RegionFactoryBean messageRegionFactoryBean;
        messageRegionFactoryBean.setBeanName(MESSAGE_STORE_REGION_NAME",1
"auto data = objectMapper.convertValue(lookupCacheEntity, JsonNode::type());
auto constraints = versionConstraints(cacheDto);
return EntityV1::builder()
    .type(ModelTypes::LOOKUP_CACHE_V1)
    .constraints(std::unordered_set<Constraint>(constraints.begin(), constraints.end()))
    .data(data)
    .build();

std::unordered_set<Constraint> versionConstraints(const CacheDto& cacheDto) {
    std::string packageName = typeid(cacheDto.config()).name();
    std::unordered_set<Constraint> result;
    for (const auto& metaData : pluginMetaData) {
        if (packageName.rfind(typeid(metaData).name(), 0) == 0) {
            result.insert(PluginVersionConstraint::of(metaData));
        }
    }
    return result;
}","EntityV1 toEntityV1(const CacheDto& cacheDto) {
    auto lookupCacheEntity = LookupCacheEntity(
        ValueReference::of(cacheDto.description()),
        toReferenceMap(configuration)
    );
    JsonNode data = objectMapper.convertValue(lookupCacheEntity, JsonNode::classType());
    auto constraints = versionConstraints(cacheDto);
    return EntityV1::builder()
        .type(ModelTypes::LOOKUP_CACHE_V1)
        .constraints(ImmutableSet<Constraint>::copyOf(constraints))
        .data(data)
        .build();
}

std::set<Constraint> versionConstraints(const CacheDto& cacheDto) {
    std::string packageName = cacheDto.config().getClass().getPackage().getName();
    std::set<Constraint> result;
    for (const auto& metaData : pluginMetaData) {
        std::string metaDataPackage = metaData.getClass().getPackage().getName();
        if (packageName.find(metaDataPackage) == 0) {
            result.insert(PluginVersionConstraint::of(metaData));
        }
    }
    return result;
}",1
"#include <memory>

class ApplicationEventPublisher;

class ServiceContext;

class BaseMetadataIndexer {
private:
    std::shared_ptr<ApplicationEventPublisher> publisher;

    // Member variables for all the dependencies
    std::shared_ptr<SearchManager> searchManager;
    std::shared_ptr<GeonetworkDataDirectory> geonetworkDataDirectory;
    std::shared_ptr<MetadataStatusRepository> statusRepository;
    std::shared_ptr<IMetadataUtils> metadataUtils;
    std::shared_ptr<IMetadataManager> metadataManager;
    std::shared_ptr<UserRepository> userRepository;
    std::shared_ptr<OperationAllowedRepository> operationAllowedRepository;
    std::shared_ptr<GroupRepository> groupRepository;
    std::shared_ptr<MetadataValidationRepository> metadataValidationRepository;
    std::shared_ptr<SchemaManager> schemaManager;
    std::shared_ptr<SvnManager> svnManager;
    std::shared_ptr<InspireAtomFeedRepository> inspireAtomFeedRepository;
    std::shared_ptr<XmlSerializer> xmlSerializer;
    std::shared_ptr<SettingManager> settingManager;

    std::shared_ptr<ServiceContext> servContext;

public:
    BaseMetadataIndexer() {
        // No-op
    }

    void init(std::shared_ptr<ServiceContext> context, bool force) {
        searchManager = context->getBean<SearchManager>();
        geonetworkDataDirectory = context->getBean<GeonetworkDataDirectory>();
        statusRepository = context->getBean<MetadataStatusRepository>();
        metadataUtils = context->getBean<IMetadataUtils>();
        metadataManager = context->getBean<IMetadataManager>();
        userRepository = context->getBean<UserRepository>();
        operationAllowedRepository = context->getBean<OperationAllowedRepository>();
        groupRepository = context->getBean<GroupRepository>();
        metadataValidationRepository = context->getBean<MetadataValidationRepository>();
        schemaManager = context->getBean<SchemaManager>();
        svnManager = context->getBean<SvnManager>();
        inspireAtomFeedRepository = context->getBean<InspireAtomFeedRepository>();
        xmlSerializer = context->getBean<XmlSerializer>();
        settingManager = context->getBean<SettingManager>();
        servContext = context;
    }
};","class BaseMetadataIndexer : public IMetadataIndexer, public ApplicationEventPublisher {
private:
    SearchManager* searchManager;
    GeonetworkDataDirectory* geonetworkDataDirectory;
    MetadataRepository* metadataRepository;
    MetadataStatusRepository* statusRepository;
    IMetadataUtils* metadataUtils;
    IMetadataManager* metadataManager;
    UserRepository* userRepository;
    OperationAllowedRepository* operationAllowedRepository;
    GroupRepository* groupRepository;
    MetadataValidationRepository* metadataValidationRepository;
    SchemaManager* schemaManager;
    SvnManager* svnManager;
    InspireAtomFeedRepository* inspireAtomFeedRepository;
    XmlSerializer* xmlSerializer;
    SettingManager* settingManager;

    ServiceContext* servContext;

public:
    BaseMetadataIndexer() {
    }

    void init(ServiceContext* context, bool force) {
        searchManager = context->getBean<SearchManager>();
        geonetworkDataDirectory = context->getBean<GeonetworkDataDirectory>();
        statusRepository = context->getBean<MetadataStatusRepository>();
        metadataUtils = context->getBean<IMetadataUtils>();
        metadataManager = context->getBean<IMetadataManager>();
        userRepository = context->getBean<UserRepository>();
        operationAllowedRepository = context->getBean<OperationAllowedRepository>();
        groupRepository = context->getBean<GroupRepository>();
        metadataValidationRepository = context->getBean<MetadataValidationRepository>();
        schemaManager = context->getBean<SchemaManager>();
        svnManager = context->getBean<SvnManager>();
        inspireAtomFeedRepository = context->getBean<InspireAtomFeedRepository>();
        xmlSerializer = context->getBean<XmlSerializer>();
        settingManager = context->getBean<SettingManager>();

        servContext = context;
    }
};",0
"}
}

Volume* cloneDataVolume(const CloneVMCmd& cmd, long snapshotId, Volume* volume) {
    long vmId = cmd.getEntityId();
    return createVolumeFromSnapshot(static_cast<VolumeVO*>(volume), snapshotId, vmId);
}

protected:
VolumeVO* createVolumeFromSnapshot(VolumeVO* volume, long snapshotId, long vmId) {
    VolumeInfo* createdVolume = nullptr;
    SnapshotVO* snapshot = _snapshotDao.findById(snapshotId);","Volume* cloneDataVolume(const CloneVMCmd& cmd, long snapshotId, Volume* volume) {
    long vmId = cmd.getEntityId();
    return createVolumeFromSnapshot(static_cast<VolumeVO*>(volume), snapshotId, vmId);
}",1
"return DefaultMuleMessage(TEST_PAYLOAD, muleContext);
}

//
///
/// @param message
/// @return creates a new MuleMessage with message as payload
///
protected:
MuleMessage getTestMuleMessage(const Object& message)
{
    return DefaultMuleMessage(message, muleContext);
}

public:
static MuleEvent getTestEvent(const Object& data, FlowConstruct* service)
{
    return MuleTestUtils::getTestEvent(data, service, MessageExchangePattern::REQUEST_RESPONSE, muleContext);
}","protected:
    MuleMessage* getTestMuleMessage(const Any& message) {
        return new DefaultMuleMessage(message, muleContext);
    }",1
"#include <atomic>
#include <memory>

class MessageConverter {
    // ...
};

class SimpleMessageConverter : public MessageConverter {
    // ...
};

class AmqpHeaderMapper {
    // ...
};

class DefaultAmqpHeaderMapper : public AmqpHeaderMapper {
    // ...
};

class RabbitTemplate {
    // ...
};

class YourClass {
private:
    std::atomic<std::shared_ptr<MessageConverter>> amqpMessageConverter{std::make_shared<SimpleMessageConverter>()};
    bool messageConverterSet;
    std::atomic<std::shared_ptr<AmqpHeaderMapper>> headerMapper{std::make_shared<DefaultAmqpHeaderMapper>()};
    RabbitTemplate* const amqpTemplate;
public:
    YourClass(RabbitTemplate* templatePtr) : amqpTemplate(templatePtr), messageConverterSet(false) {}
};","class AmqpInboundGateway : public MessagingGatewaySupport {
private:
    std::atomic<MessageConverter*> amqpMessageConverter{new SimpleMessageConverter()};
    bool messageConverterSet = false;
    std::atomic<AmqpHeaderMapper*> headerMapper{new DefaultAmqpHeaderMapper()};
    RabbitTemplate* amqpTemplate;
};",0
"#include ""TransformerException.h""
#include ""Connector.h""
#include ""CoreMessages.h""
#include ""TransformerUtils.h""
#include ""SimpleDataType.h""
#include ""Predicate.h""
#include ""SpiUtils.h""","#include ""mule/api/transformer/Transformer.h""
#include ""mule/api/transformer/TransformerException.h""
#include ""mule/api/transport/Connector.h""
#include ""mule/config/i18n/CoreMessages.h""
#include ""mule/transformer/TransformerUtils.h""
#include ""mule/transformer/types/SimpleDataType.h""
#include ""mule/util/Predicate.h""
#include ""mule/util/SpiUtils.h""",0
"std::string order(const std::string& body, const std::string& inputPersistId) {
    if (inputPersistId.empty()) {
        LOG.error(""Missing inputId. Returning HTTP 400."");
        throw WebApplicationException(400);
    }
    // ...
}","Response order(const std::string& body, const std::string& inputPersistId) {
    if (inputPersistId.empty()) {
        LOG.error(""Missing inputId. Returning HTTP 400."");
        throw WebApplicationException(400);
    }
    // ...
}",0
"}

if (!wrapperClassesList.empty()) {
    // Filter wrapperClassesList in place
    wrapperClassesList.erase(
        std::remove_if(wrapperClassesList.begin(), wrapperClassesList.end(),
            [&](const auto& wrapperClz) {
                auto wrapper = getAnnotation<Wrapper>(wrapperClz);
                if (!wrapper) return false;
                bool matchesEmpty = wrapper->matches().empty();
                bool nameInMatches = std::find(wrapper->matches().begin(), wrapper->matches().end(), name) != wrapper->matches().end();
                bool nameInMismatches = std::find(wrapper->mismatches().begin(), wrapper->mismatches().end(), name) != wrapper->mismatches().end();
                return !( (matchesEmpty || nameInMatches) && !nameInMismatches );
            }),
        wrapperClassesList.end()
    );

    for (const auto& wrapperClz : wrapperClassesList) {
        instance = injectExtension(wrapperClz->getConstructor(type)->newInstance(instance));
        instance = postProcessAfterInitialization(instance, name);
    }
}","```cpp
if (!wrapperClassesList.empty()) {
    wrapperClassesList.erase(
        std::remove_if(wrapperClassesList.begin(), wrapperClassesList.end(),
            [&](const auto& wrapperClz) {
                auto* wrapper = getAnnotation<Wrapper>(wrapperClz);
                return !(wrapper == nullptr ||
                       ((wrapper->matches().empty() || contains(wrapper->matches(), name)) &&
                        !contains(wrapper->mismatches(), name)));
            }),
        wrapperClassesList.end()
    );
    for (const auto& wrapperClz : wrapperClassesList) {
        instance = injectExtension(wrapperClz->getConstructor(type)->newInstance(instance));
        instance = postProcessAfterInitialization(instance, name);
    }
}
```",1
"return false;
}

void parseExclusiveOptional(const ExtensionParameter& extensionParameter,
                            const ParameterGroupDeclarer& parameterGroupDeclarer,
                            ParameterDeclarer& parameter) {
    if (auto groupDeclaration = dynamic_cast<const ParameterGroupDeclaration*>(parameterGroupDeclarer.getDeclaration())) {
        const auto& exclusiveParameters = groupDeclaration->getExclusiveParameters();
        if (!exclusiveParameters.empty() &&
            exclusiveParameters[0].getParameterNames().count(extensionParameter.getAlias()) > 0) {
            const auto& exclusiveParametersDeclaration = exclusiveParameters[0];
            ImmutableExclusiveParametersModel exclusiveParametersModel(
                exclusiveParametersDeclaration.getParameterNames(),
                exclusiveParametersDeclaration.isRequiresOne());
            parameter.withModelProperty(ExclusiveOptionalModelProperty(exclusiveParametersModel));
        }
    }
}

void parseConfigOverride(const ExtensionParameter& extensionParameter, ParameterDeclarer& parameter) {
    if (extensionParameter.getAnnotation<ConfigOverride>().has_value()) {
        parameter.asConfigOverride();
    }
}","void parseExclusiveOptional(const ExtensionParameter& extensionParameter, ParameterGroupDeclarer& parameterGroupDeclarer,
                            ParameterDeclarer& parameter) {
    auto* groupDeclaration = dynamic_cast<ParameterGroupDeclaration*>(parameterGroupDeclarer.getDeclaration());
    if (groupDeclaration) {
        const auto& exclusiveParameters = groupDeclaration->getExclusiveParameters();
        if (!exclusiveParameters.empty() &&
            exclusiveParameters.front().getParameterNames().count(extensionParameter.getAlias()) > 0) {
            const auto& exclusiveParametersDeclaration = exclusiveParameters.front();
            ExclusiveParametersModel* exclusiveParametersModel =
                new ImmutableExclusiveParametersModel(
                    exclusiveParametersDeclaration.getParameterNames(),
                    exclusiveParametersDeclaration.isRequiresOne()
                );
            parameter.withModelProperty(ExclusiveOptionalModelProperty(exclusiveParametersModel));
        }
    }
}",1
"auto correlationKey = this->correlationStrategy.getCorrelationKey(message);
if (correlationKey == nullptr) {
    throw std::logic_error(""Null correlation not allowed.  Maybe the CorrelationStrategy is failing?"");
}

if (this->logger.isDebugEnabled()) {
    this->logger.debug(""Handling message with correlationKey ["" + std::to_string(reinterpret_cast<uintptr_t>(correlationKey)) + ""]: "" + message);
}

auto groupIdUuid = UUIDConverter::getUUID(correlationKey);","auto correlationKey = this->correlationStrategy->getCorrelationKey(message);
assert(correlationKey != nullptr && ""Null correlation not allowed.  Maybe the CorrelationStrategy is failing?"");

if (this->logger->isDebugEnabled()) {
    std::ostringstream oss;
    oss << ""Handling message with correlationKey ["" << correlationKey << ""]: "" << message;
    this->logger->debug(oss.str());
}

auto groupIdUuid = UUIDConverter::getUUID(correlationKey);",0
"}
#include <regex>
#include <stdexcept>
#include <string>
#include <vector>
#include <map>
#include <sstream>

struct DbAndTable {
    std::string db;
    std::string table;
    DbAndTable(const std::string& db_, const std::string& table_) : db(db_), table(table_) {}
    const std::string& getDb() const { return db; }
    const std::string& getTable() const { return table; }
};

struct ConfigValue {
    enum Type { STRING, LIST } valueType;
    std::string stringValue;
    std::vector<std::string> listValue;

    ConfigValue() : valueType(STRING) {}
    ConfigValue(const std::string& s) : valueType(STRING), stringValue(s) {}
    ConfigValue(const std::vector<std::string>& l) : valueType(LIST), listValue(l) {}
};

struct Config {
    std::map<std::string, ConfigValue> values;

    Config resolve() const { return *this; }
    auto entrySet() const { return values; }
    std::vector<std::string> getStringList(const std::string& key) const { return values.at(key).listValue; }
    std::string getString(const std::string& key) const { return values.at(key).stringValue; }
};

namespace StringUtils {
    inline bool isNotBlank(const std::string& s) {
        return !s.empty() && s.find_first_not_of("" \t\n\r"") != std::string::npos;
    }
    inline std::string removeStart(const std::string& s, const std::string& start) {
        if (s.rfind(start, 0) == 0) return s.substr(start.length());
        return s;
    }
    inline std::string removeEnd(const std::string& s, const std::string& end) {
        if (s.length() >= end.length() && s.compare(s.length() - end.length(), end.length(), end) == 0)
            return s.substr(0, s.length() - end.length());
        return s;
    }
    inline std::string replaceEach(const std::string& input,
                                   const std::vector<std::string>& searchList,
                                   const std::vector<std::string>& replacementList) {
        std::string output = input;
        for (size_t i = 0; i < searchList.size(); ++i","#include <string>
#include <vector>
#include <map>
#include <stdexcept>
#include <sstream>
#include <algorithm>

struct DbAndTable {
    std::string db;
    std::string table;
    DbAndTable(const std::string& d, const std::string& t) : db(d), table(t) {}
    const std::string& getDb() const { return db; }
    const std::string& getTable() const { return table; }
};

namespace StringUtils {
    inline bool isNotBlank(const std::string& s) {
        return !s.empty() && s.find_first_not_of("" \t\n\r"") != std::string::npos;
    }
    inline std::string removeStart(const std::string& src, const std::string& prefix) {
        if (src.find(prefix) == 0) return src.substr(prefix.size());
        return src;
    }
    inline std::string removeEnd(const std::string& src, const std::string& suffix) {
        if (src.size() >= suffix.size() && 
            src.compare(src.size() - suffix.size(), suffix.size(), suffix) == 0)
            return src.substr(0, src.size() - suffix.size());
        return src;
    }
    inline std::string replaceEach(const std::string& text, const std::vector<std::string>& searchList, const std::vector<std::string>& replacementList) {
        std::string result = text;
        for (size_t i = 0; i < searchList.size(); ++i) {
            size_t pos = 0;
            while ((pos = result.find(searchList[i], pos)) != std::string::npos) {
                result.replace(pos, searchList[i].length(), replacementList[i]);
                pos += replacementList[i].length();
            }
        }
        return result;
    }
}

struct ConfigValue {
    enum ValueType { STRING, LIST };
    ValueType valueType;
    std::string stringValue;
    std::vector<std::string> listValue;
    ConfigValue(const std::string& s) : valueType(STRING), stringValue(s) {}
    ConfigValue(const std::vector<std::string>& l) : valueType(LIST), listValue(l) {}
};

class Config {
public:
    std::map<std::string, ConfigValue> data;

    Config resolve() const { return *this; }
    std::vector<std::string> get",1
"#include ""Engine.h""
#include ""EmailConfiguration.h""
#include ""NotificationService.h""
#include ""Message.h""","#include ""com/floreysoft/jmte/Engine.h""
#include ""org/graylog2/configuration/EmailConfiguration.h""
#include ""org/graylog2/notifications/NotificationService.h""
#include ""org/graylog2/plugin/Message.h""",0
"#include ""gobblin/source/extractor/limiter/LimiterConfigurationKeys.h""
#include ""gobblin/source/workunit/MultiWorkUnit.h""
#include <stdexcept>
#include <vector>","#include ""gobblin/source/extractor/limiter/LimiterConfigurationKeys.h""
#include ""gobblin/source/workunit/MultiWorkUnit.h""
#include <stdexcept>
#include <vector>",0
"CursorStream openCursor() final override {
    if (closed.get()) {
        throw CursorProviderAlreadyClosedException(
            ""Cannot open a new cursor on a closed stream"",
            getOriginatingLocation(),
            std::optional(closerResponsible)
        );
    }
    return doOpenCursor();
}","virtual CursorStream* openCursor() final {
    if (closed.load()) {
        throw CursorProviderAlreadyClosedException(
            ""Cannot open a new cursor on a closed stream"",
            getOriginatingLocation(),
            closerResponsible ? std::optional(closerResponsible) : std::nullopt
        );
    }
    return doOpenCursor();
}",0
"void verifyConfig()
{
    DefaultHttpRequesterConfig* requestConfig = muleContext.getRegistry()->lookupObject(""requestConfig"");
    assert(requestConfig->getMaxConnections() == MAX_CONNECTIONS);
    assert(requestConfig->getConnectionIdleTimeout() == IDLE_TIMEOUT);
}","void verifyConfig()
{
    DefaultHttpRequesterConfig* requestConfig = muleContext.getRegistry()->lookupObject<DefaultHttpRequesterConfig>(""requestConfig"");
    ASSERT_EQ(requestConfig->getMaxConnections(), MAX_CONNECTIONS);
    ASSERT_EQ(requestConfig->getConnectionIdleTimeout(), IDLE_TIMEOUT);
}",1
"#include <map>
#include <string>
#include <vector>

template<typename T>
class ClassAliasResolver {
  // Scan all packages in the classpath with prefix gobblin, com.linkedin.gobblin when class is loaded.
  // Since scan is expensive we do it only once when class is loaded.

  // static Reflections REFLECTIONS = Reflections(ConfigurationBuilder().forPackages(""gobblin"", ""com.linkedin.gobblin""));

public:
  std::map<std::string, std::shared_ptr<T>> aliasToClassCache;
  std::vector<Alias> aliasObjects;
};","#include <map>
#include <string>
#include <vector>

template <typename T>
class ClassAliasResolver {
private:
    // Only scan packages with prefix gobblin and com.linkedin.gobblin at initialization
    static inline Reflections REFLECTIONS = Reflections(ConfigurationBuilder().forPackages(""gobblin"", ""com.linkedin.gobblin""));

    std::map<std::string, const std::type_info*> aliasToClassCache;
    std::vector<Alias> aliasObjects;
};",1
"if (jobConfSourceFileFsUri && jobConfSourceFilePath && jobConfDirPath) {

    auto uri = URI::create(*jobConfSourceFileFsUri);

    FileSystem fs(uri, HadoopUtils::getConfFromState(ConfigUtils::configToState(config)));

    Path sourceFile(*jobConfSourceFilePath);

    std::string zipFile = appendSlash(*jobConfDirPath) +
        StringUtils::substringAfterLast(*jobConfSourceFilePath, std::filesystem::path::preferred_separator);

    LOGGER.debug(""Downloading to zip: "" + zipFile + "" from uri: "" + sourceFile.toString());

    fs.copyToLocalFile(sourceFile, Path(zipFile));

    std::string extractedPullFilesPath = appendSlash(*jobConfDirPath) + ""files"";

}","if (jobConfSourceFileFsUri.has_value() && jobConfSourceFilePath.has_value() && jobConfDirPath.has_value()) {

    std::string uri = jobConfSourceFileFsUri.value();
    auto fs = FileSystem::get(uri, HadoopUtils::getConfFromState(ConfigUtils::configToState(config)));

    std::string sourceFile = jobConfSourceFilePath.value();
    std::string zipFile = appendSlash(jobConfDirPath.value()) +
        StringUtils::substringAfterLast(sourceFile, std::filesystem::path::preferred_separator);
    LOGGER.debug(""Downloading to zip: "" + zipFile + "" from uri: "" + sourceFile);
    fs.copyToLocalFile(sourceFile, zipFile);

    std::string extractedPullFilesPath = appendSlash(jobConfDirPath.value()) + ""files"";
}",0
"#include <string>
#include <stdexcept>
#include <filesystem>

class MyClass : public BaseClass {
private:
    std::filesystem::path getClasspathResourceAsUri(const std::string& resource) {
        // Assuming resources are in ""./resources/""
        std::filesystem::path path = std::filesystem::current_path() / ""resources"" / resource;
        if (!std::filesystem::exists(path)) {
            throw std::invalid_argument(""Resource not found: "" + resource);
        }
        return std::filesystem::absolute(path);
    }
public:
    int getTestTimeoutSecs() override {
        return 20 * BaseClass::getTestTimeoutSecs();
    }
};","#include <string>
#include <stdexcept>
#include <filesystem>

class EmbeddedContainerTestCase {
protected:
    virtual int getTestTimeoutSecsBase() const {
        throw std::runtime_error(""Not implemented"");
    }

public:
    std::filesystem::path getClasspathResourceAsUri(const std::string& resource) {
        // Implementation depends on how resources are accessed; placeholder:
        return std::filesystem::absolute(resource);
    }

    int getTestTimeoutSecs() override {
        return 20 * getTestTimeoutSecsBase();
    }
};",1
"```cpp
/**
 * Commit the HoodieRecords to Metadata Table as a new delta-commit.
 * @param records The list of records to be written.
 * @param partitionName The partition to which the records are to be written.
 * @param instantTime The timestamp to use for the deltacommit.
 * @param canTriggerTableService true if table services can be scheduled and executed. false otherwise.
 */
protected:
    virtual void commit(const std::vector<HoodieRecord>& records, const std::string& partitionName,
                        const std::string& instantTime, bool canTriggerTableService) = 0;

/**
 *  Perform a compaction on the Metadata Table.
 */
```","```cpp
protected:
  virtual void commit(const std::vector<HoodieRecord>& records, const std::string& partitionName, const std::string& instantTime, bool canTriggerTableService) = 0;
```",0
"void visitCompilationUnit(const CompilationUnitTree& tree) override {
    if (tree.packageDeclaration() != nullptr) {
        scan(tree.packageDeclaration()->annotations());
    }
    scan(tree.types());
}","void visitCompilationUnit(const CompilationUnitTree& tree) override {
    if (tree.packageDeclaration() != nullptr) {
        scan(tree.packageDeclaration()->annotations());
    }
    scan(tree.types());
}",0
"#include <vector>
#include <memory>
#include <optional>
#include <cassert>
#include <istream>
#include <ostream>
#include <sstream>

#include <avro/Generic.hh>
#include <avro/Compiler.hh>
#include <avro/Encoder.hh>
#include <avro/Decoder.hh>
#include <avro/Stream.hh>
#include <avro/Specific.hh>
#include <avro/ValidSchema.hh>
#include <avro/Exception.hh>","#include <vector>
#include <optional>
#include <cassert>
#include <stdexcept>
#include <memory>
#include <avro/Specific.hh>
#include <avro/Encoder.hh>
#include <avro/Decoder.hh>
#include <avro/Generic.hh>
#include <avro/ValidSchema.hh>
#include <sstream>",0
"protected:
    static constexpr const char* METHOD_ATTRIBUTE = ""method"";
    static constexpr const char* EXPRESSION_ATTRIBUTE = ""expression"";
    static constexpr const char* CHANNEL_CREATOR_BEAN_NAME = ""$_inputChannelCreator"";
    static constexpr const char* CHANNEL_NAMES = ""$_channelNames"";

public:
    bool shouldGenerateId() override {","```cpp
class AbstractConsumerEndpointParser : public AbstractBeanDefinitionParser {
protected:
    static constexpr const char* METHOD_ATTRIBUTE = ""method"";
    static constexpr const char* EXPRESSION_ATTRIBUTE = ""expression"";
    static constexpr const char* CHANNEL_CREATOR_BEAN_NAME = ""$_inputChannelCreator"";
    static constexpr const char* CHANNEL_NAMES = ""$_channelNames"";

    bool shouldGenerateId() override;
};
```",1
"std::string key = entry.first;
auto value = entry.second;

std::unique_ptr<std::enumeration<std::string>> valueAsEnumeration = nullptr;
if (typeid(*value) != typeid(std::enumeration<std::string>)) {
    valueAsEnumeration = std::make_unique<SingleElementEnumeration>(static_cast<std::string>(*value));
} else {
    valueAsEnumeration = std::unique_ptr<std::enumeration<std::string>>(static_cast<std::enumeration<std::string>*>(value));
}

EXPECT_CALL(mockRequest, getHeaders(::testing::Eq(key))).WillOnce(::testing::Return(valueAsEnumeration.get()));","for (const auto& entry : map) {
    const std::string& key = entry.first;
    auto* value = entry.second;

    std::shared_ptr<Enumeration<std::string>> valueAsEnumeration = nullptr;
    if (dynamic_cast<Enumeration<std::string>*>(value) == nullptr) {
        valueAsEnumeration = std::make_shared<SingleElementEnumeration>(static_cast<std::string*>(value));
    } else {
        valueAsEnumeration = std::shared_ptr<Enumeration<std::string>>(static_cast<Enumeration<std::string>*>(value));
    }

    EXPECT_CALL(*mockRequest, getHeaders(::testing::Eq(key))).WillOnce(Return(valueAsEnumeration));
}",1
"TEST_METHOD(deploysAppZipWithContainerPluginBroken)
{
    ArtifactPluginFileBuilder echoPluginBroken(""echoPlugin"");
    echoPluginBroken.configuredWith(EXPORTED_CLASS_PACKAGES_PROPERTY, ""org.foo"")
                   .dependingOn(JarFileBuilder(""echoTest"", echoTestJarFile))
                   .corrupted();

    installContainerPlugin(echoPluginBroken);

    ApplicationFileBuilder applicationFileBuilder(""my-app.zip"", emptyAppFileBuilder);
    applicationFileBuilder.dependingOn(echoPluginWithLib1);
    addPackedAppFromBuilder(applicationFileBuilder);

    startDeployment();
}","```cpp
TEST_F(DeploymentServiceTestCase, deploysAppZipWithContainerPluginBroken) {
    ArtifactPluginFileBuilder echoPluginBroken(""echoPlugin"");
    echoPluginBroken.configuredWith(EXPORTED_CLASS_PACKAGES_PROPERTY, ""org.foo"")
                   .dependingOn(JarFileBuilder(""echoTest"", echoTestJarFile))
                   .corrupted();

    installContainerPlugin(echoPluginBroken);

    ApplicationFileBuilder applicationFileBuilder(""my-app.zip"", emptyAppFileBuilder);
    applicationFileBuilder.dependingOn(echoPluginWithLib1);
    addPackedAppFromBuilder(applicationFileBuilder);

    startDeployment();
}
```",0
"#include <mule/runtime/module/extension/internal/util/MuleExtensionUtils.h>
#include <slf4j/LoggerFactory.h>
#include <reactor/core/publisher/Flux.h>
#include <reactor/core/publisher/Mono.h>

using mule::runtime::module::extension::internal::util::MuleExtensionUtils::getInitialiserEvent;
using mule::runtime::module::extension::internal::util::MuleExtensionUtils::getOperationExecutorFactory;
using slf4j::LoggerFactory::getLogger;
using reactor::core::publisher::Flux::error;
using reactor::core::publisher::Flux::from;
using reactor::core::publisher::Mono::fromCallable;","#include <memory>
#include <functional>
#include <stdexcept>
#include <vector>
#include <future>
#include <spdlog/spdlog.h>
#include <spdlog/sinks/basic_file_sink.h>

using namespace std;

// Placeholder for getInitialiserEvent
auto getInitialiserEvent = []() { /* ... */ };

// Placeholder for getOperationExecutorFactory
auto getOperationExecutorFactory = []() { /* ... */ };

// Logger initialization
static auto logger = spdlog::get(""default"") ? spdlog::get(""default"") : spdlog::basic_logger_mt(""default"", ""log.txt"");

// Equivalent of error for a reactive Flux-like type
template <typename T>
auto flux_error(std::exception_ptr eptr) {
    std::promise<T> p;
    p.set_exception(eptr);
    return p.get_future();
}

// Equivalent of from for a reactive Flux-like type
template <typename Container>
auto flux_from(const Container& c) {
    // This is a placeholder that wraps the container in a vector for demonstration
    return std::vector<typename Container::value_type>(c.begin(), c.end());
}

// Equivalent of fromCallable for a reactive Mono-like type
template <typename Func>
auto mono_fromCallable(Func&& fn) {
    std::packaged_task<decltype(fn())()> task(std::forward<Func>(fn));
    auto fut = task.get_future();
    task();
    return fut;
}",0
"{
    auto runner = flowRunner(""SplitterFlow"").withPayload(PAYLOAD).asynchronously();
    runner.run();
    auto msg = client.request(""test://collectionCreated"", RECEIVE_TIMEOUT);
    assert(msg != nullptr);
    assert(dynamic_cast<std::list<std::any>*>(msg->getPayload()) != nullptr);
}","std::string payload = ""Long string that wil be broken uop into multiple messages"";
flowRunner(""SplitterFlow"").withPayload(PAYLOAD).asynchronously().run();
auto msg = client.request(""test://collectionCreated"", RECEIVE_TIMEOUT);
assert(msg != nullptr);
assert(dynamic_cast<std::list<std::any>*>(msg->getPayload()) != nullptr);",0
"```cpp
static EventContext child(EventContext* parent, std::optional<ComponentLocation> componentLocation) {
    return child(parent, componentLocation, NULL_ERROR_HANDLER);
}

static EventContext fireAndForgetChild(EventContext* parent, std::optional<ComponentLocation> componentLocation) {
    EventContext* context = parent;
    MessagingExceptionHandler exceptionHandler = NULL_ERROR_HANDLER;

    while (context != nullptr && exceptionHandler == NULL_ERROR_HANDLER) {
        if (auto abstractContext = dynamic_cast<AbstractEventContext*>(context)) {
            exceptionHandler = abstractContext->getExceptionHandler();
        } else {
            exceptionHandler = NULL_ERROR_HANDLER;
        }
        auto parentOpt = context->getParentContext();
        context = parentOpt ? *parentOpt : nullptr;
    }
    return child(parent, componentLocation, exceptionHandler);
}
```","```cpp
static EventContext* child(EventContext* parent, std::optional<ComponentLocation> componentLocation) {
    return child(parent, componentLocation, NULL_ERROR_HANDLER);
}

static EventContext* fireAndForgetChild(EventContext* parent, std::optional<ComponentLocation> componentLocation) {
    EventContext* context = parent;
    MessagingExceptionHandler exceptionHandler = NULL_ERROR_HANDLER;

    while (context != nullptr && exceptionHandler == NULL_ERROR_HANDLER) {
        if (auto absContext = dynamic_cast<AbstractEventContext*>(context)) {
            exceptionHandler = absContext->getExceptionHandler();
        } else {
            exceptionHandler = NULL_ERROR_HANDLER;
        }
        auto parentOpt = context->getParentContext();
        context = parentOpt ? parentOpt.value() : nullptr;
    }
    return child(parent, componentLocation, exceptionHandler);
}
```",1
"#include <string>
#include <typeinfo>
#include <unordered_map>
#include <memory>
#include <mutex>

class BaseDecorator {
protected:
    struct QualifiedClassNameCache {
        std::unordered_map<const std::type_info*, std::string> cache;
        std::mutex mtx;

        std::string get(const std::type_info& info) {
            std::lock_guard<std::mutex> lock(mtx);
            auto it = cache.find(&info);
            if (it != cache.end()) {
                return it->second;
            }
            std::string name = demangle(info.name());
            cache[&info] = name;
            return name;
        }

        static std::string demangle(const char* mangled) {
#ifdef __GNUG__
            int status = 0;
            char* demangled = abi::__cxa_demangle(mangled, nullptr, nullptr, &status);
            std::string result = (status == 0 && demangled) ? demangled : mangled;
            free(demangled);
            return result;
#else
            return mangled;
#endif
        }
    };

    static QualifiedClassNameCache CLASS_NAMES;

    BaseDecorator() {}
};

BaseDecorator::QualifiedClassNameCache BaseDecorator::CLASS_NAMES;","#include <string>
#include <typeinfo>
#include <unordered_map>
#include <mutex>

class QualifiedClassNameCache {
public:
    using Function = std::function<std::string(const std::type_info&)>;
    using JoinFunction = std::function<std::string(const std::string&)>;

    QualifiedClassNameCache(Function fn, JoinFunction joinFn)
        : func(fn), joinFunc(joinFn) {}

    std::string get(const std::type_info& type) {
        std::lock_guard<std::mutex> lock(mtx);
        auto it = cache.find(type.hash_code());
        if (it != cache.end()) {
            return it->second;
        }
        std::string name = func(type);
        std::string joinedName = joinFunc(name);
        cache[type.hash_code()] = joinedName;
        return joinedName;
    }

private:
    Function func;
    JoinFunction joinFunc;
    std::unordered_map<size_t, std::string> cache;
    std::mutex mtx;
};

struct Functions {
    struct PrefixJoin {
        static QualifiedClassNameCache::JoinFunction of(const std::string& /*sep*/) {
            return [](const std::string& s) { return s; };
        }
    };
};

class BaseDecorator {
protected:
    static QualifiedClassNameCache CLASS_NAMES;

    BaseDecorator() = default;
};

QualifiedClassNameCache BaseDecorator::CLASS_NAMES(
    [](const std::type_info& type) -> std::string {
        std::string name = type.name();
        size_t pos = name.rfind(""::"");
        if (pos != std::string::npos) {
            return name.substr(pos + 2);
        }
        return name;
    },
    Functions::PrefixJoin::of(""."")
);",1
"#include <vector>
#include <set>
#include <memory>
#include <functional>
#include <future>
#include <exception>

class InitialisationException : public std::exception {
public:
    const char* what() const noexcept override { return ""InitialisationException""; }
};

class Startable {
public:
    virtual void start() = 0;
    virtual ~Startable() = default;
};

class Stoppable {
public:
    virtual void stop() = 0;
    virtual ~Stoppable() = default;
};

class Scheduler {};
class SchedulerConfig {};
class SchedulerService {};
class MuleContext {};
class FlowConstruct {};
class CoreEvent {};
class Processor {
public:
    virtual CoreEvent process(const CoreEvent& event) = 0;
    virtual ~Processor() = default;
};
class ReactiveProcessor {};
class Sink {};
class ProcessingStrategy {};
class MessagingException : public std::exception {
public:
    const char* what() const noexcept override { return ""MessagingException""; }
};
class PolicyNotificationHelper {};
class AbstractProcessingStrategy {};
class StreamPerEventSink {};
class MessageProcessors {};
class InterceptedReactiveProcessor {};
class MessageProcessorChain {};
template<typename T>
class Publisher {};
template<typename T>
using Flux = std::vector<T>;
template<typename T>
using Mono = std::shared_ptr<T>;

class Inject {
public:
    template<typename T>
    void operator()(T*) {}
};

// Example class implementation using the included types above
class PolicyChain : public Startable, public Stoppable {
public:
    void start() override {}
    void stop() override {}

private:
    MuleContext* muleContext;
    FlowConstruct* flowConstruct;
    std::vector<std::shared_ptr<Processor>> processors;
    std::set<int> someSet;
    Scheduler* scheduler;
    SchedulerConfig* schedulerConfig;
    SchedulerService* schedulerService;
    PolicyNotificationHelper* policyNotificationHelper;
    std::unique_ptr<MessageProcessorChain> processorChain;

public:
    PolicyChain(MuleContext* context,
                FlowConstruct* flow,
                std::vector<std::shared_ptr<Processor>> procList)
        : muleContext(context), flowConstruct(flow), processors(std::move(procList)) {}

    std::future<CoreEvent> processAsync(const CoreEvent& event) {
        return std::async(std::launch::async, [this, event]() {
            for (const auto& processor : processors) {
                CoreEvent processed = processor->process(event);
            }
            return event;
        });
    }
};","#include <vector>
#include <set>
#include <memory>
#include <exception>

class MuleContext;
class FlowConstruct;
class CoreEvent;
class Processor;
class ReactiveProcessor;
class Sink;
class ProcessingStrategy;
class Scheduler;
class SchedulerConfig;
class SchedulerService;
class MessagingException : public std::exception {};
class PolicyNotificationHelper;
class AbstractProcessingStrategy;
class StreamPerEventSink;
class MessageProcessors;
class DefaultMessageProcessorChainBuilder;
class InterceptedReactiveProcessor;
class MessageProcessorChain;

// Reactive types placeholders
template<typename T>
class Publisher;

template<typename T>
class Flux;

template<typename T>
class Mono;

class PolicyChain {
public:
    std::vector<std::shared_ptr<Processor>> messageProcessors;
    MuleContext* muleContext;
    PolicyNotificationHelper* policyNotificationHelper;
    FlowConstruct* flowConstruct;
    SchedulerService* schedulerService;
    std::set<std::shared_ptr<Scheduler>> schedulers;

    PolicyChain() = default;
    virtual ~PolicyChain() = default;
};",0
"std::copy(
    writeFunction(records, currentInstant).begin(),
    writeFunction(records, currentInstant).end(),
    std::back_inserter(writeStatus)
);
this->eventGateway.sendEventToCoordinator(
    new BatchWriteSuccessEvent(this->taskID, currentInstant, writeStatus, isFinalBatch)
);
this->buffer.clear();
this->currentInstant = """";","```cpp
void StreamWriteFunction::process() {
    if (!buffer.empty()) {
        for (auto& records : buffer) {
            auto statuses = writeFunction(records, currentInstant);
            writeStatus.insert(writeStatus.end(), statuses.begin(), statuses.end());
        }
    } else {
        LOG.info(""No data to write in subtask [{}] for instant [{}]"", taskID, currentInstant);
        writeStatus.clear();
    }
    eventGateway->sendEventToCoordinator(
        BatchWriteSuccessEvent(taskID, currentInstant, writeStatus, isFinalBatch));
    buffer.clear();
    currentInstant = """";
}
```",0
"#include ""client/AbstractHoodieWriteClient.h""
#include ""common/config/HoodieMetadataConfig.h""
#include ""common/config/SerializableConfiguration.h""
#include ""common/data/HoodieData.h""
#include ""common/engine/HoodieEngineContext.h""
#include ""common/fs/ConsistencyGuardConfig.h""
#include ""common/fs/FSUtils.h""","#include ""org/apache/hudi/avro/model/HoodieRollbackMetadata.h""
#include ""org/apache/hudi/client/AbstractHoodieWriteClient.h""
#include ""org/apache/hudi/common/config/HoodieMetadataConfig.h""
#include ""org/apache/hudi/common/config/SerializableConfiguration.h""
#include ""org/apache/hudi/common/data/HoodieData.h""
#include ""org/apache/hudi/common/engine/HoodieEngineContext.h""
#include ""org/apache/hudi/common/fs/ConsistencyGuardConfig.h""
#include ""org/apache/hudi/common/fs/FSUtils.h""",0
"void visitBinaryExpression(const BinaryExpressionTree& tree) override {
    checkDeferredConstraint();
}

void visitAssignmentExpression(const AssignmentExpressionTree& tree) override {
    checkDeferredConstraint();
}

void visitUnaryExpression(const UnaryExpressionTree& tree) override {
    checkDeferredConstraint();
}

void visitTypeCast(const TypeCastTree& tree) override {
    checkDeferredConstraint();
}

private:
void checkDeferredConstraint() {
    SymbolicValue sv = programState.peekValue();
    if (auto deferred = dynamic_cast<DeferredStatusHolderSV*>(sv)) {
        addZeroConstraint(sv, deferred->deferredStatus);
    }
}

void addZeroConstraint(SymbolicValue sv, Status status) {
    programState = programState.addConstraint(sv, ZeroConstraint(status));
}","class DivisionByZeroCheck : public SECheck {
public:
    void visitBinaryExpression(const BinaryExpressionTree& tree) override {
        checkDeferredConstraint();
    }

    void visitAssignmentExpression(const AssignmentExpressionTree& tree) override {
        checkDeferredConstraint();
    }

    void visitUnaryExpression(const UnaryExpressionTree& tree) override {
        checkDeferredConstraint();
    }

    void visitTypeCast(const TypeCastTree& tree) override {
        checkDeferredConstraint();
    }

private:
    void checkDeferredConstraint() {
        SymbolicValue* sv = programState.peekValue();
        if (auto dsv = dynamic_cast<DeferredStatusHolderSV*>(sv)) {
            addZeroConstraint(sv, dsv->deferredStatus);
        }
    }

    void addZeroConstraint(SymbolicValue* sv, Status status) {
        programState = programState.addConstraint(sv, ZeroConstraint(status));
    }

    ProgramState programState;
};",0
"#include <gmock/gmock.h>
using ::testing::NotNull;
using ::testing::IsNull;
using ::testing::Ref;
using ::testing::Not;
using ::testing::_;","#include <gmock/gmock.h>
using ::testing::_;
using ::testing::Return;
using ::testing::NotNull;
using ::testing::IsNull;
using ::testing::Ref;
using ::testing::Not;",0
"return Builder();

protected:
    MuleDeployment()
        : SuperClass() {
    }","class MuleDeployment : public MuleInstallation {
public:
    static Builder builder() {
        return Builder();
    }

protected:
    MuleDeployment()
        : MuleInstallation() {
    }
};",0
"```cpp
class MyClass {
private:
    RCompletionToolTip* toolTip_;
    DocDisplay* docDisplay_;
    HandlerRegistrations* handlers_;
    Timer* timer_;

    HandlerRegistration* preview_;
    MouseCoordinates* coordinates_;
    Position* position_;
    AnchoredSelection* anchor_;

    UIPrefs* uiPrefs_;
    CodeToolsServerOperations* server_;
};
```","class SignatureToolTipManager
{
private:
    RCompletionToolTip* toolTip_;
    DocDisplay* docDisplay_;
    HandlerRegistrations* handlers_;
    Timer* timer_;

    HandlerRegistration* preview_;
    MouseCoordinates* coordinates_;
    Position* position_;
    AnchoredSelection* anchor_;

    UIPrefs* uiPrefs_;
    CodeToolsServerOperations* server_;
};",0
"EXPECT_CALL(virtualMachine, getDataCenterId())
    .WillRepeatedly(Return(DATACENTERID));
EXPECT_CALL(virtualMachine, getInstanceName())
    .WillRepeatedly(Return(VMINSTANCENAME));
EXPECT_CALL(virtualMachine, getUserData())
    .WillRepeatedly(Return(VMUSERDATA));
EXPECT_CALL(virtualMachine, getHostName())
    .WillRepeatedly(Return(std::string(""vm-hostname"")));
EXPECT_CALL(deployDestination, getHost())
    .WillRepeatedly(Return(hostVO));
EXPECT_CALL(hostVO, getId())
    .WillRepeatedly(Return(HOSTID));
EXPECT_CALL(nic, isDefaultNic())
    .WillRepeatedly(Return(true));","virtualMachine.getDataCenterId = []() { return DATACENTERID; };
virtualMachine.getInstanceName = []() { return VMINSTANCENAME; };
virtualMachine.getUserData = []() { return VMUSERDATA; };
virtualMachine.getHostName = []() { return ""vm-hostname""; };
deployDestination.getHost = [&]() { return hostVO; };
hostVO.getId = []() { return HOSTID; };
nic.isDefaultNic = []() { return true; };",1
"static HoodieDeltaStreamer::Config makeConfig(
    const std::string& basePath,
    Operation op,
    const std::string& transformerClassName,
    const std::string& propsFilename,
    bool enableHiveSync)
{
    return makeConfig(basePath, op, transformerClassName, propsFilename, enableHiveSync, true, false, """", """");
}

static HoodieDeltaStreamer::Config makeConfig(
    const std::string& basePath,
    Operation op,
    const std::string& transformerClassName,
    const std::string& propsFilename,
    bool enableHiveSync,
    bool useSchemaProviderClass,
    bool updatePayloadClass,
    const std::string& payloadClassName,
    const std::string& storageType)
{
    HoodieDeltaStreamer::Config cfg;
    cfg.targetBasePath = basePath;
    cfg.targetTableName = ""hoodie_trips"";
    cfg.storageType = storageType.empty() ? ""COPY_ON_WRITE"" : storageType;
    cfg.sourceClassName = typeid(TestDataSource).name();
    cfg.transformerClassName = transformerClassName;
    cfg.operation = op;
    return cfg;
}","static HoodieDeltaStreamer::Config makeConfig(const std::string& basePath, Operation op,
                                              const std::string& transformerClassName,
                                              const std::string& propsFilename, bool enableHiveSync) {
    return makeConfig(basePath, op, transformerClassName, propsFilename, enableHiveSync, true,
                     false, """", """");
}

static HoodieDeltaStreamer::Config makeConfig(const std::string& basePath, Operation op,
                                              const std::string& transformerClassName,
                                              const std::string& propsFilename, bool enableHiveSync,
                                              bool useSchemaProviderClass, bool updatePayloadClass,
                                              const std::string& payloadClassName, const std::string& storageType) {
    HoodieDeltaStreamer::Config cfg;
    cfg.targetBasePath = basePath;
    cfg.targetTableName = ""hoodie_trips"";
    cfg.storageType = storageType.empty() ? ""COPY_ON_WRITE"" : storageType;
    cfg.sourceClassName = typeid(TestDataSource).name();
    cfg.transformerClassName = transformerClassName;
    cfg.operation = op;
    return cfg;
}",0
"#include <chrono>
#include <filesystem>
#include <string>
#include <vector>

class Config {
private:
    std::chrono::seconds dashboardWidgetDefaultCacheTime{10};
    bool contentPacksLoaderEnabled = true;
    std::filesystem::path contentPacksDir = std::filesystem::path(""data"") / ""contentpacks"";
    std::vector<std::string> contentPacksAutoLoad;

    bool isMasterFlag;

public:
    bool isMaster() const {
        return isMasterFlag;
    }
};","class Configuration : public BaseConfiguration {
private:
    std::chrono::seconds dashboardWidgetDefaultCacheTime{10};

    bool contentPacksLoaderEnabled = true;

    std::filesystem::path contentPacksDir = std::filesystem::path(""data"") / ""contentpacks"";

    std::vector<std::string> contentPacksAutoLoad;

public:
    bool isMaster() const {
        return isMaster;
    }
};",1
"#include <string>
#include <map>
#include <any>

class PackageInstaller;

class Package {
public:
    void do_install(const std::map<std::string, std::any>& kwargs = {}) {
        PackageInstaller builder(this);
        builder.install(kwargs);
    }
};

class PackageInstaller {
public:
    PackageInstaller(Package* pkg) : pkg_(pkg) {}
    void install(const std::map<std::string, std::any>& kwargs) {
        // Implementation goes here
    }
private:
    Package* pkg_;
} ;","```cpp
class PackageBase {
public:
    void do_install(const std::map<std::string, boost::any>& kwargs = {}) {
        PackageInstaller builder(this);
        builder.install(kwargs);
    }

    bool unit_test_check() {
        // Hook for unit tests to assert things about package internals.
        return true;
    }
};
```",1
"bool canCommit(JobCommitPolicy commitPolicy, const JobState& jobState) {
    // Only commit job data if 1) COMMIT_ON_PARTIAL_SUCCESS is used,
    // or 2) COMMIT_ON_FULL_SUCCESS is used and the job has succeeded.
    return 
        commitPolicy == JobCommitPolicy::COMMIT_ON_PARTIAL_SUCCESS ||
        (commitPolicy == JobCommitPolicy::COMMIT_ON_FULL_SUCCESS &&
         jobState.getState() == JobState::RunningState::SUCCESSFUL);
}

void commitJob(const std::string& jobId, JobCommitPolicy commitPolicy, JobState& jobState) {
    if (!canCommit(commitPolicy, jobState)) {
        LOG.info(""Job data will not be committed due to commit policy: "" + 
                 JobCommitPolicyName(commitPolicy));
        return;
    }

    LOG.info(""Publishing job data of job "" + jobId + "" with commit policy "" +
             JobCommitPolicyName(commitPolicy));

    std::unique_ptr<DataPublisher> publisher;
    try {
        std::string dataPublisherType = jobState.getProp(
            ConfigurationKeys::DATA_PUBLISHER_TYPE, ConfigurationKeys::DEFAULT_DATA_PUBLISHER_TYPE);
        publisher = DataPublisherFactory::create(dataPublisherType, jobState);
        publisher->initialize();
        publisher->publish(jobState.getTaskStates());
    } catch (const std::exception& e) {
        throw;
    }
    // Set the job state to COMMITTED upon successful commit
    jobState.setState(JobState::RunningState::COMMITTED);
}

void persistJobState(JobState& jobState) {
    JobState::RunningState runningState = jobState.getState();
    if (runningState == JobState::RunningState::PENDING ||
        runningState == JobState::RunningState::RUNNING ||
        runningState == JobState::RunningState::SUCCESSFUL ||
        runningState == JobState::RunningState::FAILED ||
        runningState == JobState::RunningState::COMMITTED) {
        // ...
    }
}","```cpp
private:
  bool canCommit(JobCommitPolicy commitPolicy, const JobState& jobState) {
    return commitPolicy == JobCommitPolicy::COMMIT_ON_PARTIAL_SUCCESS ||
      (commitPolicy == JobCommitPolicy::COMMIT_ON_FULL_SUCCESS &&
       jobState.getState() == JobState::RunningState::SUCCESSFUL);
  }

  void commitJob(const std::string& jobId, JobCommitPolicy commitPolicy, JobState& jobState) {
    if (!canCommit(commitPolicy, jobState)) {
      LOG.info(""Job data will not be committed due to commit policy: "" + commitPolicy.name());
      return;
    }

    LOG.info(""Publishing job data of job "" + jobId + "" with commit policy "" + commitPolicy.name());

    std::unique_ptr<Closer> closer = Closer::create();
    try {
      std::string publisherType = jobState.getProp(ConfigurationKeys::DATA_PUBLISHER_TYPE, ConfigurationKeys::DEFAULT_DATA_PUBLISHER_TYPE);
      auto dataPublisher = closer->register(DataPublisherFactory::create(publisherType, jobState));
      dataPublisher->initialize();
      dataPublisher->publish(jobState.getTaskStates());
    } catch (const std::exception& t) {
      closer->rethrow(t);
    }
    closer->close();

    jobState.setState(JobState::RunningState::COMMITTED);
  }

  void persistJobState(JobState& jobState) {
    JobState::RunningState runningState = jobState.getState();
    if (runningState == JobState::RunningState::PENDING ||
        runningState == JobState::RunningState::RUNNING) {
      // ...
    }
  }
```",1
"if (auto* inv = dynamic_cast<Invocation*>(msg)) {
    std::string path = inv->getAttachments().at(Constants::PATH_KEY);
    std::string serviceKeyStr = serviceKey(channel->getLocalAddress()->getPort(), path, nullptr, nullptr);
    auto it = exporterMap.find(serviceKeyStr);
    DubboExporterBase* exporter = (it != exporterMap.end()) ? dynamic_cast<DubboExporterBase*>(it->second) : nullptr;
    if (exporter == nullptr) {
        throw RemotingException(channel,","```cpp
if (auto inv = dynamic_cast<Invocation*>(msg)) {
    std::string path = inv->getAttachments().at(Constants::PATH_KEY);
    std::string serviceKeyStr = serviceKey(channel.getLocalAddress().getPort(),
                                           path, nullptr, nullptr);
    auto exporterIt = exporterMap.find(serviceKeyStr);
    DubboExporterBase* exporter = (exporterIt != exporterMap.end())
                                    ? dynamic_cast<DubboExporterBase*>(exporterIt->second)
                                    : nullptr;
    if (exporter == nullptr) {
        throw RemotingException(channel,
                                // ... rest of the arguments
        );
    }
}
```",1
"template <typename T>
T resolve(bool failOnChanges, bool writeOnChanges,
          Converter<T, std::vector<std::shared_ptr<HeaderClause>>>& runbundlesFormatter) {
    RunResolution resolution = resolve(true);

    if (resolution.exception == nullptr) {
        update(resolution, failOnChanges, writeOnChanges);
        return runbundlesFormatter.convert(model.getRunBundles());
    }

    throw *resolution.exception;
}

RunResolution resolve(std::vector<ResolutionCallback*> callbacks = {}) {
    return resolve(false, callbacks);
}

RunResolution resolve(bool sparseErrors, std::vector<ResolutionCallback*> callbacks = {}) {
    RunResolution resolution = RunResolution::resolve(this, this, callbacks);

    if (!sparseErrors && (resolution.exception != nullptr)) {
        if (auto re = dynamic_cast<ResolutionException*>(resolution.exception)) {
            FilterParser filterParser;
            //...
        }
    }
    return resolution;
}","```cpp
template<typename T>
T resolve(bool failOnChanges, bool writeOnChanges,
          Converter<T, std::vector<HeaderClause>>* runbundlesFormatter) 
{
    RunResolution resolution = resolve(true);

    if (resolution.exception == nullptr) {
        update(resolution, failOnChanges, writeOnChanges);
        return runbundlesFormatter->convert(model.getRunBundles());
    }

    throw *resolution.exception;
}

RunResolution resolve(ResolutionCallback* callbacks...){
    return resolve(false, callbacks...);
}

RunResolution resolve(bool sparseErrors, ResolutionCallback* callbacks...) 
{
    std::vector<ResolutionCallback*> callbacksVec = {callbacks...};
    RunResolution resolution = RunResolution::resolve(this, this, callbacksVec);
    if (!sparseErrors && (resolution.exception != nullptr)) {
        ResolutionException* re = dynamic_cast<ResolutionException*>(resolution.exception);
        if (re != nullptr) {
            FilterParser filterParser;
            // ...
        }
    }
    // ...
    return resolution;
}
```",1
"struct Size {
    int width;
    int height;
};

struct Offset {
    double x;
    double y;
};

struct ViewportParams {
    Offset offset;
    Size size;
    double scaleFactorX;
    double scaleFactorY;
};

class MyClass {
public:
    Size getViewportSize() {
        return getViewportParams_().size;
    }

private:
    ViewportParams getViewportParams_() {
        if (!viewportParamsCached_) {
            if (scope_ == nullptr || !scaleByScope_) {
                int innerWidth = win_->innerWidth();
                int innerHeight = win_->innerHeight();
                cachedViewportParams_ = {
                    {0, 0},
                    {innerWidth, innerHeight},
                    1.0,
                    1.0
                };
            } else {
                auto rect = scope_->getBoundingClientRect();
                int offsetWidth = scope_->offsetWidth();
                int offsetHeight = scope_->offsetHeight();
                cachedViewportParams_ = {
                    {rect.x, rect.y},
                    {offsetWidth, offsetHeight},
                    offsetWidth / (rect.width != 0.0 ? rect.width : 1.0),
                    offsetHeight / (rect.height != 0.0 ? rect.height : 1.0)
                };
            }
            viewportParamsCached_ = true;
        }
        return cachedViewportParams_;
    }

    struct Window {
        int innerWidth();
        int innerHeight();
    };

    struct Rect {
        double x;
        double y;
        double width;
        double height;
    };

    struct Scope {
        Rect getBoundingClientRect();
        int offsetWidth();
        int offsetHeight();
    };

    Window* win_ = nullptr;
    Scope* scope_ = nullptr;
    bool scaleByScope_ = false;

    bool viewportParamsCached_ = false;
    ViewportParams cachedViewportParams_;
};","class CssContextImpl {
public:
    struct Size {
        int width;
        int height;
    };

    struct Offset {
        int x;
        int y;
    };

    struct ViewportParams {
        Offset offset;
        Size size;
        double scaleFactorX;
        double scaleFactorY;
    };

    Size getViewportSize() {
        return getViewportParams_().size;
    }

private:
    // Placeholders for members used in this code
    struct Window {
        int innerWidth;
        int innerHeight;
    }* win_ = nullptr;

    struct Scope {
        struct Rect {
            int x;
            int y;
            double width;
            double height;
        };
        int offsetWidth;
        int offsetHeight;
        Rect getBoundingClientRect() const;
    }* scope_ = nullptr;

    bool scaleByScope_ = false;
    std::optional<ViewportParams> viewportParams_;

    const ViewportParams& getViewportParams_() {
        if (!viewportParams_.has_value()) {
            if (!scope_ || !scaleByScope_) {
                viewportParams_ = ViewportParams{
                    Offset{0, 0},
                    Size{win_ ? win_->innerWidth : 0, win_ ? win_->innerHeight : 0},
                    1.0, 1.0
                };
            } else {
                auto rect = scope_->getBoundingClientRect();
                int offsetWidth = scope_->offsetWidth;
                int offsetHeight = scope_->offsetHeight;
                viewportParams_ = ViewportParams{
                    Offset{rect.x, rect.y},
                    Size{offsetWidth, offsetHeight},
                    offsetWidth / (rect.width != 0 ? rect.width : 1.0),
                    offsetHeight / (rect.height != 0 ? rect.height : 1.0)
                };
            }
        }
        return viewportParams_.value();
    }
};",1
"virtual std::map<std::string, std::any> parameters() = 0;

std::optional<bool> inGrace;","virtual std::map<std::string, std::any> parameters() const = 0;

std::optional<bool> inGrace() const;",0
"if (IsCollectionPass())
{
#ifndef _M_ARM
    if (this->collectionPassSubPhase == CollectionPassSubPhase::FirstPass)
    {
        IR::Opnd const *src1 = instr->GetSrc1();
        IR::Opnd const *src2 = instr->GetSrc2();
        IR::Opnd const *dest = instr->GetDst();

        auto getAnyDirectSymID = [](const IR::Opnd *opnd) -> SymID
        {
            SymID temp = (SymID)-1;
            if (opnd == nullptr)
            {
                return temp;
            }

            switch (opnd->m_kind)
            {
            case IR::OpndKind::OpndKindInvalid:
                AssertOrFailFastMsg(false, ""There should be no invalid operand kinds at this point..."");
                break;
            case IR::OpndKind::OpndKindIntConst:
            case IR::OpndKind::OpndKindInt64Const:
            case IR::OpndKind::OpndKindFloatConst:
            case IR::OpndKind::OpndKindFloat32Const:
            case IR::OpndKind::OpndKindSimd128Const:
                break;
            case IR::OpndKind::OpndKindHelperCall:
                break;
            case IR::OpndKind::OpndKindSym:
                temp = opnd->AsSymOpnd()->m_sym->m_id;
                break;
            case IR::OpndKind::OpndKindReg:
                temp = opnd->AsRegOpnd()->m_sym->m_id;
                break;
            case IR::OpndKind::OpndKindAddr:
                break;
            case IR::OpndKind::OpndKindIndir:
                break;
            case IR::OpndKind::OpndKindLabel:
                break;
            case IR::OpndKind::OpndKindMemRef:
                break;
            case IR::OpndKind::OpndKindRegBV:
                break;
            case IR::OpndKind::OpndKindList:
            {
                const IR::ListOpnd *list = opnd->AsListOpnd();
                if (list->Count() > 0)
                {
                    temp = list->Item(0)->m_sym->m_id;
                }
            }
            break;
            default:
                AssertOrFailFastMsg(false, ""This should be unreachable - if we've added another OpndKind,","if (IsCollectionPass())
{
#ifndef _M_ARM
    if (this->collectionPassSubPhase == CollectionPassSubPhase::FirstPass)
    {
        auto getAnyDirectSymID = [](const IR::Opnd* opnd) -> SymID
        {
            SymID temp = static_cast<SymID>(-1);
            if (opnd == nullptr)
            {
                return temp;
            }

            switch (opnd->m_kind)
            {
            case IR::OpndKind::OpndKindInvalid:
                AssertOrFailFastMsg(false, ""There should be no invalid operand kinds at this point..."");
                break;
            case IR::OpndKind::OpndKindIntConst:
            case IR::OpndKind::OpndKindInt64Const:
            case IR::OpndKind::OpndKindFloatConst:
            case IR::OpndKind::OpndKindFloat32Const:
            case IR::OpndKind::OpndKindSimd128Const:
                break;
            case IR::OpndKind::OpndKindHelperCall:
                break;
            case IR::OpndKind::OpndKindSym:
                temp = opnd->AsSymOpnd()->m_sym->m_id;
                break;
            case IR::OpndKind::OpndKindReg:
                temp = opnd->AsRegOpnd()->m_sym->m_id;
                break;
            case IR::OpndKind::OpndKindAddr:
                break;
            case IR::OpndKind::OpndKindIndir:
                break;
            case IR::OpndKind::OpndKindLabel:
                break;
            case IR::OpndKind::OpndKindMemRef:
                break;
            case IR::OpndKind::OpndKindRegBV:
                break;
            case IR::OpndKind::OpndKindList:
            {
                const IR::ListOpnd* list = opnd->AsListOpnd();
                if (list->Count() > 0)
                {
                    temp = list->Item(0)->m_sym->m_id;
                }
            }
                break;
            default:
                AssertOrFailFastMsg(false, ""This should be unreachable - if we've added another OpndKind, add proper handling for it"");
                break;
            }
            return temp;
        };

        SymID destSymID = getAnyDirectSymID(instr->GetDst());

        if (destSymID == static_cast",1
"return results;
}

bool accept(const F& file) override {
    std::atomic<bool> allAccept{true};
    for (const auto& f : this->fileFilters) {
        bool accepted = f->accept(file);
        bool expected = true;
        allAccept.compare_exchange_strong(expected, accepted);
    }
    return allAccept.load();
}

bool supportsSingleFileFiltering() const override {
    return this->allSupportAccept;
}

void rollback(const F& file, const std::vector<F>& files) override {
    for (const auto& fileFilter : this->fileFilters) {","```cpp
bool accept(const F& file) override {
    bool allAccept = true;
    for (const auto& f : this->fileFilters) {
        if (allAccept) {
            allAccept = f->accept(file);
        }
    }
    return allAccept;
}

bool supportsSingleFileFiltering() const override {
    return this->allSupportAccept;
}
```",0
"std::vector<WriteStatus> resultVector;
for (const auto& writeStatusList : result) {
    for (auto& s : writeStatusList) {
        s.getStat().setTotalUpdatedRecordsCompacted(scanner.getTotalRecordsToUpdate());
        s.getStat().setTotalLogFilesCompacted(scanner.getTotalLogFiles());
        s.getStat().setTotalLogRecords(scanner.getTotalLogRecords());
        s.getStat().setPartitionPath(operation.getPartitionPath());
        s.getStat().setTotalLogSizeCompacted(
            static_cast<long>(operation.getMetrics().at(CompactionStrategy::TOTAL_LOG_FILE_SIZE))
        );
        s.getStat().setTotalLogBlocks(scanner.getTotalLogBlocks());
        s.getStat().setTotalCorruptLogBlock(scanner.getTotalCorruptBlocks());
        s.getStat().setTotalRollbackBlocks(scanner.getTotalRollbacks());
        RuntimeStats runtimeStats;
        runtimeStats.setTotalScanTime(scanner.getTotalTimeTakenToReadAndMergeBlocks());
        s.getStat().setRuntimeStats(runtimeStats);
        resultVector.push_back(s);
    }
}
return resultVector;","std::vector<WriteStatus> resultVector;
for (auto& writeStatusList : result) {
    for (auto& s : writeStatusList) {
        s.getStat().setTotalUpdatedRecordsCompacted(scanner.getTotalRecordsToUpdate());
        s.getStat().setTotalLogFilesCompacted(scanner.getTotalLogFiles());
        s.getStat().setTotalLogRecords(scanner.getTotalLogRecords());
        s.getStat().setPartitionPath(operation.getPartitionPath());
        s.getStat().setTotalLogSizeCompacted(
            static_cast<long>(operation.getMetrics().at(CompactionStrategy::TOTAL_LOG_FILE_SIZE))
        );
        s.getStat().setTotalLogBlocks(scanner.getTotalLogBlocks());
        s.getStat().setTotalCorruptLogBlock(scanner.getTotalCorruptBlocks());
        s.getStat().setTotalRollbackBlocks(scanner.getTotalRollbacks());
        RuntimeStats runtimeStats;
        runtimeStats.setTotalScanTime(scanner.getTotalTimeTakenToReadAndMergeBlocks());
        s.getStat().setRuntimeStats(runtimeStats);
        resultVector.push_back(s);
    }
}
return resultVector;",0
"/****
 *
 * <p>
 *   Removing a JobMetrics instance for a job will also remove the TaskMetrics
 *   of every tasks of the job. This is only used by job driver where there is no ForkMetrics.
 * </p>
 * @param jobState the given JobState instance
 */","```cpp
/**
 *
 * 
 *   Removing a JobMetrics instance for a job will also remove the TaskMetrics 
 *   of every tasks of the job. This is only used by job driver where there is no ForkMetrics.
 * 
 * @param jobState the given JobState instance
 */
```",0
"}

private:
static bool isParametrizedType(JavaType* type) {
    return dynamic_cast<ParametrizedTypeJavaType*>(type) != nullptr;
}

bool isAcceptableByAutoboxing(JavaType* expressionType, JavaType* formalType) {","```cpp
private:
static bool isParametrizedType(const JavaType* type) {
    return dynamic_cast<const ParametrizedTypeJavaType*>(type) != nullptr;
}

bool isAcceptableByAutoboxing(const JavaType* expressionType, const JavaType* formalType) {
    // ... (rest of function not provided)
}
```",0
"sourceResponseSendErrorType = errorTypeRepository.getErrorType(SOURCE_RESPONSE_SEND).value();
sourceErrorResponseGenerateErrorType = errorTypeRepository.getErrorType(SOURCE_ERROR_RESPONSE_GENERATE).value();
sourceErrorResponseSendErrorType = errorTypeRepository.getErrorType(SOURCE_ERROR_RESPONSE_SEND).value();

if (processorInterceptorManager != nullptr) {
    for (const auto& interceptorFactory : processorInterceptorManager->getInterceptorFactories()) {
        auto reactiveInterceptorAdapter = std::make_shared<ReactiveInterceptorSourceCallbackAdapter>(interceptorFactory);
        try {
            muleContext->getInjector()->inject(reactiveInterceptorAdapter.get());
        } catch (const MuleException& e) {
            throw MuleRuntimeException(e);
        }
        additionalInterceptors.insert(additionalInterceptors.begin(), reactiveInterceptorAdapter);
    }
}","sourceResponseSendErrorType = errorTypeRepository.getErrorType(SOURCE_RESPONSE_SEND).value();
sourceErrorResponseGenerateErrorType = errorTypeRepository.getErrorType(SOURCE_ERROR_RESPONSE_GENERATE).value();
sourceErrorResponseSendErrorType = errorTypeRepository.getErrorType(SOURCE_ERROR_RESPONSE_SEND).value();

if (processorInterceptorManager != nullptr) {
    auto& factories = processorInterceptorManager->getInterceptorFactories();
    for (auto& interceptorFactory : factories) {
        auto reactiveInterceptorAdapter = std::make_shared<ReactiveInterceptorSourceCallbackAdapter>(interceptorFactory);
        try {
            muleContext->getInjector()->inject(*reactiveInterceptorAdapter);
        } catch (const MuleException& e) {
            throw MuleRuntimeException(e);
        }
        additionalInterceptors.insert(additionalInterceptors.begin(), reactiveInterceptorAdapter);
    }
}",0
"auto& virtualField = VirtualField<CouchbaseRequest, Span>::find();

Span* span = virtualField.get(request);
if (span != nullptr) {
    if (!remoteHostname.empty()) {
        span->setAttribute(SemanticAttributes::NET_PEER_NAME, remoteHostname);
    }
}

if (!remoteSocket.empty()) {
    std::size_t splitIndex = remoteSocket.rfind(':');","VirtualField<CouchbaseRequest, Span>& virtualField =
    VirtualField<CouchbaseRequest, Span>::find();

Span* span = virtualField.get(request);
if (span != nullptr) {
    if (!remoteHostname.empty()) {
        span->setAttribute(SemanticAttributes::NET_PEER_NAME, remoteHostname);
    }

    if (!remoteSocket.empty()) {
        size_t splitIndex = remoteSocket.rfind(':');
        // ...
    }
}",1
"return SftpInputStream(client, fileInputStream, fileName, determineAutoDelete(), endpoint);
}

private:
bool determineAutoDelete() {
    auto prop = endpoint.getProperty(""autoDelete"");
    bool autoDelete = false;
    if (prop != nullptr) {
        std::string propStr = static_cast<std::string*>(prop);
        autoDelete = (propStr == ""true"" || propStr == ""1"");
    } else {
        autoDelete = connector.isAutoDelete();
    }
    return autoDelete;
}

std::istream* archiveFileUsingTempDirs(const std::string& archive,","return SftpInputStream(client, fileInputStream, fileName, determineAutoDelete(), endpoint);
}

bool determineAutoDelete()
{
    std::any autoDeleteAny = endpoint.getProperty(""autoDelete"");
    bool autoDelete;
    if (autoDeleteAny.has_value())
    {
        std::string autoDeleteStr = std::any_cast<std::string>(autoDeleteAny);
        autoDelete = (autoDeleteStr == ""true"");
    }
    else
    {
        autoDelete = connector.isAutoDelete();
    }
    return autoDelete;
}",1
"static const bool jaxb2Present = __builtin_available( /* platform check if needed */ ) && 
    (typeid(void).name() != nullptr);","#include <type_traits>
#include <string>

class MessagingGatewaySupport {};

class ClassUtils {
public:
    static bool isPresent(const std::string& className) {
        // Dummy implementation since C++ has no runtime by-name class lookup.
        // In real situations, this could involve plugin systems or manual registration.
        return false;
    }
};

class HttpRequestHandlingEndpointSupport : public MessagingGatewaySupport {
protected:
    static const bool jaxb2Present;
};

const bool HttpRequestHandlingEndpointSupport::jaxb2Present =
    ClassUtils::isPresent(""javax.xml.bind.Binder"");",1
"auto outer = call.rel(1);
auto uncollect = call.rel(2);

if (correlate.getRequiredColumns().count() != 1) {
    return;
}","RelNode* outer = call.rel(1);
RelNode* uncollect = call.rel(2);

if (correlate->getRequiredColumns().count() != 1) {
    return;
}",1
"std::unordered_map<std::string, std::vector<HoodieBaseFile*>> groupedInputSplits;
const auto& inputSplits = partitionsToParquetSplits[partitionPath];
for (const auto& file : inputSplits) {
    std::string fileId = FSUtils::getFileId(file->getFileStatus()->getPath()->getName());
    groupedInputSplits[fileId].push_back(file);
}
try {
    for (const auto& fileSlice : latestFileSlices) {
        const std::string& fileId = fileSlice->getFileId();
        if (groupedInputSplits.count(fileId) > 0) {
            const auto& dataFileSplits = groupedInputSplits[fileId];
            for (const auto& split : dataFileSplits) {
                try {
                    std::vector<std::string> logFilePaths;
                    auto logFiles = fileSlice->getLogFiles();
                    std::vector<HoodieLogFile> logFileVec(logFiles.begin(), logFiles.end());
                    std::sort(logFileVec.begin(), logFileVec.end(), HoodieLogFile::getLogFileComparator());
                    for (const auto& logFile : logFileVec) {
                        logFilePaths.push_back(logFile.getPath()->toString());
                    }
                    resultMap[split] = logFilePaths;
                } catch (const std::exception& e) {
                    throw HoodieException(std::string(""Error creating hoodie real time split "") + e.what());
                }
            }
        }
    }
} catch (const std::exception& e) {
    throw HoodieException(""Error obtaining data file/log file grouping: "" + partitionPath + "" "" + e.what());
}","std::map<std::string, std::vector<HoodieBaseFile>> groupedInputSplits;
for (const auto& file : partitionsToParquetSplits[partitionPath]) {
    groupedInputSplits[FSUtils::getFileId(file.getFileStatus().getPath().getName())].push_back(file);
}
for (const auto& fileSlice : latestFileSlices) {
    const std::string& fileId = fileSlice.getFileId();
    auto it = groupedInputSplits.find(fileId);
    if (it != groupedInputSplits.end()) {
        const std::vector<HoodieBaseFile>& dataFileSplits = it->second;
        for (const auto& split : dataFileSplits) {
            try {
                std::vector<std::string> logFilePaths;
                auto logFiles = fileSlice.getLogFiles();
                std::vector<HoodieLogFile> sortedLogFiles(logFiles.begin(), logFiles.end());
                std::sort(sortedLogFiles.begin(), sortedLogFiles.end(), HoodieLogFile::getLogFileComparator());
                for (const auto& logFile : sortedLogFiles) {
                    logFilePaths.push_back(logFile.getPath().toString());
                }
                resultMap[split] = logFilePaths;
            } catch (const std::exception& e) {
                throw HoodieException(std::string(""Error creating hoodie real time split "") + e.what());
            }
        }
    }
}",1
"#include <string>
#include <regex>
#include <map>
#include <set>
#include <vector>
#include <memory>
#include <stdexcept>
#include <sstream>

class URL;
class Invocation;
template<typename T> class Invoker;
class Logger;

class ConditionRouter {
public:
    static constexpr const char* NAME = ""condition"";
    static const std::regex ROUTE_PATTERN;
    static const std::regex ARGUMENTS_PATTERN;

    struct MatchPair {
        std::set<std::string> matches;
        std::set<std::string> mismatches;
        bool isMatch(const std::string& value, const URL* param) const;
    };

    ConditionRouter(const std::string& rule, bool force, bool enabled)
        : force(force), enabled(enabled) {
        init(rule);
    }

    ConditionRouter(const URL& url);

    template<typename T>
    std::vector<std::shared_ptr<Invoker<T>>> route(const std::vector<std::shared_ptr<Invoker<T>>>& invokers, 
                                                   const URL& url, 
                                                   const Invocation& invocation);

    bool isRuntime() const;

    const URL& getUrl() const;

private:
    void init(const std::string& rule);

    static std::map<std::string, MatchPair> parseRule(const std::string& rule);

    bool matchWhen(const URL& url, const Invocation& invocation) const;
    bool matchThen(const URL& url, const URL& param) const;

    bool matchCondition(const std::map<std::string, MatchPair>& condition, 
                        const URL& url,
                        const URL* param, 
                        const Invocation* invocation) const;

    bool matchArguments(const std::pair<std::string, MatchPair>& matchPair, const Invocation& invocation) const;

    std::map<std::string, MatchPair> whenCondition;
    std::map<std::string, MatchPair> thenCondition;
    bool force = false;
    bool enabled = true;
    int priority = 0;
    URL* url = nullptr;
};

const std::regex ConditionRouter::ROUTE_PATTERN(R""(([&!=,]*)\s*([^&!=,\s]+))"");
const std::regex ConditionRouter::ARGUMENTS_PATTERN(R""(arguments\[([0-9]+)\])"");

inline ConditionRouter::ConditionRouter(const URL& urlObj) {
    // This assumes URL has getParameter and getParameterAndDecoded, etc.
    url = new URL(urlObj);
    priority","#include <string>
#include <map>
#include <set>
#include <vector>
#include <regex>
#include <stdexcept>
#include <memory>
#include <sstream>
#include <iostream>
#include <typeinfo>

// Forward declarations for external dependencies
class URL;
class Invocation;
template<typename T> class Invoker;
class Logger;

class ConditionRouter {
public:
    static constexpr const char* NAME = ""condition"";

protected:
    static const std::regex ROUTE_PATTERN;
    static const std::regex ARGUMENTS_PATTERN;

    struct MatchPair {
        std::set<std::string> matches;
        std::set<std::string> mismatches;

        bool isMatch(const std::string& value, const URL* param) const;
    };

    std::map<std::string, MatchPair> whenCondition;
    std::map<std::string, MatchPair> thenCondition;
    bool enabled = true;
    bool force = false;
    int priority = 0;
    URL* url = nullptr;

public:
    ConditionRouter(const std::string& rule, bool force_, bool enabled_)
        : enabled(enabled_), force(force_) {
        init(rule);
    }

    ConditionRouter(const URL& url_in);

    void init(const std::string& rule);

    template<typename T>
    std::vector<std::shared_ptr<Invoker<T>>> route(
        const std::vector<std::shared_ptr<Invoker<T>>>& invokers,
        const URL& u,
        const Invocation& invocation);

    bool isRuntime() const;
    const URL& getUrl() const;

private:
    bool matchWhen(const URL& url, const Invocation& invocation) const;
    bool matchThen(const URL& url, const URL* param) const;
    bool matchCondition(
        const std::map<std::string, MatchPair>& condition,
        const URL& url, const URL* param,
        const Invocation* invocation) const;
    bool matchArguments(const std::pair<const std::string, MatchPair>&, const Invocation&) const;
};

// Static regex members
const std::regex ConditionRouter::ROUTE_PATTERN(R""(([&!=,]*)\s*([^&!=,\s]+))"");
const std::regex ConditionRouter::ARGUMENTS_PATTERN(R""(arguments\[([0-9]+)\])"");

// ---- begin implementation of ConditionRouter methods ----

namespace {
    // Utility stub methods (replace with your actual implementations)
    bool isBlank(const std::string &str) { return str.empty(); }",1
"void initializeLanguageDialog(PreferenceScreen* screen) {
    ListPreference* languageSelection = dynamic_cast<ListPreference*>(screen->findPreference(LANGUAGE));
    Locale currentAppLocale = LanguageUtil::getLocale(
        AnkiDroidApp::getSharedPrefs(AnkiDroidApp::getInstance())
            ->getString(Preferences::LANGUAGE, """")
    );
    if (languageSelection != nullptr) {
        std::map<std::string, std::string> items;
        for (const std::string& localeCode : LanguageUtil::APP_LANGUAGES) {
            Locale loc = LanguageUtil::getLocale(localeCode);
            items[loc.getDisplayName(currentAppLocale)] = loc.toString();
        }
        std::vector<std::string> languageDialogLabels(items.size() + 1);
        std::vector<std::string> languageDialogValues(items.size() + 1);
    }
}","```cpp
void initializeLanguageDialog(PreferenceScreen* screen) {
    auto languageSelection = dynamic_cast<ListPreference*>(screen->findPreference(LANGUAGE));
    Locale currentAppLocale = LanguageUtil::getLocale(
        AnkiDroidApp::getSharedPrefs(AnkiDroidApp::getInstance())
            ->getString(Preferences::LANGUAGE, """")
    );
    if (languageSelection != nullptr) {
        std::map<std::string, std::string> items;
        for (const auto& localeCode : LanguageUtil::APP_LANGUAGES) {
            Locale loc = LanguageUtil::getLocale(localeCode);
            items[loc.getDisplayName(currentAppLocale)] = loc.toString();
        }
        std::vector<std::string> languageDialogLabels(items.size() + 1);
        std::vector<std::string> languageDialogValues(items.size() + 1);
    }
}
```",1
"protected:
    std::shared_ptr<ExecutorService> cachedThreadPool = std::make_shared<ExecutorService>(4);

public:
    testing::Rule expectedException = testing::ExpectedException::none();

    explicit AbstractProcessingStrategyTestCase(Mode mode) : mode(mode) {}

    static std::vector<Mode> modeParameters() {
        return { Mode::FLOW, Mode::SOURCE };
    }

    void before() {
        cpuLight = std::make_shared<TestScheduler>(2, CPU_LIGHT, false);
        blocking = std::make_shared<TestScheduler>(4, IO, true);
        cpuIntensive = std::make_shared<TestScheduler>(2, CPU_INTENSIVE, true);
        custom = std::make_shared<TestScheduler>(1, CUSTOM, true);
        ringBuffer = std::make_shared<TestScheduler>(1, RING_BUFFER, true);
        asyncExecutor = muleContext->getRegistry()->lookupObject<SchedulerService>()->ioScheduler();

        flowBuilder = [&]() { return builder(""test"", muleContext); };
    }","#include <memory>
#include <vector>
#include <thread>
#include <gtest/gtest.h>
#include <gmock/gmock.h>

class Scheduler {};
class ExecutorService {};
class SchedulerService {
public:
    std::shared_ptr<Scheduler> ioScheduler();
};
class MuleContext {
public:
    SchedulerService* getRegistry();
};

enum Mode { FLOW, SOURCE };

class TestScheduler : public Scheduler {
public:
    TestScheduler(int, int, bool) {}
};

class AbstractProcessingStrategyTestCase : public ::testing::TestWithParam<Mode> {
protected:
    std::shared_ptr<Scheduler> cpuLight;
    std::shared_ptr<Scheduler> blocking;
    std::shared_ptr<Scheduler> cpuIntensive;
    std::shared_ptr<Scheduler> custom;
    std::shared_ptr<Scheduler> ringBuffer;
    std::shared_ptr<Scheduler> asyncExecutor;
    std::unique_ptr<ExecutorService> cachedThreadPool { std::make_unique<ExecutorService>() };
    Mode mode;
    MuleContext muleContext;

public:
    AbstractProcessingStrategyTestCase() : mode(GetParam()) {}

    static std::vector<Mode> modeParameters() {
        return {FLOW, SOURCE};
    }

    void SetUp() override {
        cpuLight = std::make_shared<TestScheduler>(2, CPU_LIGHT, false);
        blocking = std::make_shared<TestScheduler>(4, IO, true);
        cpuIntensive = std::make_shared<TestScheduler>(2, CPU_INTENSIVE, true);
        custom = std::make_shared<TestScheduler>(1, CUSTOM, true);
        ringBuffer = std::make_shared<TestScheduler>(1, RING_BUFFER, true);
        asyncExecutor = muleContext.getRegistry()->ioScheduler();
    }
};",0
"```cpp
auto windowExpiry = window.maxTimestamp() + allowedLateness;
if (spec.getTimeDomain() == TimeDomain::EVENT_TIME) {
    if (outputTimestamp > windowExpiry) {
        throw std::invalid_argument(
            ""Attempted to set an event-time timer with an output timestamp of "" +
            std::to_string(outputTimestamp) +
            "" that is after the expiration of window "" +
            std::to_string(windowExpiry));
    }
    if (target > windowExpiry) {
        throw std::invalid_argument(
            ""Attempted to set an event-time timer with a firing timestamp of "" +
            std::to_string(target) +
            "" that is after the expiration of window "" +
            std::to_string(windowExpiry));
    }
}
```","```cpp
Instant windowExpiry = window.maxTimestamp().plus(allowedLateness);
if (TimeDomain::EVENT_TIME == spec.getTimeDomain()) {
    checkArgument(
        !outputTimestamp.isAfter(windowExpiry),
        ""Attempted to set an event-time timer with an output timestamp of %s that is""
        "" after the expiration of window %s"",
        outputTimestamp,
        windowExpiry);
    checkArgument(
        !target.isAfter(windowExpiry),
        ""Attempted to set an event-time timer with a firing timestamp of %s that is""
        "" after the expiration of window %s"",
        target,
        windowExpiry);
}
```",1
"rawRecord.topic(),
rawRecord.partition(),
rawRecord.offset(),
consumerSpEL.getEventTimestamp(rawRecord),
decode(rawRecord.key(), source.spec.getKeyCoder()),
decode(rawRecord.value(), source.spec.getValueCoder());

curTimestamp = (source.spec.getTimestampFn() == nullptr)
    ? Instant(record.getTimestamp())
    : source.spec.getTimestampFn()(record);
curRecord = record;

int recordSize = (rawRecord.key() == nullptr ? 0 : rawRecord.key()->size());","auto record = KafkaRecord(
    rawRecord.topic(),
    rawRecord.partition(),
    rawRecord.offset(),
    consumerSpEL.getEventTimestamp(rawRecord),
    decode(rawRecord.key(), source.spec.getKeyCoder()),
    decode(rawRecord.value(), source.spec.getValueCoder())
);

curTimestamp = (source.spec.getTimestampFn() == nullptr)
    ? Instant(record.getTimestamp())
    : source.spec.getTimestampFn()(record);
curRecord = record;

int recordSize = (rawRecord.key() == nullptr ? 0 : rawRecord.key()->size()) +
                 (rawRecord.value() == nullptr ? 0 : rawRecord.value()->size());",1
"default:
  throw std::runtime_error(""Unsupported Metrics Reporter type "" + writeConfig.getMetricsReporterType());
}
builder.withMetricsConfig(metricsConfig.build());
return builder.build();
}","switch (writeConfig.getMetricsReporterType()) {
  default:
    throw HoodieMetadataException(""Unsupported Metrics Reporter type "" + writeConfig.getMetricsReporterType());
}
return builder.build();",1
"#include <string>
#include <stdexcept>

class NotFoundException : public std::exception {};
class BadRequestException : public std::exception {};

class Response {
public:
    static Response accepted() {
        return Response();
    }
};

class Collector {};

class EtagService {
public:
    void invalidateAll() {}
};

class CollectorService {
public:
    Collector copy(const std::string& id, const std::string& name) { return Collector(); }
    void save(const Collector&) {}
};

void validateFromRequest(const Collector&, const std::string&) {}

Response copyCollector(const std::string& id, const std::string& name) {
    EtagService etagService;
    CollectorService collectorService;

    etagService.invalidateAll();
    Collector collector = collectorService.copy(id, name);
    validateFromRequest(collector, ""Cannot copy collector."");
    collectorService.save(collector);
    return Response::accepted();
}","Response copyCollector(const std::string& id, const std::string& name) {
    etagService.invalidateAll();
    Collector collector = collectorService.copy(id, name);
    validateFromRequest(collector, ""Cannot copy collector."");
    collectorService.save(collector);
    return Response::accepted().build();
}",0
"std::vector<ProgramState::SymbolicValueSymbol> symbolicValueSymbols;
if (terminator != nullptr) {
    switch (terminator->opcode) {
    case Opcode::GOTO:
    case Opcode::JSR:
        for (auto& b : programPosition.block->successors()) {
            enqueue(ProgramPoint(b), programState);
        }
        return;
    case Opcode::IFEQ:
    case Opcode::IFNE:
    case Opcode::IFLT:
        // ...
        break;
    }
}","```cpp
std::vector<ProgramState::SymbolicValueSymbol> symbolicValueSymbols;
if (terminator != nullptr) {
    switch (terminator->opcode) {
        case GOTO:
        case JSR:
            for (auto b : programPosition.block.successors()) {
                enqueue(ProgramPoint(b), programState);
            }
            return;
        case IFEQ:
        case IFNE:
        case IFLT:
```",0
"#include <string>

class TwitterInboundChannelAdapterParser : public AbstractPollingInboundChannelAdapterParser {
};","#include <string>

class TwitterInboundChannelAdapterParser : public AbstractPollingInboundChannelAdapterParser {
public:
    // Class implementation goes here
};",0
"```cpp
std::string exchangeName = generateExchangeName(requestMessage);
std::string routingKey = generateRoutingKey(requestMessage);
if (expectReply) {
    return sendAndReceive(exchangeName, routingKey, requestMessage, correlationData);
} else {
    send(exchangeName, routingKey, requestMessage, correlationData);
    if (waitForConfirm && correlationData != nullptr) {
        waitForConfirm(requestMessage, correlationData);
    }
    return nullptr;
}

void waitForConfirm(const Message& requestMessage, CorrelationData* correlationData) {
    try {
        Confirm confirm = correlationData->getFuture().get(getConfirmTimeout().count(), std::chrono::milliseconds::period());
        if (!confirm.isAck()) {
            throw MessageHandlingException(requestMessage, ""Negative publisher confirm received: "" + confirm.toString());
        }
        if (correlationData->getReturnedMessage() != nullptr) {
            throw MessageHandlingException(requestMessage, ""Message was returned by the broker"");
        }
    } catch (const std::exception& e) {
        if (dynamic_cast<const std::future_error*>(&e) && std::string(e.what()) == ""broken promise"") {
            std::this_thread::interrupt();
        } else if (dynamic_cast<const std::exception*>(&e)) {
            throw MessageHandlingException(requestMessage, ""Failed to get publisher confirm"", e);
        } else if (dynamic_cast<const std::future_error*>(&e)) {
            throw MessageTimeoutException(requestMessage, ""Timed out awaiting publisher confirm"", e);
        } else {
            throw;
        }
    }
}

void send(const std::string& exchangeName,
          const std::string& routingKey,
          const Message& requestMessage,
          CorrelationData* correlationData) {
    if (rabbitTemplate != nullptr) {
        //...
    }
}
```","std::string exchangeName = generateExchangeName(requestMessage);
std::string routingKey = generateRoutingKey(requestMessage);
if (expectReply) {
    return sendAndReceive(exchangeName, routingKey, requestMessage, correlationData);
} else {
    send(exchangeName, routingKey, requestMessage, correlationData);
    if (waitForConfirm && correlationData != nullptr) {
        waitForConfirm(requestMessage, correlationData);
    }
    return nullptr;
}

void waitForConfirm(const Message& requestMessage, CorrelationData* correlationData) {
    try {
        auto future = correlationData->getFuture();
        auto confirm = future.get(getConfirmTimeout().count()); // assumes milliseconds in getConfirmTimeout()
        if (!confirm.isAck()) {
            throw MessageHandlingException(requestMessage, ""Negative publisher confirm received: "" + confirm.toString());
        }
        if (correlationData->getReturnedMessage() != nullptr) {
            throw MessageHandlingException(requestMessage, ""Message was returned by the broker"");
        }
    }
    catch (const std::future_error& e) {
        if (e.code() == std::make_error_code(std::future_errc::broken_promise)) {
            throw MessageHandlingException(requestMessage, ""Failed to get publisher confirm"", e);
        } else if (e.code() == std::make_error_code(std::future_errc::timeout)) {
            throw MessageTimeoutException(requestMessage, ""Timed out awaiting publisher confirm"", e);
        } else {
            throw;
        }
    }
    catch (const std::exception& e) {
        throw MessageHandlingException(requestMessage, ""Failed to get publisher confirm"", e);
    }
}

void send(const std::string& exchangeName, const std::string& routingKey,
         const Message& requestMessage, CorrelationData* correlationData) {
    if (rabbitTemplate != nullptr) {",1
"```cpp
#include <map>
#include <string>
#include <vector>
#include <stdexcept>

class Expression {};
using ExpressionArray = std::vector<Expression*>;

class ExpressionEvaluatingSqlParameterSource {
private:
    const void* input;
    std::map<std::string, void*> values;
    const std::map<std::string, ExpressionArray> parameterExpressions;
    const bool cache;

public:
    ExpressionEvaluatingSqlParameterSource(
        const void* input,
        const std::map<std::string, void*>& staticParameters,
        const std::map<std::string, ExpressionArray>& parameterExpressions,
        bool cache
    )
        : input(input)
        , values(staticParameters)
        , parameterExpressions(parameterExpressions)
        , cache(cache)
    {}

    void* getValue(const std::string& paramName) {
        return this->doGetValue(paramName, false);
    }

    void* doGetValue(const std::string& paramName, bool calledFromHasValue) {
        auto it = values.find(paramName);
        if (it != values.end()) {
            void* cachedByHasValue = it->second;
            if (!this->cache) {
                values.erase(it);
            }
            return cachedByHasValue;
        }
        if (parameterExpressions.find(paramName) == parameterExpressions.end()) {
            throw std::invalid_argument(""Parameter not found"");
        }
        // Implementation for the rest of the logic goes here.
        return nullptr;
    }
};
```","```cpp
#include <map>
#include <string>
#include <stdexcept>

class Expression {};

class ExpressionEvaluatingSqlParameterSource {
private:
    const void* input;
    std::map<std::string, void*> values;
    const std::map<std::string, std::vector<Expression*>> parameterExpressions;
    const bool cache;

public:
    ExpressionEvaluatingSqlParameterSource(
        const void* input_,
        const std::map<std::string, void*>& staticParameters,
        const std::map<std::string, std::vector<Expression*>>& parameterExpressions_,
        bool cache_)
        : input(input_), parameterExpressions(parameterExpressions_), cache(cache_)
    {
        values.insert(staticParameters.begin(), staticParameters.end());
    }

    void* getValue(const std::string& paramName) {
        return doGetValue(paramName, false);
    }

    void* doGetValue(const std::string& paramName, bool calledFromHasValue) {
        auto it = values.find(paramName);
        if (it != values.end()) {
            void* cachedByHasValue = it->second;
            if (!cache) {
                values.erase(it);
            }
            return cachedByHasValue;
        }

        if (parameterExpressions.find(paramName) == parameterExpressions.end()) {
            throw std::invalid_argument(""Parameter expression not found: "" + paramName);
        }

        // ... further logic for evaluating the expression and caching, as per original Java code
        return nullptr;
    }
};
```",0
"```cpp
#include <string>
#include <stdexcept>
#include <iostream>
#include <memory>
#include <exception>
#include <algorithm>
#include <map>
#include <vector>
#include <mutex>
#include <sstream>
#include <cctype>

#include ""AbstractGrantType.h""
#include ""RequestAuthenticationException.h""
#include ""ConfigOAuthContext.h""
#include ""ResourceOwnerOAuthContext.h""
#include ""TokenManagerConfig.h""
#include ""AttributeEvaluator.h""
#include ""HttpListenerConfig.h""
#include ""HttpRequestBuilder.h""
#include ""HttpService.h""
#include ""HttpServer.h""
#include ""HttpServerConfiguration.h""
#include ""TlsContextFactory.h""
#include ""DefaultMuleException.h""
#include ""Event.h""
#include ""MuleContext.h""
#include ""MuleContextAware.h""

#include <curl/curl.h>

#define AUTHORIZATION ""Authorization""

class AuthorizationCodeConfig :
    public AbstractGrantType,
    public Initialisable,
    public Startable,
    public Stoppable,
    public MuleContextAware
{
public:
    AuthorizationCodeConfig() {}
    virtual ~AuthorizationCodeConfig() {}

    void initialise() override {
        std::lock_guard<std::mutex> lock(mutex_);
        initialiseIfNeeded();
    }

    void start() override {
        std::lock_guard<std::mutex> lock(mutex_);
        // Start logic here
    }

    void stop() override {
        std::lock_guard<std::mutex> lock(mutex_);
        // Stop logic here
    }

    void setMuleContext(std::shared_ptr<MuleContext> context) override {
        muleContext = context;
    }

private:
    std::shared_ptr<MuleContext> muleContext;
    std::mutex mutex_;

    void initialiseIfNeeded() {
        // Initialization logic
    }

    // Additional private members and methods here
};

static const std::string createStaticMessage(const std::string& msg) {
    return msg;
}

struct Logger {
    static Logger& getLogger(const std::string& name) {
        static Logger instance;
        return instance;
    }
    template<typename T>
    Logger& info(const T& msg) {
        std::cout << ""[INFO] "" << msg << std::endl;
        return *this;
    }
    template<typename T>
    Logger& error(const T& msg) {
        std::cerr << ""[ERROR] "" << msg << std::endl;
        return *this;
    }
    template<typename T>
    Logger& debug(const T& msg) {","#include <string>
#include <stdexcept>
#include <memory>
#include <exception>
#include <sstream>
#include <algorithm>
#include <cctype>

// Placeholder classes to represent missing dependencies
class RequestAuthenticationException : public std::runtime_error {
public:
    explicit RequestAuthenticationException(const std::string& message) : std::runtime_error(message) {}
};
class MuleException : public std::exception {};
class MuleRuntimeException : public std::exception {};
class Initialisable {
public:
    virtual void initialise() = 0;
    virtual ~Initialisable() = default;
};
class Startable {
public:
    virtual void start() = 0;
    virtual ~Startable() = default;
};
class Stoppable {
public:
    virtual void stop() = 0;
    virtual ~Stoppable() = default;
};
class TlsContextFactory {};
class MuleContext {};
class Event {};
class TokenManagerConfig {};
class AttributeEvaluator {};
class HttpListenerConfig {};
class HttpRequestBuilder {};
class HttpServer {};
class HttpServerConfiguration {};
class HttpService {};

class Logger {
public:
    template<typename T>
    Logger& operator<<(const T& val) {
        // Logging can be implemented here
        return *this;
    }
    static Logger& getLogger(const std::string&) {
        static Logger instance;
        return instance;
    }
};
#define LOG(LoggerName) Logger::getLogger(LoggerName)

// Utility
namespace StringUtils {
    inline bool isBlank(const std::string& str) {
        return std::all_of(str.begin(), str.end(), [](unsigned char c){ return std::isspace(c); });
    }
}

// ConfigOAuthContext and ResourceOwnerOAuthContext placeholder
class ConfigOAuthContext {};
class ResourceOwnerOAuthContext {};

class AbstractGrantType {};

class AuthorizationCodeConfig : public AbstractGrantType, public Initialisable, public Startable, public Stoppable {
public:
    void initialise() override {
        // Initialization logic here
    }

    void start() override {
        // Startup logic here
    }

    void stop() override {
        // Stopping logic here
    }
};",0
"#include <llnl/util/tty/color.h>
#include <spack/filesystem_view/YamlFilesystemView.h>
#include <spack/util/executable.h>
#include <spack/stage.h>
#include <spack/util/environment.h>
#include <spack/util/package_hash.h>
#include <spack/version.h>","```cpp
#include <llnl/util/tty/log.hpp>
#include <llnl/util/tty/color.hpp>
#include <spack/filesystem_view.hpp>
#include <spack/util/executable.hpp>
#include <spack/stage.hpp>
#include <spack/util/environment.hpp>
#include <spack/util/package_hash.hpp>
#include <spack/version.hpp>
```",1
"for (const auto& io : inputService.allOfThisNode(serverStatus.getNodeId().toString())) {
    try {
        auto input = inputService.getMessageInput(io);
        if (input->onlyOnePerCluster() && input->isGlobal() && !leaderElectionService.isLeader()) {
            LOG.info(""Not starting 'onlyOnePerCluster' input <{}/{}>"", input->getName(), input->getId());
        } else {
            result.push_back(input);
        }
    } catch (const NoSuchInputTypeException& e) {
        LOG.warn(""Cannot instantiate persisted input. No such type [{}]."", io.getType());
    } catch (const std::exception& e) {
        // Handle other exceptions if needed
    }
}","for (const auto& io : inputService.allOfThisNode(serverStatus.getNodeId().toString())) {
    try {
        std::shared_ptr<MessageInput> input = inputService.getMessageInput(io);
        if (input->onlyOnePerCluster() && input->isGlobal() && !leaderElectionService.isLeader()) {
            LOG.info(""Not starting 'onlyOnePerCluster' input <{}/{}>"", input->getName(), input->getId());
        } else {
            result.push_back(input);
        }
    } catch (const NoSuchInputTypeException& e) {
        LOG.warn(""Cannot instantiate persisted input. No such type [{}]."", io.getType());
    } catch (const std::exception& e) {
        // handle other exceptions if needed
    }
}",1
"if (expunge && !_accountMgr.isAdmin(ctx.getCallingAccount().getId()) && !AllowUserExpungeRecoverVm.valueIn(cmd.getEntityOwnerId())) {
    throw PermissionDeniedException(""Parameter "" + ApiConstants::EXPUNGE + "" can be passed by Admin only. Or when the allow.user.expunge.recover.vm key is set."");
}

// check if VM exists
UserVmVO* vm = _vmDao.findById(vmId);

if (vm == nullptr) {
    throw InvalidParameterValueException(""unable to find a virtual machine with id "" + std::to_string(vmId));
}

// check if there are active volume snapshots tasks
s_logger.debug(""Checking if there are any ongoing snapshots on the ROOT volumes associated with VM with ID "" + std::to_string(vmId));
if (checkStatusOfVolumeSnapshots(vmId, Volume::Type::ROOT)) {
    throw CloudRuntimeException(""There is/are unbacked up snapshot(s) on ROOT volume, vm destroy is not permitted, please try again later."");
}
s_logger.debug(""Found no ongoing snapshots on volume of type ROOT, for the vm with id "" + std::to_string(vmId));

UserVm* destroyedVm = destroyVm(vmId, expunge);
if (expunge) {
    if (!expungeVm(vm, ctx.getCallingUserId(), ctx.getCallingAccount())) {
        throw CloudRuntimeException(""Failed to expunge vm "" + destroyedVm->toString());
    }
}","if (expunge && !_accountMgr.isAdmin(ctx.getCallingAccount().getId()) && !AllowUserExpungeRecoverVm.valueIn(cmd.getEntityOwnerId())) {
    throw PermissionDeniedException(std::string(""Parameter "") + ApiConstants::EXPUNGE + "" can be passed by Admin only. Or when the allow.user.expunge.recover.vm key is set."");
}

UserVmVO* vm = _vmDao.findById(vmId);

if (vm == nullptr) {
    throw InvalidParameterValueException(""unable to find a virtual machine with id "" + std::to_string(vmId));
}

s_logger.debug(""Checking if there are any ongoing snapshots on the ROOT volumes associated with VM with ID "" + std::to_string(vmId));
if (checkStatusOfVolumeSnapshots(vmId, Volume::Type::ROOT)) {
    throw CloudRuntimeException(""There is/are unbacked up snapshot(s) on ROOT volume, vm destroy is not permitted, please try again later."");
}
s_logger.debug(""Found no ongoing snapshots on volume of type ROOT, for the vm with id "" + std::to_string(vmId));

UserVm* destroyedVm = destroyVm(vmId, expunge);
if (expunge) {
    // vm already initialized above
    if (!expunge(*vm, ctx.getCallingUserId(), ctx.getCallingAccount())) {
        throw CloudRuntimeException(""Failed to expunge vm "" + std::to_string(destroyedVm->getId()));
    }
}",1
"}

#include <fstream>
#include <filesystem>
#include <functional>
#include <string>
#include <cassert>
#include <cstdio>

namespace fs = std::filesystem;

void store(const std::function<void(std::ostream&)>& storeFn, const fs::path& target) {
    fs::create_directories(target.parent_path());

    fs::path tmp = target.parent_path() / (target.filename().string() + "".tmp"");
    try {
        {
            std::ofstream ofs(tmp, std::ios::binary);
            storeFn(ofs);
        }
        std::error_code ec;
        fs::rename(tmp, target, ec);
        if (ec) {
            fs::remove(target, ec);
            fs::rename(tmp, target, ec);
            if (ec) throw std::runtime_error(""Failed to rename tmp file"");
        }
        assert(fs::is_regular_file(target));
    } catch (...) {
        if (fs::exists(tmp)) fs::remove(tmp);
        throw;
    }
    if (fs::exists(tmp)) fs::remove(tmp);
}

std::istringstream stream(const std::vector<uint8_t>& data) {
    return stream(std::span<const uint8_t>(data.data(), data.size()));
}","```cpp
#include <filesystem>
#include <fstream>
#include <functional>

namespace IO {

using namespace std;
namespace fs = std::filesystem;

using ConsumerWithException = function<void(ostream&)>;

fs::path createTempFile(const fs::path& parent, const string& filename, const string& suffix) {
    fs::path tmp = parent / (filename + suffix);
    int count = 0;
    while (fs::exists(tmp)) {
        tmp = parent / (filename + suffix + ""."" + to_string(++count));
    }
    return tmp;
}

void store(const ConsumerWithException& store, const fs::path& target) {
    fs::create_directories(target.parent_path());
    fs::path tmp = createTempFile(target.parent_path(), target.filename().string(), "".tmp"");
    try {
        {
            ofstream outputStream(tmp, ios::binary);
            store(outputStream);
        }
        fs::rename(tmp, target, fs::copy_options::overwrite_existing);
        assert(fs::is_regular_file(target));
    } catch (...) {
        if (fs::exists(tmp))
            fs::remove(tmp);
        throw;
    }
}

}
```",1
"```cpp
char firstChar = helpers.byteToCharUnsigned(helpers.getByteFromArrayByIndex(s2Value, 0));

while (true) {
    int i = lastIndexOf(firstChar, start);

    if (i == -1) {
```","```cpp
char firstChar = helpers.byteToCharUnsigned(helpers.getByteFromArrayByIndex(s2Value, 0));

while (true) {
    int i = lastIndexOf(firstChar, start);

    if (i == -1) {
```",0
"LOGGER.debug(""Invoking connector's value provider: {} for component: {}"", providerName,
             parameterizedModel.getName());
try {
    return resultFrom(
        withContextClassLoader(
            extensionClassLoader,
            [&]() {
                return getValues(providerName, valueProviderMediator, parameterValueResolver, context);
            }
        ),
        org::mule::sdk::api::values::ValueResolvingException::class_,
        [](const auto& e) {
            throw ExecutorExceptionWrapper(e);
        }
    );
} catch (const org::mule::sdk::api::values::ValueResolvingException& e) {
    if (LOGGER.isWarnEnabled()) {
        LOGGER.warn(
            format(""Resolve value provider has FAILED with code: {} for component: {}"", e.getFailureCode(),
                   parameterizedModel.getName())
        );
    }
} finally {
    context.dispose();
}","```cpp
try {
    try {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug(""Invoking connector's value provider: {} for component: {}"",
                         providerName,
                         parameterizedModel.getName());
        }
        return resultFrom(
            withContextClassLoader(
                extensionClassLoader,
                [&]() {
                    return getValues(providerName, valueProviderMediator,
                                     parameterValueResolver, context);
                },
                org::mule::sdk::api::values::ValueResolvingException{},
                [](const auto& e) {
                    throw ExecutorExceptionWrapper(e);
                }
            )
        );
    } finally {
        context.dispose();
    }
} catch (const org::mule::sdk::api::values::ValueResolvingException& e) {
    if (LOGGER.isWarnEnabled()) {
        LOGGER.warn(
            format(""Resolve value provider has FAILED with code: {} for component: {}"", 
                   e.getFailureCode(),
                   parameterizedModel.getName()),
        );
    }
}
```",1
"std::optional<BoundedBlockingRecordQueue<Object>::QueueStats> queueStats() {
    return std::nullopt;
}","std::optional<BoundedBlockingRecordQueue<Object>::QueueStats> queueStats() {
    return std::nullopt;
}",1
"std::vector<std::string> list = {""ordered"", ""insert"", ""count"", ""find"", ""create""};

JsonWriterSettings* createJsonWriterSettings(int maxNormalizedQueryLength) {
    JsonWriterSettings* settings = nullptr;
    try {
        // The static JsonWriterSettings::builder() method was introduced in the 3.5 release
        std::optional<Method> buildMethod = /* ... */;","std::vector<std::string> myList = {""ordered"", ""insert"", ""count"", ""find"", ""create""};

JsonWriterSettings* createJsonWriterSettings(int maxNormalizedQueryLength) {
    JsonWriterSettings* settings = nullptr;
    try {
        // The static JsonWriterSettings::builder() method was introduced in the 3.5 release
        std::optional<std::function<void()>> buildMethod =",0
"auto& leftRows = pinput[0];
auto& rightRows = pinput[1];

int leftRowColumnCount = leftRelNode.getRowType().getFieldCount();

auto pairs = extractJoinRexNodes();

Schema extractKeySchemaLeft =
    toSchema(
        map(
            pairs.begin(), pairs.end(),
            [&](const Pair<RexNode, RexNode>& pair) {
                return BeamJoinRel::getFieldBasedOnRexNode(leftSchema, pair.first, 0);
            }
        )
    );

Schema extractKeySchemaRight =
    toSchema(
        map(
            pairs.begin(), pairs.end(),
            [&](const Pair<RexNode, RexNode>& pair) {
                return BeamJoinRel::getFieldBasedOnRexNode(rightSchema, pair.second, leftRowColumnCount);
            }
        )
    );

auto extractKeyRowCoder = SchemaCoder<Row>::of(extractKeySchemaLeft);","```cpp
auto leftRows = pinput[0];
auto rightRows = pinput[1];

int leftRowColumnCount = leftRelNode.getRowType().getFieldCount();

// extract the join fields
auto pairs = extractJoinRexNodes();

// build the extract key type
// the name of the join field is not important
auto extractKeySchemaLeft = toSchema(
    beam::Stream(pairs)
        .map([&](const auto& pair) {
            return BeamJoinRel::getFieldBasedOnRexNode(leftSchema, pair.first, 0);
        })
);

auto extractKeySchemaRight = toSchema(
    beam::Stream(pairs)
        .map([&](const auto& pair) {
            return BeamJoinRel::getFieldBasedOnRexNode(rightSchema, pair.second, leftRowColumnCount);
        })
);

auto extractKeyRowCoder = SchemaCoder<Row>::of(extractKeySchemaLeft);
```",1
"this->element->addEventListener(AmpEvents::DOM_UPDATE, [this](const Event& event) {
    auto target = event.target;
    this->liveStoryManager_->update(
        target,
        this->element->querySelectorAll(""amp-story-page:not([ad])""),
        this->systemLayer_
    );
});","this->element.addEventListener(AmpEvents::DOM_UPDATE, [this](const Event& event) {
    this->liveStoryManager_->update(
        event.target,
        this->element.querySelectorAll(""amp-story-page:not([ad])""),
        this->systemLayer_
    );
});",1
"#include <utility>
#include <stdexcept>
#include ""BaseFileWithLogsSplit.h""
#include ""BootstrapBaseFileSplit.h""
#include ""HoodieRealtimeFileSplit.h""
#include ""HoodieVirtualKeyInfo.h""","#include <utility>
#include <stdexcept>
#include ""BaseFileWithLogsSplit.h""
#include ""BootstrapBaseFileSplit.h""
#include ""HoodieRealtimeFileSplit.h""
#include ""HoodieVirtualKeyInfo.h""",0
"if (lastKnownPartitionPath.empty() || lastKnownPartitionPath != partitionPath || !handle->canWrite()) {
    LOG.info(""Creating new file for partition path "" + partitionPath);
    handle = getRowCreateHandle(partitionPath);
    lastKnownPartitionPath = partitionPath;
}
handle->write(record);","if (lastKnownPartitionPath.empty() || lastKnownPartitionPath != partitionPath || !handle->canWrite()) {
    LOG.info(""Creating new file for partition path "" + partitionPath);
    handle = getRowCreateHandle(partitionPath);
    lastKnownPartitionPath = partitionPath;
}
handle->write(record);",0
"class Main {
public:
    // Entry point for loading containers
};","#include <mutex>

class Main {
public:
};",1
"quot1 = res;

// Write the digit into the correct position
value[index1--] = static_cast<char>('0' - rem);
} while (quot1 != 0);

if (v1 < 0) {
    value[index1--] = '-';
}

initCompressionFlag();
} else {
    value = std::vector<char>(len);
    count = len;

    int start = len;

    // Copy in s3 contents
    start = start - s3len;
    std::copy(s3.value.begin(), s3.value.begin() + s3len, value.begin() + start);

    // Copy in s2 contents
    start = start - s2len;
    std::copy(s2.value.begin(), s2.value.begin() + s2len, value.begin() + start);

    // Copy in v2
    int index2 = start - 1;","```cpp
quot1 = res;

// Write the digit into the correct position
value[index1--] = static_cast<char>('0' - rem);

} while (quot1 != 0);

if (v1 < 0) {
    value[index1--] = '-';
}

initCompressionFlag();
} else {
    value = std::vector<char>(len);
    count = len;

    int start = len;

    // Copy in s3 contents
    start = start - s3len;
    std::copy(s3.value.begin(), s3.value.begin() + s3len, value.begin() + start);

    // Copy in s2 contents
    start = start - s2len;
    std::copy(s2.value.begin(), s2.value.begin() + s2len, value.begin() + start);

    // Copy in v2
    int index2 = start - 1;
}
```",0
"#include <stdexcept>
#include <gmock/gmock.h>
#include <gtest/gtest.h>","#include <gtest/gtest.h>
#include <gmock/gmock.h>

#include ""MuleException.h""
#include ""Error.h""
#include ""ErrorType.h""",0
"return isSchemaCompatible(Schema::Parser().parse(oldSchema), Schema::Parser().parse(newSchema));
}

//
// Get latest schema either from incoming schema or table schema.
//
Schema getLatestSchema(
    const Schema& writeSchema,
    bool convertTableSchemaToAddNamespace,
    const std::function<Schema(const Schema&)>& converterFn
) {
    Schema latestSchema = writeSchema;
    try {
        if (metaClient.isTimelineNonEmpty()) {
            Schema tableSchema = getTableAvroSchemaWithoutMetadataFields();
            if (convertTableSchemaToAddNamespace && converterFn) {
                tableSchema = converterFn(tableSchema);
            }
            if (
                writeSchema.getFields().size() < tableSchema.getFields().size() &&
                isSchemaCompatible(writeSchema, tableSchema)
            ) {
                latestSchema = tableSchema;
                LOG.debug(""Using latest table schema to rewrite incoming records "" + tableSchema.toString());
            }
        }
    } catch (const IllegalArgumentException& e) {
        LOG.warn(""Could not find any commits, falling back to using incoming batch's write schema"");
    } catch (const InvalidTableException& e) {
        LOG.warn(""Could not find any commits, falling back to using incoming batch's write schema"");
    } catch (const std::exception& e) {
        LOG.warn(std::string(""Unknown exception thrown "") + e.what() + "", Falling back to using incoming batch's write schema"");
    }
    return latestSchema;
}","Schema getLatestSchema(const Schema& writeSchema, bool convertTableSchemaToAddNamespace,
                      const std::function<Schema(const Schema&)>& converterFn) {
    Schema latestSchema = writeSchema;
    try {
        if (metaClient.isTimelineNonEmpty()) {
            Schema tableSchema = getTableAvroSchemaWithoutMetadataFields();
            if (convertTableSchemaToAddNamespace && converterFn) {
                tableSchema = converterFn(tableSchema);
            }
            if (writeSchema.getFields().size() < tableSchema.getFields().size() &&
                isSchemaCompatible(writeSchema, tableSchema)) {
                latestSchema = tableSchema;
                LOG.debug(""Using latest table schema to rewrite incoming records "" + tableSchema.toString());
            }
        }
    } catch (const IllegalArgumentException& e) {
        LOG.warn(""Could not find any commits, falling back to using incoming batch's write schema"");
    } catch (const InvalidTableException& e) {
        LOG.warn(""Could not find any commits, falling back to using incoming batch's write schema"");
    } catch (const std::exception& e) {
        LOG.warn(std::string(""Unknown exception thrown "") + e.what() + "", Falling back to using incoming batch's write schema"");
    }
    return latestSchema;
}",1
"enum class SqlStatement {
    DELETE_MESSAGE_GROUP,
    CREATE_GROUP_TO_MESSAGE,
    UPDATE_GROUP
};

constexpr const char* getSqlStatement(SqlStatement stmt) {
    switch (stmt) {
        case SqlStatement::DELETE_MESSAGE_GROUP:
            return ""DELETE from %PREFIX%MESSAGE_GROUP where GROUP_KEY=? and REGION=?"";
        case SqlStatement::CREATE_GROUP_TO_MESSAGE:
            return ""INSERT into %PREFIX%GROUP_TO_MESSAGE(GROUP_KEY, MESSAGE_ID, REGION) values (?, ?, ?)"";
        case SqlStatement::UPDATE_GROUP:
            return ""UPDATE %PREFIX%MESSAGE_GROUP set UPDATED_DATE=? where GROUP_KEY=? and REGION=?"";
        default:
            return """";
    }
}","enum class Query {
    DELETE_MESSAGE_GROUP = 0,
    CREATE_GROUP_TO_MESSAGE,
    UPDATE_GROUP
};

const std::string queries[] = {
    ""DELETE from %PREFIX%MESSAGE_GROUP where GROUP_KEY=? and REGION=?"",
    ""INSERT into %PREFIX%GROUP_TO_MESSAGE(GROUP_KEY, MESSAGE_ID, REGION) values (?, ?, ?)"",
    ""UPDATE %PREFIX%MESSAGE_GROUP set UPDATED_DATE=? where GROUP_KEY=? and REGION=?""
};",0
"if (DpiHelper::IsPerMonitorV2Awareness && !std::is_base_of<Form, std::decay_t<decltype(*this)>>::value)
{
    int old = _deviceDpi;
    _deviceDpi = static_cast<int>(User32::GetDpiForWindow(this));
    if (old != _deviceDpi)
    {
        RescaleConstantsForDpi(old, _deviceDpi);","if (DpiHelper::IsPerMonitorV2Awareness && !(dynamic_cast<Form*>(this)))
{
    int old = _deviceDpi;
    _deviceDpi = static_cast<int>(User32::GetDpiForWindow(this));
    if (old != _deviceDpi)
    {
        RescaleConstantsForDpi(old, _deviceDpi);
    }
}",1
"#include <string>
#include <memory>","#include <string>
#include <memory>",0
"addressesTag.and(std::vector<std::string>{""8a""})
    .and(namesTag, std::vector<std::string>{});

auto coder = KvCoder<int, CoGbkResult>::of(
    VarIntCoder::of(),
    CoGbkResult::CoGbkResultCoder::of(
        CoGbkResultSchema::of(
            std::vector<TagType>{purchasesTag, addressesTag, namesTag}),
        UnionCoder::of(
            std::vector<std::shared_ptr<Coder>>{
                StringUtf8Coder::of(),
                StringUtf8Coder::of(),
                StringUtf8Coder::of()
            }
        )
    )
);

auto results = p
    | Create(KV<int, decltype(result1)>{1, result1},
             KV<int, decltype(result2)>{2, result2},
             KV<int, decltype(result3)>{3, result3},
             KV<int, decltype(result4)>{4, result4})
        .withCoder(coder)
    | ParDo(CorrelatePurchaseCountForAddressesWithoutNamesFn(
        purchasesTag,
        addressesTag,
        namesTag
      ));

PAssert::that(results).containsInAnyOrder(
    KV<std::string, int>(""4a"", 2),
    KV<std::string, int>(""8a"", 0)
);

p.run();","auto coder = KvCoder<int, CoGbkResult>::of(
    VarIntCoder::of(),
    CoGbkResult::CoGbkResultCoder::of(
        CoGbkResultSchema::of(
            { purchasesTag, addressesTag, namesTag }),
        UnionCoder::of(
            { StringUtf8Coder::of(),
              StringUtf8Coder::of(),
              StringUtf8Coder::of() })));

auto input = Create::of({
        KV<int, CoGbkResult>::of(1, result1),
        KV<int, CoGbkResult>::of(2, result2),
        KV<int, CoGbkResult>::of(3, result3),
        KV<int, CoGbkResult>::of(4, result4)
    })->withCoder(coder);

auto results = input->apply(
    ParDo::of(std::make_shared<CorrelatePurchaseCountForAddressesWithoutNamesFn>(
        purchasesTag, addressesTag, namesTag)));

PAssert::that(results)->containsInAnyOrder({
    KV<std::string, int>::of(""4a"", 2),
    KV<std::string, int>::of(""8a"", 0)
});

p->run();",1
"{
    std::vector<Package*> enumerable = packages.ToList();

    for (auto* pkg : enumerable)
    {
        if (pkg != nullptr)
        {
            TryLoadPackageIntoLibrary(pkg);
        }
    }

    std::vector<AssemblyType*> assemblies;
    for (auto* x : enumerable) {
        auto tmp = x->EnumerateAssembliesInBinDirectory();
        for (auto* y : tmp) {
            if (y->IsNodeLibrary) {
                assemblies.push_back(y);
            }
        }
    }
    std::vector<Assembly*> assemblies_selected;
    for (auto* x : assemblies) {
        assemblies_selected.push_back(x->Assembly);
    }
    OnPackagesLoaded(assemblies_selected);
}","```cpp
auto enumerable = std::vector<Package*>(packages.begin(), packages.end());

for (auto pkg : enumerable)
{
    if (pkg != nullptr)
    {
        TryLoadPackageIntoLibrary(pkg);
    }
}

std::vector<Assembly*> assemblies;
for (auto x : enumerable)
{
    auto libs = x->EnumerateAssembliesInBinDirectory();
    for (auto y : libs)
    {
        if (y->IsNodeLibrary)
        {
            assemblies.push_back(y);
        }
    }
}

std::vector<Assembly*> assembliesToLoad;
for (auto x : assemblies)
{
    assembliesToLoad.push_back(x->Assembly);
}

OnPackagesLoaded(assembliesToLoad);
```",1
"bool messageJournalEnabled = true;

std::string messageJournalMode = MessageQueueModule::DISK_IMPLEMENTATION;

int inputbufferProcessors = 2;","```cpp
class BaseConfiguration : public PathConfiguration {
protected:
    bool messageJournalEnabled = true;

    std::string messageJournalMode = MessageQueueModule::DISK_IMPLEMENTATION;

    int inputbufferProcessors = 2;
};
```",1
"schemaProvider = dataAndCheckpoint.getSchemaProvider();
}

if (checkpointStr == (resumeCheckpointStr ? *resumeCheckpointStr : std::string())) {
    log.info(""No new data, source checkpoint has not changed. Nothing to commit.""
             ""Old checkpoint=("" + (resumeCheckpointStr ? *resumeCheckpointStr : ""null"") + ""). New Checkpoint=("" + checkpointStr + "")"");
    return nullptr;
}

if (!avroRDDOptional.has_value() || avroRDDOptional->empty()) {
    log.info(""No new data, perform empty commit."");
    return std::make_pair(schemaProvider, std::make_pair(checkpointStr, jssc.emptyRDD()));
}

auto avroRDD = *avroRDDOptional;
auto records = map(avroRDD, [&](const GenericRecord& gr) {
    auto payload = DataSourceUtils::createPayload(cfg.payloadClassName, gr,","if (checkpointStr == (resumeCheckpointStr ? *resumeCheckpointStr : std::string())) {
    log.info(""No new data, source checkpoint has not changed. Nothing to commit.""
             ""Old checkpoint=("" + (resumeCheckpointStr ? *resumeCheckpointStr : ""null"") +
             ""). New Checkpoint=("" + checkpointStr + "")"");
    return nullptr;
}

if ((!avroRDDOptional.has_value()) || (avroRDDOptional->empty())) {
    log.info(""No new data, perform empty commit."");
    return std::make_pair(schemaProvider, std::make_pair(checkpointStr, jssc.emptyRDD()));
}

auto avroRDD = *avroRDDOptional;
auto records = avroRDD.map([&](const GenericRecord& gr) {
    auto payload = DataSourceUtils::createPayload(cfg.payloadClassName, gr,
        // ... (additional arguments as needed)
    );
    // ... (rest of the lambda implementation)
});",1
"virtual bool canBeUsedDirect(AbstractMessageProducingHandler* handler) {
    return true;
}

virtual void postProcessReplyProducer(AbstractMessageProducingHandler* handler) {
    if (this->sendTimeout != nullptr) {
        handler->setSendTimeout(this->sendTimeout);
    }
    if (this->requiresReply != nullptr) {
        if (auto replyHandler = dynamic_cast<AbstractReplyProducingMessageHandler*>(handler)) {
            replyHandler->setRequiresReply(this->requiresReply);
        } else {
            if (logger.isDebugEnabled()) {
                logger.debug(std::string(""requires-reply can only be set to AbstractReplyProducingMessageHandler or its subclass, "")
                    + handler->getComponentName() + "" doesn't support it."");
            }
        }
    }
}","```cpp
class ServiceActivatorFactoryBean : public AbstractStandardMessageHandlerFactory {
protected:
    bool canBeUsedDirect(AbstractMessageProducingHandler* handler) override {
        return true;
    }

    void postProcessReplyProducer(AbstractMessageProducingHandler* handler) override {
        if (this->sendTimeout.has_value()) {
            handler->setSendTimeout(this->sendTimeout.value());
        }
        if (this->requiresReply.has_value()) {
            auto* replyHandler = dynamic_cast<AbstractReplyProducingMessageHandler*>(handler);
            if (replyHandler != nullptr) {
                replyHandler->setRequiresReply(this->requiresReply.value());
            } else {
                if (logger.isDebugEnabled()) {
                    logger.debug(
                        std::string(""requires-reply can only be set to AbstractReplyProducingMessageHandler or its subclass, "")
                        + handler->getComponentName() + "" doesn't support it.""
                    );
                }
            }
        }
    }
};
```",0
"class Themes {
public:
    static constexpr int ALPHA_ICON_ENABLED_LIGHT = 255;
    static constexpr int ALPHA_ICON_DISABLED_LIGHT = 76;
    static constexpr int THEME_DAY_LIGHT = 0;
};","class Themes {
public:
    static const int ALPHA_ICON_ENABLED_LIGHT = 255;
    static const int ALPHA_ICON_DISABLED_LIGHT = 76;
    static const int THEME_DAY_LIGHT = 0;
};",1
"getDialogHandler()->sendMessage(handlerMessage);
    }
}
updateDeckList();
if (mFragmented) {
    // Create the fragment in a new handler since Android won't let you perform fragment
}","updateDeckList();
if (mFragmented) {
    // Create the fragment in a new handler since Android won't let you perform fragment
}",0
"auto pipeline = Pipeline::create(options);

auto input = pipeline","Pipeline pipeline = Pipeline::create(options);

/*
 * Concept #1: the Beam SDK lets us run the same pipeline with either a bounded or
 * unbounded input source.
 */
auto input = pipeline;",1
"#include <hudi/client/SparkRDDWriteClient.h>
#include <hudi/client/WriteStatus.h>
#include <hudi/client/common/HoodieSparkEngineContext.h>
#include <hudi/common/config/HoodieMetadataConfig.h>
#include <hudi/common/model/EmptyHoodieRecordPayload.h>
#include <hudi/common/model/HoodieKey.h>
#include <hudi/common/model/HoodieRecord.h>","#include ""org/apache/hudi/client/SparkRDDWriteClient.h""
#include ""org/apache/hudi/client/WriteStatus.h""
#include ""org/apache/hudi/client/common/HoodieSparkEngineContext.h""
#include ""org/apache/hudi/common/config/HoodieMetadataConfig.h""
#include ""org/apache/hudi/common/model/EmptyHoodieRecordPayload.h""
#include ""org/apache/hudi/common/model/HoodieKey.h""
#include ""org/apache/hudi/common/model/HoodieRecord.h""",0
"#include <stdexcept>
#include <string>
#include <memory>
#include <type_traits>
#include <cassert>

// Placeholder for Config class functionality.
class Config {
public:
    // Interface and implementation as required
};

// Equivalent of ConfigFactory
class ConfigFactory {
public:
    static Config load() {
        return Config();
    }
}

// Equivalent of Preconditions.checkArgument
inline void checkArgument(bool condition, const std::string& msg = """") {
    if (!condition) {
        throw std::invalid_argument(msg);
    }
}

// Equivalent of Preconditions.checkNotNull
template <typename T>
T checkNotNull(const T& value, const std::string& msg = """") {
    if constexpr (std::is_pointer<T>::value) {
        if (value == nullptr) {
            throw std::invalid_argument(msg);
        }
    }
    return value;
}

// Utility emulating Apache Gobblin's ConfigUtils if needed
class ConfigUtils {
public:
    // static helper methods as required
};

// Equivalent of JOptSimple Strings helper
namespace Strings {
    inline bool isNullOrEmpty(const std::string& str) {
        return str.empty();
    }
}","#include <cassert>
#include <string>
#include <memory>
#include <utility>
#include <algorithm>
#include <vector>",0
"{
    auto pgpCryptInfo = this->safeGetCryptInfo(cryptInfo);
    auto publicKey = pgpCryptInfo.getPublicKey();
    StreamTransformer transformer = EncryptStreamTransformer(data, publicKey, provider, encryptionAlgorithm);
    return LazyTransformedInputStream(TransformContinuouslyPolicy(), transformer);
}
catch (const std::exception& e)","try
{
    auto pgpCryptInfo = this->safeGetCryptInfo(cryptInfo);
    auto publicKey = pgpCryptInfo.getPublicKey();
    auto transformer = std::make_shared<EncryptStreamTransformer>(data, publicKey, provider, encryptionAlgorithm);
    return std::make_shared<LazyTransformedInputStream>(std::make_shared<TransformContinuouslyPolicy>(), transformer);
}
catch (const std::exception& e)
{",0
"}

static bool useUnifiedWorker(const DataflowPipelineOptions& options) {
    return hasExperiment(options, ""beam_fn_api"")
        || hasExperiment(options, ""use_runner_v2"")
        || hasExperiment(options, ""use_unified_worker"");
}

static void verifyDoFnSupportedBatch(const DoFnBase& fn) {","static bool useUnifiedWorker(const DataflowPipelineOptions& options) {
    return hasExperiment(options, ""beam_fn_api"") ||
           hasExperiment(options, ""use_runner_v2"") ||
           hasExperiment(options, ""use_unified_worker"");
}",1
#include <set>,#include <set>,0
"Control* FindMarshalingControl() {
    Control* c = this;
    while (c != nullptr && !c->IsHandleCreated()) {
        Control* p = c->ParentInternal();
        c = p;
    }
    if (c == nullptr) {
        c = this;
    } else {
        assert(c->IsHandleCreated() && ""FindMarshalingControl chose a bad control."");
    }
    return c;
}","```cpp
#include <mutex>
#include <cassert>

class Control {
public:
    virtual ~Control() = default;

    virtual bool IsHandleCreated() const = 0;
    virtual Control* ParentInternal() const = 0;

protected:
    Control* FindMarshalingControl() {
        std::lock_guard<std::mutex> lock(m_mutex);

        Control* c = this;

        while (c != nullptr && !c->IsHandleCreated()) {
            Control* p = c->ParentInternal();
            c = p;
        }

        if (c == nullptr) {
            c = this;
        } else {
            assert(c->IsHandleCreated() && ""FindMarshalingControl chose a bad control."");
        }

        return c;
    }

private:
    mutable std::mutex m_mutex;
};
```",1
"assertStdOutContains(stdOutErrPair, ""|GOOG  |2018-08-31 10:29:00|3391  |1230.1899|1230.085|"");

void testIncrementalHiveQuery(const std::string& minCommitTimeScript, const std::string& incrementalCommandsFile,
                              const std::string& expectedOutput, int expectedTimes) {
    std::string minCommitTime =
        executeCommandStringInDocker(ADHOC_2_CONTAINER, minCommitTimeScript, true).getStdout().toString();
    auto stdOutErrPair =
        executeHiveCommandFile(incrementalCommandsFile, ""min.commit.time="" + minCommitTime + ""`"");
    assertStdOutContains(stdOutErrPair, expectedOutput, expectedTimes);
}

void testIncrementalHiveQueryBeforeCompaction() {
    std::string expectedOutputCOW = ""| GOOG    | 2018-08-31 10:59:00  | 9021    | 1227.1993  | 1227.215  |"";

    // verify that 10:59 is present in COW table because there is no compaction process for COW
    testIncrementalHiveQuery(MIN_COMMIT_TIME_COW_SCRIPT, HIVE_INCREMENTAL_COW_COMMANDS, expectedOutputCOW, 1);

    // verify that 10:59 is NOT present in RO table because of pending compaction
    testIncrementalHiveQuery(MIN_COMMIT_TIME_MOR_SCRIPT, HIVE_INCREMENTAL_MOR_RO_COMMANDS, expectedOutputCOW, 0);

    // verify that 10:59 is present in RT table even with pending compaction
    testIncrementalHiveQuery(MIN_COMMIT_TIME_MOR_SCRIPT, HIVE_INCREMENTAL_MOR_RT_COMMANDS, expectedOutputCOW, 1);
}

void testIncrementalHiveQueryAfterCompaction() {
    std::string expectedOutput =
        ""| symbol  |          ts          | volume  |    open    |   close   |\n""
        ""+---------+----------------------+---------+------------+-----------+\n""
        ""| GOOG    | 2018-08-31 10:59:00  | 9021    | 1227.1993  | 1227.215  |"";

    // verify that 10:59 is present for all views because compaction is complete
    testIncrementalHiveQuery(MIN","```cpp
void testIncrementalHiveQuery(const std::string& minCommitTimeScript,
                              const std::string& incrementalCommandsFile,
                              const std::string& expectedOutput,
                              int expectedTimes) {
    std::string minCommitTime =
        executeCommandStringInDocker(ADHOC_2_CONTAINER, minCommitTimeScript, true).getStdout();
    auto stdOutErrPair =
        executeHiveCommandFile(incrementalCommandsFile, ""min.commit.time="" + minCommitTime + ""`"");
    assertStdOutContains(stdOutErrPair, expectedOutput, expectedTimes);
}

void testIncrementalHiveQueryBeforeCompaction() {
    std::string expectedOutputCOW = ""| GOOG    | 2018-08-31 10:59:00  | 9021    | 1227.1993  | 1227.215  |"";

    // verify that 10:59 is present in COW table because there is no compaction process for COW
    testIncrementalHiveQuery(MIN_COMMIT_TIME_COW_SCRIPT, HIVE_INCREMENTAL_COW_COMMANDS, expectedOutputCOW, 1);

    // verify that 10:59 is NOT present in RO table because of pending compaction
    testIncrementalHiveQuery(MIN_COMMIT_TIME_MOR_SCRIPT, HIVE_INCREMENTAL_MOR_RO_COMMANDS, expectedOutputCOW, 0);

    // verify that 10:59 is present in RT table even with pending compaction
    testIncrementalHiveQuery(MIN_COMMIT_TIME_MOR_SCRIPT, HIVE_INCREMENTAL_MOR_RT_COMMANDS, expectedOutputCOW, 1);
}

void testIncrementalHiveQueryAfterCompaction() {
    std::string expectedOutput =
        ""| symbol  |          ts          | volume  |    open    |   close   |\n""
        ""+---------+----------------------+---------+------------+-----------+\n""
        ""| GOOG    | 2018-08-31 10:59:00  | 9021    | 1227.1993  | 1227.215  |"";

    // verify that 10:59 is present for all views because compaction is complete
    testIncrementalHiveQuery(MIN_COMMIT_TIME_COW_SCRIPT, HIVE_INCREMENTAL_COW_COMMANDS, expectedOutput, 1);
    testIncrementalHiveQuery(MIN_COMMIT_TIME_MOR_SCRIPT, HIVE_INCREMENTAL",1
"```cpp
    return rv;
}
case MODELS_ID_TEMPLATES_ID: {
    // Direct access model template with specific ID
    int ord = std::stoi(uri.getLastPathSegment());
    nlohmann::json currentModel = col.getModels().at(getModelIdFromUri(uri, col));
    std::vector<std::string> columns = (projection.size() > 0) ? projection : CardTemplate::DEFAULT_PROJECTION;
```","```cpp
case MODELS_ID_TEMPLATES_ID: {
    int ord = std::stoi(uri.getLastPathSegment());
    auto currentModel = col.getModels().at(getModelIdFromUri(uri, col));
    std::vector<std::string> columns = (projection != nullptr) ? *projection : CardTemplate::DEFAULT_PROJECTION;
    // ...
}
```",0
"std::unordered_map<std::type_index, std::shared_ptr<MethodAnnotationPostProcessorBase>> postProcessors;

ConfigurableListableBeanFactory* beanFactory;

std::unordered_set<std::type_index> noAnnotationsCache;","```cpp
#include <map>
#include <set>
#include <typeindex>
#include <type_traits>

class ConfigurableListableBeanFactory;

template<typename T>
class MethodAnnotationPostProcessor;

class MessagingAnnotationPostProcessor {
private:
    std::map<std::type_index, MethodAnnotationPostProcessor<void>*> postProcessors;

    ConfigurableListableBeanFactory* beanFactory = nullptr;

    std::set<std::type_index> noAnnotationsCache;
};
```",0
"std::optional<ClassTreeImpl> classBody,
std::optional<InternalSyntaxToken> commaToken) {

IdentifierTreeImpl identifier(static_cast<InternalSyntaxToken>(identifierToken));

SyntaxToken openParenToken = nullptr;","std::optional<IdentifierTreeImpl> identifier = std::make_optional<IdentifierTreeImpl>(static_cast<InternalSyntaxToken*>(identifierToken));

SyntaxToken* openParenToken = nullptr;",0
"#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <unordered_set>
#include <atomic>
#include <memory>
#include <stdexcept>
#include <string>

using ::testing::_;
using ::testing::Throw;
using ::testing::Test;
using ::testing::HasSubstr;

class SimplePool {
public:
    SimplePool(size_t maxSize,
               std::shared_ptr<std::unordered_set<std::string>> s,
               std::shared_ptr<std::atomic_bool> st) :
        maxSize_(maxSize), strings_(s), stale_(st), allocatedCount_(0) {}

    std::string getItem() {
        ++allocatedCount_;
        return {};
    }

    void releaseItem(const std::string& item) {
        if (strings_->find(item) == strings_->end()) {
            throw std::invalid_argument(""Item not from this pool"");
        }
    }

    size_t getAllocatedCount() const { return allocatedCount_; }

private:
    size_t maxSize_;
    std::shared_ptr<std::unordered_set<std::string>> strings_;
    std::shared_ptr<std::atomic_bool> stale_;
    size_t allocatedCount_;
};

std::unique_ptr<SimplePool> stringPool(size_t maxSize, std::shared_ptr<std::unordered_set<std::string>> strings, std::shared_ptr<std::atomic_bool> stale) {
    return std::make_unique<SimplePool>(maxSize, strings, stale);
}

TEST(SimplePoolTest, AllocatedCount) {
    auto strings = std::make_shared<std::unordered_set<std::string>>();
    auto stale = std::make_shared<std::atomic_bool>(false);
    auto pool = stringPool(2, strings, stale);
    pool->getItem();
    pool->getItem();
    ASSERT_EQ(pool->getAllocatedCount(), 2);
}

TEST(SimplePoolTest, ForeignObject) {
    auto strings = std::make_shared<std::unordered_set<std::string>>();
    auto stale = std::make_shared<std::atomic_bool>(false);
    auto pool = stringPool(2, strings, stale);
    pool->getItem();
    EXPECT_THROW(pool->releaseItem(""Hello, world!""), std::invalid_argument);
}","```cpp
#include <set>
#include <string>
#include <atomic>
#include <stdexcept>
#include <gtest/gtest.h>

TEST(SimplePoolTests, testForeignObject) {
    std::set<std::string> strings;
    std::atomic_bool stale(false);
    SimplePool<std::string> pool = stringPool(2, strings, stale);
    pool.getItem();
    EXPECT_THROW(pool.releaseItem(""Hello, world!""), std::invalid_argument);
}
```",0
"```cpp
        else if (dynamic_cast<std::exception*>(t))
        {
            throw *static_cast<std::exception*>(t);
        }
        else
        {
```","```cpp
if (logger.isDebugEnabled())
{
    logger.debug(message);
}
else if (auto ex = dynamic_cast<std::exception*>(&t))
{
    throw *ex;
}
else
{
```",0
"class TokenUrlResponseException : public std::exception {
protected:
    Event tokenUrlResponse;
public:
    explicit TokenUrlResponseException(const Event& tokenUrlResponse)
        : tokenUrlResponse(tokenUrlResponse) {}

    const Event& getTokenUrlResponse() const {
        return tokenUrlResponse;
    }
};","class TokenUrlResponseException : public std::exception {
private:
    Event tokenUrlResponse;
public:
    explicit TokenUrlResponseException(const Event& tokenUrlResponse)
        : tokenUrlResponse(tokenUrlResponse) {}

    const Event& getTokenUrlResponse() const {
        return tokenUrlResponse;
    }
};",0
"#include <gtest/gtest.h>

TEST(ChoiceRouterTest, testChoice) {
    ChoiceRouter choiceRouter;
    choiceRouter.addRoute(newChain(getAppendingMP(""1"")), AcceptAllFilter());
    choiceRouter.addRoute(newChain(getAppendingMP(""2"")), AcceptAllFilter());
    choiceRouter.addRoute(newChain(getAppendingMP(""3"")), AcceptAllFilter());

    auto result = process(newChain(choiceRouter), getTestEventUsingFlow(""0""))
                      .getMessage().getPayload().getValue();
    EXPECT_EQ(result, ""01"");
}","#include <gtest/gtest.h>
#include <gmock/gmock.h>

TEST(DefaultMessageProcessorChainTestCase, testChoice) {
    ChoiceRouter choiceRouter;
    choiceRouter.addRoute(newChain(getAppendingMP(""1"")), AcceptAllFilter());
    choiceRouter.addRoute(newChain(getAppendingMP(""2"")), AcceptAllFilter());
    choiceRouter.addRoute(newChain(getAppendingMP(""3"")), AcceptAllFilter());

    ASSERT_THAT(process(newChain(choiceRouter), getTestEventUsingFlow(""0"")).getMessage().getPayload().getValue(), ::testing::Eq(""01""));
}",1
"void redeploysDomainZipDeployedAfterStartup()
{
    addPackedDomainFromBuilder(dummyDomainFileBuilder);
    std::filesystem::path dummyDomainFile = std::filesystem::path(domainsDir) / dummyDomainFileBuilder.getZipPath();
    auto firstFileTimestamp = std::filesystem::last_write_time(dummyDomainFile);
    deploymentService.start();
}","```cpp
void redeploysDomainZipDeployedAfterStartup() {
    addPackedDomainFromBuilder(dummyDomainFileBuilder);
    std::filesystem::path dummyDomainFile = domainsDir / dummyDomainFileBuilder.getZipPath();
    auto firstFileTimestamp = std::filesystem::last_write_time(dummyDomainFile);

    deploymentService.start();
}
```",0
"```cpp
#include <vector>
#include <list>
#include <map>
#include <string>
#include <memory>

void enrichParameterFields(
    std::vector<FieldValues>& fieldsValues, 
    ParameterDeclaration& paramDeclaration,
    std::map<std::string, std::string>& parameterNames,
    const std::string& name, 
    const std::vector<ParameterDeclaration>& allParameters
) {
    std::list<FieldValueProviderModel> fieldValueProviderModels;
    std::map<std::string, ValueProviderFactoryModelProperty> valueProviderFactoryModelProperties;

    for (const auto& fieldValues : fieldsValues) {
        auto propertyBuilder = ValueProviderFactoryModelProperty::builder(fieldValues.value());

        ParameterizableTypeWrapper resolverClassWrapper(
            fieldValues.value(), 
            DefaultExtensionsTypeLoaderFactory().createTypeLoader()
        );
        auto resolverParameters = resolverClassWrapper.getParametersAnnotatedWith(Parameter::static_type());

        for (const auto& param : resolverParameters) {
            propertyBuilder.withInjectableParameter(
                param.getName(), 
                param.getType().asMetadataType(), 
                param.isRequired()
            );
        }

        bool requiresConfiguration = false;
        bool requiresConnection = false;

        if (auto field = enrichWithConnection(propertyBuilder, resolverClassWrapper)) {
            requiresConnection = true;
        }
        if (auto field = enrichWithConfiguration(propertyBuilder, resolverClassWrapper)) {
            requiresConfiguration = true;
        }

        int partOrder = 1;
        for (const auto& targetPath : fieldValues.targetPaths()) {
            ValueProviderFactoryModelProperty valueProviderFactoryModelProperty = propertyBuilder.build();
            valueProviderFactoryModelProperties[targetPath] = valueProviderFactoryModelProperty;

            fieldValueProviderModels.emplace_back(
                getActingParametersModel(
                    resolverParameters, 
                    parameterNames, 
                    allParameters, 
                    {}
                ),
                requiresConfiguration, 
                requiresConnection, 
                fieldValues.open(),
                partOrder,
                name, 
                getValueProviderId(fieldValues.value()), 
                targetPath
            );
            ++partOrder;
        }
        paramDeclaration.setFieldValueProviderModels(fieldValueProviderModels);
        paramDeclaration.addModelProperty(
            std::make_shared<FieldsValueProviderFactoryModelProperty>(valueProviderFactoryModelProperties)
        );
    }
}
```","```cpp
#include <vector>
#include <list>
#include <map>
#include <string>
#include <memory>

void enrichParameterFields(
    const std::vector<FieldValues>& fieldsValues,
    ParameterDeclaration& paramDeclaration,
    const std::map<std::string, std::string>& parameterNames,
    const std::string& name,
    const std::vector<ParameterDeclaration>& allParameters) 
{
    std::list<FieldValueProviderModel> fieldValueProviderModels;
    std::map<std::string, ValueProviderFactoryModelProperty> valueProviderFactoryModelProperties;

    for (const auto& fieldValues : fieldsValues) {
        auto propertyBuilder = ValueProviderFactoryModelProperty::builder(fieldValues.value());

        ParameterizableTypeWrapper resolverClassWrapper(
            fieldValues.value(), DefaultExtensionsTypeLoaderFactory().createTypeLoader());

        auto resolverParameters = resolverClassWrapper.getParametersAnnotatedWith<Parameter>();

        for (const auto& param : resolverParameters) {
            propertyBuilder.withInjectableParameter(param.getName(), param.getType().asMetadataType(), param.isRequired());
        }

        bool requiresConfiguration = false;
        bool requiresConnection = false;

        auto maybeConnection = enrichWithConnection(propertyBuilder, resolverClassWrapper);
        if (maybeConnection) {
            requiresConnection = true;
        }
        auto maybeConfiguration = enrichWithConfiguration(propertyBuilder, resolverClassWrapper);
        if (maybeConfiguration) {
            requiresConfiguration = true;
        }

        int partOrder = 1;
        for (const auto& targetPath : fieldValues.targetPaths()) {
            auto valueProviderFactoryModelProperty = propertyBuilder.build();
            valueProviderFactoryModelProperties[targetPath] = valueProviderFactoryModelProperty;

            fieldValueProviderModels.emplace_back(
                getActingParametersModel(
                    resolverParameters,
                    parameterNames,
                    allParameters,
                    std::map<std::string, std::string>()),
                requiresConfiguration,
                requiresConnection,
                fieldValues.open(),
                partOrder,
                name,
                getValueProviderId(fieldValues.value()),
                targetPath
            );
            ++partOrder;
        }
        paramDeclaration.setFieldValueProviderModels(fieldValueProviderModels);
        paramDeclaration.addModelProperty(
            std::make_shared<FieldsValueProviderFactoryModelProperty>(valueProviderFactoryModelProperties));
    }
}
```",1
"[[deprecated(""Use setKnownHostsResource(Resource) instead"")]]
void setKnownHosts(const std::string& knownHosts) {
    setKnownHostsResource(FileSystemResource(knownHosts));
}

void setKnownHostsResource(const Resource& knownHosts) {
    this->knownHosts = knownHosts;
}","void setKnownHosts(const std::string& knownHosts) {
    setKnownHostsResource(std::make_shared<FileSystemResource>(knownHosts));
}

void setKnownHostsResource(const std::shared_ptr<Resource>& knownHosts) {
    this->knownHosts = knownHosts;
}",1
"```cpp
std::string line;
while (std::getline(in, line)) {
    line.erase(0, line.find_first_not_of("" \t\n\r\f\v""));
    line.erase(line.find_last_not_of("" \t\n\r\f\v"") + 1);

    if (line.empty()) {
        continue;
    }
    if (line[0] == '#') {
        continue;
    }

    size_t eq_pos = line.find('=');
    if (eq_pos != std::string::npos) {
        const std::string name = line.substr(0, eq_pos);
        std::string value = line.substr(eq_pos + 1);

        size_t nstart = name.find_first_not_of("" \t\n\r\f\v"");
        size_t nend = name.find_last_not_of("" \t\n\r\f\v"");
        const std::string name_trimmed = name.substr(nstart, nend - nstart + 1);

        size_t vstart = value.find_first_not_of("" \t\n\r\f\v"");
        size_t vend = value.find_last_not_of("" \t\n\r\f\v"");
        value = value.substr(vstart, vend - vstart + 1);

        if (!value.empty() && value[0] == '""') {
            value = value.substr(1, value.length() - 2);
        }

        _properties[name_trimmed] = value;
    } else {
        if (line.rfind(""RW"", 0) == 0) {
            const size_t startPos = line.find('""');
            const size_t endPos = line.rfind('""');
            assert(startPos != std::string::npos);
            assert(endPos != std::string::npos);
            _baseFileName = line.substr(startPos + 1, endPos - startPos - 1);
        } else {
            // else branch content
        }
    }
}
```","```cpp
std::string line;
while (std::getline(in, line)) {
    // ignore empty and comment lines
    line.erase(0, line.find_first_not_of("" \t\n\r""));
    line.erase(line.find_last_not_of("" \t\n\r"") + 1);
    if (line.empty()) {
        continue;
    }
    if (line[0] == '#') {
        continue;
    }

    auto eqPos = line.find('=');
    if (eqPos != std::string::npos) {
        const std::string name = line.substr(0, eqPos);
        std::string value = line.substr(eqPos + 1);

        auto name_trim_start = name.find_first_not_of("" \t\n\r"");
        auto name_trim_end = name.find_last_not_of("" \t\n\r"");
        std::string name_trimmed =
            (name_trim_start == std::string::npos) ? """" : name.substr(name_trim_start, name_trim_end - name_trim_start + 1);

        auto value_trim_start = value.find_first_not_of("" \t\n\r"");
        auto value_trim_end = value.find_last_not_of("" \t\n\r"");
        std::string value_trimmed =
            (value_trim_start == std::string::npos) ? """" : value.substr(value_trim_start, value_trim_end - value_trim_start + 1);

        if (!value_trimmed.empty() && value_trimmed[0] == '""') {
            value_trimmed = value_trimmed.substr(1, value_trimmed.length() - 2);
        }

        _properties[name_trimmed] = value_trimmed;
    } else {
        if (line.rfind(""RW"", 0) == 0) {
            auto startPos = line.find('""');
            auto endPos = line.rfind('""');
            assert(startPos > 0);
            assert(endPos > 0);

            _baseFileName = line.substr(startPos + 1, endPos - startPos - 1);
        } else {
            // ... other handling (not shown)
        }
    }
}
```",1
"#include ""Template.h""
#include ""Time.h""
#include ""Upgrade.h""
#include ""DatabaseChangeDecorator.h""
#include ""FunctionalInterfaces.h""
#include ""VersionUtils.h""","```cpp
#include ""libanki/sched/SchedV2.h""
#include ""libanki/template/Template.h""
#include ""libanki/utils/Time.h""
#include ""upgrade/Upgrade.h""
#include ""utils/DatabaseChangeDecorator.h""
#include ""utils/FunctionalInterfaces.h""
#include ""utils/VersionUtils.h""
```",0
"#include <gtest/gtest.h>
#include <string>
#include <vector>
#include <iostream>
#include <memory>
#include ""Workspace.h""
#include ""Project.h""
#include ""File.h""
#include ""Run.h""
#include ""assertThat.h""

TEST(FindProvidersTest, findprovidersMacroTestWithStrategy) {
    test([](Workspace& ws) {
        auto* project = ws.getProject(""p1"");
        ASSERT_THAT(project).isNotNull();
        auto build = project->build();
        ASSERT_THAT(build).isNotNull().isNotEmpty();
        ASSERT_THAT(build[0]).hasName(""p1.jar"");
        std::string services = ws._findproviders({
            ""findproviders"", ""osgi.service"", ""(objectClass=*)"", ""ALL""
        });
        std::cout << services << std::endl;
        ASSERT_THAT(services).contains(""org.apache.felix.scr;version="");
        ASSERT_THAT(services).contains(""org.apache.felix.http.jetty;version="");
        ASSERT_THAT(services).contains(""p1;version="");

        services = ws._findproviders({
            ""findproviders"", ""osgi.service"", ""(objectClass=*)"", ""REPOS""
        });
        std::cout << services << std::endl;
        ASSERT_THAT(services).contains(""org.apache.felix.scr;version="");
        ASSERT_THAT(services).contains(""org.apache.felix.http.jetty;version="");
        ASSERT_THAT(services).doesNotContain(""p1;version="");

        services = ws._findproviders({
            ""findproviders"", ""osgi.service"", ""(objectClass=*)"", ""WORKSPACE""
        });
        std::cout << services << std::endl;
        ASSERT_THAT(services).doesNotContain(""org.apache.felix.scr;version="");
        ASSERT_THAT(services).doesNotContain(""org.apache.felix.http.jetty;version="");
        ASSERT_THAT(services).contains(""p1;version="");

        services = ws._findproviders({
            ""findproviders"", ""osgi.service"", ""(objectClass=*)"", ""all""
        });
        std::cout << services << std::endl;
        ASSERT_THAT(services).contains(""org.apache.felix.scr;version="");
        ASSERT_THAT(services).contains(""org.apache.felix.http.jetty;version="");
        ASSERT_THAT(services).contains(""p1;version","#include <gtest/gtest.h>
#include <string>
#include <vector>
#include <iostream>

// Assume existence of helper functions/classes: test, assertThat, assertNull, assertFalse, etc.

TEST(WorkspaceRepositoryTest, findprovidersMacroTestWithStrategy) {
    test([](auto& ws) {
        auto project = ws.getProject(""p1"");
        ASSERT_NE(project, nullptr);
        auto build = project->build();
        ASSERT_NE(build, nullptr);
        ASSERT_FALSE(build->empty());
        ASSERT_EQ(build->at(0).getName(), ""p1.jar"");
        std::string services;

        services = ws._findproviders({""findproviders"", ""osgi.service"", ""(objectClass=*)"", ""ALL""});
        std::cout << services << std::endl;
        ASSERT_NE(services.find(""org.apache.felix.scr;version=""), std::string::npos);
        ASSERT_NE(services.find(""org.apache.felix.http.jetty;version=""), std::string::npos);
        ASSERT_NE(services.find(""p1;version=""), std::string::npos);

        services = ws._findproviders({""findproviders"", ""osgi.service"", ""(objectClass=*)"", ""REPOS""});
        std::cout << services << std::endl;
        ASSERT_NE(services.find(""org.apache.felix.scr;version=""), std::string::npos);
        ASSERT_NE(services.find(""org.apache.felix.http.jetty;version=""), std::string::npos);
        ASSERT_EQ(services.find(""p1;version=""), std::string::npos);

        services = ws._findproviders({""findproviders"", ""osgi.service"", ""(objectClass=*)"", ""WORKSPACE""});
        std::cout << services << std::endl;
        ASSERT_EQ(services.find(""org.apache.felix.scr;version=""), std::string::npos);
        ASSERT_EQ(services.find(""org.apache.felix.http.jetty;version=""), std::string::npos);
        ASSERT_NE(services.find(""p1;version=""), std::string::npos);

        services = ws._findproviders({""findproviders"", ""osgi.service"", ""(objectClass=*)"", ""all""});
        std::cout << services << std::endl;
        ASSERT_NE(services.find(""org.apache.felix.scr;version=""), std::string::npos);
        ASSERT_NE(services.find(""org.apache.felix.http.jetty;version",1
"#include <gtest/gtest.h>
#include <chrono>
#include <thread>
#include ""StaticQueue.h""
#include ""Pipeline.h""
#include ""PCollection.h""
#include ""PAssert.h""
#include ""Sum.h""
#include ""Window.h""
#include ""GlobalWindows.h""
#include ""AfterWatermark.h""
#include ""Duration.h""
#include ""Create.h""
#include ""MapElements.h""
#include ""TypeDescriptors.h""
#include ""PDone.h""
#include ""PTransform.h""

class PipelineTest : public ::testing::Test {};

TEST_F(PipelineTest, testTwoPOutputsInPipelineWithCascade) {
    auto start = StaticQueue<int>::of(""start"", VarIntCoder::of());
    auto messages = StaticQueue<int>::of(""messages"", VarIntCoder::of());

    auto pipeline = getPipeline(false);
    pipeline.begin().apply(""outputStartSignal"", outputStartTo(start));
    auto result =
        pipeline
        .apply(""processMessages"", messages.read())
        .apply(
            Window<int>::into(GlobalWindows())
                .triggering(AfterWatermark::pastEndOfWindow())
                .discardingFiredPanes()
                .withAllowedLateness(Duration::ZERO))
        .apply(Sum::integersGlobally());

    PAssert::that(result).containsInAnyOrder({6});

    auto run = pipeline.run();

    while (!start.take().has_value()) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }

    messages.add(1).add(2).add(3).terminate();

    run.waitUntilFinish();
}

class OutputStartToTransform : public PTransform<PBegin, PDone> {
public:
    explicit OutputStartToTransform(StaticQueue<int> queue) : queue_(queue) {}
    PDone expand(PBegin input) override {
        input
            .apply(Create::of(1))
            .apply(
                MapElements::into(TypeDescriptors::voids())
                .via([this](int in) {
                    queue_.add(in);
                    return nullptr;
                })
            );
        return PDone::in(input.getPipeline());
    }
private:
    StaticQueue<int> queue_;
};

std::shared_ptr<PTransform<PBegin, PDone>> outputStartTo(StaticQueue<int> queue) {
    return std::make_shared<OutputStartToTransform>(queue);
}","```cpp
#include <gtest/gtest.h>
#include <future>
#include <atomic>

class DirectRunnerTest : public ::testing::Test {
protected:
    class StaticQueue {
    public:
        StaticQueue() : terminated_(false) {}

        StaticQueue& add(int value) {
            {
                std::lock_guard<std::mutex> lock(mutex_);
                queue_.push(value);
            }
            cv_.notify_all();
            return *this;
        }

        StaticQueue& terminate() {
            {
                std::lock_guard<std::mutex> lock(mutex_);
                terminated_ = true;
            }
            cv_.notify_all();
            return *this;
        }

        std::optional<int> take() {
            std::unique_lock<std::mutex> lock(mutex_);
            cv_.wait(lock, [this]() { return !queue_.empty() || terminated_; });
            if (!queue_.empty()) {
                int v = queue_.front();
                queue_.pop();
                return v;
            }
            return std::nullopt;
        }

        static StaticQueue of(const std::string&, /* coder placeholder */ int) {
            return StaticQueue();
        }

    private:
        std::queue<int> queue_;
        std::mutex mutex_;
        std::condition_variable cv_;
        bool terminated_;
    };

    struct Pipeline;

    struct PipelineResult {
        void waitUntilFinish() {
            if (future_.valid()) future_.wait();
        }
        std::future<void> future_;
    };

    struct PCollection {
        std::vector<int> data;
    };

    struct PBegin {};

    struct PDone {};

    struct Pipeline {
        PBegin begin() { return PBegin{}; }

        Pipeline& apply(const std::string&, const std::function<void()>& fn) {
            stages_.emplace_back(fn);
            return *this;
        }

        PCollection apply(const std::string&, PCollection coll) {
            // pass-through
            return coll;
        }

        Pipeline& apply(const std::string&, const std::function<PCollection()>& fn) {
            results_.push_back(fn());
            return *this;
        }

        template<typename T>
        PCollection apply(const std::string&, StaticQueue& queue) {
            PCollection coll;
            std::optional<int> v;
            while ((v = queue.take())) {
                coll.data.push_back(*v);
            }
            return coll;
        }

        PipelineResult run() {
            // runs all stages in",1
"return activeFlags.getJavaCharacterForFlag(flag);
}

void visit(RegexTree* tree) {
    tree->accept(*this);
}

void visit(const std::vector<RegexTree*>& trees) {
    for (auto tree : trees) {
        visit(tree);
    }
}

void visit(RegexParseResult* regexParseResult) override {
    if (!regexParseResult->hasSyntaxErrors()) {
        activeFlags = regexParseResult->getInitialFlags();
        visit(regexParseResult->getResult());
        after(regexParseResult);
    }
}

protected:
virtual void after(RegexParseResult* regexParseResult) {
    // does nothing unless overridden
}

void visitPlainCharacter(PlainCharacterTree* tree) override {
    // No children to visit
}","```cpp
class RegexBaseVisitor : public RegexVisitor {
protected:
    ActiveFlags activeFlags;

    char getJavaCharacterForFlag(int flag) {
        return activeFlags.getJavaCharacterForFlag(flag);
    }

    void visit(std::shared_ptr<RegexTree> tree) {
        tree->accept(*this);
    }

    void visit(const std::vector<std::shared_ptr<RegexTree>>& trees) {
        for (const auto& tree : trees) {
            visit(tree);
        }
    }

public:
    void visit(RegexParseResult& regexParseResult) override {
        if (!regexParseResult.hasSyntaxErrors()) {
            activeFlags = regexParseResult.getInitialFlags();
            visit(regexParseResult.getResult());
            after(regexParseResult);
        }
    }

protected:
    virtual void after(RegexParseResult& regexParseResult) {
        // does nothing unless overridden
    }

public:
    void visitPlainCharacter(PlainCharacterTree& tree) override {
        // No children to visit
    }
};
```",1
"for (auto& instance : vmsThatAreMissingReport) {
    // Make sure powerState is up to date for missing VMs
    try {
        if (!_instanceDao.isPowerStateUpToDate(instance.getId())) {
            s_logger.warn(""Detected missing VM but power state is outdated, wait for another process report run for VM id: "" + std::to_string(instance.getId()));
            _instanceDao.resetVmPowerStateTracking(instance.getId());
            continue;
        }
    } catch (const CloudRuntimeException& e) {
        s_logger.warn(""Checked for missing powerstate of a none existing vm"", e);
        continue;
    }

    auto vmStateUpdateTime = instance.getPowerStateUpdateTime();
    if (!vmStateUpdateTime) {
        s_logger.warn(""VM state was updated but update time is null?! vm id: "" + std::to_string(instance.getId()));
        vmStateUpdateTime = currentTime;
    }
}","```cpp
for (const auto& instance : vmsThatAreMissingReport) {

    // Make sure powerState is up to date for missing VMs
    try {
        if (!_instanceDao->isPowerStateUpToDate(instance->getId())) {
            s_logger->warn(""Detected missing VM but power state is outdated, wait for another process report run for VM id: "" + std::to_string(instance->getId()));
            _instanceDao->resetVmPowerStateTracking(instance->getId());
            continue;
        }
    } catch (const CloudRuntimeException& e) {
        s_logger->warn(""Checked for missing powerstate of a non-existing vm"", e);
        continue;
    }

    std::optional<std::chrono::system_clock::time_point> vmStateUpdateTime = instance->getPowerStateUpdateTime();
    if (!vmStateUpdateTime.has_value()) {
        s_logger->warn(""VM state was updated but update time is null?! vm id: "" + std::to_string(instance->getId()));
        vmStateUpdateTime = currentTime;
    }
}
```",1
"return function->GetScriptContext()->GetLibrary()->GetUndefined();
}

Var GlobalObject::EntryEnabledDiagnosticsTrace(RecyclableObject* function, CallInfo callInfo, ...)
{
    PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);
    ARGUMENTS(args, callInfo);

    if(function->GetScriptContext()->ShouldPerformRecordOrReplayAction())
    {
        return function->GetScriptContext()->GetLibrary()->GetTrue();
    }
    else
    {
        return function->GetScriptContext()->GetLibrary()->GetFalse();
    }
}

Var GlobalObject::EntryEmitTTDLog(RecyclableObject* function, CallInfo callInfo, ...)
{
    PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);
    ARGUMENTS(args, callInfo);

    Js::JavascriptLibrary* jslib = function->GetScriptContext()->GetLibrary();

    if(args.Info.Count != 2 || !Js::JavascriptString::Is(args[1]))
    {
        return jslib->GetFalse();
    }

    if(function->GetScriptContext()->ShouldPerformReplayAction())
    {
        function->GetScriptContext()->GetThreadContext()->TTDLog->ReplayEmitLogEvent();

        return jslib->GetTrue();
    }

    if(function->GetScriptContext()->ShouldPerformRecordAction())
    {
        Js::JavascriptString* jsString = Js::JavascriptString::FromVar(args[1]);
        function->GetScriptContext()->GetThreadContext()->TTDLog->RecordEmitLogEvent(jsString);

        return jslib->GetTrue();
    }

    return jslib->GetFalse();
}","```cpp
Var GlobalObject::EntryEnabledDiagnosticsTrace(RecyclableObject* function, CallInfo callInfo, ...)
{
    PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);
    ARGUMENTS(args, callInfo);

    if(function->GetScriptContext()->ShouldPerformRecordOrReplayAction())
    {
        return function->GetScriptContext()->GetLibrary()->GetTrue();
    }
    else
    {
        return function->GetScriptContext()->GetLibrary()->GetFalse();
    }
}

Var GlobalObject::EntryEmitTTDLog(RecyclableObject* function, CallInfo callInfo, ...)
{
    PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);
    ARGUMENTS(args, callInfo);

    Js::JavascriptLibrary* jslib = function->GetScriptContext()->GetLibrary();

    if(args.Info.Count != 2 || !Js::JavascriptString::Is(args[1]))
    {
        return jslib->GetFalse();
    }

    if(function->GetScriptContext()->ShouldPerformReplayAction())
    {
        function->GetScriptContext()->GetThreadContext()->TTDLog->ReplayEmitLogEvent();

        return jslib->GetTrue();
    }

    if(function->GetScriptContext()->ShouldPerformRecordAction())
    {
        Js::JavascriptString* jsString = Js::JavascriptString::FromVar(args[1]);
        function->GetScriptContext()->GetThreadContext()->TTDLog->RecordEmitLogEvent(jsString);

        return jslib->GetTrue();
    }

    return jslib->GetFalse();
}
```",1
"auto message = ...; // placeholder for message construction with content-type header ""application/json""
ctRequestChannel.send(message);
auto m = receive(template);
assert(m != nullptr);
assert(std::string(reinterpret_cast<const char*>(m->getBody().data()), m->getBody().size()) == ""\""hello\"""");
assert(m->getMessageProperties().getContentType() == ""application/json"");","auto message = MessageBuilder::withPayload(""hello"")
    .setHeader(AmqpHeaders::CONTENT_TYPE, ""application/json"")
    .build();
ctRequestChannel.send(message);
auto m = receive(template);
assert(m != nullptr);
assert(std::string(reinterpret_cast<const char*>(m->getBody()), m->getBodyLength()) == ""\""hello\"""");
assert(m->getMessageProperties()->getContentType() == ""application/json"");",1
"```cpp
#include <string>
#include <memory>
#include <cassert>
#include <optional>
#include <uuid/uuid.h>

static const std::string MESSAGE_GROUP_KEY_PREFIX = ""MESSAGE_GROUP_"";

// Represents the time when the message has been added to the store.
// @deprecated since 5.0. This constant isn't used any more.
[[deprecated(""since 5.0. This constant isn't used any more."")]]
static const std::string CREATED_DATE = ""CREATED_DATE"";

class Message { 
    // ...
};

class MessageMetadata {
    // ...
};

class MessageHolder {
public:
    std::shared_ptr<Message> getMessage() const;
    std::shared_ptr<MessageMetadata> getMessageMetadata() const;
    // ...
};

std::string MESSAGE_KEY_PREFIX = ""MESSAGE_"";

class MessageStore {
protected:
    virtual void* doRetrieve(const std::string& key) = 0;
public:
    virtual std::shared_ptr<Message> getMessage(const std::string& messageId) {
        assert(!messageId.empty());
        MessageHolder* messageHolder = static_cast<MessageHolder*>(doRetrieve(MESSAGE_KEY_PREFIX + messageId));
        if (messageHolder != nullptr) {
            return messageHolder->getMessage();
        } else {
            return nullptr;
        }
    }

    virtual std::shared_ptr<MessageMetadata> getMessageMetadata(const std::string& messageId) {
        assert(!messageId.empty());
        MessageHolder* messageHolder = static_cast<MessageHolder*>(doRetrieve(MESSAGE_KEY_PREFIX + messageId));
        if (messageHolder != nullptr) {
            return messageHolder->getMessageMetadata();
        } else {
            return nullptr;
        }
    }
};
```","```cpp
#include <string>
#include <memory>
#include <cassert>
#include <optional>
#include <uuid/uuid.h>

class MessageBase {};
class MessageHolder; // Forward declaration
class MessageMetadata;

class AbstractKeyValueMessageStore : public AbstractMessageGroupStore {
protected:
    static constexpr const char* MESSAGE_GROUP_KEY_PREFIX = ""MESSAGE_GROUP_"";
    [[deprecated(""since 5.0. This constant isn't used any more."")]]
    static constexpr const char* CREATED_DATE = ""CREATED_DATE"";

public:
    virtual ~AbstractKeyValueMessageStore() = default;

    std::shared_ptr<MessageBase> getMessage(const uuid_t& messageId) {
        assert(messageId != nullptr); // Or use custom not_null assertion.
        auto key = MESSAGE_KEY_PREFIX + uuidToString(messageId);
        auto raw = doRetrieve(key);
        auto messageHolder = std::dynamic_pointer_cast<MessageHolder>(raw);
        if (messageHolder) {
            return messageHolder->getMessage();
        }
        return nullptr;
    }

    std::shared_ptr<MessageMetadata> getMessageMetadata(const uuid_t& messageId) {
        assert(messageId != nullptr);
        auto key = MESSAGE_KEY_PREFIX + uuidToString(messageId);
        auto raw = doRetrieve(key);
        auto messageHolder = std::dynamic_pointer_cast<MessageHolder>(raw);
        if (messageHolder) {
            return messageHolder->getMessageMetadata();
        }
        return nullptr;
    }

protected:
    static constexpr const char* MESSAGE_KEY_PREFIX = ""MESSAGE_"";

    // These functions should be defined/overridden elsewhere
    virtual std::shared_ptr<void> doRetrieve(const std::string& key) = 0;

    std::string uuidToString(const uuid_t& uuid) const {
        char out[37];
        uuid_unparse(uuid, out);
        return std::string(out);
    }
};
```",1
"void writeState() {
    writeState(nullptr);
}

void writeState(CommandWithArg<bool>* onCompleted) {
    UpdatePrefs(session_.getSessionInfo().getUserState());
    server_.setUserState(
        session_.getSessionInfo().getUserStateLayer().getValues(),
        new ServerRequestCallback<void>()
    );
}","void writeState() {
    writeState(nullptr);
}

void writeState(std::function<void(bool)> onCompleted) {
    UpdatePrefs(session_.getSessionInfo().getUserState());
    server_.setUserState(
        session_.getSessionInfo().getUserStateLayer().getValues(),
        ServerRequestCallback<void>()
    );
}",0
"std::stringstream ss;
ss << ""["" << transportName << ""] [unthrottled] fall through"";
log.debug(ss.str());
return false;

void blockUntilUnthrottled() {
    if (blockLatch == nullptr) {","```cpp
void blockUntilUnthrottled() {
    if (blockLatch == nullptr) {
        return;
    }
    blockLatch->wait();
}
```",0
"dismissAllDialogFragments();
                         });
             } else {
fileListTextView->setVisible(false);
                 builder.negativeText(res().getString(R::string::dialog_ok))
                         .onNegative([this](auto dialog, auto which) { static_cast<MediaCheckDialogListener*>(getActivity())->dismissAllDialogFragments(); });
             }
             return builder
                     .customView(dialogBody, false)
                     .cancelable(false)
                     .show();
         }
         default:","```cpp
switch (someCase) {
    case 126: {
        dismissAllDialogFragments();
        break;
    }
    default: {
        fileListTextView->setVisible(false);
        builder->negativeText(res()->getString(R::dialog_ok))
               ->onNegative([this](auto dialog, auto which) { 
                   static_cast<MediaCheckDialogListener*>(getActivity())->dismissAllDialogFragments(); 
               });
        return builder
                ->customView(dialogBody, false)
                ->cancelable(false)
                ->show();
    }
}
```",1
"void showDataImportFileChoice(
    const FileSystemItem& file,
    const std::function<void()>& onEdit,
    const std::function<void()>& onImport)
{
    ToolbarPopupMenu menu;

    std::string editLabel = AppCommand::formatMenuLabel(
        commands_.renameFile().getImageResource(), ""Open in Editor"", nullptr);
    std::string importLabel = AppCommand::formatMenuLabel(
        StandardIcons::INSTANCE.import_dataset(),
        ""Import Dataset"",
        nullptr);

    menu.addItem(MenuItem(editLabel, true, onEdit));
    menu.addItem(MenuItem(importLabel, true, onImport));

    menu.setPopupPositionAndShow([&menu](int offsetWidth, int offsetHeight) {
        Event event = Event::getCurrentEvent();
        PopupPositioner::setPopupPosition(menu, event.getClientX(), event.getClientY());
    });
}","void showDataImportFileChoice(
    FileSystemItem file,
    const std::function<void()>& onEdit,
    const std::function<void()>& onImport)
{
    ToolbarPopupMenu menu;

    std::string editLabel = AppCommand::formatMenuLabel(
        commands_.renameFile().getImageResource(), ""Open in Editor"", nullptr);
    std::string importLabel = AppCommand::formatMenuLabel(
        StandardIcons::INSTANCE.import_dataset(),
        ""Import Dataset"",
        nullptr);

    menu.addItem(MenuItem(editLabel, true, onEdit));
    menu.addItem(MenuItem(importLabel, true, onImport));

    menu.setPopupPositionAndShow([&menu](int offsetWidth, int offsetHeight) {
        Event* event = Event::getCurrentEvent();
        PopupPositioner::setPopupPosition(menu, event->getClientX(), event->getClientY());
    });
}",1
"return message;
}

Error getError() override {
    return error;
}

std::vector<uint8_t> getMessageAsBytes(MuleContext& muleContext) override {
    try {","Error* getError() override {
    return error;
}",0
"std::vector<std::string> packagesDirectoriesToVerifyCertificates;

std::string getPackagesDirectory() const {
    return packagesDirectories[0];
}

PackageLoader(const std::string& overridePackageDirectory)
    : PackageLoader(std::vector<std::string>{overridePackageDirectory})
{
}

PackageLoader(const std::vector<std::string>& packagesDirectories)
{
    InitializePackageDirectories(packagesDirectories);
}

PackageLoader(const std::vector<std::string>& packagesDirectories, const std::vector<std::string>& packageDirectoriesToVerify)
{
    InitializePackageDirectories(packagesDirectories);
    if (packageDirectoriesToVerify.empty())
        throw std::invalid_argument(""packageDirectoriesToVerify"");
    packagesDirectoriesToVerifyCertificates.insert(
        packagesDirectoriesToVerifyCertificates.end(),
        packageDirectoriesToVerify.begin(),
        packageDirectoriesToVerify.end()
    );
}

void InitializePackageDirectories(const std::vector<std::string>& packagesDirectories)
{
    if (packagesDirectories.empty())
        throw std::invalid_argument(""packagesDirectories"");
    // ...
}","```cpp
#include <vector>
#include <string>
#include <stdexcept>
#include <initializer_list>

class PackageLoader
{
private:
    std::vector<std::string> packagesDirectories;
    std::vector<std::string> packagesDirectoriesToVerifyCertificates;

    void InitializePackageDirectories(const std::vector<std::string>& packagesDirs)
    {
        if (packagesDirs.empty())
            throw std::invalid_argument(""packagesDirectories"");
        packagesDirectories = packagesDirs;
    }

public:
    const std::string& PrimaryPackageDirectory() const
    {
        return packagesDirectories[0];
    }

    PackageLoader(const std::string& overridePackageDirectory)
        : PackageLoader(std::vector<std::string>{overridePackageDirectory})
    {
    }

    PackageLoader(const std::vector<std::string>& packagesDirs)
    {
        InitializePackageDirectories(packagesDirs);
    }

    PackageLoader(const std::vector<std::string>& packagesDirs, const std::vector<std::string>& packageDirsToVerify)
    {
        InitializePackageDirectories(packagesDirs);

        if (packageDirsToVerify.empty())
            throw std::invalid_argument(""packageDirectoriesToVerify"");

        packagesDirectoriesToVerifyCertificates.insert(
            packagesDirectoriesToVerifyCertificates.end(),
            packageDirsToVerify.begin(),
            packageDirsToVerify.end()
        );
    }
};
```",1
"```cpp
void getChars(int start, int end, std::vector<char>& data, int index) {
    if (0 <= start && start <= end && end <= lengthInternal()) {
        getCharsNoBoundChecks(start, end, data, index);
    } else {
        throw std::out_of_range(""String index out of bounds"");
    }
}

void getCharsNoBoundChecks(int start, int end, std::vector<char>& data, int index) {
    if (enableCompression && (compressionFlag == nullptr || count >= 0)) {
        decompress(value, start, data, index, end - start);
    } else {
        decompressedArrayCopy(value, start, data, index, end - start);
    }
}

void getChars(int start, int end, std::vector<uint8_t>& data, int index) {
    if (0 <= start && start <= end && end <= lengthInternal()) {
        getCharsNoBoundChecks(start, end, data, index);
    } else {
        throw std::out_of_range(""String index out of bounds"");
    }
}

void getCharsNoBoundChecks(int start, int end, std::vector<uint8_t>& data, int index) {
    if (enableCompression && (compressionFlag == nullptr || count >= 0)) {
        decompress(value, start, data, index, end - start);
    } else {
        decompressedArrayCopy(value, start, data, index, end - start);
    }
}
```","```cpp
class String {
public:
    void getChars(int start, int end, std::vector<char>& data, int index) const {
        if (0 <= start && start <= end && end <= lengthInternal()) {
            getCharsNoBoundChecks(start, end, data, index);
        } else {
            throw std::out_of_range(""StringIndexOutOfBoundsException"");
        }
    }

    void getCharsNoBoundChecks(int start, int end, std::vector<char>& data, int index) const {
        if (enableCompression && (compressionFlag == nullptr || count >= 0)) {
            decompress(value, start, data, index, end - start);
        } else {
            decompressedArrayCopy(value, start, data, index, end - start);
        }
    }

    void getChars(int start, int end, std::vector<uint8_t>& data, int index) const {
        if (0 <= start && start <= end && end <= lengthInternal()) {
            getCharsNoBoundChecks(start, end, data, index);
        } else {
            throw std::out_of_range(""StringIndexOutOfBoundsException"");
        }
    }

    void getCharsNoBoundChecks(int start, int end, std::vector<uint8_t>& data, int index) const {
        if (enableCompression && (compressionFlag == nullptr || count >= 0)) {
            decompress(value, start, data, index, end - start);
        } else {
            decompressedArrayCopy(value, start, data, index, end - start);
        }
    }

private:
    std::vector<char> value;
    bool enableCompression;
    void* compressionFlag;
    int count;

    int lengthInternal() const;
    void decompress(const std::vector<char>& src, int start, std::vector<char>& dst, int index, int len) const;
    void decompress(const std::vector<char>& src, int start, std::vector<uint8_t>& dst, int index, int len) const;
    void decompressedArrayCopy(const std::vector<char>& src, int start, std::vector<char>& dst, int index, int len) const;
    void decompressedArrayCopy(const std::vector<char>& src, int start, std::vector<uint8_t>& dst, int index, int len) const;
};
```",1
"#include <cassert>
#include <vector>
#include <typeinfo>
#include <string>","#include <cassert>
#include <vector>
#include <algorithm>
#include <typeinfo>",1
"#include ""mule/util/SplashScreen.h""
#include ""mule/config/i18n/CoreMessages.h""
#include ""mule/config/i18n/MessageFactory.h""
#include ""mule/module/launcher/application/NullDeploymentListener.h""

using mule::util::SplashScreen::miniSplash;","#include ""SplashScreen.h""
#include ""CoreMessages.h""
#include ""MessageFactory.h""
#include ""NullDeploymentListener.h""

using namespace mule::module::launcher;
using mule::util::SplashScreen::miniSplash;",0
"```cpp
template<typename T>
class AbstractClusterInvoker : public Invoker<T> {
protected:
    Directory<T>* directory;
    bool availablecheck;

private:
    std::atomic<bool> destroyed{false};
    std::atomic<Invoker<T>*> stickyInvoker{nullptr};
    static Logger logger;

public:
    AbstractClusterInvoker() {}

    AbstractClusterInvoker(Directory<T>* directory)
        : AbstractClusterInvoker(directory, directory->getUrl()) {}

    AbstractClusterInvoker(Directory<T>* directory, const URL& url) {
        if (directory == nullptr) {
            throw std::invalid_argument(""service directory == null"");
        }
        this->directory = directory;
        // sticky: invoker.isAvailable() should always be checked before using when availablecheck is true.
    }
};

template<typename T>
Logger AbstractClusterInvoker<T>::logger = LoggerFactory::getLogger(""AbstractClusterInvoker"");
```","```cpp
#include <atomic>
#include <stdexcept>

template <typename T>
class AbstractClusterInvoker : public Invoker<T> {
protected:
    Directory<T>* directory;
    bool availablecheck;
    std::atomic<bool> destroyed{false};
    Invoker<T>* stickyInvoker = nullptr;

public:
    AbstractClusterInvoker() = default;

    AbstractClusterInvoker(Directory<T>* directory)
        : AbstractClusterInvoker(directory, directory->getUrl()) {}

    AbstractClusterInvoker(Directory<T>* directory, const URL& url) {
        if (directory == nullptr) {
            throw std::invalid_argument(""service directory == nullptr"");
        }
        this->directory = directory;
        // sticky: invoker->isAvailable() should always be checked before using when availablecheck is true.
    }
};
```",0
"{
    elog->LoadPreservedBPInfo();

    if(elog->GetPerservedBPInfoCount() != 0)
    {
        TTD::TTDebuggerSourceLocation** locationList = elog->GetPerservedBPInfoLocationArray();
        for(uint32_t i = 0; i < elog->GetPerservedBPInfoCount(); ++i)
        {
            TTD::TTDebuggerSourceLocation* bpLocation = locationList[i];
            bpLocation->EnsureTopLevelBodyCtrPreInflate();
        }
    }

    if(elog->HasPendingTTDBP())
    {
        elog->EnsureTTDBPInfoTopLevelBodyCtrPreInflate();
    }

    elog->DoSnapshotInflate(snapTime);

    if(elog->GetPerservedBPInfoCount() != 0)
    {
        JsrtDebugManager* jsrtDebugManager = runtime->GetJsrtDebugManager();

        bool bpNotMapped = false;
        TTD_LOG_PTR_ID* ctxIdList = elog->GetPerservedBPInfoScriptArray();
        TTD::TTDebuggerSourceLocation** locationList = elog->GetPerservedBPInfoLocationArray();
        for(uint32_t i = 0; i < elog->GetPerservedBPInfoCount(); ++i)
        {
            TTD::TTDebuggerSourceLocation* bpLocation = locationList[i];
            Js::ScriptContext* bpContext = threadContext->TTDContext->LookupContextForScriptId(ctxIdList[i]);

            // TODO: When we travel back some script may not be loaded (so no place to put BP). We need to update this
            // to do a more extensive maintaining of the preserved breakpoints and put them back as we add new script -- instead of just here.
            // However, for now just print a warn if the BP cannot be resolved.
            bool thisBPNotMapped = (bpContext == nullptr || bpLocation->LoadFunctionBodyIfPossible(bpContext) == nullptr);
            bpNotMapped |= thisBPNotMapped;

            if(!thisBPNotMapped)
            {
                Js::Utf8SourceInfo* utf8SourceInfo = bpLocation->LoadFunctionBodyIfPossible(bpContext)->GetUtf8SourceInfo();

                bool isNewBP = false;
                jsrtDebugManager->SetBreakpointHelper_TTD(bpContext, utf8SourceInfo, bpLocation->GetLine(), bpLocation->GetColumn(), &isNewBP);
            }
        }

        if(bpNotMapped)","JsErrorCode TTDHandleBreakpointInfoAndInflate(TTD::EventLog* elog, int64_t snapTime)
{
    elog->LoadPreservedBPInfo();

    if(elog->GetPerservedBPInfoCount() != 0)
    {
        TTD::TTDebuggerSourceLocation** locationList = elog->GetPerservedBPInfoLocationArray();
        for(uint32_t i = 0; i < elog->GetPerservedBPInfoCount(); ++i)
        {
            TTD::TTDebuggerSourceLocation* bpLocation = locationList[i];
            bpLocation->EnsureTopLevelBodyCtrPreInflate();
        }
    }

    if(elog->HasPendingTTDBP())
    {
        elog->EnsureTTDBPInfoTopLevelBodyCtrPreInflate();
    }

    elog->DoSnapshotInflate(snapTime);

    if(elog->GetPerservedBPInfoCount() != 0)
    {
        JsrtDebugManager* jsrtDebugManager = runtime->GetJsrtDebugManager();

        bool bpNotMapped = false;
        TTD_LOG_PTR_ID* ctxIdList = elog->GetPerservedBPInfoScriptArray();
        TTD::TTDebuggerSourceLocation** locationList = elog->GetPerservedBPInfoLocationArray();
        for(uint32_t i = 0; i < elog->GetPerservedBPInfoCount(); ++i)
        {
            TTD::TTDebuggerSourceLocation* bpLocation = locationList[i];
            Js::ScriptContext* bpContext = threadContext->TTDContext->LookupContextForScriptId(ctxIdList[i]);

            bool thisBPNotMapped = (bpContext == nullptr || bpLocation->LoadFunctionBodyIfPossible(bpContext) == nullptr);
            bpNotMapped |= thisBPNotMapped;

            if(!thisBPNotMapped)
            {
                Js::Utf8SourceInfo* utf8SourceInfo = bpLocation->LoadFunctionBodyIfPossible(bpContext)->GetUtf8SourceInfo();

                bool isNewBP = false;
                jsrtDebugManager->SetBreakpointHelper_TTD(bpContext, utf8SourceInfo, bpLocation->GetLine(), bpLocation->GetColumn(), &isNewBP);
            }
        }

        if(bpNotMapped)
        {
            fprintf(stderr, ""Could not map a breakpoint after inflate -- some breakpoints may be disabled.\n"");
        }
    }
    elog->UnLoadPreservedBPInfo();

    return JsNoError;
}",1
"PipelineOptions* pipelineOptions,
BeamFnDataClient* beamFnDataClient,
BeamFnStateClient* beamFnStateClient,
BeamFnTimerClient* beamFnTimerClient,
const std::string& pTransformId,
const PTransform& pTransform,
std::function<std::string()> processBundleInstructionId,","void ProcessBundleHandlerTest(
    PipelineOptions pipelineOptions,
    BeamFnDataClient beamFnDataClient,
    BeamFnStateClient beamFnStateClient,
    BeamFnTimerClient beamFnTimerClient,
    std::string pTransformId,
    PTransform pTransform,
    std::function<std::string()> processBundleInstructionId
)",1
"```cpp
void submitAfterShutdownSameExecutor() {
    executor1.shutdown();
    assertRejected(executor1, SUBMIT_EMPTY_RUNNABLE);
}

void submitAfterShutdownOtherExecutor() {
    executor1.shutdown();
    std::counting_semaphore<1> latch(0);
}
```","void submitAfterShutdownSameExecutor() {
    executor1.shutdown();

    assertRejected(executor1, SUBMIT_EMPTY_RUNNABLE);
}

void submitAfterShutdownOtherExecutor() {
    executor1.shutdown();

    std::latch latch(1);
}",1
"#include <atomic>
#include <type_traits>","#include <atomic>
#include <type_traits>
#include <functional>
#include <cstddef>

class HttpServletRequest {};
class HttpServletResponse {};

template<typename T>
class ApplicationListener {};

class ContextRefreshedEvent {};

namespace org {
namespace springframework {
namespace util {
class ObjectUtils {};
class ReflectionUtils {};
}
namespace web {
class HttpRequestHandler {};
}
}
}",0
"```cpp
#include <vector>
#include <algorithm>
#include <cassert>
#include <functional>

constexpr int ALL_NUMBERS = /* appropriate value */;
constexpr int ALL_PETS = /* appropriate value */;
constexpr int FAILED_ADOPTION_COUNT = /* appropriate value */;

class MuleException : public std::exception {
public:
    MuleException(const char* msg) : std::exception(msg) {}
};

class Startable {
public:
    virtual void start() = 0;
    virtual ~Startable() = default;
};

class CoreEvent {
    // Define appropriate member variables and functions
};

// Mock equivalents for check, checkNot, and assertThat/hasSize
inline void check(const std::function<bool()>& condition) {
    while (!condition()) {/* polling simulation */}
}

inline void checkNot(const std::function<bool()>& condition) {
    while (condition()) {/* polling simulation */}
}

template<typename T>
inline void assertThat(const std::vector<T>& vec, size_t expectedSize) {
    assert(vec.size() == expectedSize);
}
```","#include <vector>
#include <algorithm>
#include <cassert>
#include <exception>

using namespace std;

const vector<int> ALL_NUMBERS = {/* ... */};
const vector<string> ALL_PETS = {/* ... */};
const int FAILED_ADOPTION_COUNT = /* ... */;

class MuleException : public std::exception {
  // implementation ...
};

class Startable {
public:
    virtual void start() = 0;
    virtual ~Startable() = default;
};

class CoreEvent {
  // implementation ...
};

// Helpers similar to PollingProber's check and checkNot
template<class Func>
void check(Func condition) {
    // implementation for polling or waiting until condition is true
    assert(condition());
}

template<class Func>
void checkNot(Func condition) {
    // implementation for polling or waiting until condition is false
    assert(!condition());
}",0
"if (file.getName().find(' ') != std::string::npos)
{
    globalDisplay_.showErrorMessage(
        constants_.fireCompilePdfEventErrorCaption(),
        constants_.fireCompilePdfEventErrorMessage(file.getName())
    );
    return;
}","if (file.getName().find(' ') != std::string::npos)
{
    globalDisplay_->showErrorMessage(
        constants_.fireCompilePdfEventErrorCaption(),
        constants_.fireCompilePdfEventErrorMessage(file.getName())
    );
    return;
}",0
"}
 
template<typename T>
std::optional<DslElementModel<T>> create(const ComponentAst& configuration) {
    return createIdentifiedElement(configuration);
}
 
DslElementModel createIdentifiedElement(const ComponentAst& configuration) {
    const ComponentIdentifier& identifier = configuration.getIdentifier();

    std::optional<std::pair<ExtensionModel, DslSyntaxResolver>> entry =","template<typename T>
std::optional<DslElementModel<T>> create(const ComponentAst& configuration) {
    return createIdentifiedElement(configuration);
}

DslElementModel createIdentifiedElement(const ComponentAst& configuration) {
    const ComponentIdentifier& identifier = configuration.getIdentifier();

    std::optional<std::pair<ExtensionModel, DslSyntaxResolver>> entry =
        // ... (rest of the method implementation)
        ;
}",0
"void shutdownScheduler() {
    if (executor != nullptr) {
        executor->stop();
        executor = nullptr;
    }
}","void shutdownScheduler() {
    if (executor != nullptr) {
        executor->stop();
        executor = nullptr;
    }
}",0
"wbFilename->addSelectionListener(
    new SelectionAdapterFileDialogTextVar(
        log,
        wFilename,
        transMeta,
        SelectionAdapterOptions(
            SelectionOperation::SAVE_TO,
            { FilterType::XLS, FilterType::XLSX, FilterType::ALL },
            FilterType::XLS,
            { ProviderFilterType::DEFAULT }
        )
    )
);

wbTemplateFilename->addSelectionListener(
    new SelectionAdapterFileDialogTextVar(
        log,
        wTemplateFilename,
        transMeta,
        SelectionAdapterOptions(
            SelectionOperation::FILE,
            { FilterType::XLS, FilterType::XLSX, FilterType::ALL },
            FilterType::XLS,
            { ProviderFilterType::DEFAULT }
        )
    )
);","wbFilename.addSelectionListener(
    new SelectionAdapterFileDialogTextVar(
        log,
        wFilename,
        transMeta,
        SelectionAdapterOptions{
            SelectionOperation::SAVE_TO,
            { FilterType::XLS, FilterType::XLSX, FilterType::ALL },
            FilterType::XLS,
            { ProviderFilterType::DEFAULT }
        }
    )
);

wbTemplateFilename.addSelectionListener(
    new SelectionAdapterFileDialogTextVar(
        log,
        wTemplateFilename,
        transMeta,
        SelectionAdapterOptions{
            SelectionOperation::FILE,
            { FilterType::XLS, FilterType::XLSX, FilterType::ALL },
            FilterType::XLS,
            { ProviderFilterType::DEFAULT }
        }
    )
);",1
"view_.setStopSearchButtonVisible(false);
}

std::string currentFindHandle_;
void stopReplace() {
    if (!currentFindHandle_.empty()) {
        server_.stopReplace(currentFindHandle_, std::make_unique<VoidServerRequestCallback>());
        currentFindHandle_.clear();
        view_.setStopReplaceButtonVisible(false);
        view_.hideProgress();
    }
}

std::string currentFindHandle_;
FindInFilesDialog::State dialogState_;

Display& view_;
FindInFilesServerOperations& server_;
Session& session_;
WorkbenchContext& workbenchContext_;
Commands& commands_;
EventBus* events_;

constexpr const char* GROUP_FIND_IN_FILES = ""find-in-files"";
constexpr const char* KEY_DIALOG_STATE = ""dialog-state"";

GlobalDisplay* globalDisplay_ = RStudioGinjector::INSTANCE().getGlobalDisplay();
}","```cpp
class FindOutputPresenter : public BasePresenter
{
public:
    void stopReplace()
    {
        if (!currentFindHandle_.empty())
        {
            server_->stopReplace(currentFindHandle_, new VoidServerRequestCallback());
            currentFindHandle_.clear();
            view_->setStopReplaceButtonVisible(false);
            view_->hideProgress();
        }
    }

private:
    std::string currentFindHandle_;
    FindInFilesDialog::State dialogState_;

    std::shared_ptr<Display> view_;
    std::shared_ptr<FindInFilesServerOperations> server_;
    std::shared_ptr<Session> session_;
    std::shared_ptr<WorkbenchContext> workbenchContext_;
    std::shared_ptr<Commands> commands_;
    std::shared_ptr<EventBus> events_;

    static constexpr const char* GROUP_FIND_IN_FILES = ""find-in-files"";
    static constexpr const char* KEY_DIALOG_STATE = ""dialog-state"";
    GlobalDisplay* globalDisplay_ = RStudioGinjector::INSTANCE->getGlobalDisplay();
};
```",1
"}
std::vector<long> findOfferingIdsByDomainIds(const std::vector<long>& domainIds) override {
    std::vector<std::string> dIds;
    dIds.reserve(domainIds.size());
    for (auto s : domainIds) {
        dIds.push_back(std::to_string(s));
    }

    auto sb = createSearchBuilder<long>();
    sb.selectFields(sb.entity().getResourceId());
    sb.and_(""name"", sb.entity().getName(), Op::EQ);
    sb.and_().op(""value"", sb.entity().getValue(), Op::IN);
    sb.or_(""valueNull"", sb.entity().getValue(), Op::NULL);
    sb.cp();
    sb.done();

    auto sc = sb.create();
    sc.setParameters(""name"", ""domainid"");
    sc.setParameters(""value"", dIds);

    return customSearch(sc, nullptr);
}","std::vector<long> findOfferingIdsByDomainIds(const std::vector<long>& domainIds) override {
    std::vector<std::string> dIds;
    dIds.reserve(domainIds.size());
    for (auto s : domainIds) {
        dIds.push_back(std::to_string(s));
    }

    auto sb = createSearchBuilder<long>();
    sb.selectFields(sb.entity().getResourceId());
    sb.and_(""name"", sb.entity().getName(), Op::EQ);
    sb.and_().op(""value"", sb.entity().getValue(), Op::IN);
    sb.or_(""valueNull"", sb.entity().getValue(), Op::Null);
    sb.cp();
    sb.done();

    auto sc = sb.create();
    sc.setParameters(""name"", ""domainid"");
    sc.setParameters(""value"", dIds);

    return customSearch(sc, nullptr);
}",1
"#include <chrono>
#include <string>","#include <string>
#include <chrono>",0
"```cpp
bool installed() const {
    bool has_prefix = std::filesystem::is_directory(this->prefix());
    bool db_says_installed = false;
    try {
        auto rec = spack::store::db::get_record(this->spec());
        db_says_installed = rec.installed();
    } catch (const std::out_of_range&) {
        db_says_installed = false;
    }
    return has_prefix && db_says_installed;
}

std::filesystem::path prefix() const;
```","```cpp
#include <filesystem>

class PackageBase {
public:
    PackageBase(const std::string& spec, const std::string& prefix)
        : spec_(spec), prefix_(prefix) {}

    bool installed() const {
        bool has_prefix = std::filesystem::is_directory(prefix_);
        bool db_says_installed = false;
        try {
            const auto& rec = spack::store::db::get_record(spec_);
            db_says_installed = rec.installed;
        } catch (const std::out_of_range&) {
            db_says_installed = false;
        }
        return has_prefix && db_says_installed;
    }

    const std::string& prefix() const {
        return prefix_;
    }

private:
    std::string spec_;
    std::string prefix_;
};
```",1
"#ifdef DEBUG
    gcRootSymbolNames.push_back(""__thisptr"");
#endif
    if (stackFrame.ThisPtr.IsReferenceType)
        gcRoots.push_back(stackFrame.ThisPtr);
    blockId = stackFrame.FunctionCallerBlock;
    currentFramePointer = stackFrame.FramePointer;
#ifdef DEBUG
#endif
    if (RX.IsReferenceType)
        gcRoots.push_back(RX);
#if TRACING_GC
    for (const auto& r : runtimeCore.ReplicationRoots) {
        if (r.IsReferenceType)
            gcRoots.push_back(r);
    }
    for (const auto& s : rmem.Stack) {
        if (s.IsReferenceType)
            gcRoots.push_back(s);
    }
#endif
    return gcRoots;
}","#if DEBUG
    gcRootSymbolNames.push_back(""__thisptr"");
#endif
    if (stackFrame.ThisPtr.IsReferenceType)
        gcRoots.push_back(stackFrame.ThisPtr);
    blockId = stackFrame.FunctionCallerBlock;
    currentFramePointer = stackFrame.FramePointer;
}
#endif
if (RX.IsReferenceType)
    gcRoots.push_back(RX);

#if TRACING_GC
    for (const auto& r : runtimeCore.ReplicationRoots)
        if (r.IsReferenceType)
            gcRoots.push_back(r);
    for (const auto& s : rmem.Stack)
        if (s.IsReferenceType)
            gcRoots.push_back(s);
#endif

    return gcRoots;
}",1
"class StagingSessionToken {
public:
    std::string sessionId;
    std::string basePath;
};","class StagingSessionToken {
public:
    std::string sessionId;
    std::string basePath;
};",1
"#include ""HoodieRecord.h""
#include ""HoodieRecordLocation.h""
#include ""HoodieRecordPayload.h""
#include ""HoodieWriteStat.h""
#include ""RuntimeStats.h""
#include ""IOType.h""
#include ""HoodieLogFormat.h""","#include ""HoodiePartitionMetadata.h""
#include ""HoodieRecord.h""
#include ""HoodieRecordLocation.h""
#include ""HoodieRecordPayload.h""
#include ""HoodieWriteStatRuntimeStats.h""
#include ""IOType.h""
#include ""HoodieLogFormat.h""",0
"return recordsWithLocation
    | std::views::filter([](const auto& v1) { return !v1.isCurrentLocationKnown(); });

/**
 * Main API to run bootstrap to hudi.
 */
void bootstrap(std::optional<std::map<std::string, std::string>> extraMetadata) {
    if (rollbackPending) {
        rollBackPendingBootstrap();
    }
    auto table = getTableAndInitCtx(WriteOperationType::UPSERT);
    table.bootstrap(jsc, extraMetadata);
}

/**
 * Main API to rollback pending bootstrap.
 */
protected:
void rollBackPendingBootstrap() {
    LOG.info(""Rolling back pending bootstrap if present"");
    auto table = HoodieTable<T>::create(config, hadoopConf);
    auto inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();
    auto instant = Option::fromJavaOptional(
        inflightTimeline.getReverseOrderedInstants()
            | std::views::transform([](const HoodieInstant& i){ return i.getTimestamp(); })
            | std::views::take(1)
    );
    if (instant.isPresent() &&
        HoodieTimeline::compareTimestamps(
            instant.get(), HoodieTimeline::LESSER_THAN_OR_EQUALS,
            HoodieTimeline::FULL_BOOTSTRAP_INSTANT_TS))
    {
        LOG.info(""Found pending bootstrap instants. Rolling them back"");
        table.rollbackBootstrap(jsc, HoodieActiveTimeline::createNewInstantTime());
        LOG.info(""Finished rolling back pending bootstrap"");
    }
}","```cpp
void bootstrap(std::optional<std::map<std::string, std::string>> extraMetadata) {
    if (rollbackPending) {
        rollBackPendingBootstrap();
    }
    auto table = getTableAndInitCtx(WriteOperationType::UPSERT);
    table->bootstrap(jsc, extraMetadata);
}

protected:
void rollBackPendingBootstrap() {
    LOG.info(""Rolling back pending bootstrap if present"");
    auto table = HoodieTable<T>::create(config, hadoopConf);
    auto inflightTimeline = table->getMetaClient()->getCommitsTimeline().filterPendingExcludingCompaction();
    auto instantOpt = Option::fromJavaOptional(
        inflightTimeline.getReverseOrderedInstants()
            .transform([](const HoodieInstant& inst){ return inst.getTimestamp(); })
            .findFirst()
    );
    if (instantOpt.isPresent() &&
        HoodieTimeline::compareTimestamps(instantOpt.get(), HoodieTimeline::LESSER_THAN_OR_EQUALS,
                                          HoodieTimeline::FULL_BOOTSTRAP_INSTANT_TS)) {
        LOG.info(""Found pending bootstrap instants. Rolling them back"");
        table->rollbackBootstrap(jsc, HoodieActiveTimeline::createNewInstantTime());
        LOG.info(""Finished rolling back pending bootstrap"");
    }
}
```",1
"```cpp
#include <fstream>
#include <string>

File handleStringMessage(const std::string& content, File originalFile, File tempFile, const File& resultFile) {
    const File fileToWriteTo = this->determineFileToWrite(resultFile, tempFile);

    const FileState state = getFileState(fileToWriteTo, true);

    const bool append = FileExistsMode::APPEND == this->fileExistsMode;

    WhileLockedProcessor whileLockedProcessor(this->lockRegistry, fileToWriteTo.getAbsolutePath(), [&]() {
        std::ostream* writer = nullptr;
        std::ofstream localWriter;
        if (state.writer) {
            writer = state.writer;
        } else {
            localWriter.open(fileToWriteTo.getPath(), append ? std::ios::app : std::ios::out);
            localWriter.imbue(this->charset);
            writer = &localWriter;
        }
        writer->write(content.c_str(), content.size());
        if (FileWritingMessageHandler::appendNewLine) {
            (*writer) << '\n';
        }
    });

    whileLockedProcessor.process();

    return fileToWriteTo;
}
```","```cpp
#include <fstream>
#include <string>

File handleStringMessage(const std::string& content, File originalFile, File tempFile, const File& resultFile) {
    const File fileToWriteTo = this->determineFileToWrite(resultFile, tempFile);

    const FileState* state = getFileState(fileToWriteTo, true);

    const bool append = (this->fileExistsMode == FileExistsMode::APPEND);

    WhileLockedProcessor whileLockedProcessor(
        this->lockRegistry, fileToWriteTo.getAbsolutePath(),
        [&, content, append, state, this, &fileToWriteTo]() {
            std::unique_ptr<std::ofstream> writerPtr;
            std::ofstream* writer = nullptr;

            if (state != nullptr && state->writer) {
                writer = state->writer;
            } else {
                writerPtr = createWriter(fileToWriteTo, append);
                writer = writerPtr.get();
            }

            writer->write(content.c_str(), content.size());
            if (this->appendNewLine) {
                *writer << std::endl;
            }
        }
    );

    whileLockedProcessor.process();
    return fileToWriteTo;
}
```",0
"#include ""dubbo/common/Constants.h""
#include ""dubbo/common/URL.h""
#include ""dubbo/rpc/Invocation.h""
#include ""dubbo/rpc/Invoker.h""
#include ""dubbo/rpc/cluster/LoadBalance.h""","#include ""Constants.h""
#include ""URL.h""
#include ""Invocation.h""
#include ""Invoker.h""
#include ""LoadBalance.h""",0
"auto allocs_when_invalid = counting_allocations([&]{ return type.valid(invalid); });
assert(allocs_when_invalid == 0);

{
    auto type = T::Array<std::string>();
    auto msg = check_error_message_for_obj(type, TestEnumerable());
    assert(msg == ""Expected type T::Array[String], got Opus::Types::Test::TypesTest::TestEnumerable"");
}","```cpp
#include <gtest/gtest.h>
#include <string>
#include <vector>
#include <typeinfo>

class TestEnumerable {};

template<typename T>
std::string check_error_message_for_obj(const std::vector<std::string>& /*type*/, const T& obj) {
    return ""Expected type T::Array[String], got "" + std::string(typeid(obj).name());
}

TEST(OpusTypesTest, ErrorForUnrelatedEnumerable) {
    std::vector<std::string> type;
    std::string msg = check_error_message_for_obj(type, TestEnumerable());
    ASSERT_EQ(""Expected type T::Array[String], got TestEnumerable"", msg);
}
```",1
"#include <map>
#include <string>
#include <vector>
#include <algorithm>

inline std::map<std::string, std::string> singletonMap(const std::string& key, const std::string& value) {
    return {{key, value}};
}

template <typename Container, typename T>
bool hasItem(const Container& container, const T& item) {
    return std::find(container.begin(), container.end(), item) != container.end();
}

template <typename Container, typename... Ts>
bool hasItems(const Container& container, const Ts&... items) {
    return (... && hasItem(container, items));
}

template <typename Container>
auto hasSize(const Container& container, size_t expected) {
    return container.size() == expected;
}","#include <algorithm>
#include <vector>
#include <map>
#include <string>
#include <gtest/gtest.h>

using namespace std;",0
"#include <string>

class HttpListenerRegistry {};
class HttpServerManager {};

class YourClassName {
public:
    static constexpr const char* HTTP_LISTENER_CONNECTION_MANAGER = ""_httpListenerConnectionManager"";
private:
    static constexpr const char* UNKNOWN_APP_NAME = ""UNKNOWN-APP"";

    HttpListenerRegistry httpListenerRegistry;
    HttpServerManager* httpServerManager = nullptr;
};","```cpp
class HttpListenerConnectionManager : public Initialisable, public Disposable
{
public:
    static constexpr const char* HTTP_LISTENER_CONNECTION_MANAGER = ""_httpListenerConnectionManager"";
private:
    static constexpr const char* UNKNOWN_APP_NAME = ""UNKNOWN-APP"";

    HttpListenerRegistry httpListenerRegistry = HttpListenerRegistry();
    HttpServerManager* httpServerManager;
};
```",1
"for (auto i : JUMP_INSN) {
    Label jumpLabel;
    ins.visitJumpInsn(i, jumpLabel);
    ins.visitLabel(jumpLabel);
}

ins.visitLdcInsn(""a"");","std::for_each(JUMP_INSN.begin(), JUMP_INSN.end(), [&](auto i) {
    Label jumpLabel;
    ins.visitJumpInsn(i, jumpLabel);
    ins.visitLabel(jumpLabel);
});

ins.visitLdcInsn(""a"");",0
"}
 
void
LowererMD::ChangeToWriteBarrierAssign(IR::Instr * assignInstr, const Func* func)
{
#ifdef RECYCLER_WRITE_BARRIER_JIT
    IR::Opnd* dest = assignInstr->GetDst();

    auto threadContextInfo = func->GetTopFunc()->GetThreadContextInfo();
    void* destAddr = nullptr;
    bool isPossibleBarrieredDest = false;

    if (TySize[dest->GetType()] == sizeof(void*))
    {
        if (dest->IsIndirOpnd())
        {
            Assert(!dest->AsIndirOpnd()->HasAddrKind());
            isPossibleBarrieredDest = true;
        }
        else if (dest->IsMemRefOpnd())
        {
            destAddr = (void*)dest->AsMemRefOpnd()->GetMemLoc();
            isPossibleBarrieredDest =
                destAddr != nullptr &&
                ((intptr_t)destAddr % sizeof(void*)) == 0 &&
                destAddr != (void*)threadContextInfo->GetImplicitCallFlagsAddr() &&
                destAddr != (void*)threadContextInfo->GetDisableImplicitFlagsAddr() &&
                destAddr != (void*)threadContextInfo->GetBailOutRegisterSaveSpaceAddr();

            if (isPossibleBarrieredDest)
            {
                Assert(Recycler::WBCheckIsRecyclerAddress((char*)destAddr));
            }
        }
    }
#endif

    ChangeToAssign(assignInstr);

#ifdef RECYCLER_WRITE_BARRIER_JIT
    if (isPossibleBarrieredDest
        && assignInstr->m_opcode == Js::OpCode::MOV
        && assignInstr->GetSrc1()->IsWriteBarrierTriggerableValue())
    {
        func->GetTopFunc()->m_lowerer->GetLowererMD()->GenerateWriteBarrier(assignInstr);
    }
#endif
}","void LowererMD::ChangeToWriteBarrierAssign(IR::Instr* assignInstr, const Func* func)
{
#ifdef RECYCLER_WRITE_BARRIER_JIT
    IR::Opnd* dest = assignInstr->GetDst();

    auto threadContextInfo = func->GetTopFunc()->GetThreadContextInfo();
    void* destAddr = nullptr;
    bool isPossibleBarrieredDest = false;

    if (TySize[dest->GetType()] == sizeof(void*))
    {
        if (dest->IsIndirOpnd())
        {
            Assert(!dest->AsIndirOpnd()->HasAddrKind());
            isPossibleBarrieredDest = true;
        }
        else if (dest->IsMemRefOpnd())
        {
            destAddr = reinterpret_cast<void*>(dest->AsMemRefOpnd()->GetMemLoc());
            isPossibleBarrieredDest = destAddr != nullptr
                && (reinterpret_cast<intptr_t>(destAddr) % sizeof(void*)) == 0
                && destAddr != reinterpret_cast<void*>(threadContextInfo->GetImplicitCallFlagsAddr())
                && destAddr != reinterpret_cast<void*>(threadContextInfo->GetDisableImplicitFlagsAddr())
                && destAddr != reinterpret_cast<void*>(threadContextInfo->GetBailOutRegisterSaveSpaceAddr());

            if (isPossibleBarrieredDest)
            {
                Assert(Recycler::WBCheckIsRecyclerAddress(static_cast<const char*>(destAddr)));
            }
        }
    }
#endif

    ChangeToAssign(assignInstr);

#ifdef RECYCLER_WRITE_BARRIER_JIT
    if (isPossibleBarrieredDest
        && assignInstr->m_opcode == Js::OpCode::MOV
        && assignInstr->GetSrc1()->IsWriteBarrierTriggerableValue())
    {
        func->GetTopFunc()->m_lowerer->GetLowererMD()->GenerateWriteBarrier(assignInstr);
    }
#endif
}",1
"class ErrorMonitorMessagesHandler : public JobMessagesHandler {
private:
    DataflowPipelineJob* job;
    JobMessagesHandler* messageHandler;
    std::string errorMessage;
    std::atomic<bool> hasSeenError;

public:
    ErrorMonitorMessagesHandler(
        DataflowPipelineJob* job, JobMessagesHandler* messageHandler)
        : job(job),
          messageHandler(messageHandler),
          errorMessage(),
          hasSeenError(false) {}
};","class ErrorMonitorMessagesHandler : public JobMessagesHandler {
private:
    DataflowPipelineJob* job;
    JobMessagesHandler* messageHandler;
    std::stringstream errorMessage;
    std::atomic<bool> hasSeenError;

public:
    ErrorMonitorMessagesHandler(DataflowPipelineJob* job, JobMessagesHandler* messageHandler)
        : job(job), messageHandler(messageHandler), hasSeenError(false) {}

    // Implement other required methods...
};",1
"if (bndFile.getAbsolutePath().find(base.getAbsolutePath()) != 0)
    return nullptr;

ProjectBuilder* pb = getBuilder(nullptr);
bool close = true;
try {
    for (auto* b : pb->getSubBuilders()) {
        std::filesystem::path propertiesFile = b->getPropertiesFile();
        if (!propertiesFile.empty()) {
            if (std::filesystem::canonical(propertiesFile) == bndFile) {
                if (b == pb) {
                    close = false;
                } else {
                    pb->removeClose(b);
                }
                return b;
            }
        }
    }
    return nullptr;
} catch (...) {
    if (close) {
        pb->close();
    }
    throw;
}
if (close) {
    pb->close();
}
return nullptr;","```cpp
ProjectBuilder* pb = getBuilder(nullptr);
bool close = true;
try {
    for (auto* b : pb->getSubBuilders()) {
        std::filesystem::path propertiesFile = b->getPropertiesFile();
        if (!propertiesFile.empty()) {
            if (std::filesystem::canonical(propertiesFile) == bndFile) {
                if (b == pb) {
                    close = false;
                } else {
                    pb->removeClose(b);
                }
                return b;
            }
        }
    }
    return nullptr;
} catch(...) {
    throw;
} 
if (close) {
    pb->close();
}
```",1
"#include ""org/apache/dubbo/registry/Constants.h""
#include ""org/apache/dubbo/remoting/Constants.h""

using org::apache::dubbo::registry::CONFIGURATORS_SUFFIX;
using org::apache::dubbo::registry::CONSUMER_PROTOCOL;
using org::apache::dubbo::registry::DEFAULT_REGISTRY;
using org::apache::dubbo::registry::DEFAULT_REGISTRY_RETRY_PERIOD;
using org::apache::dubbo::registry::PROVIDER_PROTOCOL;
using org::apache::dubbo::registry::REGISTER_IP_KEY;
using org::apache::dubbo::registry::REGISTER_KEY;
using org::apache::dubbo::registry::REGISTRY_RETRY_PERIOD_KEY;
using org::apache::dubbo::registry::SIMPLIFIED_KEY;
using org::apache::dubbo::remoting::BIND_IP_KEY;
using org::apache::dubbo::remoting::BIND_PORT_KEY;","#include ""org/apache/dubbo/common/utils/UrlUtils.h""
#include ""org/apache/dubbo/registry/Constants.h""
#include ""org/apache/dubbo/remoting/Constants.h""

using org::apache::dubbo::common::utils::UrlUtils::classifyUrls;
using org::apache::dubbo::registry::Constants::CONFIGURATORS_SUFFIX;
using org::apache::dubbo::registry::Constants::CONSUMER_PROTOCOL;
using org::apache::dubbo::registry::Constants::DEFAULT_REGISTRY;
using org::apache::dubbo::registry::Constants::DEFAULT_REGISTRY_RETRY_PERIOD;
using org::apache::dubbo::registry::Constants::PROVIDER_PROTOCOL;
using org::apache::dubbo::registry::Constants::REGISTER_IP_KEY;
using org::apache::dubbo::registry::Constants::REGISTER_KEY;
using org::apache::dubbo::registry::Constants::REGISTRY_RETRY_PERIOD_KEY;
using org::apache::dubbo::registry::Constants::SIMPLIFIED_KEY;
using org::apache::dubbo::remoting::Constants::BIND_IP_KEY;
using org::apache::dubbo::remoting::Constants::BIND_PORT_KEY;",0
"```cpp
#include <string>
#include <vector>
#include <ctime>
#include <iomanip>
#include <sstream>

class Logger {
public:
    void debug(const std::string& msg) {
        // implement logging
    }
};

class HarvestSummary {
public:
    int recordsUpdated = 0;
    std::vector<std::string> updatedMetadata;
};

class DataMan {
public:
    std::string setUUID(const std::string& outputSchema, const std::string& recUuid, const std::string& templateStr) {
        // implementation
        return templateStr;
    }
};

class Element {
    // implementation
};

Logger log;
DataMan dataMan;
HarvestSummary harvestSummary;

void update(const std::string& id, Element templateElem, const std::string* title, bool isSubtemplate) {
    std::ostringstream oss;
    time_t now = time(0);
    tm* gmtm = gmtime(&now);
    oss << std::put_time(gmtm, ""%Y-%m-%dT%H:%M:%S"");
    std::string date = oss.str();
    // implementation
}

// somewhere in the code:
log.debug(""\t- Attempting to update metadata record "" + id + "" with links"");
template = dataMan.setUUID(params.outputSchema, recUuid, template);
update(id, template, nullptr, false);
harvestSummary.recordsUpdated++;
harvestSummary.updatedMetadata.push_back(recUuid);
```","```cpp
#include <string>
#include <vector>
#include <set>
#include <chrono>
#include <iomanip>
#include <sstream>

class HarvestSummary {
public:
    int recordsUpdated = 0;
    std::set<std::string> updatedMetadata;
};

class DataMan {
public:
    // Placeholder method. Replace with actual implementation.
    std::string setUUID(const std::string& outputSchema, const std::string& recUuid, const std::string& templateStr) {
        // ...
        return templateStr;
    }
};

class FragmentHarvester /* : public BaseAligner */ {
protected:
    DataMan dataMan;
    HarvestSummary harvestSummary;

    void update(const std::string& id, const std::string& templateStr, const std::string* title, bool isSubtemplate) {
        auto now = std::chrono::system_clock::now();
        auto in_time_t = std::chrono::system_clock::to_time_t(now);
        std::stringstream ss;
        ss << std::put_time(std::gmtime(&in_time_t), ""%Y-%m-%dT%H:%M:%S"");
        std::string date = ss.str();
        // ...
    }

    void someFunction(const std::string& id, const std::string& recUuid, const std::string& templateStr, const std::string& outputSchema) {
        // log.debug(""\t- Attempting to update metadata record "" + id + "" with links"");
        std::string updatedTemplate = dataMan.setUUID(outputSchema, recUuid, templateStr);
        update(id, updatedTemplate, nullptr, false);
        harvestSummary.recordsUpdated++;
        harvestSummary.updatedMetadata.insert(recUuid);
    }
};
```",0
"#include ""Stoppable.h""
#include ""Registry.h""
#include ""CoreMessages.h""
// [DEL] #include ""ContainerManagedLifecyclePhase.h""
#include ""MuleContextDisposePhase.h""
#include ""MuleContextInitialisePhase.h""
#include ""MuleContextStartPhase.h""","#include ""mule/api/lifecycle/Startable.h""
#include ""mule/api/lifecycle/Stoppable.h""
#include ""mule/api/registry/Registry.h""
#include ""mule/config/i18n/CoreMessages.h""
#include ""mule/lifecycle/phases/MuleContextDisposePhase.h""
#include ""mule/lifecycle/phases/MuleContextInitialisePhase.h""
#include ""mule/lifecycle/phases/MuleContextStartPhase.h""",0
"auto morDs = HypervisorHostHelper::findDatastoreWithBackwardsCompatibility(hyperHost, cmd.getStorageId());

if (morDs != nullptr) {
    long long capacity = 0;
    long long free = 0;
    if (cmd.getPooltype() == StoragePoolType::DatastoreCluster) {
        StoragepodMO datastoreClusterMo(getServiceContext(), morDs);
        auto summary = datastoreClusterMo.getDatastoreClusterSummary();
        capacity = summary.getCapacity();
        free = summary.getFreeSpace();
    } else {
        DatastoreMO datastoreMo(context, morDs);
        auto summary = datastoreMo.getDatastoreSummary();
        capacity = summary.getCapacity();
        free = summary.getFreeSpace();
    }

    long long used = capacity - free;

    if (s_logger.isDebugEnabled()) {","ManagedObjectReference morDs = HypervisorHostHelper::findDatastoreWithBackwardsCompatibility(hyperHost, cmd.getStorageId());

if (morDs != nullptr) {
    int64_t capacity = 0;
    int64_t free = 0;
    if (cmd.getPooltype() == StoragePoolType::DatastoreCluster) {
        StoragepodMO datastoreClusterMo(getServiceContext(), morDs);
        StoragePodSummary summary = datastoreClusterMo.getDatastoreClusterSummary();
        capacity = summary.getCapacity();
        free = summary.getFreeSpace();
    } else {
        DatastoreMO datastoreMo(context, morDs);
        DatastoreSummary summary = datastoreMo.getDatastoreSummary();
        capacity = summary.getCapacity();
        free = summary.getFreeSpace();
    }

    int64_t used = capacity - free;

    if (s_logger.isDebugEnabled()) {",1
"constexpr const char* INTEGRATION_PROPERTIES_BEAN_NAME = ""integrationProperties"";","```cpp
#include <string>

class IntegrationContextUtils {
public:
    static constexpr const char* INTEGRATION_PROPERTIES_BEAN_NAME = ""integrationProperties"";

    // Interface for MetadataStore equivalent
    class MetadataStore {};

    // Interface for BeanFactory equivalent
    class BeanFactory {
    public:
        virtual MetadataStore* getBean(const std::string& name) = 0;
        virtual ~BeanFactory() = default;
    };

    static MetadataStore* getMetadataStore(BeanFactory* beanFactory) {
        return beanFactory->getBean(""metadataStore"");
    }
};
```",1
"LoggingHandler(const std::string& level)
    : LoggingHandler(convertLevel(level))
{
}

static Level convertLevel(const std::string& level) {
    if (level.empty()) {
        throw std::invalid_argument(""'level' cannot be empty"");
    }
    try {
        return Level::valueOf(toUpperCase(level));
    } catch (const std::invalid_argument&) {
        throw std::invalid_argument(""Invalid log level '"" + level + ""'"");
    }
}","#include <string>
#include <algorithm>
#include <stdexcept>

enum class Level { /* ... */ };

class LoggingHandler {
public:
    LoggingHandler(const std::string& level)
        : level(convertLevel(level))
    {
    }

private:
    static Level convertLevel(const std::string& level) {
        if (level.empty()) {
            throw std::invalid_argument(""'level' cannot be empty"");
        }
        std::string lvl = level;
        std::transform(lvl.begin(), lvl.end(), lvl.begin(), ::toupper);
        try {
            return LevelValueOf(lvl);
        } catch (const std::invalid_argument&) {
            throw std::invalid_argument(""Invalid log level '"" + level + ""'"");
        }
    }

    static Level LevelValueOf(const std::string& levelStr) {
        // Implement mapping from string to Level enum
        // Example stub:
        if (levelStr == ""DEBUG"") return Level::/*...*/;
        if (levelStr == ""INFO"") return Level::/*...*/;
        if (levelStr == ""WARN"") return Level::/*...*/;
        if (levelStr == ""ERROR"") return Level::/*...*/;
        throw std::invalid_argument(""Invalid log level"");
    }

    Level level;
};",0
"protected:
    static Latch undeployLatch;

private:
    bool useMockedListeners = true;

public:
    static void beforeClass() {
        // method body
    }","static Latch undeployLatch;

private:
    bool useMockedListeners = true;

public:
    static void beforeClass();",1
"protected:
    void after() override
    {
        if (STOP_ON_EXIT)
        {
            if (mule.isRunning())
            {
                logger.info(""Stopping Mule Server"");
                mule.stop();
            }
            BaseClass::after();
        }
    }","protected:
    void after() override
    {
        if (STOP_ON_EXIT)
        {
            if (mule.isRunning())
            {
                logger.info(""Stopping Mule Server"");
                mule.stop();
            }
            __super::after();
        }
    }",0
"return bucket;
}

void assignInserts(const WorkloadProfile& profile, JavaSparkContext& jsc) {
    std::set<std::string> partitionPaths = profile.getPartitionPaths();
    long averageRecordSize =
        averageBytesPerRecord(
            metaClient.getActiveTimeline().getCommitTimeline().filterCompletedInstants(),
            config.getCopyOnWriteRecordSizeEstimate()
        );
    LOG.info(""AvgRecordSize => "" + std::to_string(averageRecordSize));

    std::map<std::string, std::vector<SmallFile>> partitionSmallFilesMap =
        getSmallFilesForPartitions(
            std::vector<std::string>(partitionPaths.begin(), partitionPaths.end()),
            jsc
        );

    for (const auto& partitionPath : partitionPaths) {
        WorkloadStat pStat = profile.getWorkloadStat(partitionPath);
        if (pStat.getNumInserts() > 0) {

            std::vector<SmallFile> smallFiles = partitionSmallFilesMap[partitionPath];
            this->smallFiles.insert(this->smallFiles.end(), smallFiles.begin(), smallFiles.end());

            LOG.info(""For partitionPath : "" + partitionPath + "" Small Files => "" + /* appropriate conversion for smallFiles */ """");

            long totalUnassignedInserts = pStat.getNumInserts();
        }
    }
}","```cpp
void assignInserts(const WorkloadProfile& profile, JavaSparkContext* jsc) {
    // for new inserts, compute buckets depending on how many records we have for each partition
    std::set<std::string> partitionPaths = profile.getPartitionPaths();
    long averageRecordSize =
        averageBytesPerRecord(
            metaClient.getActiveTimeline().getCommitTimeline().filterCompletedInstants(),
            config.getCopyOnWriteRecordSizeEstimate());
    LOG.info(""AvgRecordSize => "" + std::to_string(averageRecordSize));

    std::map<std::string, std::vector<SmallFile>> partitionSmallFilesMap =
        getSmallFilesForPartitions(std::vector<std::string>(partitionPaths.begin(), partitionPaths.end()), jsc);

    for (const auto& partitionPath : partitionPaths) {
        const WorkloadStat& pStat = profile.getWorkloadStat(partitionPath);
        if (pStat.getNumInserts() > 0) {

            std::vector<SmallFile> smallFiles = partitionSmallFilesMap[partitionPath];
            this->smallFiles.insert(this->smallFiles.end(), smallFiles.begin(), smallFiles.end());

            LOG.info(""For partitionPath : "" + partitionPath + "" Small Files => "" + toString(smallFiles));

            long totalUnassignedInserts = pStat.getNumInserts();
        }
    }
}
```",1
"throw CertificateException(""Unreadable or missing X.509 certificate: "" + certFile);

SSLContextConfigurator sslContextConfigurator;
std::string password = keyPassword.value_or("""");
KeyStore keyStore = PemKeyStore::buildKeyStore(certFile, keyFile, password);

sslContextConfigurator.setKeyStorePass(password);
sslContextConfigurator.setKeyStoreBytes(KeyStoreUtils::getBytes(keyStore, password));

SSLContext sslContext = sslContextConfigurator.createSSLContext(true);
return SSLEngineConfigurator(sslContext, false, false, false);","if (!std::filesystem::exists(certFile)) {
    throw std::runtime_error(""Unreadable or missing X.509 certificate: "" + certFile);
}

SSLContextConfigurator sslContextConfigurator;
std::string password = keyPassword.empty() ? """" : keyPassword;
std::vector<unsigned char> passwordVec(password.begin(), password.end());
KeyStore keyStore = PemKeyStore::buildKeyStore(certFile, keyFile, passwordVec);
sslContextConfigurator.setKeyStorePass(passwordVec);
sslContextConfigurator.setKeyStoreBytes(KeyStoreUtils::getBytes(keyStore, passwordVec));

SSLContext sslContext = sslContextConfigurator.createSSLContext(true);
return SSLEngineConfigurator(sslContext, false, false, false);",0
"// Less penalty if character follows special delim
if (matchPos >= 1)
{
    char prevChar = string[matchPos - 1];
    if (prevChar == '_' || prevChar == '-' ||
        (prevChar == '.' && (matchPos + 3 < string_n)))
    {
        matchPos = j + 1;
    }
}

// More penalty for 'uninteresting' files (e.g. .Rd)
std::string extension = StringUtil::getExtension(string);
if (toLower(extension) == ""rd"")
{
    matchPos += 3;
}","```cpp
if (matchPos >= 1)
{
    char prevChar = string[matchPos - 1];
    if (prevChar == '_' || prevChar == '-' ||
        (prevChar == '.' && (matchPos + 3 < string_n)))
    {
        matchPos = j + 1;
    }
}

std::string extension = StringUtil::getExtension(string);
std::string extLower = extension;
std::transform(extLower.begin(), extLower.end(), extLower.begin(), ::tolower);
if (extLower == ""rd"")
{
    matchPos += 3;
}
```",0
"```cpp
#include <string>
#include <cstdint>

template<typename T>
class ConfigProperty {
public:
    static ConfigProperty<T> key(const std::string& k) {
        ConfigProperty<T> prop;
        prop.key_ = k;
        return prop;
    }

    ConfigProperty<T>& defaultValue(const T& val) {
        default_value_ = val;
        return *this;
    }

    ConfigProperty<T>& sinceVersion(const std::string& version) {
        since_version_ = version;
        return *this;
    }

    ConfigProperty<T>& withDocumentation(const std::string& doc) {
        documentation_ = doc;
        return *this;
    }

    std::string key_;
    T default_value_;
    std::string since_version_;
    std::string documentation_;
};

enum class MarkerType {
    DIRECT,
    TIMELINE_SERVER_BASED
};

inline std::string to_string(MarkerType type) {
    switch(type) {
        case MarkerType::DIRECT:
            return ""DIRECT"";
        case MarkerType::TIMELINE_SERVER_BASED:
            return ""TIMELINE_SERVER_BASED"";
        default:
            return """";
    }
}

const ConfigProperty<std::string> MARKERS_TYPE_PROP = ConfigProperty<std::string>::key(""hoodie.write.markers.type"")
    .defaultValue(to_string(MarkerType::DIRECT))
    .sinceVersion(""0.9.0"")
    .withDocumentation(
        ""Marker IO mode to use.  Two modes are supported: ""
        ""- DIRECT: individual marker file corresponding to each data file is directly ""
        ""created by writer. ""
        ""- TIMELINE_SERVER_BASED: marker operations are all handled at the timeline service ""
        ""which serves as a proxy.  New marker entries are batch processed and stored ""
        ""in a limited number of underlying files for efficiency.""
    );

const ConfigProperty<int> MARKERS_TIMELINE_SERVER_BASED_BATCH_NUM_THREADS_PROP = ConfigProperty<int>::key(""hoodie.markers.timeline_server_based.batch.num_threads"")
    .defaultValue(20)
    .sinceVersion(""0.9.0"")
    .withDocumentation(""Number of threads to use for batch processing marker creation requests at the timeline service"");

const ConfigProperty<int64_t> MARKERS_TIMELINE_SERVER_BASED_BATCH_INTERVAL_MS_PROP = ConfigProperty<int64_t>::key(""hoodie.markers.timeline_server_based.batch.interval_ms"")
    .defaultValue(50L)
    .sinceVersion(""","```cpp
static const ConfigProperty<std::string> MARKERS_TYPE_PROP = ConfigProperty<std::string>()
    .key(""hoodie.write.markers.type"")
    .defaultValue(MarkerType::DIRECT.toString())
    .sinceVersion(""0.9.0"")
    .withDocumentation(""Marker IO mode to use.  Two modes are supported: ""
        ""- DIRECT: individual marker file corresponding to each data file is directly ""
        ""created by writer. ""
        ""- TIMELINE_SERVER_BASED: marker operations are all handled at the timeline service ""
        ""which serves as a proxy.  New marker entries are batch processed and stored ""
        ""in a limited number of underlying files for efficiency."");

static const ConfigProperty<int> MARKERS_TIMELINE_SERVER_BASED_BATCH_NUM_THREADS_PROP = ConfigProperty<int>()
    .key(""hoodie.markers.timeline_server_based.batch.num_threads"")
    .defaultValue(20)
    .sinceVersion(""0.9.0"")
    .withDocumentation(""Number of threads to use for batch processing marker ""
        ""creation requests at the timeline service"");

static const ConfigProperty<long long> MARKERS_TIMELINE_SERVER_BASED_BATCH_INTERVAL_MS_PROP = ConfigProperty<long long>()
    .key(""hoodie.markers.timeline_server_based.batch.interval_ms"")
    .defaultValue(50LL)
    .sinceVersion(""0.9.0"")
    .withDocumentation(""The batch interval in milliseconds for marker creation batch processing"");

static const ConfigProperty<std::string> MARKERS_DELETE_PARALLELISM = ConfigProperty<std::string>()
    .key(""hoodie.markers.delete.parallelism"")
    .defaultValue(""100"");
```",1
"#include <list>
#include <map>
#include <memory>
#include <stdexcept>
#include <typeinfo>
#include <typeindex>
#include <string>

class SmartLifecycle {
    // ... definition ...
};

class MessageChannel {
public:
    virtual ~MessageChannel() = default;
    // ... definition ...
};

class IntegrationFlowDefinitionBase {
public:
    virtual void configure(class IntegrationFlowDefinitionBase& flow) = 0;
    virtual MessageChannel* getInputChannel() = 0;
};

class StandardIntegrationFlow : public IntegrationFlowDefinitionBase {
private:
    std::list<std::shared_ptr<SmartLifecycle>> lifecycles;
    MessageChannel* inputChannel = nullptr;
    bool running = false;
    std::map<std::shared_ptr<void>, std::string> integrationComponents;
public:
    StandardIntegrationFlow(const std::map<std::shared_ptr<void>, std::string>& integrationComponents)
        : integrationComponents(integrationComponents)
    {}

    void configure(IntegrationFlowDefinitionBase& /*flow*/) override {
        throw std::runtime_error(""UnsupportedOperationException"");
    }

    MessageChannel* getInputChannel() override {
        if (this->inputChannel == nullptr) {
            for (const auto& pair : this->integrationComponents) {
                auto channel = std::dynamic_pointer_cast<MessageChannel>(pair.first);
                if (channel) {
                    this->inputChannel = channel.get();
                    break;
                }
            }
            if (this->inputChannel == nullptr) {
                throw std::logic_error(
                    std::string(""The 'IntegrationFlow' ["") + std::to_string(reinterpret_cast<uintptr_t>(this)) +
                    ""] doesn't start with 'MessageChannel' for direct message sending."");
            }
        }
        return this->inputChannel;
    }

    void setIntegrationComponents(const std::map<std::shared_ptr<void>, std::string>& components) {
        this->integrationComponents.clear();
        this->integrationComponents.insert(components.begin(), components.end());
    }
};","```cpp
#include <map>
#include <list>
#include <memory>
#include <stdexcept>
#include <typeinfo>
#include <typeindex>

class MessageChannel {
    // ... Implementation details ...
};

class IntegrationFlow {
public:
    virtual void configure() = 0;
    virtual MessageChannel* getInputChannel() = 0;
};

class SmartLifecycle {
    // ... Implementation details ...
};

class StandardIntegrationFlow : public IntegrationFlow, public SmartLifecycle {
private:
    std::map<void*, std::string> integrationComponents;
    std::list<SmartLifecycle*> lifecycles;
    MessageChannel* inputChannel = nullptr;
    bool running = false;

public:
    StandardIntegrationFlow(const std::map<void*, std::string>& components)
        : integrationComponents(components) {}

    void configure() override {
        throw std::logic_error(""UnsupportedOperationException"");
    }

    MessageChannel* getInputChannel() override {
        if (!inputChannel) {
            for (const auto& pair : integrationComponents) {
                MessageChannel* channel = dynamic_cast<MessageChannel*>(reinterpret_cast<MessageChannel*>(pair.first));
                if (channel) {
                    inputChannel = channel;
                    break;
                }
            }
            if (!inputChannel) {
                throw std::logic_error(""The 'IntegrationFlow' doesn't start with 'MessageChannel' for direct message sending."");
            }
        }
        return inputChannel;
    }

    void setIntegrationComponents(const std::map<void*, std::string>& components) {
        integrationComponents.clear();
        integrationComponents.insert(components.begin(), components.end());
    }
};
```",1
"bool delete_(const Path& f) override {
    return delete_(f, true);
}","bool deleteFile(const Path& f) override {
    return deleteFile(f, true);
}",0
"bool doubleAlignment = (totalDoubleCount > 0) || (totalFlatFieldDoubleBytes > 0);

if (
    ((getSuperclassObjectSize() % OBJECT_SIZE_INCREMENT_IN_BYTES) != 0) &&
    (doubleAlignment || (!objectCanUseBackfill && (totalObjectCount > 0)))
) {
    fieldDataStart += BACKFILL_SIZE;
}","```cpp
bool doubleAlignment = (totalDoubleCount > 0) || (totalFlatFieldDoubleBytes > 0);

if (
    ((getSuperclassObjectSize() % OBJECT_SIZE_INCREMENT_IN_BYTES) != 0) && // superclass is not end-aligned
    (doubleAlignment || (!objectCanUseBackfill && (totalObjectCount > 0)))
) { // our fields start on a 8-byte boundary
    fieldDataStart += BACKFILL_SIZE;
}
```",0
"#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <string>

using ::testing::_;
using ::testing::Eq;
using ::testing::Return;

// Assuming definitions for the following exist appropriately in your test framework/environment:
// parseTemplateProcessor, mockExpressionManager, event, LOCATION, LOCATION_MEDIA_TYPE, UNKNOWN_MEDIATYPE_LOCATION, ANY, create(), IOUtils::getResourceAsString, CoreEvent, MediaType, expectedException

TEST(ParseTemplateProcessorTest, ParseTemplateFromLocationWithKnownMediaType) {
    parseTemplateProcessor.setLocation(LOCATION);
    parseTemplateProcessor.initialise();
    std::string expectedExpression = IOUtils::getResourceAsString(LOCATION, typeid(*this));
    EXPECT_CALL(mockExpressionManager, parseLogTemplate(Eq(expectedExpression), Eq(event), _, _))
        .WillOnce(Return(""Parsed""));
    CoreEvent response = parseTemplateProcessor.process(event);
    EXPECT_EQ(response.getMessage().getPayload().getDataType().getMediaType(), LOCATION_MEDIA_TYPE);
}

TEST(ParseTemplateProcessorTest, ParseTemplateFromLocationWithUnknownMediaType) {
    parseTemplateProcessor.setLocation(UNKNOWN_MEDIATYPE_LOCATION);
    parseTemplateProcessor.initialise();
    std::string expectedExpression = IOUtils::getResourceAsString(UNKNOWN_MEDIATYPE_LOCATION, typeid(*this));
    EXPECT_CALL(mockExpressionManager, parseLogTemplate(Eq(expectedExpression), Eq(event), _, _))
        .WillOnce(Return(""Parsed""));
    CoreEvent response = parseTemplateProcessor.process(event);
    EXPECT_EQ(response.getMessage().getPayload().getDataType().getMediaType(), ANY);
}

TEST(ParseTemplateProcessorTest, ParseTemplateWithOverriddenDataType) {
    std::string customEncoding = ""UTF-16"";
    MediaType customMediaType = create(""application"", ""lrmextension"");
    parseTemplateProcessor.setLocation(UNKNOWN_MEDIATYPE_LOCATION);
    parseTemplateProcessor.setOutputMimeType(customMediaType.toRfcString());
    parseTemplateProcessor.setOutputEncoding(customEncoding);
    parseTemplateProcessor.initialise();
    std::string expectedExpression = IOUtils::getResourceAsString(UNKNOWN_MEDIATYPE_LOCATION, typeid(*this));
    EXPECT_CALL(mockExpressionManager, parseLogTemplate(Eq(expectedExpression), Eq(event), _, _))
        .WillOnce(Return(""Parsed""));
    CoreEvent response = parseTemplateProcessor.process(event);
    EXPECT_EQ(response.getMessage().getPayload().getDataType().getMediaType().getPrimaryType(),
              customMedia","```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <string>

using ::testing::_;
using ::testing::Eq;
using ::testing::Return;
using ::testing::StrEq;

class ParseTemplateProcessorTestCase : public ::testing::Test {
protected:
    ParseTemplateProcessor parseTemplateProcessor;
    MockExpressionManager* mockExpressionManager;
    CoreEvent event;

    static constexpr const char* LOCATION = ""location"";
    static constexpr const char* UNKNOWN_MEDIATYPE_LOCATION = ""unknown_mediatype_location"";
    static const MediaType LOCATION_MEDIA_TYPE;
    static const MediaType ANY;

    void SetUp() override {
        mockExpressionManager = new MockExpressionManager();
        parseTemplateProcessor.setExpressionManager(mockExpressionManager);
        // ... other setup ...
    }

    void TearDown() override {
        delete mockExpressionManager;
    }
};

const MediaType ParseTemplateProcessorTestCase::LOCATION_MEDIA_TYPE = /* ... */;
const MediaType ParseTemplateProcessorTestCase::ANY = /* ... */;

TEST_F(ParseTemplateProcessorTestCase, parseTemplateFromLocationWithKnownMediaType) {
    parseTemplateProcessor.setLocation(LOCATION);
    parseTemplateProcessor.initialise();
    std::string expectedExpression = IOUtils::getResourceAsString(LOCATION, typeid(*this));
    EXPECT_CALL(*mockExpressionManager, parseLogTemplate(StrEq(expectedExpression), Eq(event), _, _))
        .WillOnce(Return(""Parsed""));
    CoreEvent response = parseTemplateProcessor.process(event);
    ASSERT_EQ(response.getMessage().getPayload().getDataType().getMediaType(), LOCATION_MEDIA_TYPE);
}

TEST_F(ParseTemplateProcessorTestCase, parseTemplateFromLocationWithUnknownMediaType) {
    parseTemplateProcessor.setLocation(UNKNOWN_MEDIATYPE_LOCATION);
    parseTemplateProcessor.initialise();
    std::string expectedExpression = IOUtils::getResourceAsString(UNKNOWN_MEDIATYPE_LOCATION, typeid(*this));
    EXPECT_CALL(*mockExpressionManager, parseLogTemplate(StrEq(expectedExpression), Eq(event), _, _))
        .WillOnce(Return(""Parsed""));
    CoreEvent response = parseTemplateProcessor.process(event);
    ASSERT_EQ(response.getMessage().getPayload().getDataType().getMediaType(), ANY);
}

TEST_F(ParseTemplateProcessorTestCase, parseTemplateWithOverriddenDataType) {
    std::string customEncoding = ""UTF-16"";
    MediaType customMediaType = create(""application"", ""lrmextension"");
    parseTemplateProcessor.setLocation(UNKNOWN_MED",1
"```cpp
#include <gtest/gtest.h>
#include <stdexcept>
#include <memory>

class ExpressionCompilationException : public std::exception {
public:
    explicit ExpressionCompilationException(const std::string& message) : msg_(message) {}
    const char* what() const noexcept override { return msg_.c_str(); }
private:
    std::string msg_;
};

class ExpressionRuntimeException : public std::runtime_error {
public:
    explicit ExpressionRuntimeException(const std::string& message, std::exception_ptr cause)
        : std::runtime_error(message), cause_(cause) {}
    std::exception_ptr cause() const { return cause_; }
private:
    std::exception_ptr cause_;
};

class CompiledExpression {
public:
    virtual ~CompiledExpression() = default;
};

class IllegalCompiledExpression : public CompiledExpression {
public:
    IllegalCompiledExpression(const std::string& expr, const ExpressionCompilationException& cause)
        : expr_(expr), cause_(std::make_exception_ptr(cause)) {}

    void evaluate() const {
        std::rethrow_exception(
            std::make_exception_ptr(ExpressionRuntimeException(""Runtime exception"", cause_))
        );
    }
private:
    std::string expr_;
    std::exception_ptr cause_;
};

class ExpressionLanguageSessionAdaptor {
public:
    ~ExpressionLanguageSessionAdaptor() = default;
};

std::string createStaticMessage(const std::string& msg) {
    return msg;
}

TEST(ExpressionTest, evaluateInvalidCompiledExpression) {
    ExpressionCompilationException e(createStaticMessage(""oopsy""));
    IllegalCompiledExpression compiled(""#[ble]"", e);

    try {
        ExpressionLanguageSessionAdaptor session;
        compiled.evaluate();
        FAIL() << ""Expected ExpressionRuntimeException"";
    } catch (const ExpressionRuntimeException& ex) {
        try {
            std::rethrow_exception(ex.cause());
        } catch (const ExpressionCompilationException& inner) {
            EXPECT_STREQ(inner.what(), e.what());
        }
    }
}
```","#include <stdexcept>
#include <memory>
#include <gtest/gtest.h>

class ExpressionCompilationException : public std::exception {
public:
    explicit ExpressionCompilationException(const std::string& msg) : msg_(msg) {}
    const char* what() const noexcept override { return msg_.c_str(); }
private:
    std::string msg_;
};

class ExpressionRuntimeException : public std::runtime_error {
public:
    explicit ExpressionRuntimeException(const std::string& msg, const std::exception_ptr& cause)
        : std::runtime_error(msg), cause_(cause) {}
    std::exception_ptr cause() const { return cause_; }
private:
    std::exception_ptr cause_;
};

class CompiledExpression {
public:
    virtual ~CompiledExpression() = default;
};

class IllegalCompiledExpression : public CompiledExpression {
public:
    IllegalCompiledExpression(const std::string& expr, const ExpressionCompilationException& e)
        : expr_(expr), exception_(e) {}
private:
    std::string expr_;
    ExpressionCompilationException exception_;
};

class ExpressionLanguageSessionAdaptor {
public:
    ExpressionLanguageSessionAdaptor() = default;
    ~ExpressionLanguageSessionAdaptor() = default;
};

std::string createStaticMessage(const std::string& msg) {
    return msg;
}

TEST(DataWeaveExpressionLanguageAdaptorTestCase, evaluateInvalidCompiledExpression) {
    ExpressionCompilationException e(createStaticMessage(""oopsy""));
    auto compiled = std::make_unique<IllegalCompiledExpression>(""#[ble]"", e);

    try {
        ExpressionLanguageSessionAdaptor session;
        throw ExpressionRuntimeException(""runtime error"", std::make_exception_ptr(e));
    } catch (const ExpressionRuntimeException& ex) {
        EXPECT_NE(nullptr, dynamic_cast<const ExpressionRuntimeException*>(&ex));
        try {
            std::rethrow_exception(ex.cause());
        } catch (const ExpressionCompilationException& cause) {
            EXPECT_STREQ(e.what(), cause.what());
            throw;
        } catch (...) {
            FAIL() << ""Unexpected exception cause type"";
        }
    } catch (...) {
        FAIL() << ""Exception is not of type ExpressionRuntimeException"";
    }
}",1
"```
#include <vector>
#include <iterator>

enum class Kind { ANNOTATION, OTHER };
enum class Modifier { /* ... */ };

struct ModifierTree {
    virtual bool is(Kind kind) const = 0;
};

struct ModifierKeywordTree : public ModifierTree {
    virtual Modifier modifier() const = 0;
};

using ModifierTreePtr = ModifierTree*;
using ModifierTreeList = std::vector<ModifierTreePtr>;
using ModifierTreeIter = ModifierTreeList::iterator;

ModifierTreePtr testOnlyAnnotationsAreLeft(ModifierTreeIter begin, ModifierTreeIter end) {
    for (auto it = begin; it != end; ++it) {
        if (!(*it)->is(Kind::ANNOTATION)) {
            if (it != begin) {
                return *(--it);
            }
        }
    }
    return nullptr;
}

// Moves iterator to the first non-annotation (if any)
ModifierTreeIter skipAnnotations(ModifierTreeIter begin, ModifierTreeIter end) {
    auto it = begin;
    while (it != end && (*it)->is(Kind::ANNOTATION)) {
        ++it;
    }
    return it;
}

ModifierTreePtr getFirstBadlyOrdered(ModifierTreeList& modifiersTree, const std::vector<Modifier>& modifiers) {
    auto it = modifiersTree.begin();
    it = skipAnnotations(it, modifiersTree.end());
    size_t modifierIndex = 0;
    while (it != modifiersTree.end()) {
        ModifierTreePtr modifier = *it;
        if (modifier->is(Kind::ANNOTATION)) {
            break;
        }
        ModifierKeywordTree* mkt = dynamic_cast<ModifierKeywordTree*>(modifier);
        for (; modifierIndex < modifiers.size() && mkt && mkt->modifier() != modifiers[modifierIndex]; ++modifierIndex) {
            // Just interested in position at end
        }
        if (modifierIndex == modifiers.size()) {
            return modifier;
        }
        ++it;
    }
    return testOnlyAnnotationsAreLeft(it, modifiersTree.end());
}
```","```cpp
#include <vector>
#include <iterator>

class ModifierTree {
public:
    virtual bool is(Kind kind) const = 0;
};

class ModifierKeywordTree : public ModifierTree {
public:
    virtual Modifier modifier() const = 0;
};

enum class Kind { ANNOTATION };

enum class Modifier {
    // Assume same as Modifier.values() in Java.
};

std::vector<Modifier> ModifierValues() {
    // Return vector of all Modifier enum values.
    // Implement this according to your Modifier enum.
}

// Move iterator to first element not an annotation
template<typename Iterator>
void skipAnnotations(Iterator& it, const Iterator& end) {
    while (it != end && (*it)->is(Kind::ANNOTATION)) {
        ++it;
    }
    // Move back one if not at beginning
    if (it != end) {
        --it;
    }
}

template<typename Iterator>
ModifierTree* testOnlyAnnotationsAreLeft(Iterator& it, const Iterator& end) {
    while (it != end) {
        ModifierTree* modifier = *it;
        ++it;
        if (!modifier->is(Kind::ANNOTATION)) {
            --it;
            if (it != typename std::vector<ModifierTree*>::const_iterator{}) {
                --it;
                return *it;
            }
        }
    }
    return nullptr;
}

ModifierTree* getFirstBadlyOrdered(const std::vector<ModifierTree*>& modifiersTree) {
    auto modifiersIterator = modifiersTree.cbegin();
    auto end = modifiersTree.cend();
    skipAnnotations(modifiersIterator, end);
    std::vector<Modifier> modifiers = ModifierValues();
    size_t modifierIndex = 0;
    while (modifiersIterator != end) {
        ModifierTree* modifier = *modifiersIterator;
        ++modifiersIterator;
        if (modifier->is(Kind::ANNOTATION)) {
            break;
        }
        auto* mkt = dynamic_cast<ModifierKeywordTree*>(modifier);
        for (; modifierIndex < modifiers.size() && mkt && mkt->modifier() != modifiers[modifierIndex]; ++modifierIndex) {
            // We're just interested in the final value of modifierIndex
        }
        if (modifierIndex == modifiers.size()) {
            return modifier;
        }
    }
    return testOnlyAnnotationsAreLeft(modifiersIterator, end);
}
```",1
"```cpp
#include <string>
#include <unordered_map>
#include <stdexcept>

class MonitoringInfo {
public:
    class Builder {
    public:
        Builder(const MonitoringInfo& info);
        void clearPayload();
        void clearStartTime();
        void clearType();
        MonitoringInfo build();
    };

    static Builder newBuilder(const MonitoringInfo& info);

    bool operator==(const MonitoringInfo& other) const;
    struct Hash {
        std::size_t operator()(const MonitoringInfo& info) const;
    };
};

class ShortIdMap {
private:
    int counter = 0;
    std::unordered_map<std::string, MonitoringInfo> shortIdToInfo;
    std::unordered_map<MonitoringInfo, std::string, MonitoringInfo::Hash> cleanedInfoToShortId;

public:
    std::string getOrCreateShortId(const MonitoringInfo& info) {
        // Remove the payload, startTime and type before using the MonitoringInfo as a key.
        MonitoringInfo::Builder cleaner = MonitoringInfo::newBuilder(info);
        cleaner.clearPayload();
        cleaner.clearStartTime();
        cleaner.clearType();
        MonitoringInfo cleaned = cleaner.build();

        auto cleanedIt = cleanedInfoToShortId.find(cleaned);
        std::string shortId;
        if (cleanedIt != cleanedInfoToShortId.end()) {
            shortId = cleanedIt->second;
        } else {
            shortId = ""metric"" + std::to_string(counter++);
            MonitoringInfo::Builder noPayloadCleaner = MonitoringInfo::newBuilder(info);
            noPayloadCleaner.clearPayload();
            shortIdToInfo.emplace(shortId, noPayloadCleaner.build());
            cleanedInfoToShortId.emplace(cleaned, shortId);
        }
        return shortId;
    }

    MonitoringInfo get(const std::string& shortId) {
        auto it = shortIdToInfo.find(shortId);
        if (it == shortIdToInfo.end()) {
            throw std::out_of_range(shortId);
        }
        return it->second;
    }
};
```","#include <string>
#include <unordered_map>
#include <stdexcept>

class MonitoringInfo {
public:
    class Builder {
    public:
        Builder(const MonitoringInfo &info) : info_(info) {}
        Builder &clearPayload() { info_.payload_.clear(); return *this; }
        Builder &clearStartTime() { info_.start_time_.clear(); return *this; }
        Builder &clearType() { info_.type_.clear(); return *this; }
        MonitoringInfo build() { return info_; }
    private:
        MonitoringInfo info_;
    };

    static Builder newBuilder(const MonitoringInfo &info) { return Builder(info); }

    bool operator==(const MonitoringInfo &other) const {
        return urn_ == other.urn_ && labels_ == other.labels_; // Assumption: only urn and labels
    }

    struct Hash {
        std::size_t operator()(const MonitoringInfo &info) const {
            std::size_t hash = std::hash<std::string>()(info.urn_);
            for (const auto &pair : info.labels_) {
                hash ^= std::hash<std::string>()(pair.first) ^ std::hash<std::string>()(pair.second);
            }
            return hash;
        }
    };

    std::string urn_;
    std::unordered_map<std::string, std::string> labels_;
    std::string payload_;
    std::string start_time_;
    std::string type_;
};

class ShortIdMap {
public:
    std::string getOrCreateShortId(const MonitoringInfo &info) {
        MonitoringInfo::Builder cleaner = MonitoringInfo::newBuilder(info);
        cleaner.clearPayload();
        cleaner.clearStartTime();
        cleaner.clearType();
        MonitoringInfo cleaned = cleaner.build();
        auto it = cleanedInfoToShortId_.find(cleaned);
        std::string shortId;
        if (it != cleanedInfoToShortId_.end()) {
            shortId = it->second;
        } else {
            shortId = ""metric"" + std::to_string(counter_++);
            MonitoringInfo::Builder noPayloadCleaner = MonitoringInfo::newBuilder(info);
            noPayloadCleaner.clearPayload();
            shortIdToInfo_[shortId] = noPayloadCleaner.build();
            cleanedInfoToShortId_[cleaned] = shortId;
        }
        return shortId;
    }

    MonitoringInfo get(const std::string &shortId) {
        auto it = shortIdToInfo_.find(shortId);
        if",1
"bool delete_all_connection_tokens() {
    return JetpackOptions::delete_option();
}","class Manager {
public:
    /**
     * Deletes all connection tokens and transients from the local Jetpack site.
     *
     * @return true if disconnected successfully, false otherwise.
     */
    bool delete_all_connection_tokens() {
        return Jetpack_Options::delete_option(
            // arguments go here
        );
    }
};",1
"#include <thread>
#include <string>
#include <vector>
#include <set>
#include <optional>
#include <algorithm>
#include <iterator>
#include <sstream>

using std::this_thread::get_id;
using UTF8 = std::string;
inline const std::vector<int>& emptyList() { static std::vector<int> v; return v; }
using std::vector;
inline std::vector<int> singletonList(int x) { return {x}; }
inline std::optional<int> emptyOptional() { return std::nullopt; }
using std::make_optional;
template <typename T>
inline std::optional<T> ofNullable(T&& val) { return val ? std::optional<T>(std::forward<T>(val)) : std::nullopt; }
template <typename Iterable>
std::string joining(const Iterable& c, const std::string& delim = """") {
    std::ostringstream oss;
    auto it = c.begin();
    if(it != c.end()) {
        oss << *it++;
        while(it != c.end()) {
            oss << delim << *it++;
        }
    }
    return oss.str();
}
template <typename Iterable>
auto toList(const Iterable& c) {
    using T = typename Iterable::value_type;
    return std::vector<T>(c.begin(), c.end());
}
template <typename Iterable>
auto toSet(const Iterable& c) {
    using T = typename Iterable::value_type;
    return std::set<T>(c.begin(), c.end());
}","#include <string>
#include <thread>
#include <vector>
#include <optional>
#include <set>
#include <algorithm>
#include <iterator>
#include <codecvt>
#include <locale>

using std::string;
using std::thread;
using std::vector;
using std::optional;
using std::set;

// Equivalent to Java's String.join
inline string join(const string& delimiter, const vector<string>& elements) {
    if (elements.empty()) return """";
    string result = elements[0];
    for (size_t i = 1; i < elements.size(); ++i) {
        result += delimiter + elements[i];
    }
    return result;
}

inline thread::id currentThread() {
    return std::this_thread::get_id();
}

// UTF_8: use std::wstring_convert for demonstration purposes
inline std::string toUtf8(const std::wstring& wstr) {
    std::wstring_convert<std::codecvt_utf8<wchar_t>> conv;
    return conv.to_bytes(wstr);
}

inline vector<string> emptyList() {
    return {};
}

inline vector<string> singletonList(const string& item) {
    return {item};
}

template<typename T>
inline std::optional<T> emptyOptional() {
    return std::nullopt;
}

template<typename T>
inline std::optional<T> of(const T& value) {
    return std::make_optional(value);
}

template<typename T>
inline std::optional<T> ofNullable(const T* ptr) {
    return ptr ? std::make_optional(*ptr) : std::nullopt;
}

// joining: collects string elements with a delimiter
inline string joining(const vector<string>& elements, const string& delimiter) {
    return join(delimiter, elements);
}

// toList: collects unique elements from a container
template <typename Container>
vector<typename Container::value_type> toList(const Container& c) {
    return vector<typename Container::value_type>(c.begin(), c.end());
}

// toSet: collects unique elements from a container
template <typename Container>
set<typename Container::value_type> toSet(const Container& c) {
    return set<typename Container::value_type>(c.begin(), c.end());
}",0
"#include <filesystem>
#include <set>","#include <filesystem>
#include <set>",1
"for (const auto& [key, value] : source) {
    destination[key] = copyElement(value, maxDepth);
}
} else if (isObject(source) && !isRegExp(source)) {
    auto keys = getOwnPropertyNames(source);
    for (const auto& key : keys) {
        auto elementCopy = copyElement(source.at(key), maxDepth);

        if (isPropertyEnumerable(source, key)) {
            destination[key] = elementCopy;
        } else {
            defineProperty(destination, key, elementCopy);
        }
    }
} else if (source && hasOwnPropertyFunction(source)) {
    for (const auto& [key, value] : source) {
        if (hasOwnProperty(source, key)) {
            destination[key] = copyElement(value, maxDepth);
        }
    }
}","```cpp
#include <unordered_map>
#include <string>
#include <vector>
#include <type_traits>

// Forward declarations for helpers used below
bool isObject(const auto& value);
bool isRegExp(const auto& value);
std::vector<std::string> getOwnPropertyNames(const auto& obj);
bool propertyIsEnumerable(const auto& obj, const std::string& key);
auto copyElement(const auto& element, int maxDepth);

// Define a generic object representation (akin to JS objects)
using Object = std::unordered_map<std::string, std::any>;

void copy(const Object& source, Object& destination, int maxDepth) {
    for (const auto& [key, value] : source) {
        destination[key] = copyElement(value, maxDepth);
    }
    // don't use getOwnPropertyNames with RegExp to avoid copying RegExp lastIndex property
    // isObject, isRegExp, propertyIsEnumerable, and getOwnPropertyNames must be implemented
    if (isObject(source) && !isRegExp(source)) {
        for (const auto& key : getOwnPropertyNames(source)) {
            auto elementCopy = copyElement(source.at(key), maxDepth);
            if (propertyIsEnumerable(source, key)) {
                destination[key] = elementCopy;
            } else {
                // Mimic non-enumerable: store in a way to track property attributes if needed
                destination[key] = elementCopy; // No built-in support for property attributes in C++
            }
        }
    } else {
        // Fallback: just copy all properties as above
        for (const auto& [key, value] : source) {
            destination[key] = copyElement(value, maxDepth);
        }
    }
}
```",1
"auto targetMuleContextAware = std::make_shared<testing::NiceMock<MockMuleContextAware>>();
EXPECT_CALL(*std::static_pointer_cast<Processor>(targetMuleContextAware), apply(testing::_))
    .WillOnce(testing::Return(just(result)));

auto flowRefFactoryBean = createDynamicFlowRefFactoryBean(
    std::static_pointer_cast<Processor>(targetMuleContextAware), nullptr, applicationContext);

ASSERT_EQ(result.getMessage(), getFlowRefProcessor(flowRefFactoryBean)->process(event)->getMessage());

EXPECT_CALL(*targetMuleContextAware, setMuleContext(mockMuleContext));","auto targetMuleContextAware = std::make_shared<NiceMock<MuleContextAware>>();
ON_CALL(*std::static_pointer_cast<Processor>(targetMuleContextAware), apply(::testing::_))
    .WillByDefault(::testing::Return(std::make_shared<Result>(result)));

auto flowRefFactoryBean = createDynamicFlowRefFactoryBean(
    std::static_pointer_cast<Processor>(targetMuleContextAware), nullptr, applicationContext);

EXPECT_EQ(result.getMessage(), getFlowRefProcessor(flowRefFactoryBean)->process(event)->getMessage());

EXPECT_CALL(*targetMuleContextAware, setMuleContext(mockMuleContext));",0
"#include ""com/ichi2/libanki/Utils.h""
#include ""com/ichi2/libanki/importer/AnkiPackageImporter.h""
#include ""com/ichi2/themes/StyledProgressDialog.h""
#include ""com/ichi2/utils/VersionUtils.h""
#include ""com/ichi2/widget/WidgetStatus.h""","#include ""Sched.h""
#include ""Utils.h""
#include ""AnkiPackageImporter.h""
#include ""StyledProgressDialog.h""
#include ""VersionUtils.h""
#include ""WidgetStatus.h""",0
"#include <string>
#include <gtest/gtest.h>

class SomeParameterGroupOneRequiredConfig {
public:
    std::string getRepeatedNameParameter() const;
    class ComplexParameter {
    public:
        std::string getRepeatedNameParameter() const;
    };
    ComplexParameter getComplexParameter() const;
};

class ComplexParameter {
public:
    std::string getRepeatedNameParameter() const;
};

class SomeAliasedParameterGroupOneRequiredConfig {
public:
    class ComplexParameter {
    public:
        std::string getAnotherParameter() const;
    };
    ComplexParameter getComplexParameter() const;
    std::string getSomeParameter() const;
};

void startFlow(const std::string& flowName);
void assertEventsFired();
SomeParameterGroupOneRequiredConfig getParameterGroupConfigValue();
ComplexParameter getComplexParameterValue();
SomeAliasedParameterGroupOneRequiredConfig getAliasedParameterGroupConfigValue();

TEST(FlowTests, testShowInDslTrueWithRepeatedNameParameter) {
    startFlow(""dslTrueRepeatedNameParameter"");
    assertEventsFired();
    SomeParameterGroupOneRequiredConfig config = getParameterGroupConfigValue();
    ASSERT_EQ(config.getRepeatedNameParameter(), ""hello cat!"");
}

TEST(FlowTests, testShowInDslTrueWithComplexParameterWithRepeatedNameParameter) {
    startFlow(""dslTrueComplexParameterWithRepeatedNameParameter"");
    assertEventsFired();
    SomeParameterGroupOneRequiredConfig config = getParameterGroupConfigValue();
    ASSERT_EQ(config.getComplexParameter().getRepeatedNameParameter(), ""hi bird!"");
}

TEST(FlowTests, testWithDslTrueRepeatedParameterNameInParameterGroup) {
    startFlow(""dslTrueRepeatedParameterNameInParameterGroup"");
    assertEventsFired();
    ComplexParameter complexParameter = getComplexParameterValue();
    SomeParameterGroupOneRequiredConfig config = getParameterGroupConfigValue();
    ASSERT_EQ(complexParameter.getRepeatedNameParameter(), ""hi lizard!"");
    ASSERT_EQ(config.getComplexParameter().getRepeatedNameParameter(), ""hi bird!"");
}

TEST(FlowTests, testWithDslTrueRepeatedParameterNameInSource) {
    startFlow(""dslTrueRepeatedParameterNameInSource"");
    assertEventsFired();
    SomeParameterGroupOneRequiredConfig config = getParameterGroupConfigValue();
    ASSERT_EQ(config.getComplexParameter().getRepeatedNameParameter(), ""hi bird!"");
}

TEST(FlowTests, testShowInDslTrueWithComplexParameterWithParameterAlias) {
    startFlow(""dslTrueComplexParameterWithParameterAlias"");
    assert","#include <gtest/gtest.h>
#include <string>

class SourceWithParameterGroupExclusiveOptionalsOneRequiredTestCase : public ::testing::Test {
protected:
    void startFlow(const std::string& flowName) {
        static_cast<Startable*>(getFlowConstruct(flowName))->start();
    }

    void assertEventsFired();
    SomeParameterGroupOneRequiredConfig getParameterGroupConfigValue();
    SomeAliasedParameterGroupOneRequiredConfig getAliasedParameterGroupConfigValue();
    ComplexParameter getComplexParameterValue();
};

TEST_F(SourceWithParameterGroupExclusiveOptionalsOneRequiredTestCase, testShowInDslTrueWithRepeatedNameParameter) {
    startFlow(""dslTrueRepeatedNameParameter"");
    assertEventsFired();
    SomeParameterGroupOneRequiredConfig config = getParameterGroupConfigValue();
    ASSERT_EQ(config.getRepeatedNameParameter(), ""hello cat!"");
}

TEST_F(SourceWithParameterGroupExclusiveOptionalsOneRequiredTestCase, testShowInDslTrueWithComplexParameterWithRepeatedNameParameter) {
    startFlow(""dslTrueComplexParameterWithRepeatedNameParameter"");
    assertEventsFired();
    SomeParameterGroupOneRequiredConfig config = getParameterGroupConfigValue();
    ASSERT_EQ(config.getComplexParameter().getRepeatedNameParameter(), ""hi bird!"");
}

TEST_F(SourceWithParameterGroupExclusiveOptionalsOneRequiredTestCase, testWithDslTrueRepeatedParameterNameInParameterGroup) {
    startFlow(""dslTrueRepeatedParameterNameInParameterGroup"");
    assertEventsFired();
    ComplexParameter complexParameter = getComplexParameterValue();
    SomeParameterGroupOneRequiredConfig config = getParameterGroupConfigValue();
    ASSERT_EQ(complexParameter.getRepeatedNameParameter(), ""hi lizard!"");
    ASSERT_EQ(config.getComplexParameter().getRepeatedNameParameter(), ""hi bird!"");
}

TEST_F(SourceWithParameterGroupExclusiveOptionalsOneRequiredTestCase, testWithDslTrueRepeatedParameterNameInSource) {
    startFlow(""dslTrueRepeatedParameterNameInSource"");
    assertEventsFired();
    SomeParameterGroupOneRequiredConfig config = getParameterGroupConfigValue();
    ASSERT_EQ(config.getComplexParameter().getRepeatedNameParameter(), ""hi bird!"");
}

TEST_F(SourceWithParameterGroupExclusiveOptionalsOneRequiredTestCase, testShowInDslTrueWithComplexParameterWithParameterAlias) {
    startFlow(""dslTrueComplexParameterWithParameterAlias"");
    assertEventsFired();
    SomeAliasedParameterGroupOneRequiredConfig config = getAliasedParameterGroupConfigValue();
    ASSERT_EQ(config.getComplexParameter().get",1
"void addRow() {
    std::vector<BloomFilter> tmp(matrix.size() + 1);
    std::copy(matrix.begin(), matrix.end(), tmp.begin());
    tmp[tmp.size() - 1] = BloomFilter(vectorSize, nbHash, hashType);
    matrix = std::move(tmp);
}","void addRow() {
    std::vector<BloomFilter> tmp(matrix.size() + 1);
    std::copy(matrix.begin(), matrix.end(), tmp.begin());
    tmp[tmp.size() - 1] = BloomFilter(vectorSize, nbHash, hashType);
    matrix = std::move(tmp);
}",1
"```cpp
} else {
    for (auto* successor : block->successors()) {
        if (!block->isFinallyBlock() || isDirectFlowSuccessorOf(successor, block)) {
            node.happyPath = terminator == nullptr || !terminator->is(Tree::Kind::THROW_STATEMENT);
            enqueue(ExplodedGraph::ProgramPoint(successor, 0), programState, successor == block->exitBlock());
        }
    }
}
```","```cpp
} else {
    for (const auto& successor : block.successors()) {
        if (!block.isFinallyBlock() || isDirectFlowSuccessorOf(successor, block)) {
            node.happyPath = (terminator == nullptr) || !terminator->is(Tree::Kind::THROW_STATEMENT);
            enqueue(ExplodedGraph::ProgramPoint(successor, 0), programState, successor == block.exitBlock());
        }
    }
```",0
"basePathKnown = true;
// Check if this is for a snapshot query
tagAsIncrementalOrSnapshot(inputPath, metaClient, incrementalTables);
break;
}
}
if (!basePathKnown) {
    // This path is for a table that we don't know about yet.
    std::shared_ptr<HoodieTableMetaClient> metaClient;
    try {
        metaClient = getTableMetaClientForBasePath(inputPath.getFileSystem(conf), inputPath);
        std::string databaseName = metaClient->getTableConfig().getDatabaseName();
        std::string tableName = metaClient->getTableConfig().getTableName();
        tableMetaClientMap[
            (isIncrementalUseDatabase && !databaseName.empty())
                ? (databaseName + ""."" + tableName)
                : tableName
        ] = metaClient;
        tagAsIncrementalOrSnapshot(inputPath, metaClient, incrementalTables);
    } catch (const TableNotFoundException& e) {
        // This is a non Hoodie inputPath
        LOG.info(""Handling a non-hoodie path "" + inputPath);
    } catch (const InvalidTableException& e) {
        LOG.info(""Handling a non-hoodie path "" + inputPath);
    }
}","```cpp
bool basePathKnown = false;
for (const auto& entry : tableMetaClientMap) {
    if (isSameBasePath(inputPath, entry.second)) {
        basePathKnown = true;
        tagAsIncrementalOrSnapshot(inputPath, entry.second, incrementalTables);
        break;
    }
}
if (!basePathKnown) {
    try {
        auto metaClient = getTableMetaClientForBasePath(inputPath.getFileSystem(conf), inputPath);
        std::string databaseName = metaClient->getTableConfig().getDatabaseName();
        std::string tableName = metaClient->getTableConfig().getTableName();
        std::string mapKey;
        if (isIncrementalUseDatabase && !databaseName.empty()) {
            mapKey = databaseName + ""."" + tableName;
        } else {
            mapKey = tableName;
        }
        tableMetaClientMap[mapKey] = metaClient;
        tagAsIncrementalOrSnapshot(inputPath, metaClient, incrementalTables);
    } catch (const TableNotFoundException& e) {
        LOG.info(""Handling a non-hoodie path "" + inputPath);
    } catch (const InvalidTableException& e) {
        LOG.info(""Handling a non-hoodie path "" + inputPath);
    }
}
```",1
"std::string url;
try
{
    if (getIFrameEx() != nullptr && getIFrameEx()->getContentWindow() != nullptr)
        url = getIFrameEx()->getContentWindow()->getLocationHref();
}
catch (const std::exception& e)
{
}","std::string url;
try
{
    if (getIFrameEx() != nullptr && getIFrameEx()->getContentWindow() != nullptr)
        url = getIFrameEx()->getContentWindow()->getLocationHref();
}
catch (const std::exception& e)
{
}",0
"bool tableExists = hoodieHiveClient.doesTableExist(tableName);

if (cfg.enableCreateDatabase) {
    try {
        hoodieHiveClient.updateHiveSQL(""create database if not exists "" + cfg.databaseName);
    } catch (const std::exception& e) {
        LOG.warn(""Unable to create database"", e);
    }
}","```cpp
bool tableExists = hoodieHiveClient.doesTableExist(tableName);

// check if the database exists else create it
if (cfg.enableCreateDatabase) {
    try {
        hoodieHiveClient.updateHiveSQL(""create database if not exists "" + cfg.databaseName);
    } catch (const std::exception& e) {
        LOG.warn(""Unable to create database"", e);
    }
}

// Get the parquet schema for this table looking at the latest commit
```",1
"bool isVpc() const {
    return _isVpc;
}

const std::vector<std::map<std::string, std::any>>& getStaticNatDetails() const {
    return _staticNatDetails;
}

class Builder : public CmdBuilder<ApplyStaticNatVspCommand> {
private:
    std::string _networkDomainUuid;
    std::string _networkUuid;
    std::string _vpcOrSubnetUuid;
    bool _isL3Network = false;
    bool _isVpc = false;
    std::vector<std::map<std::string, std::any>> _staticNatDetails;
public:
    Builder& networkDomainUuid(const std::string& networkDomainUuid) {
        _networkDomainUuid = networkDomainUuid;
        return *this;
    }

    Builder& networkUuid(const std::string& networkUuid) {
        _networkUuid = networkUuid;
        return *this;
    }

    Builder& vpcOrSubnetUuid(const std::string& vpcOrSubnetUuid) {
        _vpcOrSubnetUuid = vpcOrSubnetUuid;
        return *this;
    }

    Builder& isL3Network(bool isL3Network) {
        _isL3Network = isL3Network;
        return *this;
    }

    Builder& isVpc(bool isVpc) {
        _isVpc = isVpc;
        return *this;
    }

    Builder& staticNatDetails(const std::vector<std::map<std::string, std::any>>& staticNatDetails) {
        _staticNatDetails = staticNatDetails;
        return *this;
    }

    std::unique_ptr<ApplyStaticNatVspCommand> build() override {
        return std::make_unique<ApplyStaticNatVspCommand>(_networkDomainUuid, _networkUuid, _vpcOrSubnetUuid, _isL3Network, _isVpc, _staticNatDetails);
    }
};

bool executeInSequence() const override {
    return false;
}

bool operator==(const ApplyStaticNatVspCommand& that) const {
    if (this == &that) return true;
    if (!CmdBuilder<ApplyStaticNatVspCommand>::operator==(that)) return false;
    if (_isL3Network != that._isL3Network) return false;
    if (_isVpc != that._isVpc) return false;
    if (_networkDomainUuid != that._networkDomainUuid) return false;
    if (_networkUuid != that._network","```cpp
class ApplyStaticNatVspCommand : public Command {
public:
    bool isL3Network() const {
        return _isL3Network;
    }

    bool isVpc() const {
        return _isVpc;
    }

    const std::vector<std::map<std::string, std::any>>& getStaticNatDetails() const {
        return _staticNatDetails;
    }

    class Builder : public CmdBuilder<ApplyStaticNatVspCommand> {
    private:
        std::string _networkDomainUuid;
        std::string _networkUuid;
        std::string _vpcOrSubnetUuid;
        bool _isL3Network = false;
        bool _isVpc = false;
        std::vector<std::map<std::string, std::any>> _staticNatDetails;
    public:
        Builder& networkDomainUuid(const std::string& networkDomainUuid) {
            _networkDomainUuid = networkDomainUuid;
            return *this;
        }

        Builder& networkUuid(const std::string& networkUuid) {
            _networkUuid = networkUuid;
            return *this;
        }

        Builder& vpcOrSubnetUuid(const std::string& vpcOrSubnetUuid) {
            _vpcOrSubnetUuid = vpcOrSubnetUuid;
            return *this;
        }

        Builder& isL3Network(bool isL3Network) {
            _isL3Network = isL3Network;
            return *this;
        }

        Builder& isVpc(bool isVpc) {
            _isVpc = isVpc;
            return *this;
        }

        Builder& staticNatDetails(const std::vector<std::map<std::string, std::any>>& staticNatDetails) {
            _staticNatDetails = staticNatDetails;
            return *this;
        }

        ApplyStaticNatVspCommand build() override {
            return ApplyStaticNatVspCommand(_networkDomainUuid, _networkUuid, _vpcOrSubnetUuid, _isL3Network, _isVpc, _staticNatDetails);
        }
    };

    bool executeInSequence() const override {
        return false;
    }

    bool operator==(const ApplyStaticNatVspCommand& other) const {
        if (this == &other) return true;
        if (!Command::operator==(other)) return false;
        return _isL3Network == other._isL3Network
            && _isVpc == other._isVpc
            && _network",1
"return getAll(storeName, [](const std::string&) { return true; });
}

std::vector<std::string> getStateNames(const std::string& storeName, const std::function<bool(const std::string&)>& predicate) {
    std::vector<std::string> names;
    std::string path = formPath(storeName);

    std::vector<std::string> children = propStore.getChildNames(path, 0);

    if (!children.empty()) {
        for (const std::string& c : children) {
            if (predicate(c)) {
                names.push_back(c);
            }
        }
    }

    return names;
}

void createAlias(const std::string& storeName, const std::string& original, const std::string& alias) {
    std::string pathOriginal = formPath(storeName, original);
    std::vector<uint8_t> data;

    if (!propStore.exists(pathOriginal, 0)) {","```cpp
std::vector<std::string> getStateNames(const std::string& storeName, std::function<bool(const std::string&)> predicate) {
    std::vector<std::string> names;
    std::string path = formPath(storeName);

    std::vector<std::string> children = propStore.getChildNames(path, 0);

    if (!children.empty()) {
        for (const auto& c : children) {
            if (predicate(c)) {
                names.push_back(c);
            }
        }
    }

    return names;
}

void createAlias(const std::string& storeName, const std::string& original, const std::string& alias) {
    std::string pathOriginal = formPath(storeName, original);
    std::string pathAlias = formPath(storeName, alias);
    std::vector<uint8_t> data;

    if (!propStore.exists(pathOriginal, 0)) {
        // function logic continues...
    }
}
```",0
"#include <cassert>
#include <functional>
#include <vector>
#include <future>
#include <thread>
#include <memory>
#include <type_traits>","#include <cassert>
#include <functional>
#include <vector>
#include <future>
#include <thread>
#include <memory>",0
"```cpp
bool deleteTags(const std::vector<std::string>& resourceIds, ResourceObjectType resourceType, const std::map<std::string, std::string>& tags) {
    Account caller = CallContext::current().getCallingAccount();
    std::vector<std::shared_ptr<ResourceTag>> resourceTags = getResourceTags(resourceIds, resourceType);
    std::vector<std::shared_ptr<ResourceTag>> tagsToRemove;

    // Finalize which tags should be removed

}
```","```cpp
bool deleteTags(const std::vector<std::string>& resourceIds, ResourceObjectType resourceType, const std::map<std::string, std::string>& tags) {
    Account* caller = CallContext::current().getCallingAccount();
    std::vector<std::shared_ptr<ResourceTag>> resourceTags = getResourceTags(resourceIds, resourceType);
    std::vector<std::shared_ptr<ResourceTag>> tagsToRemove;
    
    // Finalize which tags should be removed

    // ...
    return false; // Replace as appropriate
}
```",1
"static const Logger LOG = LogManager::getLogger(typeid(HoodieHiveClient));
const PartitionValueExtractor partitionValueExtractor;
IMetaStoreClient* client;
SessionState* sessionState;
org::apache::hadoop::hive::ql::Driver* hiveDriver;
HiveSyncConfig syncConfig;
FileSystem* fs;
Connection* connection;","#include <memory>
#include <string>

class Logger {};
class PartitionValueExtractor {};
class IMetaStoreClient {};
class SessionState {};
class HiveDriver {};
class HiveSyncConfig {};
class FileSystem {};
class Connection {};

class HoodieHiveClient : public AbstractSyncHoodieClient {
private:
    static Logger LOG;
    PartitionValueExtractor partitionValueExtractor;
    std::unique_ptr<IMetaStoreClient> client;
    std::unique_ptr<SessionState> sessionState;
    std::unique_ptr<HiveDriver> hiveDriver;
    HiveSyncConfig syncConfig;
    FileSystem fs;
    Connection connection;
};",1
"#include <gtest/gtest.h>
#include <gmock/gmock.h>

using ::testing::Eq;
using ::testing::Ne;
using ::testing::NotNull;
using ::testing::StartsWith;
using ::testing::IsNull;
using ::testing::StrEq;
using ::testing::StrNe;

#include ""mule/api/endpoint/InboundEndpoint.h""
#include ""mule/api/endpoint/OutboundEndpoint.h""
#include ""mule/api/lifecycle/InitialisationException.h""
#include ""mule/api/service/Service.h""
#include ""mule/api/transport/Connector.h""
#include ""mule/api/transport/ConnectorException.h""
#include ""mule/api/transport/MessageReceiver.h""
#include ""mule/api/transport/NoReceiverForEndpointException.h""
#include ""mule/tck/MuleTestUtils.h""
using mule::tck::MuleTestUtils::TestCallback;","#include <gtest/gtest.h>
#include <gmock/gmock.h>

using ::testing::_;
using ::testing::StrEq;
using ::testing::StartsWith;

#include ""InboundEndpoint.h""
#include ""OutboundEndpoint.h""
#include ""InitialisationException.h""
#include ""Service.h""
#include ""Connector.h""
#include ""ConnectorException.h""
#include ""MessageReceiver.h""
#include ""NoReceiverForEndpointException.h""
#include ""MuleTestUtils.h""",0
"#include <vector>
#include <string>
#include ""GobblinKafkaConsumerClientFactory.h""
#include ""KafkaConsumerRecord.h""
#include ""Tag.h""
#include ""JobShutdownException.h""
#include ""DataRecordException.h""
#include ""Extractor.h""
#include ""EventBasedExtractor.h""","#include ""GobblinKafkaConsumerClient.h""
#include ""GobblinKafkaConsumerClientFactory.h""
#include ""KafkaConsumerRecord.h""
#include ""Tag.h""
#include ""JobShutdownException.h""
#include ""DataRecordException.h""
#include ""Extractor.h""
#include ""EventBasedExtractor.h""",0
"try {
    mCol->getDecks()->save(mOptionsCopy);
} catch (const std::exception& e) {
    Timber::e(e.what(), ""DeckOptions - RuntimeException on saving conf"");
    AnkiDroidApp::sendExceptionReport(e, ""DeckOptionsSaveConf"");
}","try {
    mCol->getDecks()->save(mOptionsCopy);
} catch (const std::runtime_error& e) {
    Timber::e(e, ""DeckOptions - RuntimeException on saving conf"");
    AnkiDroidApp::sendExceptionReport(e, ""DeckOptionsSaveConf"");
}",0
"```cpp
std::vector<org::mule::extension::http::api::HttpPart> buildParts(const org::mule::extension::http::api::HttpPart& part)
{
    return {part};
}

std::vector<org::mule::extension::http::api::HttpPart> buildParts(const org::mule::extension::http::api::HttpPart& part1, const org::mule::extension::http::api::HttpPart& part2)
{
    return {part1, part2};
}

class CreatePartMessageProcessor : public MessageProcessor
{
public:
    MuleEvent process(MuleEvent event) override
    {
        org::mule::extension::http::api::HttpPart part(TEXT_BODY_FIELD_NAME,
            TEXT_BODY_FIELD_VALUE,
            TEXT_PLAIN.toString(),
            nullptr);
        event.setFlowVariable(""parts"", buildParts(part));
        return event;
    }
};

class CreatePartsMessageProcessor : public MessageProcessor
{
public:
    MuleEvent process(MuleEvent event) override
    {
        org::mule::extension::http::api::HttpPart part1(TEXT_BODY_FIELD_NAME,
            TEXT_BODY_FIELD_VALUE,
            TEXT_PLAIN.toString(),
            nullptr);
        org::mule::extension::http::api::HttpPart part2(FILE_BODY_FIELD_NAME,
            FILE_BODY_FIELD_VALUE.getBytes(),
            APPLICATION_OCTET_STREAM.toString(),
            FILE_BODY_FIELD_FILENAME);
        event.setFlowVariable(""parts"", buildParts(part1, part2));
        return event;
    }
};

class ConvertPartsMessageProcessor : public MessageProcessor
{
public:
    MuleEvent process(MuleEvent event) override
    {
        std::vector<org::mule::extension::http::api::HttpPart> parts;
        auto attrs = static_cast<HttpRequestAttributes*>(event.getMessage().getAttributes());
        for (const auto& entry : attrs->getParts())
        {
            const auto& id = entry.first;
            const auto& dataHandler = entry.second;
            try
            {
                std::string filename;
                if (id != dataHandler.getName())
                {
                    filename = dataHandler.getName();
                }
                org::mule::extension::http::api::HttpPart part(id,
                    dataHandler.getContent(),
                    dataHandler.getContentType(),
                    filename.empty() ? nullptr : filename.c_str());
                parts.push_back(part);
            }
            catch (const std::ios","#include <vector>
#include <list>
#include <string>
#include <memory>
#include <algorithm>

using std::vector;
using std::list;
using std::string;
using std::shared_ptr;
using std::make_shared;

namespace org {
namespace mule {
namespace extension {
namespace http {
namespace api {

struct HttpPart {
    string name;
    std::vector<unsigned char> content;
    string contentType;
    string filename;

    HttpPart(const string& n, const string& v, const string& ct, const string& fn)
        : name(n), content(v.begin(), v.end()), contentType(ct), filename(fn ? fn : """") {}

    HttpPart(const string& n, const std::vector<unsigned char>& v, const string& ct, const string& fn)
        : name(n), content(v), contentType(ct), filename(fn ? fn : """") {}
};

}
}
}
}
}

class Message {
public:
    void setFlowVariable(const string& key, const list<org::mule::extension::http::api::HttpPart>& value);
    void setFlowVariable(const string& key, const vector<org::mule::extension::http::api::HttpPart>& value);
    // getAttributes and other methods...
};

class MuleEvent {
public:
    Message& getMessage();
    void setFlowVariable(const string& key, const list<org::mule::extension::http::api::HttpPart>& value);
    void setFlowVariable(const string& key, const vector<org::mule::extension::http::api::HttpPart>& value);
    // other methods...
};

class MuleException : public std::exception {};

class MessageProcessor {
public:
    virtual MuleEvent process(MuleEvent event) = 0;
    virtual ~MessageProcessor() = default;
};

static list<org::mule::extension::http::api::HttpPart> buildParts(const org::mule::extension::http::api::HttpPart& part)
{
    return list<org::mule::extension::http::api::HttpPart>{part};
}

static list<org::mule::extension::http::api::HttpPart> buildParts(const org::mule::extension::http::api::HttpPart& part1, const org::mule::extension::http::api::HttpPart& part2)
{
    return list<org::mule::extension::http::api::HttpPart>{part1, part2};
}",1
"return builder.addTags(generatedTags).addTags(tags).build();
}

static MetricContext getDefaultMetricContext(const Properties& properties, const std::type_info& klazz) {
    org::apache::gobblin::configuration::State fakeState(properties);
    std::vector<std::shared_ptr<TagBase>> tags;
    MetricContext res = Instrumented::getMetricContext(fakeState, klazz, tags);
    return res;
}","static MetricContext getDefaultMetricContext(const Properties& properties, const std::type_info& klazz) {
    gobblin::configuration::State fakeState(properties);
    std::vector<TagBasePtr> tags;
    MetricContext res = Instrumented::getMetricContext(fakeState, klazz, tags);
    return res;
}",1
"private:
    Journal& journal;
    Meter& filteredOutMessages;
    Timer& executionTime;
    MetricRegistry& metricRegistry;
    ConfigurationStateUpdater& stateUpdater;","class PipelineInterpreter : public MessageProcessor {
private:
    Journal& journal;
    Meter& filteredOutMessages;
    Timer& executionTime;
    MetricRegistry& metricRegistry;
    ConfigurationStateUpdater& stateUpdater;

public:
    PipelineInterpreter(Journal& journal,
                        Meter& filteredOutMessages,
                        Timer& executionTime,
                        MetricRegistry& metricRegistry,
                        ConfigurationStateUpdater& stateUpdater)
        : journal(journal),
          filteredOutMessages(filteredOutMessages),
          executionTime(executionTime),
          metricRegistry(metricRegistry),
          stateUpdater(stateUpdater) {}
};",0
"FSUtils::fs = fs;
}

static std::shared_ptr<FileSystem> getFs(const std::string& path) {
    if (fs != nullptr) {
        return fs;
    }
    Configuration conf;
    conf.set(""fs.hdfs.impl"", ""org.apache.hadoop.hdfs.DistributedFileSystem"");
    conf.set(""fs.file.impl"", ""org.apache.hadoop.fs.LocalFileSystem"");
    return getFs(path, conf);
}

static std::shared_ptr<FileSystem> getFs(const std::string& path, const Configuration& conf) {
    if (fs != nullptr) {
        return fs;
    }
    std::shared_ptr<FileSystem> fsLocal;
    try {
        fsLocal = Path(path).getFileSystem(conf);
    } catch (const IOException& e) {
        throw HoodieIOException(""Failed to get instance of FileSystem"", e);
    }
    return fsLocal;
}","```cpp
#include <memory>
#include <string>
#include <stdexcept>

class FileSystem {
public:
    static std::shared_ptr<FileSystem> get(const Configuration& conf);
};

class Path {
public:
    Path(const std::string& path);
    std::shared_ptr<FileSystem> getFileSystem(const Configuration& conf);
};

class FSUtils {
private:
    static std::shared_ptr<FileSystem> fs;

public:
    static void setFs(std::shared_ptr<FileSystem> filesystem) {
        fs = filesystem;
    }

    static std::shared_ptr<FileSystem> getFs(const std::string& path) {
        if (fs) {
            return fs;
        }
        Configuration conf;
        conf.set(""fs.hdfs.impl"", ""org.apache.hadoop.hdfs.DistributedFileSystem"");
        conf.set(""fs.file.impl"", ""org.apache.hadoop.fs.LocalFileSystem"");
        return getFs(path, conf);
    }

    static std::shared_ptr<FileSystem> getFs(const std::string& path, const Configuration& conf) {
        if (fs) {
            return fs;
        }
        try {
            std::shared_ptr<FileSystem> filesystem = Path(path).getFileSystem(conf);
            return filesystem;
        } catch (const std::exception& e) {
            throw std::runtime_error(
                std::string(""Failed to get instance of FileSystem: "") + e.what()
            );
        }
    }
};

std::shared_ptr<FileSystem> FSUtils::fs = nullptr;
```",1
"}
    
std::optional<IndexedRecord> getIndexedRecord(const HoodieRecord<T>& hoodieRecord) {
    auto recordMetadata = hoodieRecord.getData().getMetadata();
    try {
        auto avroRecord = hoodieRecord.getData().getInsertValue(schema);","```cpp
std::optional<RecordMetadata> recordMetadata = hoodieRecord.getData().getMetadata();
try {
    std::optional<IndexedRecord> avroRecord = hoodieRecord.getData().getInsertValue(schema);
```",0
"std::set<IpSubnet> trustedProxies;

std::set<std::string> deactivatedBuiltinAuthenticationProviders;

bool isMaster() const {
    return isMaster_;
}","class Configuration : public BaseConfiguration {
private:
    std::set<IpSubnet> trustedProxies;
    std::set<std::string> deactivatedBuiltinAuthenticationProviders;

public:
    Configuration()
        : trustedProxies(),
          deactivatedBuiltinAuthenticationProviders()
    {}

    bool isMaster() const {
        return isMaster;
    }
};",1
"RootBeanDefinition beanDefinition;
beanDefinition.setBeanClass(beanClass);
beanDefinition.setLazyInit(false);

std::string id = generateId(element, parserContext, beanClass, required);

if (StringUtils::isNotEmpty(id)) {
    if (parserContext.getRegistry().containsBeanDefinition(id)) {
        throw std::runtime_error(""Duplicate spring bean id "" + id);
    }
}","```cpp
RootBeanDefinition beanDefinition;
beanDefinition.setBeanClass(beanClass);
beanDefinition.setLazyInit(false);
std::string id = generateId(element, parserContext, beanClass, required);

if (!id.empty()) {
    if (parserContext.getRegistry().containsBeanDefinition(id)) {
        throw std::runtime_error(""Duplicate spring bean id "" + id);
    }
}
```",0
"try {
  // ...
} catch (const std::ios_base::failure& ioe) {
  LOGGER.error(std::string(""Failed to shutdown the "") + typeid(GobblinYarnAppLauncher).name(), ioe);
} catch (const TimeoutException& te) {
  LOGGER.error(""Timeout in stopping the service manager"", te);
} catch (...) {
  throw;
} finally {
  gobblinYarnAppLauncher.sendEmailOnShutdown(std::nullopt);
}","```cpp
try {
  LOGGER.error(""Failed to shutdown the {}"", typeid(GobblinYarnAppLauncher).name(), ioe);
} catch (const TimeoutException& te) {
  LOGGER.error(""Timeout in stopping the service manager"", te);
} catch (...) {
  gobblinYarnAppLauncher.sendEmailOnShutdown(std::nullopt);
  throw;
}
gobblinYarnAppLauncher.sendEmailOnShutdown(std::nullopt);
```",0
"```cpp
#include <string>
#include <optional>
#include <functional>

template<typename T>
class BaseDeclaration
{
public:
    template<typename Property>
    std::optional<Property> getModelProperty() const;
};

class DeclaringMemberModelProperty
{
public:
    struct DeclaringField {
        std::string getName() const;
    };
    DeclaringField getDeclaringField() const;
};

template<typename T>
std::string getMemberName(const BaseDeclaration<T>& declaration, const std::string& defaultName)
{
    auto prop = declaration.getModelProperty<DeclaringMemberModelProperty>();
    if (prop)
    {
        return prop->getDeclaringField().getName();
    }
    return defaultName;
}
```","#include <string>
#include <optional>

template <typename T>
class BaseDeclaration
{
public:
    std::optional<std::string> getModelProperty() const;
};

class DeclaringField
{
public:
    std::string getName() const;
};

class DeclaringMemberModelProperty
{
public:
    DeclaringField getDeclaringField() const;
};

std::string getMemberName(const BaseDeclaration<DeclaringMemberModelProperty>& declaration, const std::string& defaultName)
{
    auto prop = declaration.getModelProperty();
    if (prop.has_value())
        return prop.value();
    else
        return defaultName;
}",0
"#include ""org/mule/runtime/core/api/util/ClassUtils.h""
#include ""org/mule/runtime/module/extension/internal/util/MuleExtensionUtils.h""
#include ""org/mule/runtime/module/tooling/internal/config/params/ParameterExtractor.h""
#include ""org/mule/runtime/module/tooling/internal/config/params/ParameterSimpleValueExtractor.h""

#include ""org/mule/metadata/java/api/JavaTypeLoader.h""
#include ""org/mule/runtime/api/component/location/ConfigurationComponentLocator.h""
#include ""org/mule/runtime/api/connection/ConnectionValidationResult.h""","#include <memory>
#include <string>
#include <utility>

using std::string;
using std::unique_ptr;",0
"{
    if (!name.empty())
        setActive(getByName(name));
    if (!hasActiveEditor())
    {
        if (activeColumn_ == nullptr)","if (!StringUtil::isNullOrEmpty(name))
    setActive(getByName(name));

if (!hasActiveEditor())
{
    if (activeColumn_ == nullptr)
    {
        // ...
    }
}",0
"/ *
 * The SpannerWriteResult object contains the results of the transform,
 * including a PCollection of MutationGroups that failed to write, and a PCollection
 * that can be used in batch pipelines as a completion signal to Wait::OnSignal to indicate when all input has been written.
 * Note that in streaming pipelines, this signal will never be triggered as the input is unbounded
 * and this PCollection is using the GlobalWindow.
 *
 * <h3>Batching</h3>
 * /","#include <string>
#include <vector>

class SpannerWriteResult {
    // The SpannerWriteResult object contains the results of the transform,
    // including a vector of MutationGroups that failed to write,
    // and another container that can be used in batch pipelines as a completion signal to
    // Wait::OnSignal to indicate when all input has been written.
    // Note that in streaming pipelines, this signal will never be triggered as the input is unbounded
    // and this container is using the GlobalWindow.

public:
    std::vector<std::string> failed_mutation_groups;
    std::vector<std::string> completion_signals; // Used as a completion signal in batch pipelines.

    // ...
};",1
"#include <hudi/avro/model/HoodieCompactionPlan.h>
#include <hudi/cli/HoodieCLI.h>
#include <hudi/cli/HoodiePrintHelper.h>
#include <hudi/cli/HoodieTableHeaderFields.h>
#include <hudi/cli/TableHeader.h>
#include <hudi/cli/commands/SparkMain/SparkCommand.h>
#include <hudi/cli/utils/CommitUtil.h>","#include ""HoodieCompactionOperation.h""
#include ""HoodieCompactionPlan.h""
#include ""HoodieCLI.h""
#include ""HoodiePrintHelper.h""
#include ""HoodieTableHeaderFields.h""
#include ""TableHeader.h""
#include ""SparkCommand.h""
#include ""CommitUtil.h""",0
"std::string query = ""SELECT c.id, n.id, n.mid, c.did, c.ord, n.tags, n.flds FROM cards c, notes n WHERE c.nid == n.id "" + where;
sqlite3_stmt* stmt;
sqlite3_prepare_v2(db, query.c_str(), -1, &stmt, nullptr);
while (sqlite3_step(stmt) == SQLITE_ROW) {
    data.push_back({
        sqlite3_column_int64(stmt, 0),
        sqlite3_column_int64(stmt, 1),
        getModels().at(sqlite3_column_int64(stmt, 2)),
        sqlite3_column_int64(stmt, 3),
        sqlite3_column_int(stmt, 4),
        reinterpret_cast<const char*>(sqlite3_column_text(stmt, 5)),
        reinterpret_cast<const char*>(sqlite3_column_text(stmt, 6))
    });
}
sqlite3_finalize(stmt);","std::vector<std::tuple<long long, long long, Model, long long, int, std::string, std::string>> data;
auto cur = db.executeQuery(
    ""SELECT c.id, n.id, n.mid, c.did, c.ord, ""
    ""n.tags, n.flds FROM cards c, notes n WHERE c.nid == n.id "" + where);

while (cur->moveToNext()) {
    data.emplace_back(
        cur->getLong(0),
        cur->getLong(1),
        getModels().get(cur->getLong(2)),
        cur->getLong(3),
        cur->getInt(4),
        cur->getString(5),
        cur->getString(6)
    );
}",1
"#include <string>
#include <memory>",#include <string>,0
"class UuidToDBObjectConverter : public Converter<UUID, DBObject> {
public:
    DBObject convert(const UUID& source) override {
        BasicDBObject dbObject;
        dbObject.put(""_value"", source.toString());
        dbObject.put(""_class"", typeid(source).name());
        return dbObject;
    }
};

class DBObjectToUUIDConverter : public Converter<DBObject, UUID> {
public:
    UUID convert(const DBObject& source) override {
        UUID id = UUID::fromString(source.get<std::string>(""_value""));
        return id;
    }
};","#include <string>
#include <map>
#include <any>
#include <memory>
#include <uuid/uuid.h>

class ConverterBase {
public:
    virtual ~ConverterBase() = default;
};

class UUID {
public:
    UUID(const std::string& str) { uuid_parse(str.c_str(), uuid); }
    static UUID fromString(const std::string& str) { return UUID(str); }
    std::string toString() const {
        char str[37];
        uuid_unparse(uuid, str);
        return std::string(str);
    }
    const std::type_info& getClass() const { return typeid(*this); }
private:
    uuid_t uuid;
};

using DBObject = std::map<std::string, std::any>;

class UuidToDBObjectConverter : public ConverterBase {
public:
    DBObject convert(const UUID& source) {
        DBObject dbObject;
        dbObject[""_value""] = source.toString();
        dbObject[""_class""] = source.getClass().name();
        return dbObject;
    }
};

class DBObjectToUUIDConverter : public ConverterBase {
public:
    UUID convert(const DBObject& source) {
        auto it = source.find(""_value"");
        if (it != source.end()) {
            return UUID::fromString(std::any_cast<std::string>(it->second));
        }
        throw std::runtime_error(""Missing _value in DBObject"");
    }
};",1
"this->pattern = (this->pattern ? std::regex(this->pattern->pattern(), flags) : std::nullopt);
}

public:
void setValue(const std::string& value)
{
    this->value = AttributeEvaluator(value);
}

bool operator==(const RegExFilter& other) const
{
    if (this == &other)
    {
        return true;
    }

    if (typeid(*this) != typeid(other))
    {
        return false;
    }

    bool patternsAreEqual = ClassUtils::equal(pattern.pattern(), other.pattern.pattern());
    bool flagsAreEqual = (flags == other.flags);
    bool valuesAreEquals = areValuesEqual(value, other.value);
    return (patternsAreEqual && flagsAreEqual && valuesAreEquals);
}

void setMuleContext(MuleContext* context)
{
    this->muleContext = context;
}

std::size_t hashCode() const
{
    return hash_combine(typeid(*this).hash_code(), pattern, value ? value->getRawValue() : """");
}

private:
bool areValuesEqual(const std::optional<AttributeEvaluator>& value1, const std::optional<AttributeEvaluator>& value2) const
{
    if (!value1)
    {
        return !value2;
    }
    else
    {
        if (!value2)
        {
            return false;
        }
        if (value1->getRawValue().empty())
        {
            return value2->getRawValue().empty();
        }
        return value1->getRawValue() == value2->getRawValue();
    }
}
};","class RegExFilter : public Filter, public ObjectFilter
{
public:
    RegExFilter() : pattern_(), flags_(0), value_(), muleContext_(nullptr) {}

    void setValue(const std::string& value)
    {
        value_ = AttributeEvaluator(value);
    }

    bool operator==(const RegExFilter& other) const
    {
        if (this == &other)
        {
            return true;
        }
        bool patternsAreEqual = (pattern_.pattern() == other.pattern_.pattern());
        bool flagsAreEqual = (flags_ == other.flags_);
        bool valuesAreEquals = areValuesEqual(value_, other.value_);
        return (patternsAreEqual && flagsAreEqual && valuesAreEquals);
    }

    void setMuleContext(MuleContext* context)
    {
        muleContext_ = context;
    }

    std::size_t hashCode() const
    {
        std::size_t seed = 0;
        hash_combine(seed, typeid(*this).hash_code(), pattern_, value_ ? value_->getRawValue() : std::string());
        return seed;
    }

private:
    bool areValuesEqual(const std::optional<AttributeEvaluator>& value1, const std::optional<AttributeEvaluator>& value2) const
    {
        if (!value1)
        {
            return !value2;
        }
        else
        {
            if (!value2)
            {
                return false;
            }
            if (!value1->getRawValue())
            {
                return !value2->getRawValue();
            }
            return value1->getRawValue() == value2->getRawValue();
        }
    }

    Pattern pattern_;
    int flags_;
    std::optional<AttributeEvaluator> value_;
    MuleContext* muleContext_;

    template <typename T>
    static void hash_combine(std::size_t& seed, const T& v)
    {
        std::hash<T> hasher;
        seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
    }

    template <typename T, typename... Rest>
    static void hash_combine(std::size_t& seed, const T& v, const Rest&... rest)
    {
        hash_combine(seed, v);
        hash_combine(seed, rest...);
    }
};",1
"#include <cassert>
#include <functional>
#include <typeinfo>","#include <gtest/gtest.h>
#include <cassert>",0
"if (windmillBinary) {
    filesToStage.push_back(""windmill_main="" + windmillBinary);
}
int uploadSizeBytes = (options.getGcsUploadBufferSizeBytes() == nullptr)
    ? 1024 * 1024
    : std::min(*options.getGcsUploadBufferSizeBytes(), 1024 * 1024);
auto util = GcsUtilFactory::create(
    Transport::newStorageClient(options).build(),
    options.getExecutorService(),
    uploadSizeBytes);
return PackageUtil::stageClasspathElements(
    options.getFilesToStage(), options.getStagingLocation(), util
);","if (windmillBinary != nullptr) {
    filesToStage.push_back(""windmill_main="" + windmillBinary);
}
int uploadSizeBytes = (options.getGcsUploadBufferSizeBytes() == nullptr)
    ? 1024 * 1024
    : std::min(options.getGcsUploadBufferSizeBytes(), 1024 * 1024);
auto util = GcsUtilFactory::create(
    Transport::newStorageClient(options).build(),
    options.getExecutorService(),
    uploadSizeBytes);
return PackageUtil::stageClasspathElements(
    options.getFilesToStage(), options.getStagingLocation(), util);",1
"#include <vector>
#include <optional>","#include <vector>
#include <optional>",0
"template<typename T>
T getConnection(const ConfigurationInstance& config) {
    auto* connectionHandler = connectionManager.getConnection(config.getValue());
    void* connection = connectionHandler->getConnection();
    Reference<void> connReference(connection);
    withLock(lock, [&] {
        auto it = connections.find(connReference);
        if (it == connections.end()) {
            connections.emplace(connReference, std::make_pair(std::make_shared<std::atomic<int>>(0), connectionHandler));
            it = connections.find(connReference);
        }
        it->second.first->fetch_add(1);
    });
    return static_cast<T>(connection);
}","template<typename T>
T getConnection(const ConfigurationInstance& config) {
    auto connectionHandler = connectionManager.getConnection(config.getValue());
    auto connection = connectionHandler->getConnection();
    auto connReference = std::make_shared<Reference<void>>(connection);
    withLock(lock, [&] {
        auto it = connections.find(connReference);
        if (it == connections.end()) {
            auto pair = std::make_pair(std::make_shared<std::atomic<int>>(0), connectionHandler);
            it = connections.emplace(connReference, pair).first;
        }
        it->second.first->fetch_add(1);
    });
    return static_cast<T>(connection);
}",1
"return std::unordered_map<std::string, ErrorHandler*>{{""errorHandlerFromConfig"", errorHandler}};
}

private:
MuleContext* muleContextSpy;

void SetUp() override {
    muleContextSpy = ::testing::NiceMock<MuleContext*>(muleContext);
    transformer.setMuleContext(muleContextSpy);
}

TEST_F(YourTestFixture, reusesDefaultFlowConstruct) {
    transform();
    transform();
    transform();
    EXPECT_CALL(*muleContextSpy, getDefaultErrorHandler(::testing::_)).Times(1);
}

TEST_F(YourTestFixture, doesntCreateTransformationEventIfEventProvided) {
    transformer.transform(Message::of(new Object()), defaultCharset(), testEvent());
    EXPECT_THAT(builTransformationtEvent, ::testing::IsNull());
}

TEST_F(YourTestFixture, createsTransformationEventIfEventNotProvided) {
    transformer.transform(Message::of(new Object()), defaultCharset(), nullptr);
    EXPECT_THAT(builTransformationtEvent, ::testing::NotNull());
    EXPECT_THAT(builTransformationtEvent->getContext()->isTerminated(), ::testing::IsTrue());
}

void transform() {
    EXPECT_THAT(transformer.transform(Message::of(new Object()), defaultCharset(), nullptr), ::testing::ContainerEq(BYTES));
}","#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <map>
#include <string>
#include <memory>

using namespace testing;

class AbstractMessageTransformerTestCase : public ::testing::Test {
protected:
    std::shared_ptr<MuleContext> muleContextSpy;
    std::unique_ptr<Transformer> transformer;
    std::shared_ptr<TransformationEvent> builTransformationtEvent;

    virtual void SetUp() override {
        muleContextSpy = std::make_shared<NiceMock<MuleContextMock>>(*muleContext);
        transformer->setMuleContext(muleContextSpy);
    }

    std::map<std::string, std::shared_ptr<ErrorHandler>> getErrorHandlerFromConfig() {
        return { {""errorHandlerFromConfig"", errorHandler} };
    }

    void transform() {
        ASSERT_THAT(transformer->transform(Message::of(std::make_shared<Object>()), defaultCharset(), nullptr), Eq(BYTES));
    }

public:
    // Members errorHandler, muleContext, etc. are assumed to be defined elsewhere.
};

TEST_F(AbstractMessageTransformerTestCase, reusesDefaultFlowConstruct) {
    transform();
    transform();
    transform();
    EXPECT_CALL(*muleContextSpy, getDefaultErrorHandler(_)).Times(1);
}

TEST_F(AbstractMessageTransformerTestCase, doesntCreateTransformationEventIfEventProvided) {
    transformer->transform(Message::of(std::make_shared<Object>()), defaultCharset(), testEvent());
    ASSERT_THAT(builTransformationtEvent, IsNull());
}

TEST_F(AbstractMessageTransformerTestCase, createsTransformationEventIfEventNotProvided) {
    transformer->transform(Message::of(std::make_shared<Object>()), defaultCharset(), nullptr);
    ASSERT_THAT(builTransformationtEvent, Not(IsNull()));
    ASSERT_THAT(builTransformationtEvent->getContext()->isTerminated(), Eq(true));
}",1
"return tags;
}

protected:
    const std::string id;
    MetricContext metricContext;","public:
  static void remove(const std::string& id) {
    GobblinMetricsRegistry::getInstance().remove(id);
  }

protected:
  const std::string id;
  MetricContext metricContext;",0
"#include <stdexcept>
#include <string>
#include <vector>
#include <list>
#include <set>
#include <iterator>
#include <map>
#include <memory>
#include <optional>
#include <filesystem>
#include <algorithm>
#include <cstddef>
#include <utility>","#include <string>
#include <vector>
#include <list>
#include <iterator>
#include <memory>
#include <stdexcept>
#include <optional>
#include <algorithm>",0
"} else if (getModel().getExpressionSupport() != NOT_SUPPORTED) {
    if (isExpression(rawValue)) {
        expression.set(extractExpression(rawValue).value());
    } else {
        value.set(rawValue);
    }
}","```cpp
if (getModel().getExpressionSupport() != NOT_SUPPORTED) {
    if (isExpression(rawValue)) {
        expression.set(extractExpression(rawValue).value());
    } else {
        value.set(rawValue);
    }
}
```",1
"#include <optional>
#include <map>
#include <vector>
#include <set>
#include <unordered_set>
#include <functional>
#include <future>
#include <string>
#include <sstream>
#include <algorithm>
#include <iterator>

using std::optional;
using std::map;
using std::vector;
using std::set;
using std::unordered_set;
using std::function;
using std::future;
using std::string;
using std::stringstream;
using std::begin;
using std::end;

template<typename T>
using Collection = std::vector<T>;

template<typename T>
using List = std::vector<T>;

template<typename K, typename V>
using Map = std::map<K, V>;

template<typename T>
using Set = std::unordered_set<T>;

template<typename T>
using Supplier = std::function<T()>;

template<typename T>
using Callable = std::function<T()>;

template<typename T, typename R>
using Function = std::function<R(T)>;

template<typename T>
auto stream(const T& container) {
    return container;
}

struct ValueResolvingException : public std::runtime_error {
    using std::runtime_error::runtime_error;
};

struct MetadataResolverFactoryModelProperty {};
struct NullSafeModelProperty {};
struct SdkSourceFactoryModelProperty {};
struct MutableConfigurationStats {};
struct ComponentExecutorCompletableAdapterFactory {};
struct ReactiveOperationExecutorFactoryWrapper {};
struct ParameterValueResolver {};
struct ResolverSet {};
struct ValueResolver {};
struct ValueResolvingContext {};

struct Joiner {
    static std::string on(const std::string& delim, const std::vector<std::string>& items) {
        std::ostringstream os;
        for (auto it = items.begin(); it != items.end(); ++it) {
            if (it != items.begin())
                os << delim;
            os << *it;
        }
        return os.str();
    }
};

template<typename T>
auto ImmutableList(const std::vector<T>& v) {
    return v;
}

template<typename K, typename V>
auto ImmutableMap(const std::map<K,V>& m) {
    return m;
}","#include <map>
#include <vector>
#include <set>
#include <list>
#include <optional>
#include <functional>
#include <future>
#include <string>
#include <algorithm>
#include <iterator>
#include <sstream>
#include <memory>
#include <utility>

using std::map;
using std::vector;
using std::set;
using std::list;
using std::optional;
using std::function;
using std::future;
using std::string;
using std::pair;
using std::shared_ptr;
using std::make_shared;",0
"#include <vector>
#include <memory>

class CustomNodeDefinition {};

class ObservableCollection {
public:
    using value_type = CustomNodeDefinition;
    ObservableCollection() = default;
    // Implement methods as needed to be observable
    std::vector<CustomNodeDefinition>& get() { return data_; }
    const std::vector<CustomNodeDefinition>& get() const { return data_; }
    void set(const std::vector<CustomNodeDefinition>& newData) { data_ = newData; }

private:
    std::vector<CustomNodeDefinition> data_;
};

class MyClass {
private:
    ObservableCollection customNodeDefinitions;

public:
    ObservableCollection& CustomNodeDefinitions() {
        return customNodeDefinitions;
    }
    void CustomNodeDefinitions(const ObservableCollection& value) {
        customNodeDefinitions = value;
    }
};","#include <vector>
#include <memory>

class CustomNodeDefinition {};

template<typename T>
class ObservableCollection : public std::vector<T> {
    // Implement notification mechanisms if needed
};

class SomeClass {
private:
    ObservableCollection<std::shared_ptr<CustomNodeDefinition>> customNodeDefinitions;

public:
    ObservableCollection<std::shared_ptr<CustomNodeDefinition>>& getCustomNodeDefinitions() {
        return customNodeDefinitions;
    }

    void setCustomNodeDefinitions(const ObservableCollection<std::shared_ptr<CustomNodeDefinition>>& value) {
        customNodeDefinitions = value;
    }
};",1
"std::vector<IncomingMessage> incomingMessages;
incomingMessages.reserve(response.getReceivedMessages().size());
for (const auto& message : response.getReceivedMessages()) {
    const PubsubMessage& pubsubMessage = message.getMessage();
    std::map<std::string, std::string> attributes;
    if (pubsubMessage.getAttributes() != nullptr) {
        attributes = *pubsubMessage.getAttributes();
    } else {
        attributes = std::map<std::string, std::string>();
    }

    std::vector<uint8_t> elementBytes;
    if (pubsubMessage.getData() == nullptr) {
        elementBytes = std::vector<uint8_t>();
    } else {
        elementBytes = pubsubMessage.decodeData();
    }
}","std::vector<IncomingMessage> incomingMessages;
incomingMessages.reserve(response.getReceivedMessages().size());
for (const auto& message : response.getReceivedMessages()) {
    const PubsubMessage& pubsubMessage = message.getMessage();
    std::map<std::string, std::string> attributes;
    if (pubsubMessage.getAttributes()) {
        attributes = *pubsubMessage.getAttributes();
    } else {
        attributes = std::map<std::string, std::string>{};
    }

    std::optional<std::vector<uint8_t>> elementBytes = pubsubMessage.getData() 
        ? std::optional<std::vector<uint8_t>>(pubsubMessage.decodeData()) 
        : std::nullopt;
}",1
"std::cout << ""===============> Showing only "" << limit << "" archived commits <==============="" << std::endl;
std::string basePath = HoodieCLI::getTableMetaClient().getBasePath();
std::filesystem::path archivePath = basePath + ""/.hoodie/.commits_.archive*"";
if (!folder.empty()) {
    archivePath = basePath + ""/.hoodie/"" + folder;
}","#include <iostream>
#include <string>

void showArchivedCommits(int limit, const std::string& folder, bool headerOnly) {
    std::cout << ""===============> Showing only "" << limit << "" archived commits <==============="" << std::endl;
    std::string basePath = HoodieCLI::getTableMetaClient().getBasePath();
    std::string archivePath = basePath + ""/.hoodie/.commits_.archive*"";
    if (!folder.empty()) {
        archivePath = basePath + ""/.hoodie/"" + folder;
    }
    // ... rest of the function ...
}",0
"void setHeaderExpressions(const std::map<std::string, Expression>& headerExpressions) {
    assert(!headerExpressions.empty() && ""'headerExpressions' must not be null"");
    this->headerExpressions.clear();
    this->headerExpressions.insert(headerExpressions.begin(), headerExpressions.end());
}

std::string getRequestChannelName() {","void setHeaderExpressions(const std::map<std::string, Expression>& headerExpressions) {
    if (&headerExpressions == nullptr) {
        throw std::invalid_argument(""'headerExpressions' must not be null"");
    }
    this->headerExpressions.clear();
    this->headerExpressions.insert(headerExpressions.begin(), headerExpressions.end());
}",1
"```cpp
#include <regex>
#include <string>
#include <locale>

std::string removeFormattingFromMathjax(const std::string& txt, const std::string& ord);

std::string clozeText(std::string txt, const std::string& ord, char type)
{
    static const std::string clozeReg = /* your regex pattern here */;
    std::regex pattern1((std::ostringstream() << clozeReg).str(), std::regex_constants::icase | std::regex_constants::dotall);
    std::smatch n;
    if (!std::regex_search(txt, n, pattern1)) {
        return """";
    }

    txt = removeFormattingFromMathjax(txt, ord);

    std::regex pattern2((std::ostringstream() << clozeReg).str(), std::regex_constants::icase | std::regex_constants::dotall);

    std::string result;
    std::string::const_iterator searchStart( txt.cbegin() );
    std::smatch m;
    while (std::regex_search(searchStart, txt.cend(), m, pattern2)) {
        result.append(m.prefix().str());
        std::string buf;
        if (type == 'q') {
            if (!m[4].str().empty()) {
                buf = ""["" + m[4].str() + ""]"";
            } else {
                buf = ""[...]"";
            }
        } else {
            buf = m[2].str();
        }
        std::string replacement;
        if (m[1].str() == ""c"") {
            replacement = ""<span class=cloze>"" + buf + ""</span>"";
        } else {
            replacement = buf;
        }
        result.append(replacement);
        searchStart = m.suffix().first;
    }
    result.append(std::string(searchStart, txt.cend()));

    // Now replace all remaining cloze patterns with $2 (2nd group)
    std::regex patternFinal((std::ostringstream() << clozeReg.substr(0, clozeReg.size()) << ""\\d+"").str(), std::regex_constants::icase | std::regex_constants::dotall);
    result = std::regex_replace(result, patternFinal, ""$2"");
    return result;
}

std::string removeFormattingFromMathjax(const std::string& txt, const std::string& ord)
{
    // This assumes clozeReg is defined in this scope, and you have an equivalent for Pattern.quote,","#include <regex>
#include <string>
#include <sstream>
#include <locale>

std::string clozeReg = /* your clozeReg pattern here */;

std::string removeFormattingFromMathjax(const std::string& txt, const std::string& ord) {
    std::string result = txt;
    // look for clozes wrapped in mathjax, and change {{cx to {{Cx
    const char* openings[] = {""\\("", ""\\[""};
    const char* closings[] = {""\\)"", ""\\]""};

    std::string creg = clozeReg;
    // Java removes (?si), so let's do that
    size_t pos;
    while ((pos = creg.find(""(?si)"")) != std::string::npos) {
        creg.erase(pos, 5);
    }

    std::stringstream regexBuilder;
    regexBuilder << R""((\\[)"";
    regexBuilder << R""((\[\(])""; // One of [ or (
    regexBuilder << R""()(.*?)"";
    regexBuilder << std::regex_replace(creg, std::regex(""\\(\\?si\\)""), """");
    regexBuilder << R""((.*?)(\\[)"";
    regexBuilder << R""((\]\\)])"";
    regexBuilder << R""())"";

    // Due to complexity, let's use a simple approach for this translation.
    // In practice, this may need further adaptation to match original Java's behavior.
    // We'll use a regex to find {{cx...}} inside mathjax delimiters and replace with {{Cx...}}

    std::regex mathjaxCloze(R""((\\[\[\(])(.*?)(\{\{c)([0-9]+)::(.*?)}\}(.*?)(\\[\]\)]))"", std::regex::icase);
    std::string output;
    std::sregex_iterator it(result.begin(), result.end(), mathjaxCloze), end;
    std::string::const_iterator lastPos = result.begin();

    while (it != end) {
        output.append(lastPos, it->prefix().second);
        std::string replacement = it->str();
        size_t clozePos = replacement.find(""{{c"");
        if (clozePos != std::string::npos)
            replacement.replace(clozePos, 3, ""{{C"");
        output.append(replacement);
        lastPos = it->suffix().first;
        ++it;
    }
    output.append(lastPos",1
"#include <string>
#include <map>
#include <vector>
#include <memory>
#include <stdexcept>
#include <fstream>
#include <sstream>","#include <string>
#include <algorithm>
#include <memory>
#include <vector>
#include <map>
#include <sstream>
#include <fstream>
#include <stdexcept>",0
"BeamIOType getSourceType() override {
    return BeamIOType::BOUNDED;
}

PCollection<BeamSqlRow> buildIOReader(Pipeline* pipeline) override {
    return PBegin::in(pipeline).apply(
        ""MockedBeamSQLTable_Reader_"" + std::to_string(COUNTER.incrementAndGet()), Create::of(inputRecords));
}","BeamIOType getSourceType() const override {
    return BeamIOType::BOUNDED;
}

PCollection<BeamSqlRow> buildIOReader(Pipeline& pipeline) override {
    return PBegin::in(pipeline).apply(
        ""MockedBeamSQLTable_Reader_"" + std::to_string(COUNTER.incrementAndGet()),
        Create::of(inputRecords)
    );
}",1
"#include <string>
#include <memory>
#include <filesystem>","#include ""Artifact.h""
#include ""MojoExecution.h""
#include ""MavenProject.h""
#include ""LocalArtifactRepository.h""
#include ""ILogger.h""
#include ""Logger.h""
#include ""WorkspaceReader.h""
#include ""WorkspaceRepository.h""
#include ""IFolder.h""",0
"private:
    const PMap<SymbolicValue, int> references;
    SymbolicValue exitSymbolicValue;
    const PMap<Symbol, SymbolicValue> values;
    const PMap<SymbolicValue, PMap<std::type_index, std::shared_ptr<Constraint>>> constraints;

    ProgramState(
        const PMap<Symbol, SymbolicValue>& values,
        const PMap<SymbolicValue, int>& references,
        const PMap<SymbolicValue, PMap<std::type_index, std::shared_ptr<Constraint>>>& constraints,
        const PMap<ProgramPoint, int>& visitedPoints,
        const PStack<SymbolicValue>& stack,
        const SymbolicValue& exitSymbolicValue
    )
        : values(values),
          references(references),
          constraints(constraints),
          exitSymbolicValue(exitSymbolicValue)
    {}","```cpp
#include <map>
#include <memory>
#include <typeindex>
#include <stack>

template<typename K, typename V>
using PMap = std::map<K, V>;

template<typename T>
using PStack = std::stack<T>;

class Symbol {};
class SymbolicValue {};
class Constraint {};
class ProgramPoint {};

class ProgramState {
private:
    const PMap<SymbolicValue, int> references;
    SymbolicValue* exitSymbolicValue;
    const PMap<Symbol, SymbolicValue> values;
    const PMap<SymbolicValue, PMap<std::type_index, std::unique_ptr<Constraint>>> constraints;

    ProgramState(
        PMap<Symbol, SymbolicValue> values,
        PMap<SymbolicValue, int> references,
        PMap<SymbolicValue, PMap<std::type_index, std::unique_ptr<Constraint>>> constraints,
        PMap<ProgramPoint, int> visitedPoints,
        PStack<SymbolicValue> stack,
        SymbolicValue* exitSymbolicValue
    )
        : values(std::move(values)),
          references(std::move(references)),
          constraints(std::move(constraints)),
          exitSymbolicValue(exitSymbolicValue)
    {}
};
```",0
"return t;
}

private:
void addVariableToList(const VariableDeclarationExpression& e2, std::vector<VariableTreeImpl>& list) {
    auto modifiers = convertModifiers(e2.modifiers());
    auto type = convertType(e2.getType());

    for (size_t i = 0; i < e2.fragments().size(); ++i) {
        auto* fragment = static_cast<VariableDeclarationFragment*>(e2.fragments()[i]);
        VariableTreeImpl t(createSimpleName(fragment->getName()));
        t.completeModifiers(modifiers);
        if (fragment->getInitializer() == nullptr) {
            t.completeType(type);","```cpp
void addVariableToList(const VariableDeclarationExpression& e2, std::vector<VariableTreeImpl*>& list) {
    ModifiersTreeImpl modifiers = convertModifiers(e2.modifiers());
    TypeTree type = convertType(e2.getType());

    for (size_t i = 0; i < e2.fragments().size(); ++i) {
        auto* fragment = static_cast<VariableDeclarationFragment*>(e2.fragments()[i]);
        auto* t = new VariableTreeImpl(createSimpleName(fragment->getName()));
        t->completeModifiers(modifiers);
        if (fragment->getInitializer() == nullptr) {
            t->completeType(type);
        }
        list.push_back(t);
    }
}
```",0
"mailProps.setContent(content);
mailProps.setContentType(""text/plain"");

if (recipients == nullptr) {
    return;
}

std::set<MailAddress> addresses;
for (const std::string& recipient : *recipients) {
    addresses.insert(MailAddress(recipient));
}","mailProps.setContent(content);
mailProps.setContentType(""text/plain"");

if (recipients == nullptr) {
    return;
}

std::set<MailAddress> addresses;
for (const auto& recipient : *recipients) {
    addresses.insert(MailAddress(recipient));
}",1
"```cpp
template <typename T>
ClusterInvoker<T>* buildClusterInvokerChain(ClusterInvoker<T>* originalInvoker, const std::string& key, const std::string& group) {
    ClusterInvoker<T>* last = originalInvoker;
    URL url = originalInvoker->getUrl();
    std::vector<ModuleModel*> moduleModels = getModuleModelsFromUrl(url);
    std::vector<ClusterFilter*> filters;
    if (!moduleModels.empty()) {
        for (ModuleModel* moduleModel : moduleModels) {
            std::vector<ClusterFilter*> tempFilters = ScopeModelUtil::getExtensionLoader<ClusterFilter>(moduleModel)->getActivateExtension(url, key, group);
            filters.insert(filters.end(), tempFilters.begin(), tempFilters.end());
        }
    } else {
        std::vector<ClusterFilter*> tempFilters = ScopeModelUtil::getExtensionLoader<ClusterFilter>(nullptr)->getActivateExtension(url, key, group);
        filters.insert(filters.end(), tempFilters.begin(), tempFilters.end());
    }
    if (!filters.empty()) {
        for (int i = static_cast<int>(filters.size()) - 1; i >= 0; --i) {
            ClusterFilter* filter = filters[i];
            Invoker<T>* next = last;
            // body of loop as needed
        }
    }
    return last;
}
```","```cpp
template <typename T>
std::shared_ptr<ClusterInvoker<T>> buildClusterInvokerChain(
    const std::shared_ptr<ClusterInvoker<T>>& originalInvoker,
    const std::string& key, const std::string& group)
{
    std::shared_ptr<ClusterInvoker<T>> last = originalInvoker;
    URL url = originalInvoker->getUrl();

    std::vector<std::shared_ptr<ModuleModel>> moduleModels = getModuleModelsFromUrl(url);
    std::vector<std::shared_ptr<ClusterFilter>> filters;

    if (!moduleModels.empty()) {
        for (const auto& moduleModel : moduleModels) {
            auto tempFilters = ScopeModelUtil::getExtensionLoader<ClusterFilter>(moduleModel)
                ->getActivateExtension(url, key, group);
            filters.insert(filters.end(), tempFilters.begin(), tempFilters.end());
        }
    } else {
        auto tempFilters = ScopeModelUtil::getExtensionLoader<ClusterFilter>(nullptr)
            ->getActivateExtension(url, key, group);
        filters.insert(filters.end(), tempFilters.begin(), tempFilters.end());
    }

    if (!filters.empty()) {
        for (auto it = filters.rbegin(); it != filters.rend(); ++it) {
            auto filter = *it;
            auto next = last;
            // (presumably further processing with filter and next happens here)
        }
    }

    return last;
}
```",0
"#include <string>

static const std::string DESTINATION_DATA_PATH_KEY = ""destination.dataPath"";
static const std::string CLUSTER_BY_KEY = ""clusterByList"";
static const std::string NUM_BUCKETS_KEY = ""numBuckets"";
static const std::string EVOLUTION_ENABLED = ""evolution.enabled"";

static const std::string HIVE_RUNTIME_PROPERTIES_KEY_PREFIX = ""hiveRuntime"";
const std::string destinationFormat;","```cpp
class ConvertibleHiveDataset : public HiveDataset {
public:
    static constexpr const char* DESTINATION_DATA_PATH_KEY = ""destination.dataPath"";
    static constexpr const char* CLUSTER_BY_KEY = ""clusterByList"";
    static constexpr const char* NUM_BUCKETS_KEY = ""numBuckets"";
    static constexpr const char* EVOLUTION_ENABLED = ""evolution.enabled"";

private:
    static constexpr const char* HIVE_RUNTIME_PROPERTIES_KEY_PREFIX = ""hiveRuntime"";
    const std::string destinationFormat;
};
```",0
"TypedValue read(const EvaluationContext& context, const Object& target, const std::string& name) {
    JsonNode node = asJson(target);
    std::optional<int> index = maybeIndex(name);
    if (index && node.has(*index)) {
        return typedValue(node.get(*index));
    } else {
        return typedValue(node.get(name));
    }
}","TypedValue read(EvaluationContext* context, void* target, const std::string& name) {
    JsonNode node = asJson(target);
    std::optional<int> index = maybeIndex(name);
    if (index && node.has(*index)) {
        return typedValue(node.get(*index));
    } else {
        return typedValue(node.get(name));
    }
}",0
"std::vector<std::string> splitPath(const std::string& path, const std::string& SLASH) {
    std::vector<std::string> result;
    size_t start = 0, end;
    while ((end = path.find(SLASH, start)) != std::string::npos) {
        result.push_back(path.substr(start, end - start));
        start = end + SLASH.length();
    }
    result.push_back(path.substr(start));
    return result;
}

class Path {
public:
    std::vector<RequestHandlerMatcherPair> requestHandlerMatcherPairs;

private:
    std::string name;
    Path* parent = nullptr;
    std::unordered_map<std::string, Path*> subPaths;
    Path* catchAll = nullptr;
    Path* catchAllUriParam = nullptr;

public:
    void addIdentity(const std::string& name_, Path* parent_) {
        name = name_;
        parent = parent_;
    }

    Path* getCatchAll() {
        return catchAll;
    }

    Path* getCatchAllUriParam() {
        return catchAllUriParam;
    }
};

bool isCatchAllPath(const std::string& path, const std::string& WILDCARD_CHARACTER) {
    return path == WILDCARD_CHARACTER;
}","```cpp
#include <string>
#include <vector>
#include <unordered_map>
#include <memory>

class RequestHandlerMatcherPair {}; // Placeholder for actual implementation

class HttpListenerRegistry {
private:
    static constexpr const char* WILDCARD_CHARACTER = ""*"";

    bool isCatchAllPath(const std::string& path) {
        return path == WILDCARD_CHARACTER;
    }

public:
    class Path {
    public:
        std::vector<RequestHandlerMatcherPair> requestHandlerMatcherPairs;

    private:
        std::string name;
        Path* parent = nullptr;
        std::unordered_map<std::string, std::unique_ptr<Path>> subPaths;
        std::unique_ptr<Path> catchAll;
        std::unique_ptr<Path> catchAllUriParam;

    public:
        void addIdentity(const std::string& nm, Path* prnt) {
            name = nm;
            parent = prnt;
        }

        Path* getCatchAll() {
            return catchAll.get();
        }

        Path* getCatchAllUriParam() {
            return catchAllUriParam.get();
        }
    };
};
```",1
"{
    library->AddMember(library->GetIntlObject(), PropertyIds::platform, this->intlNativeInterfaces);
#ifdef INTL_ICU
    UErrorCode status = U_ZERO_ERROR;
    u_init(&status);
    if (status == U_MEMORY_ALLOCATION_ERROR || status == U_FILE_ACCESS_ERROR || status == U_MISSING_RESOURCE_ERROR)
    {
        INTL_TRACE(""Could not initialize ICU - u_init returned status %S"", u_errorName(status));
        Throw::OutOfMemory();
    }
    AssertOrFailFastMsg(U_SUCCESS(status), ""u_init returned non-OOM failure"");
#endif
}
wasInitialized = true;
}","#ifdef INTL_ICU
    // when using ICU, we need to call u_init to ensure that ICU is functioning properly before allowing Intl to continue.
    // u_init will cause the data file to be loaded, and if we don't have enough memory to do so, we can throw OutOfMemory here.
    // This is to protect against spurious U_MISSING_RESOURCE_ERRORs and U_FILE_ACCESS_ERRORs coming from early-lifecycle
    // functions that require ICU data.
    // See OS#16897150, OS#16896933, and others relating to bad statuses returned by GetLocaleData and IsLocaleAvailable
    UErrorCode status = U_ZERO_ERROR;
    u_init(&status);
    if (status == U_MEMORY_ALLOCATION_ERROR || status == U_FILE_ACCESS_ERROR || status == U_MISSING_RESOURCE_ERROR)
    {
        // Trace that this happens in case there are build system changes that actually cause the data file to be not found
        INTL_TRACE(""Could not initialize ICU - u_init returned status %s"", u_errorName(status));
        Throw::OutOfMemory();
    }

    AssertOrFailFastMsg(U_SUCCESS(status), ""u_init returned non-OOM failure"");
#endif",1
"assertAllPetsAdopted();
}

[[maybe_unused]]
void whenSourceIsStopAndStartedSchedulerIsReset() {
    startFlow(""longFrequencyPoll"");
    assertStartedPolls(1);
    stopFlow(""longFrequencyPoll"");
    sleep(1000);
    startFlow(""longFrequencyPoll"");
    assertStartedPolls(1);
}

[[maybe_unused]]
void sourceRetriggersImmediatlyOnReconnection() {
    startFlow(""failingLongFrequencyPoll"");
    assertPetFailingSourcePolls(2);
}

void assertStartedPolls(int polls) {
    check(5000, 200, [&]() {
        assertThat(STARTED_POLLS, is(polls));
        return true;
    });
}

void assertPetFailingSourcePolls(int polls) {
    check(5000, 200, [&]() {
        assertThat(PetFailingPollingSource::STARTED_POLLS, is(polls));
        return true;
    });
}

void assertIdempotentAdoptions() {
    checkNot(5000, 100, [&]() {
        std::scoped_lock lock(ADOPTION_EVENTS);","void whenSourceIsStopAndStartedSchedulerIsReset() {
    startFlow(""longFrequencyPoll"");
    assertStartedPolls(1);
    stopFlow(""longFrequencyPoll"");
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    startFlow(""longFrequencyPoll"");
    assertStartedPolls(1);
}

void sourceRetriggersImmediatlyOnReconnection() {
    startFlow(""failingLongFrequencyPoll"");
    assertPetFailingSourcePolls(2);
}

void assertStartedPolls(int polls) {
    check(5000, 200, [polls]() {
        assertThat(STARTED_POLLS, is(polls));
        return true;
    });
}

void assertPetFailingSourcePolls(int polls) {
    check(5000, 200, [polls]() {
        assertThat(PetFailingPollingSource::STARTED_POLLS, is(polls));
        return true;
    });
}",1
"RayObject call(const RayFunc& func, const std::vector<Object>& args, const CallOptions& options) override {
    assert(!workerContext.getCurrentDriverId().isNil());
    TaskSpec spec = createTaskSpec(func, RayActorImpl::NIL, args, false, options);
    rayletClient.submitTask(spec);
    return RayObjectImpl(spec.returnIds[0]);
}","RayObject call(RayFunc func, const std::vector<Object>& args, const CallOptions& options) override {
    assert(!workerContext.getCurrentDriverId().isNil());
    TaskSpec spec = createTaskSpec(func, RayActorImpl::NIL, args, false, options);
    rayletClient.submitTask(spec);
    return RayObjectImpl(spec.returnIds[0]);
}",1
"```cpp
long bytesWritten() {
    long totalBytes = 0;
    for (const auto& entry : this->partitionWriters) {
        totalBytes += entry.second->bytesWritten();
    }
    return totalBytes;
}
```","long bytesWritten() {
    long totalBytes = 0;
    for (const auto& entry : partitionWriters) {
        totalBytes += entry.second->bytesWritten();
    }
    return totalBytes;
}",0
"}
catch (const std::ios_base::failure& e)
{
    // Ignore
}","try
{
    // code that may throw
}
catch (const std::ios_base::failure&)
{
    // Ignore
}",0
"return ConfigUtils::getMaxMemoryAllowedForMerge(props, maxMemoryFraction);
}

HoodieMemoryConfig build() {","private:
    long getMaxMemoryAllowedForMerge(const std::string& maxMemoryFraction) {
        return ConfigUtils::getMaxMemoryAllowedForMerge(props, maxMemoryFraction);
    }",1
"```cpp
std::map<int, std::vector<Report>>& getMetadataErrors() {
    return metadataErrors;
}

void addMetadataError(int metadataId, const std::string& metadataUUID, bool draft, bool approved, const std::exception& error) {
    std::lock_guard<std::mutex> lock(metadataErrorsMutex);
    Report errorReport = ErrorReport(error);
    errorReport.setUuid(metadataUUID);
    errorReport.setDraft(draft);
    errorReport.setApproved(approved);
    auto it = metadataErrors.find(metadataId);
    if (it == metadataErrors.end()) {
        std::vector<Report> errors;
        errors.push_back(errorReport);
        metadataErrors[metadataId] = errors;
    } else {
        it->second.push_back(errorReport);
    }
}

void addMetadataError(AbstractMetadata& metadata, const std::exception& error) {
    addMetadataError(metadata.getId(), metadata.getUuid(), isMetadataDraft(metadata.getId()), isMetadataApproved(metadata.getId()), error);
}

void addMetadataError(int metadataId, const std::string& metadataUUID, bool draft, bool approved, const std::string& error) {
    std::lock_guard<std::mutex> lock(metadataErrorsMutex);
    Report errorReport = ErrorReport(error);
    errorReport.setUuid(metadataUUID);
    errorReport.setDraft(draft);
    errorReport.setApproved(approved);
    auto it = metadataErrors.find(metadataId);
    if (it == metadataErrors.end()) {
        std::vector<Report> errors;
        errors.push_back(errorReport);
        metadataErrors[metadataId] = errors;
    } else {
        it->second.push_back(errorReport);
    }
}

void addMetadataError(AbstractMetadata& metadata, const std::string& error) {
    addMetadataError(metadata.getId(), metadata.getUuid(), isMetadataDraft(metadata.getId()), isMetadataApproved(metadata.getId()), error);
}

std::map<int, std::vector<InfoReport>>& getMetadataInfos() {
    return metadataInfos;
}

void addMetadataInfos(int metadataId, const std::string& metadataUUID, bool draft, bool approved, const std::string& message) {
    InfoReport infoReport(message);
    infoReport.setUuid(metadataUUID);
    infoReport.setDraft(draft);
    infoReport.setApproved(approved);
    auto it = metadataInfos.find(metadataId);
    if (it == metadataInfos.end()) {
        std::vector<InfoReport> infos;
        infos.push","#include <map>
#include <vector>
#include <memory>
#include <string>
#include <stdexcept>

class Exception {
public:
    Exception(const std::string& msg) : message(msg) {}
    std::string message;
};

class Report {
public:
    virtual ~Report() = default;
    void setUuid(const std::string& uuid_) { uuid = uuid_; }
    void setDraft(bool d) { draft = d; }
    void setApproved(bool a) { approved = a; }
protected:
    std::string uuid;
    bool draft = false;
    bool approved = false;
};

class ErrorReport : public Report {
public:
    ErrorReport(const Exception& e) : error(e.message) {}
    ErrorReport(const std::string& e) : error(e) {}
private:
    std::string error;
};

class InfoReport {
public:
    InfoReport(const std::string& msg) : message(msg) {}
    void setUuid(const std::string& uuid_) { uuid = uuid_; }
    void setDraft(bool d) { draft = d; }
    void setApproved(bool a) { approved = a; }
private:
    std::string message;
    std::string uuid;
    bool draft = false;
    bool approved = false;
};

class AbstractMetadata {
public:
    int getId() const;
    std::string getUuid() const;
};

class IMetadataUtils {
public:
    virtual bool isMetadataDraft(int metadataId) = 0;
    virtual bool isMetadataApproved(int metadataId) = 0;
    virtual ~IMetadataUtils() = default;
};

class ApplicationContextHolder {
public:
    static ApplicationContextHolder& get() {
        static ApplicationContextHolder instance;
        return instance;
    }
    IMetadataUtils* getBean() { return metadataUtils; }
    void setMetadataUtils(IMetadataUtils* utils) { metadataUtils = utils; }
private:
    IMetadataUtils* metadataUtils = nullptr;
};

class MetadataProcessingReport /*: public ProcessingReport*/ {
public:
    const std::map<int, std::vector<std::unique_ptr<Report>>>& getMetadataErrors() const {
        return metadataErrors;
    }

    void addMetadataError(int metadataId, const std::string& metadataUUID, bool draft, bool approved, const Exception& error) {
        auto errorReport = std::make_unique<ErrorReport>(error);
        errorReport->setUuid(metadataUUID);
        errorReport->setDraft(draft);",1
"result = DecodeableRpcResult(channel, res, is,
    static_cast<Invocation*>(getRequestData(id)), proto);
result.decode();
std::cout << std::this_thread::get_id() << std::endl;
} else {
    result = DecodeableRpcResult(channel, res,
        UnsafeByteArrayInputStream(readMessageData(is)));","```cpp
result = DecodeableRpcResult(channel, res, is,
    static_cast<Invocation*>(getRequestData(id)), proto);
result.decode();
std::cout << std::this_thread::get_id() << std::endl;
```",1
"void setContext(const std::string& context)
{
    std::string lower = context;
    std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
}","std::string getContext() const
{
    return context_;
}

void setContext(const std::string& context)
{
    std::string lower = context;
    std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
}",0
"IdentifierTreeImpl* classToken = new IdentifierTreeImpl(InternalSyntaxToken::create(classTokenAstNode));

return new MemberSelectExpressionTreeImpl(voidType, dotSyntaxToken, classToken);
}

PrimitiveTypeTreeImpl* newBasicType(std::optional<std::vector<AnnotationTreeImpl*>> annotations, AstNode* basicType) {","IdentifierTreeImpl classToken = IdentifierTreeImpl(InternalSyntaxToken::create(classTokenAstNode));

return MemberSelectExpressionTreeImpl(voidType, dotSyntaxToken, classToken);",0
"std::map<std::string, std::string> getStartupErrors() {
    checkCleared(""startup errors not available"");
    return _startupErrors;
}","std::map<std::string, std::string> getStartupErrors() {
    checkCleared(""startup errors not available"");
    return _startupErrors;
}",0
"return sched.getCard();
}

TaskData doInBackgroundLoadDeckCounts(TaskData* params) {
    std::cout << ""doInBackgroundLoadDeckCounts"" << std::endl;
    Collection* col = CollectionHelper::getInstance()->getCol(mContext);
    try {
        std::vector<std::any> o = { col->getSched()->deckDueTree() };
        return TaskData(o);
    } catch (...) {
        // Handle exception as appropriate
    }
}","TaskData doInBackgroundLoadDeckCounts(TaskData* params) {
    qDebug() << ""doInBackgroundLoadDeckCounts"";
    Collection* col = CollectionHelper::getInstance()->getCol(mContext);
    try {
        std::vector<QVariant> o = { QVariant::fromValue(col->getSched()->deckDueTree()) };
        return TaskData(o);
    } catch (...) {
        // handle exception if needed
    }
    return TaskData();
}",0
"layout.addView(mImageFileSize, ViewGroup::LayoutParams::MATCH_PARENT);
layout.addView(mImageFileSizeWarning, ViewGroup::LayoutParams::MATCH_PARENT);
layout.addView(mBtnGallery, ViewGroup::LayoutParams::MATCH_PARENT);

if (android::os::Build::VERSION::SDK_INT >= android::os::Build::VERSION_CODES::N) {
    layout.addView(mBtnDraw, ViewGroup::LayoutParams::MATCH_PARENT);
}

if (CheckCameraPermission::manifestContainsPermission(context)) {
    layout.addView(mBtnCamera, ViewGroup::LayoutParams::MATCH_PARENT);
}

layout.addView(mCropButton, ViewGroup::LayoutParams::MATCH_PARENT);","layout.addView(mImageFileSize, ViewGroup::LayoutParams::MATCH_PARENT);
layout.addView(mImageFileSizeWarning, ViewGroup::LayoutParams::MATCH_PARENT);
layout.addView(mBtnGallery, ViewGroup::LayoutParams::MATCH_PARENT);

#if __ANDROID_API__ >= 24
layout.addView(mBtnDraw, ViewGroup::LayoutParams::MATCH_PARENT);
#endif

if (com::ichi2::utils::CheckCameraPermission::manifestContainsPermission(context)) {
    layout.addView(mBtnCamera, ViewGroup::LayoutParams::MATCH_PARENT);
}
layout.addView(mCropButton, ViewGroup::LayoutParams::MATCH_PARENT);",1
"ApplyUpdateCachedItems();
if (IsHandleCreated && !ListViewHandleDestroyed) {
    NativeMethods::LVFINDINFO info;
    info.lParam = static_cast<LPARAM>(item.ID);
    info.flags = NativeMethods::LVFI_PARAM;
}","ApplyUpdateCachedItems();
if (IsHandleCreated && !ListViewHandleDestroyed) {
    NativeMethods::LVFINDINFO info;
    info.lParam = static_cast<IntPtr>(item.ID);
    info.flags = NativeMethods::LVFI_PARAM;
}",1
"return valueOf(properties.getProperty(name), int(), defaultValue);
}

static std::vector<std::string> parseList(const std::string& str) {
    if (str.empty() || std::all_of(str.begin(), str.end(), isspace)) {
        return {};
    }","static std::vector<std::string> parseList(const std::string& str) {
    if (str.empty() || std::all_of(str.begin(), str.end(), ::isspace)) {
        return {};
    }
    // Implementation of parsing the string into a list goes here.
    // For now, return an empty vector (since only the stub was shown).
    return {};
}",0
"```
}
rootDiskSize = std::stoll(customParameters[""rootdisksize""]);

// only KVM, XenServer and VMware supports rootdisksize override
if (!(hypervisorType == HypervisorType::KVM || hypervisorType == HypervisorType::XenServer || hypervisorType == HypervisorType::VMware)) {
    throw InvalidParameterValueException(""Hypervisor "" + std::to_string(static_cast<int>(hypervisorType)) + "" does not support rootdisksize override"");
}

VMTemplateVO* templateVO = _templateDao->findById(template->getId());
if (templateVO == nullptr) {
    throw InvalidParameterValueException(""Unable to look up template by id "" + std::to_string(template->getId()));
}

validateRootDiskResize(hypervisorType, rootDiskSize, templateVO, vm, customParameters);
}

if (isDisplayVm != nullptr) {
```","```cpp
long rootDiskSize = std::stol(customParameters[""rootdisksize""]);

if (!(hypervisorType == HypervisorType::KVM || 
      hypervisorType == HypervisorType::XenServer || 
      hypervisorType == HypervisorType::VMware)) {
    throw InvalidParameterValueException(""Hypervisor "" + std::to_string(static_cast<int>(hypervisorType)) + "" does not support  rootdisksize override"");
}

VMTemplateVO* templateVO = _templateDao->findById(template->getId());
if (templateVO == nullptr) {
    throw InvalidParameterValueException(""Unable to look up template by id "" + std::to_string(template->getId()));
}

validateRootDiskResize(hypervisorType, rootDiskSize, templateVO, vm, customParameters);
```",1
"class RepositionField : public TaskDelegate<void, bool> {
private:
    Model& mModel;
    nlohmann::json mField;
    int mIndex;
public:
    RepositionField(Model& model, const nlohmann::json& field, int index)
        : mModel(model), mField(field), mIndex(index) {}
};","class RepositionField : public TaskDelegate<void, bool> {
private:
    Model& mModel;
    const nlohmann::json mField;
    const int mIndex;

public:
    RepositionField(Model& model, const nlohmann::json& field, int index)
        : mModel(model), mField(field), mIndex(index) {}
};",0
"assert(stackToAssert != nullptr);

assertStackElements(stackToAssert,
    isFlowStackElement(""subFlow"", ""subFlow/processors/0""),
    isFlowStackElement(""subFlowDynamic"", ""subFlowDynamic/processors/0"")
);","assertThat(stackToAssert, not_(nullValue()));

assertStackElements(stackToAssert,
                    isFlowStackElement(""subFlow"", ""subFlow/processors/0""),
                    isFlowStackElement(""subFlowDynamic"", ""subFlowDynamic/processors/0""));",0
"std::vector<FileStatus> listStatus(const Path& f, const PathFilter& filter) override {
    this->metricsRegistry.increment(MetricNames::listStatus.name());
    return fileSystem.listStatus(convertToDefaultPath(f), filter);
}

std::vector<FileStatus> listStatus(const std::vector<Path>& files) override {
    this->metricsRegistry.increment(MetricNames::listStatus.name());
    return fileSystem.listStatus(convertDefaults(files));
}

std::vector<FileStatus> listStatus(const std::vector<Path>& files, const PathFilter& filter) override {
    this->metricsRegistry.increment(MetricNames::listStatus.name());
    return fileSystem.listStatus(convertDefaults(files), filter);
}

std::vector<FileStatus> globStatus(const Path& pathPattern) override {
    this->metricsRegistry.increment(MetricNames::globStatus.name());
    return fileSystem.globStatus(convertToDefaultPath(pathPattern));
}

std::vector<FileStatus> globStatus(const Path& pathPattern, const PathFilter& filter) override {
    this->metricsRegistry.increment(MetricNames::globStatus.name());
    return fileSystem.globStatus(convertToDefaultPath(pathPattern), filter);
}","std::vector<FileStatus> listStatus(const Path& f, const PathFilter& filter) override {
    metricsRegistry.increment(MetricNames::listStatus);
    return fileSystem.listStatus(convertToDefaultPath(f), filter);
}

std::vector<FileStatus> listStatus(const std::vector<Path>& files) override {
    metricsRegistry.increment(MetricNames::listStatus);
    return fileSystem.listStatus(convertDefaults(files));
}

std::vector<FileStatus> listStatus(const std::vector<Path>& files, const PathFilter& filter) override {
    metricsRegistry.increment(MetricNames::listStatus);
    return fileSystem.listStatus(convertDefaults(files), filter);
}

std::vector<FileStatus> globStatus(const Path& pathPattern) override {
    metricsRegistry.increment(MetricNames::globStatus);
    return fileSystem.globStatus(convertToDefaultPath(pathPattern));
}

std::vector<FileStatus> globStatus(const Path& pathPattern, const PathFilter& filter) override {
    metricsRegistry.increment(MetricNames::globStatus);
    return fileSystem.globStatus(convertToDefaultPath(pathPattern), filter);
}",0
"{
    deploymentService.start();

    addExplodedAppFromResource(INCOMPLETE_APP_ZIP_PATH);

    assertDeploymentFailure(applicationDeploymentListener, INCOMPLETE_APP);

    assertAppsDir(NONE, std::vector<std::string>{INCOMPLETE_APP}, true);
    const auto zombieMap = deploymentService.getZombieApplications();
    assertEquals(""Wrong number of zombie apps registered."", 1, zombieMap.size());
    auto zombie = *zombieMap.begin();
    assertEquals(""Wrong URL tagged as zombie."", INCOMPLETE_APP, fs::path(zombie.first.path()).parent_path().filename().string());
    assertTrue(""Invalid lastModified value for file URL."", zombie.second != -1);

    reset(applicationDeploymentListener);

    fs::path configFile = fs::path(appsDir) / INCOMPLETE_APP_PATH / MULE_CONFIG_XML_FILE;
    auto currentLastModified = fs::last_write_time(configFile);
    fs::last_write_time(configFile, currentLastModified + std::chrono::seconds(1));

    assertDeploymentFailure(applicationDeploymentListener, INCOMPLETE_APP);
}

void redeploysInvalidExplodedAppAfterSuccessfulDeploymentOnStartup()
{
    addExplodedAppFromResource(DUMMY_APP_ZIP_PATH, DUMMY_APP);

    deploymentService.start();
}","```cpp
void testDeploymentService()
{
    deploymentService.start();

    addExplodedAppFromResource(INCOMPLETE_APP_ZIP_PATH);

    assertDeploymentFailure(applicationDeploymentListener, INCOMPLETE_APP);

    // Maintains app dir created
    assertAppsDir(NONE, std::vector<std::string>{INCOMPLETE_APP}, true);
    const auto& zombieMap = deploymentService.getZombieApplications();
    assertEquals(""Wrong number of zombie apps registered."", 1, zombieMap.size());
    auto zombie = *zombieMap.begin();
    assertEquals(""Wrong URL tagged as zombie."", INCOMPLETE_APP,
                 std::filesystem::path(zombie.first.path()).parent_path().filename().string());
    assertTrue(""Invalid lastModified value for file URL."", zombie.second != -1);

    reset(applicationDeploymentListener);

    std::filesystem::path configFile = std::filesystem::path(appsDir) / INCOMPLETE_APP_PATH / MULE_CONFIG_XML_FILE;
    auto ftime = std::filesystem::last_write_time(configFile);
    std::filesystem::last_write_time(configFile, ftime + std::chrono::seconds(1));

    assertDeploymentFailure(applicationDeploymentListener, INCOMPLETE_APP);
}

void redeploysInvalidExplodedAppAfterSuccessfulDeploymentOnStartup()
{
    addExplodedAppFromResource(DUMMY_APP_ZIP_PATH, DUMMY_APP);

    deploymentService.start();
}
```",0
"}
return DiagnosticProperties::makeStringResult(result);
}

static DiagnosticProperties getThreadInfo(const std::string& diagnosticCommand) {
    DiagnosticProperties result;
    bool okay = true;","```cpp
private:
static DiagnosticProperties getThreadInfo(const std::string& diagnosticCommand) {
    DiagnosticProperties result;
    bool okay = true;
```",0
"return canHandle(network.getTrafficType());
}

void storePasswordInVmDetails(VirtualMachineProfile& vm) {
    std::string password = static_cast<std::string>(vm.getParameter(VirtualMachineProfile::Param::VmPassword));
    std::string password_encrypted = DBEncryptionUtil::encrypt(password);
    UserVmVO userVmVO = _userVmDao.findById(vm.getId());

    _userVmDetailsDao.addDetail(vm.getId(), ""password"", password_encrypted, false);

    userVmVO.setUpdateParameters(true);
    _userVmDao.update(userVmVO.getId(), userVmVO);
}

bool verifyServicesCombination(const std::set<Service>& services) override {
    return true;
}","void storePasswordInVmDetails(VirtualMachineProfile* vm) {
    std::string password = static_cast<std::string>(vm->getParameter(VirtualMachineProfile::Param::VmPassword));
    std::string password_encrypted = DBEncryptionUtil::encrypt(password);
    UserVmVO* userVmVO = _userVmDao->findById(vm->getId());

    _userVmDetailsDao->addDetail(vm->getId(), ""password"", password_encrypted, false);

    userVmVO->setUpdateParameters(true);
    _userVmDao->update(userVmVO->getId(), *userVmVO);
}",1
"class MessageProducerSupport : public AbstractEndpoint, public MessageProducer, public TrackableComponent, public SmartInitializingSingleton
{
protected:
    MessagingTemplate messagingTemplate;
};","#include <string>

class MessageProducerSupport : public AbstractEndpoint, public MessageProducer, public TrackableComponent, public SmartInitializingSingleton {
protected:
    MessagingTemplate messagingTemplate;
public:
    MessageProducerSupport() : messagingTemplate() {}
};",0
"// preface the exiv2 messages with ""[exiv2] ""
Exiv2::LogMsg::setHandler(&dt_exif_log_handler);

#if EXIV2_TEST_VERSION(0,27,4)
Exiv2::enableBMFF();
#endif

Exiv2::XmpParser::initialize();
// this has to stay with the old url (namespace already propagated outside dt)
Exiv2::XmpProperties::registerNs(""http://darktable.sf.net/"", ""darktable"");","void dt_exif_init()
{
  // preface the exiv2 messages with ""[exiv2] ""
  Exiv2::LogMsg::setHandler(&dt_exif_log_handler);

#if EXIV2_TEST_VERSION(0,27,4)
  Exiv2::enableBMFF();
#endif

  Exiv2::XmpParser::initialize();
  Exiv2::XmpProperties::registerNs(""http://darktable.sf.net/"", ""darktable"");
}",1
"void doOnComplete(OperationHandler* handler) {
    execute([this, handler]() {
        AppResponse result;
        if (std::string(getMethodDescriptor()->getReturnClass()->getName()) != ""void"") {
            auto resp = deserializeResponse(getData());
            result = AppResponse(resp);
        } else {
            result = AppResponse();
        }
        Response response(getRequest()->getId(), TripleConstant::TRI_VERSION);
        result.setObjectAttachments(parseMetadataToAttachmentMap(getTrailers()));
        response.setResult(result);
        DefaultFuture2::received(getConnection(), response);
    });
}","void doOnComplete(OperationHandler handler) {
    execute([this, handler]() {
        try {
            AppResponse result;
            if (std::string(getMethodDescriptor()->getReturnClass()->getName()) != ""void"") {
                auto resp = deserializeResponse(getData());
                result = AppResponse(resp);
            } else {
                result = AppResponse();
            }
            Response response(getRequest()->getId(), TripleConstant::TRI_VERSION);
            result.setObjectAttachments(parseMetadataToAttachmentMap(getTrailers()));
            response.setResult(result);
            DefaultFuture2::received(getConnection(), response);
        } catch (...) {
            // Handle exception appropriately
        }
    });
}",1
"#include <unicode/ucol.h>
#include <unicode/udat.h>
#include <unicode/unum.h>
#include <unicode/unumsys.h>

#define ICU_ERROR_FMT u""INTL: %S failed with error code %S\n""
#define ICU_EXPR_FMT  u""INTL: %S failed expression check %S\n""","using namespace Windows::Globalization;
using namespace PlatformAgnostic::Resource;
#define U_STATIC_IMPLEMENTATION
#define U_SHOW_CPLUSPLUS_API 0
#include <unicode/ucol.h>
#include <unicode/udat.h>
#include <unicode/unum.h>
#include <unicode/unumsys.h>

#define ICU_ERROR_FMT L""INTL: %S failed with error code %S\n""
#define ICU_EXPR_FMT L""INTL: %S failed expression check %S\n""",1
"#include ""Card.h""
#include ""Consts.h""
#include ""Deck.h""
#include ""Note.h""
#include ""AnkiAssert.h""
#include ""IntentAssert.h""","#include ""Card.h""
#include ""Consts.h""
#include ""Deck.h""
#include ""Note.h""
#include ""AnkiAssert.h""
#include ""IntentAssert.h""",0
"private:
    std::ostream& delegate;
    io::opentelemetry::context::Context otelContext;
    AwsLambdaRequest request;
    OpenTelemetrySdk openTelemetrySdk;

    OutputStreamWrapper(
        std::ostream& delegate,
        const io::opentelemetry::context::Context& otelContext,
        const AwsLambdaRequest& request,
        const OpenTelemetrySdk& openTelemetrySdk)
        : delegate(delegate),
          otelContext(otelContext),
          request(request),
          openTelemetrySdk(openTelemetrySdk) {}","class OutputStreamWrapper {
private:
    std::ostream& delegate;
    io::opentelemetry::context::Context otelContext;
    AwsLambdaRequest request;
    OpenTelemetrySdk openTelemetrySdk;

    OutputStreamWrapper(
        std::ostream& delegate,
        const io::opentelemetry::context::Context& otelContext,
        const AwsLambdaRequest& request,
        const OpenTelemetrySdk& openTelemetrySdk)
        : delegate(delegate),
          otelContext(otelContext),
          request(request),
          openTelemetrySdk(openTelemetrySdk)
    {}
};",0
"if (this->filenameRegex != nullptr) {
    filtersNeeded.push_back(std::make_shared<RegexPatternFileListFilter>(this->filenameRegex));
}

else if (this->preventDuplicates.has_value() && this->preventDuplicates.value() == false) {
    filtersNeeded.push_back(std::make_shared<AcceptAllFileListFilter<File>>());
}
else {
    filtersNeeded.push_back(std::make_shared<AcceptOnceFileListFilter<File>>());
}

if (filtersNeeded.size() == 1) {
    createdFilter = filtersNeeded[0];
}
else {
    createdFilter = std::make_shared<CompositeFileListFilter<File>>(filtersNeeded);
}

this->result = createdFilter;","```cpp
template<typename File>
class FileListFilterFactoryBean : public FactoryBean<FileListFilter<File>*> {
private:
    std::vector<FileListFilter<File>*> filtersNeeded;
    std::regex filenameRegex;
    std::optional<bool> preventDuplicates;
    FileListFilter<File>* result = nullptr;

    void someFunction() { // replace with actual method name/params
        FileListFilter<File>* createdFilter = nullptr;

        if (filenameRegex.mark_count() > 0) {
            filtersNeeded.push_back(new RegexPatternFileListFilter<File>(filenameRegex));
        }

        if (filtersNeeded.empty()) {
            if (preventDuplicates && !(*preventDuplicates)) {
                filtersNeeded.push_back(new AcceptAllFileListFilter<File>());
            } else {
                filtersNeeded.push_back(new AcceptOnceFileListFilter<File>());
            }
        }

        if (filtersNeeded.size() == 1) {
            createdFilter = filtersNeeded[0];
        } else {
            createdFilter = new CompositeFileListFilter<File>(filtersNeeded);
        }

        this->result = createdFilter;
    }

    CompositeFileListFilter<File>* createCompositeWithAcceptOnceFilter(FileListFilter<File>* otherFilter) {
        auto* compositeFilter = new CompositeFileListFilter<File>();
        compositeFilter->addFilter(new AcceptOnceFileListFilter<File>());
        compositeFilter->addFilter(otherFilter);
        return compositeFilter;
    }
};
```",0
"if (IGNORE_DISABLED) {
    context.addParameter(DISABLE_COMPONENT_IGNORE, true);
}
if (ENABLE_POLLING_SOURCE_LIMIT) {
    context.addParameter(ENABLE_POLLING_SOURCE_LIMIT_PARAMETER, true);
}","if (IGNORE_DISABLED) {
    context.addParameter(DISABLE_COMPONENT_IGNORE, true);
}
if (ENABLE_POLLING_SOURCE_LIMIT) {
    context.addParameter(ENABLE_POLLING_SOURCE_LIMIT_PARAMETER, true);
}",0
"});
    return knownRelations;
}

ObjectConstraint* getConstraintWithStatus(const SymbolicValue& value, const Object& aState) {
    Object* constraint = getConstraint(value.wrappedValue());
    if (auto oConstraint = dynamic_cast<ObjectConstraint*>(constraint)) {
        if (oConstraint->hasStatus(aState)) {
            return oConstraint;
        }
    }
    return nullptr;
}","ObjectConstraint* getConstraintWithStatus(const SymbolicValue& value, const Object& aState) {
    auto constraint = getConstraint(value.wrappedValue());
    if (auto oConstraint = dynamic_cast<ObjectConstraint*>(constraint)) {
        if (oConstraint->hasStatus(aState)) {
            return oConstraint;
        }
    }
    return nullptr;
}",1
"""_source"", std::unordered_map<std::string, bool>{{""enabled"", false}},
""properties"", std::unordered_map<std::string, std::unordered_map<std::string, std::string>>{
    {""message"", std::unordered_map<std::string, std::string>{
        {""type"", ""string""},
        {""index"", ""not_analyzed""}
    }}
};
assert(client.preparePutTemplate(templateName)
    .setTemplate(indices.allIndicesAlias()));","{
    std::map<std::string, std::any> mapping = {
        {""_source"", std::map<std::string, bool>{{""enabled"", false}}},
        {""properties"", std::map<std::string, std::map<std::string, std::any>>{
            {""message"", std::map<std::string, std::any>{
                {""type"", std::string(""string"")},
                {""index"", std::string(""not_analyzed"")}
            }}
        }}
    };

    assertThat(client.preparePutTemplate(templateName)
        .setTemplate(indices.allIndicesAlias()));
}",1
"ComponentLocator<ElementDeclaration>& locator) 
    : elementModelFactory(DslElementModelFactory::getDefault(context)),
      delegate([this, &locator](auto l) {
          auto e = locator.get(l);
          if (e) {
              auto modelOpt = elementModelFactory.create(*e);
              if (modelOpt) {
                  return *modelOpt;
              }
          }
          return decltype(elementModelFactory.create(*e))::value_type{};
      })
{
}","DeclarationBasedValueProviderCacheIdGenerator(
    const Context& context,
    ComponentLocator<ElementDeclaration>& locator)
    : elementModelFactory(DslElementModelFactory::getDefault(context)),
      delegate([&locator, this](auto l) {
          auto optElem = locator.get(l);
          if (optElem) {
              auto model = elementModelFactory.create(*optElem);
              if (model) return *model;
              else return decltype(*model)();
          }
          return decltype(elementModelFactory.create(*optElem))();
      })
{
}",1
"}
return state;
}

State cancel() override {
    throw std::runtime_error(""DirectPipelineResult does not support cancel."");
}

State waitToFinish(std::chrono::milliseconds duration) override {
    throw std::runtime_error(""DirectPipelineResult does not support waitToFinish."");
}
}
}","```cpp
class DirectRunner {
public:
    virtual State cancel() {
        throw std::runtime_error(""DirectPipelineResult does not support cancel."");
    }

    virtual State waitToFinish(std::chrono::milliseconds duration) {
        throw std::runtime_error(""DirectPipelineResult does not support waitToFinish."");
    }
};
```",1
"#include <gtest/gtest.h>
#include <optional>
#include <string>
#include <map>

TEST(DeploymentServiceTest, whenDomainIsStoppedStateIsPersistedAsDeploymentProperty)
{
    addPackedDomainFromBuilder(emptyDomainFileBuilder);

    deploymentService.start();

    assertDeploymentSuccess(domainDeploymentListener, emptyDomainFileBuilder.getId());
    Domain* domain = findADomain(emptyDomainFileBuilder.getId(), 1);
    domain->stop();

    ASSERT_NE(domain->getMuleContext()->getRegistry()->lookupObject(ARTIFACT_STOPPED_LISTENER), nullptr);

    std::optional<std::map<std::string, std::string>> properties = std::nullopt;
    std::map<std::string, std::string> deploymentProperties = resolveDeploymentProperties(emptyDomainFileBuilder.getId(), properties);
    ASSERT_NE(deploymentProperties[START_ARTIFACT_ON_DEPLOYMENT_PROPERTY], """");
    ASSERT_EQ(deploymentProperties[START_ARTIFACT_ON_DEPLOYMENT_PROPERTY], ""false"");
}

TEST(DeploymentServiceTest, whenDomainIsStoppedByUndeploymentStateIsNotPersistedAsDeploymentProperty)
{
    addPackedDomainFromBuilder(emptyDomainFileBuilder);

    deploymentService.start();

    assertDeploymentSuccess(domainDeploymentListener, emptyDomainFileBuilder.getId());
    Domain* domain = findADomain(emptyDomainFileBuilder.getId(), 1);

    ASSERT_NE(domain->getMuleContext()->getRegistry()->lookupObject(ARTIFACT_STOPPED_LISTENER), nullptr);
    deploymentService.undeploy(domain);

    std::optional<std::map<std::string, std::string>> properties = std::nullopt;
    std::map<std::string, std::string> deploymentProperties = resolveDeploymentProperties(emptyDomainFileBuilder.getId(), properties);
    ASSERT_EQ(deploymentProperties.find(START_ARTIFACT_ON_DEPLOYMENT_PROPERTY), deploymentProperties.end());
}","void whenDomainIsStoppedStateIsPersistedAsDeploymentProperty() {
    addPackedDomainFromBuilder(emptyDomainFileBuilder);

    deploymentService.start();

    assertDeploymentSuccess(domainDeploymentListener, emptyDomainFileBuilder.getId());
    Domain* domain = findADomain(emptyDomainFileBuilder.getId(), 1);
    domain->stop();

    assertThat(domain->getMuleContext()->getRegistry()->lookupObject(ARTIFACT_STOPPED_LISTENER), is(notNullValue()));

    std::optional<Properties> properties = std::nullopt;
    Properties deploymentProperties = resolveDeploymentProperties(emptyDomainFileBuilder.getId(), properties);
    assertThat(deploymentProperties.get(START_ARTIFACT_ON_DEPLOYMENT_PROPERTY), is(notNullValue()));
    assertThat(deploymentProperties.get(START_ARTIFACT_ON_DEPLOYMENT_PROPERTY), ::is<std::string>(""false""));
}

void whenDomainIsStoppedByUndeploymentStateIsNotPersistedAsDeploymentProperty() {
    addPackedDomainFromBuilder(emptyDomainFileBuilder);

    deploymentService.start();

    assertDeploymentSuccess(domainDeploymentListener, emptyDomainFileBuilder.getId());
    Domain* domain = findADomain(emptyDomainFileBuilder.getId(), 1);

    assertThat(domain->getMuleContext()->getRegistry()->lookupObject(ARTIFACT_STOPPED_LISTENER), is(notNullValue()));
    deploymentService.undeploy(domain);

    std::optional<Properties> properties = std::nullopt;
    Properties deploymentProperties = resolveDeploymentProperties(emptyDomainFileBuilder.getId(), properties);
    assertThat(deploymentProperties.get(START_ARTIFACT_ON_DEPLOYMENT_PROPERTY), is(nullValue()));
}",0
"class DefaultHttpHeaderMapper : public HeaderMapper<HttpHeaders>, public BeanFactoryAware, public InitializingBean {","#include <string>

class DefaultHttpHeaderMapper {  
public:
    DefaultHttpHeaderMapper();
    // Implement equivalent methods and members here
};",0
"#include <string>
#include <vector>
#include <map>
#include <memory>
#include <filesystem>

class Tree;

class DefaultJavaFileScannerContext {
private:
    std::shared_ptr<Tree> tree;
};","#include <string>
#include <vector>
#include <map>
#include <memory>

class CompilationUnitTree;

class DefaultJavaFileScannerContext {
private:
    std::shared_ptr<CompilationUnitTree> tree;

public:
    // Constructors and member functions here
};",0
"registeredConverters.erase(converter);
}

std::vector<DataType> getSuperVertexes(const DataType& vertex) {
    if (Base::containsVertex(vertex)) {
        return {vertex};
    }
    std::vector<DataType> result;
    for (const auto& graphVertex : vertexSet()) {
        if (graphVertex.isCompatibleWith(vertex)) {
            result.push_back(graphVertex);
        }
    }
    return result;
}

std::vector<DataType> getSubVertexes(const DataType& vertex) {
    if (Base::containsVertex(vertex)) {
        return {vertex};
    }
    std::vector<DataType> result;
    for (const auto& graphVertex : vertexSet()) {
        if (vertex.isCompatibleWith(graphVertex)) {
            result.push_back(graphVertex);
        }
    }
    return result;
}

bool containsVertexOrSuper(const DataType& vertex) {
    return !getSuperVertexes(vertex).empty();
}

bool containsVertexOrSub(const DataType& vertex) {
    return !getSubVertexes(vertex).empty();
}","```cpp
#include <vector>
#include <algorithm>

class TransformationGraph : public DirectedMultigraph<DataType, Transformation> {
public:
    std::vector<DataType> getSuperVertexes(const DataType& vertex) {
        if (DirectedMultigraph<DataType, Transformation>::containsVertex(vertex)) {
            return {vertex};
        }
        std::vector<DataType> result;
        for (const auto& graphVertex : this->vertexSet()) {
            if (graphVertex.isCompatibleWith(vertex)) {
                result.push_back(graphVertex);
            }
        }
        return result;
    }

    std::vector<DataType> getSubVertexes(const DataType& vertex) {
        if (DirectedMultigraph<DataType, Transformation>::containsVertex(vertex)) {
            return {vertex};
        }
        std::vector<DataType> result;
        for (const auto& graphVertex : this->vertexSet()) {
            if (vertex.isCompatibleWith(graphVertex)) {
                result.push_back(graphVertex);
            }
        }
        return result;
    }

    bool containsVertexOrSuper(const DataType& vertex) {
        return !getSuperVertexes(vertex).empty();
    }

    bool containsVertexOrSub(const DataType& vertex) {
        return !getSubVertexes(vertex).empty();
    }
};
```",1
"#include <vector>
#include <string>","#include <vector>

#include <string>

#define name MetricRegistry::name",0
"#include <queue>
#include <utility>
#include <filesystem>
#include <vector>
#include <atomic>
#include <memory>
#include <string>

using std::queue;
using std::pair;
using std::unique_ptr;
using std::string;

namespace fs = std::filesystem;

class File {
public:
    fs::path path;

    File() = default;
    File(const string& p) : path(p) {}
    File(const fs::path& p) : path(p) {}

    string getAbsolutePath() const { return fs::absolute(path).string(); }
    string getName() const { return path.filename().string(); }
    bool exists() const { return fs::exists(path); }
    bool isDirectory() const { return fs::is_directory(path); }
    uintmax_t length() const { return fs::is_regular_file(path) ? fs::file_size(path) : 0; }
    bool renameTo(const File& dest) const { return fs::rename(path, dest.path), true; }
    bool mkdirs() const { return fs::create_directories(path); }
    bool deleteFile() const { return fs::remove_all(path) > 0; }
    std::time_t lastModified() const { return fs::last_write_time(path).time_since_epoch().count(); }
    std::vector<File> listFiles() const {
        std::vector<File> files;
        if (fs::is_directory(path)) {
            for (const auto& entry : fs::directory_iterator(path)) {
                files.emplace_back(entry.path());
            }
        }
        return files;
    }
};

template<typename T>
class LinkedBlockingDeque {
public:
    std::deque<T> queue;
    std::mutex mtx;
    std::condition_variable cv;

    void put(const T& value) {
        {
            std::lock_guard<std::mutex> lock(mtx);
            queue.push_back(value);
        }
        cv.notify_one();
    }

    T take() {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [this] { return !queue.empty(); });
        T val = queue.front();
        queue.pop_front();
        return val;
    }

    T peek() {
        std::lock_guard<std::mutex> lock(mtx);
        return queue.empty() ? T() : queue.front();
    }

    void clear() {
        std::lock_guard<std::mutex> lock(mtx);
        queue.clear();
    }
};

class","#include <deque>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <memory>
#include <atomic>
#include <string>
#include <vector>

class File {
public:
    File(const std::string& path);
    File(const File& parent, const std::string& child);
    std::string getAbsolutePath() const;
    std::string getName() const;
    bool exists() const;
    bool isDirectory() const;
    int64_t length() const;
    bool renameTo(const File& dest);
    int64_t lastModified() const;
    bool mkdirs();
    bool deleteFile();
    std::vector<File> listFiles() const;
};

template<typename T1, typename T2>
struct Pair {
    T1 first;
    T2 second;
    Pair(const T1& a, const T2& b) : first(a), second(b) {}
};

template<typename T>
class LinkedBlockingDeque {
public:
    void put(const T& value) {
        std::unique_lock<std::mutex> lock(m_mutex);
        m_queue.push_back(value);
        m_cv.notify_one();
    }

    T take() {
        std::unique_lock<std::mutex> lock(m_mutex);
        m_cv.wait(lock, [&]{ return !m_queue.empty(); });
        T value = m_queue.front();
        m_queue.pop_front();
        return value;
    }

    T peek() {
        std::unique_lock<std::mutex> lock(m_mutex);
        if (m_queue.empty()) return T();
        return m_queue.front();
    }

    void clear() {
        std::unique_lock<std::mutex> lock(m_mutex);
        m_queue.clear();
    }
private:
    std::deque<T> m_queue;
    std::mutex m_mutex;
    std::condition_variable m_cv;
};

class ProgressSenderAndCancelListener {
public:
    void doProgress(int value);
    bool isCancelled();
};

class Collection {
public:
    void* getContext();
};

class Context {};

class SharedPreferences {
public:
    class Editor {
    public:
        Editor& remove(const std::string& key);
        void commit();
    };
    Editor edit();
};

class AnkiDroidApp {
public:
    static SharedPreferences getSharedPrefs(Context* context);
};

class Timber {
public:
    template<typename... Args>
    static void i(const char* fmt, Args&&... args);
    template<typename... Args>
    static void w(Args&&... args);
    template<typename",1
"if (taskType == TaskType::ACTOR_TASK) {
    actor = actorContext.currentActor;
}
args = ArgumentsBuilder::unwrap(argsBytes, rayFunction.executable.getParameterTypes());
for (auto& arg : args) {
    throwIfDependencyFailed(arg);
}

decltype(auto) result;
if (!rayFunction.isConstructor()) {
    result = rayFunction.getMethod().invoke(actor, args);
} else {
    result = rayFunction.getConstructor().newInstance(args);
}

if (taskType != TaskType::ACTOR_CREATION_TASK) {
    if (rayFunction.hasReturn()) {","```cpp
T* actor = nullptr;
if (taskType == TaskType::ACTOR_TASK) {
    actor = actorContext.currentActor;
}
auto args = ArgumentsBuilder::unwrap(argsBytes, rayFunction.executable->getParameterTypes());
for (const auto& arg : args) {
    throwIfDependencyFailed(arg);
}

std::any result;
try {
    if (!rayFunction.isConstructor()) {
        result = rayFunction.getMethod()->invoke(actor, args);
    } else {
        result = rayFunction.getConstructor()->newInstance(args);
    }
} catch (const std::exception& e) {
    bool isIntentionalSystemExit = dynamic_cast<const RayIntentionalSystemExitException*>(&e) != nullptr;
    if (!isIntentionalSystemExit) {
        std::vector<std::type_index> argTypes;
        for (const auto& arg : args) {
            if (arg.has_value()) {
                argTypes.push_back(std::type_index(arg.type()));
            } else {
                argTypes.push_back(std::type_index(typeid(void)));
            }
        }
        LOGGER.error(""Execute rayFunction {} failed. actor {}, argument types {}"", rayFunction, actor, argTypes);
    }
    throw;
}

if (taskType != TaskType::ACTOR_CREATION_TASK) {
    if (rayFunction.hasReturn()) {
        // ...
    }
}
```",1
"onInit();
auto* beanFactory = this->getBeanFactory();
if (beanFactory != nullptr) {
    getMessagingTemplate().setBeanFactory(beanFactory);
    Assert::state(!(this->discardChannelName != nullptr && this->discardChannel != nullptr),
        ""'discardChannelName' and 'discardChannel' are mutually exclusive."");
    Assert::state(!(getOutputChannelName() != nullptr && getOutputChannel() != nullptr),
        ""'outputChannelName' and 'outputChannel' are mutually exclusive."");

    if (dynamic_cast<BeanFactoryAware*>(this->outputProcessor) != nullptr) {
        static_cast<BeanFactoryAware*>(this->outputProcessor)->setBeanFactory(beanFactory);
    }
}","super::onInit();
BeanFactory* beanFactory = this->getBeanFactory();
if (beanFactory != nullptr) {
    getMessagingTemplate()->setBeanFactory(beanFactory);
    Assert::state(!(this->discardChannelName != nullptr && this->discardChannel != nullptr),
                  ""'discardChannelName' and 'discardChannel' are mutually exclusive."");

    Assert::state(!(getOutputChannelName() != nullptr && getOutputChannel() != nullptr),
                  ""'outputChannelName' and 'outputChannel' are mutually exclusive."");

    if (auto* aware = dynamic_cast<BeanFactoryAware*>(this->outputProcessor)) {
        aware->setBeanFactory(beanFactory);
    }
}",0
"}
}

static XmlObject* createMessageElement(const std::string& name, const std::any& value, bool useExternalKey) {
    XmlObject* me = nullptr;

    if (useExternalKey) {
        // We use an external key","```cpp
static XmlObject* createMessageElement(const std::string& name, const AnyType& value, bool useExternalKey) {
    XmlObject* me = nullptr;

    if (useExternalKey) {
        // We use an external key
    }

    return me;
}
```",0
"```cpp
#include <iterator>
#include <vector>
#include <memory>

class DatasetPartition {};
class PartitionableDataset {
public:
    std::vector<std::shared_ptr<DatasetPartition>> getPartitions(int sortedFlag, auto comparator);
    std::string getUrn();
};

class LoopingDatasetFinderSource {
public:
    struct {
        bool operator()(const std::shared_ptr<DatasetPartition>& a, const std::shared_ptr<DatasetPartition>& b) const;
    } lexicographicalComparator;

    std::vector<std::shared_ptr<DatasetPartition>>::iterator currentPartitionIterator;

    std::vector<std::shared_ptr<DatasetPartition>>::iterator getPartitionIterator(PartitionableDataset& dataset) {
        try {
            auto partitions = dataset.getPartitions(/*Spliterator.SORTED*/ 1, lexicographicalComparator);
            std::sort(partitions.begin(), partitions.end(), lexicographicalComparator);
            currentPartitionIterator = partitions.begin();
            return currentPartitionIterator;
        } catch (const std::exception& e) {
            // log.error(""Failed to get partitions for dataset "" + dataset.getUrn());
            return std::vector<std::shared_ptr<DatasetPartition>>().end();
        }
    }
};
```","```cpp
private:
std::vector<PartitionableDataset::DatasetPartition>::iterator getPartitionIterator(PartitionableDataset& dataset) {
    try {
        auto partitions = sortStreamLexicographically(
            dataset.getPartitions(Spliterator::SORTED, LoopingDatasetFinderSource::lexicographicalComparator));
        this->currentPartitionIterator = partitions.begin();
        return this->currentPartitionIterator;
    } catch (const std::ios_base::failure& ioe) {
        log.error(""Failed to get partitions for dataset "" + dataset.getUrn());
        return {};
    }
}
```",0
"```cpp
static bool isFirstUsageANullCheck(const ExpressionTree* boxedBoolean) {
    if (boxedBoolean->is(Kind::IDENTIFIER)) {
        auto* identifier = static_cast<const IdentifierTree*>(boxedBoolean);
        auto usages = identifier->symbol()->usages();
        if (!usages.empty()) {
            Tree* firstUsage = usages[0]->parent();
            // Test if the first usage in our list is a null check
            if (firstUsage->is(Kind::EQUAL_TO, Kind::NOT_EQUAL_TO) && isNullCheck(static_cast<ExpressionTree*>(firstUsage))) {
                return true;
            }
            // Return false if the only usage is not a null check
            if (usages.size() == 1) {
                return false;
            }
            // Fetch the first null check in the usages list
            auto firstNullCheck = getFirstNullCheck(identifier);
            if (!firstNullCheck.has_value()) {
                return false;
            }
            // Test if the first null check and the first usage are part of the same higher if structure
            auto ifStatementWithNullCheck = getParentConditionalBranch(firstNullCheck.value());
            auto ifStatementWithFirstUsage = getParentConditionalBranch(static_cast<ExpressionTree*>(firstUsage));
            return ifStatementWithNullCheck == ifStatementWithFirstUsage;
        }
    }
    return false;
}

static std::optional<const ExpressionTree*> getFirstNullCheck(const IdentifierTree* identifier) {
    auto it = firstNullCheckCache.find(identifier);
    if (it != firstNullCheckCache.end()) {
        return it->second;
    }
    auto usages = identifier->symbol()->usages();
    auto firstNullCheck = getFirstNullCheck(usages);
    firstNullCheckCache[identifier] = firstNullCheck;
    return firstNullCheck;
}

static std::optional<const ExpressionTree*> getFirstNullCheck(const std::vector<const IdentifierTree*>& usages) {
    for (const auto* usage : usages) {
        Tree* parent = usage->parent();
        if (parent->is(Kind::EQUAL_TO, Kind::NOT_EQUAL_TO) && isNullCheck(static_cast<ExpressionTree*>(parent))) {
            return static_cast<const ExpressionTree*>(parent);
        }
    }
    return std::nullopt;
}

static std::optional<const IfStatementTree*> getParentConditionalBranch(const ExpressionTree* tree) {
    auto it = ifStatementCache.find(tree);
    if (it","```cpp
static bool isFirstUsageANullCheck(const ExpressionTree* boxedBoolean) {
    if (boxedBoolean->is(Kind::IDENTIFIER)) {
        const IdentifierTree* identifier = static_cast<const IdentifierTree*>(boxedBoolean);
        const std::vector<const IdentifierTree*>& usages = identifier->symbol()->usages();
        const Tree* firstUsage = usages.front()->parent();
        if ((firstUsage->is(Kind::EQUAL_TO) || firstUsage->is(Kind::NOT_EQUAL_TO)) && isNullCheck(static_cast<const ExpressionTree*>(firstUsage))) {
            return true;
        }
        if (usages.size() == 1) {
            return false;
        }
        std::optional<const ExpressionTree*> firstNullCheck = getFirstNullCheck(identifier);
        if (!firstNullCheck.has_value()) {
            return false;
        }
        std::optional<const IfStatementTree*> ifStatementWithNullCheck = getParentConditionalBranch(firstNullCheck.value());
        std::optional<const IfStatementTree*> ifStatementWithFirstUsage = getParentConditionalBranch(static_cast<const ExpressionTree*>(firstUsage));
        return ifStatementWithNullCheck == ifStatementWithFirstUsage;
    }
    return false;
}

static std::optional<const ExpressionTree*> getFirstNullCheck(const IdentifierTree* identifier) {
    auto it = firstNullCheckCache.find(identifier);
    if (it != firstNullCheckCache.end()) {
        return it->second;
    }
    const std::vector<const IdentifierTree*>& usages = identifier->symbol()->usages();
    std::optional<const ExpressionTree*> firstNullCheck = getFirstNullCheck(usages);
    firstNullCheckCache[identifier] = firstNullCheck;
    return firstNullCheck;
}

static std::optional<const ExpressionTree*> getFirstNullCheck(const std::vector<const IdentifierTree*>& usages) {
    for (const auto* usage : usages) {
        const Tree* parent = usage->parent();
        if ((parent->is(Kind::EQUAL_TO) || parent->is(Kind::NOT_EQUAL_TO)) && isNullCheck(static_cast<const ExpressionTree*>(parent))) {
            return static_cast<const ExpressionTree*>(parent);
        }
    }
    return std::nullopt;
}

static std::optional<const IfStatementTree*> getParentConditionalBranch(const ExpressionTree* tree) {
    auto it = ifStatementCache.find(tree);
    if (it != ifStatementCache.end()) {
        return it->second;
    }
    const Tree",1
"CoderProperties::coderSerializable(RandomAccessDataCoder::of());
CoderProperties::structuralValueConsistentWithEquals(
    RandomAccessDataCoder::of(), streamA, streamB);
assert(RandomAccessDataCoder::of().isRegisterByteSizeObserverCheap(streamA));
assert(RandomAccessDataCoder::of().isRegisterByteSizeObserverCheap(streamA));
assert(RandomAccessDataCoder::of().getEncodedElementByteSize(streamA) == 4);
assert(RandomAccessDataCoder::of().getEncodedElementByteSize(streamA) == 3);","CoderProperties::coderSerializable(RandomAccessDataCoder::of());
CoderProperties::structuralValueConsistentWithEquals(
    RandomAccessDataCoder::of(), streamA, streamB);
ASSERT_TRUE(RandomAccessDataCoder::of().isRegisterByteSizeObserverCheap(streamA));
ASSERT_TRUE(RandomAccessDataCoder::of().isRegisterByteSizeObserverCheap(streamA));
ASSERT_EQ(4, RandomAccessDataCoder::of().getEncodedElementByteSize(streamA));
ASSERT_EQ(3, RandomAccessDataCoder::of().getEncodedElementByteSize(streamA));",1
"std::string formatted = 
    std::format(""{}.{}.{}"", muleContext.getConfiguration().getId(), getLocation().getRootContainerName(),
                typeid(*this).name());

void setupObjectStore() {
    // Check if OS was properly configured
    if (store != nullptr && privateStore != nullptr) {
        throw InitialisationException(
            createStaticMessage(""Ambiguous definition of object store, both reference and private were configured""),
            this
        );
    }
    if (store == nullptr) {
        if (privateStore == nullptr) { // If no object store was defined, create one
            this->store = createMessageIdStore();
        } else { // If object store was defined privately
            this->store = privateStore;
        }
    }
    initialiseIfNeeded(store, true, muleContext);
}

void start() override {
    startIfNeeded(store);
}

void stop() override {
    stopIfNeeded(store);
}","```cpp
void IdempotentMessageValidator::initialise() {
    std::string id = muleContext->getConfiguration()->getId();
    std::string rootContainer = getLocation()->getRootContainerName();
    std::string className = typeid(*this).name();
    std::string formatStr = id + ""."" + rootContainer + ""."" + className;

    setupObjectStore();
}

void IdempotentMessageValidator::setupObjectStore() {
    if (store != nullptr && privateStore != nullptr) {
        throw InitialisationException(
            createStaticMessage(""Ambiguous definition of object store, both reference and private were configured""),
            this);
    }
    if (store == nullptr) {
        if (privateStore == nullptr) {
            store = createMessageIdStore();
        } else {
            store = privateStore;
        }
    }
    initialiseIfNeeded(store, true, muleContext);
}

void IdempotentMessageValidator::start() {
    startIfNeeded(store);
}

void IdempotentMessageValidator::stop() {
    stopIfNeeded(store);
}
```",1
"static Container error(const Project& project, const std::string& message) {
    return Container(project, message);
}","class Container {
public:
    static Container error(const Project& project, const std::string& message) {
        return Container(project, message);
    }
};",0
"if (!this->unpackComplexSchemas) {
    return SingleRecordIterable(inputRecord);
}
JsonObject rec = parseJsonBasedOnSchema(inputRecord, outputSchema);
return SingleRecordIterable(rec);
}

JsonObject parseJsonBasedOnSchema(const JsonArray& input, const JsonArray& schema) {
    JsonObject firstSchema = schema[0][""dataType""].get<JsonObject>();
    return unwrapTempAsArray(wrapAndProcess(input, firstSchema));
}

/**
 * Parses a provided JsonObject input using the provided JsonArray schema into
 * a JsonObject.
 */
JsonObject parseJsonBasedOnSchema(const JsonObject& record, const JsonArray& schema) {
    try {
        JsonObject output;
        for (int i = 0; i < schema.size(); ++i) {
            JsonElement schemaElement = schema[i];
            JsonObject schemaObject = schemaElement.get<JsonObject>();
            std::string expectedColumnName = getColumnName(schemaObject);
            JsonArray dataType = getDataTypeTypeFromSchema(schemaObject);

            if (record.contains(expectedColumnName)) {
                JsonElement value = record.at(expectedColumnName);
                if (isUnionType(schemaObject)) {
                    JsonArray unionSchema = buildUnionSchema(schemaElement);
                    JsonObject firstTypeSchema = getFirstType(unionSchema).get<JsonObject>();
                    JsonObject secondTypeSchema = getSecondType(unionSchema).get<JsonObject>();
                    try {
                        output[expectedColumnName] = unwrapTemp(wrapAndProcess(value, firstTypeSchema));
                    } catch (const DataConversionException&) {
                        output[expectedColumnName] = unwrapTemp(wrapAndProcess(value, secondTypeSchema));
                    }
                } else if (isEnumType(schemaObject)) {
                    JsonElement parseEnumTypeVal = parseEnumType(schemaElement, value);
                    output[expectedColumnName] = parseEnumTypeVal;
                } else if (value.isJsonArray()) {
                    JsonElement parsed = parseJsonArrayType(schemaElement, value);
                    output[expectedColumnName] = parsed;
                } else if (value.isJsonObject()) {
                    JsonElement parsed = parseJsonObjectType(schemaElement, value);
                    output[expectedColumnName] = parsed;
                } else {
                    JsonElement parsedElement = parsePrimitiveType(schemaObject, dataType, value);
                    output[expectedColumnName] = parsedElement;
                }
            } else {
                output[expectedColumnName] = JsonNull::instance();
            }
        }","#include <string>
#include <stdexcept>
#include <vector>
#include <map>
#include <any>
#include <memory>
#include <variant>
#include <optional>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

class DataConversionException : public std::runtime_error {
public:
    explicit DataConversionException(const std::string& msg) : std::runtime_error(msg) {}
};

static const std::string TEMP_COLUMN_NAME = ""__temp__"";

class JsonStringToJsonIntermediateConverter {
public:
    bool unpackComplexSchemas;

    JsonStringToJsonIntermediateConverter(bool unpackComplexSchemas)
        : unpackComplexSchemas(unpackComplexSchemas) {}

    std::vector<json> convert(const std::string& inputRecord, const json& outputSchema) {
        if (!this->unpackComplexSchemas) {
            return {json::parse(inputRecord)};
        }
        json rec = parseJsonBasedOnSchema(json::parse(inputRecord), outputSchema);
        return {rec};
    }

private:
    json parseJsonBasedOnSchema(const json& input, const json& schema) {
        if (input.is_array() && schema.is_array()) {
            json firstSchema = schema.at(0).at(""dataType"");
            return unwrapTempAsArray(wrapAndProcess(input, firstSchema));
        } else if (input.is_object() && schema.is_array()) {
            try {
                json output = json::object();
                for (size_t i = 0; i < schema.size(); ++i) {
                    const json& schemaElement = schema.at(i);
                    const json& schemaObject = schemaElement;
                    std::string expectedColumnName = JsonUtils::getColumnName(schemaObject);
                    json dataType = JsonUtils::getDataTypeTypeFromSchema(schemaObject);

                    if (input.contains(expectedColumnName)) {
                        json value = input.at(expectedColumnName);
                        if (JsonUtils::isUnionType(schemaObject)) {
                            json unionSchema = buildUnionSchema(schemaElement);
                            json firstTypeSchema = JsonUtils::getFirstType(unionSchema);
                            json secondTypeSchema = JsonUtils::getSecondType(unionSchema);
                            try {
                                output[expectedColumnName] = unwrapTemp(wrapAndProcess(value, firstTypeSchema));
                            } catch (const DataConversionException&) {
                                output[expectedColumnName] = unwrapTemp(wrapAndProcess(value, secondTypeSchema));
                            }
                        } else if (JsonUtils::isEnumType(schema",1
"template<typename R>
R runWithValueProvidersContext(std::function<R(ExtensionResolvingContext&)> metadataContextFunction) {
    ExtensionResolvingContext context = getResolvingContext();
    R result = metadataContextFunction(context);
    context.dispose();
    return result;
}

MetadataContext getMetadataContext() {
    Event fakeEvent = getInitialiserEvent(muleContext);
    // ...
}","template <typename R>
R runWithValueProvidersContext(std::function<R(ExtensionResolvingContext&)> metadataContextFunction) {
    ExtensionResolvingContext context = getResolvingContext();
    R result = metadataContextFunction(context);
    context.dispose();
    return result;
}",0
"pnodeFnc->sxFnc.pnodeBody = nullptr;
pnodeFnc->sxFnc.nestedCount = 0;

ParseNodePtr pnodeParentFnc = m_currentNodeFunc;
m_currentNodeFunc = pnodeFnc;
m_currentNodeDeferredFunc = nullptr;
m_ppnodeScope = nullptr;","HRESULT Parser::ParseFunctionInBackground(ParseNodePtr pnodeFnc, ParseContext* pParseContext)
{
    pnodeFnc->sxFnc.pnodeBody = nullptr;
    pnodeFnc->sxFnc.nestedCount = 0;

    ParseNodePtr pnodeParentFnc = m_currentNodeFunc;
    m_currentNodeFunc = pnodeFnc;
    m_currentNodeDeferredFunc = nullptr;
    m_ppnodeScope = nullptr;
}",1
"public:
    bool isGeneric() const {
        return ProtocolUtils::isGeneric(generic);
    }","virtual bool isGeneric() const override {
    return ProtocolUtils::isGeneric(generic);
}",1
"return callHttpService(rowMeta, row);
}

std::vector<void*> callHttpService(RowMetaInterface* rowMeta, const std::vector<void*>& rowData) {
    auto clientBuilder = HttpClientManager::getInstance().createBuilder();

    if (data.realConnectionTimeout > -1) {","Object* callHttpService(RowMetaInterface* rowMeta, Object* rowData) {
    auto clientBuilder = HttpClientManager::getInstance().createBuilder();

    if (data.realConnectionTimeout > -1) {
        // ...
    }
}",0
bool isEmpty(const auto& value) {,bool $isEmpty(const auto& value) {,1
"static std::optional<bool> isThreadCpuTimeSupported;

const ObjectName objectName;

static const auto threadInfoConstructorHandle = getThreadInfoConstructorHandle();

// Protected constructor to limit instantiation.","#include <optional>
#include <mutex>

class ThreadMXBeanImpl {
private:
    static std::optional<bool> isThreadCpuTimeSupported;

    // Assuming ObjectName is a class you have elsewhere
    const ObjectName objectName;

    static const auto threadInfoConstructorHandle;

protected:
    // Constructor and other members...
};

// Definition of static members
std::optional<bool> ThreadMXBeanImpl::isThreadCpuTimeSupported = std::nullopt;
const decltype(getThreadInfoConstructorHandle()) ThreadMXBeanImpl::threadInfoConstructorHandle = getThreadInfoConstructorHandle();",0
"return isPropertyDescriptorDefined;
}

Var JavascriptObject::EntryGetOwnPropertyDescriptors(RecyclableObject* function, CallInfo callInfo, ...)
{
    PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);

    ARGUMENTS(args, callInfo);
    ScriptContext* scriptContext = function->GetScriptContext();

    Assert(!(callInfo.Flags & CallFlags_New));

    RecyclableObject* obj = nullptr;

    if (args.Info.Count < 2)
    {
        obj = RecyclableObject::FromVar(JavascriptOperators::ToObject(scriptContext->GetLibrary()->GetUndefined(), scriptContext));
    }
    else
    {
        obj = RecyclableObject::FromVar(JavascriptOperators::ToObject(args[1], scriptContext));
    }

    if (obj->GetTypeId() == TypeIds_HostDispatch)
    {
        Var result;
        if (obj->InvokeBuiltInOperationRemotely(EntryGetOwnPropertyDescriptors, args, &result))
        {
            return result;
        }
    }

    Var ownPropertyKeys = JavascriptOperators::GetOwnPropertyKeys(obj, scriptContext);
    Assert(JavascriptArray::Is(ownPropertyKeys));

    if (!JavascriptArray::Is(ownPropertyKeys))
    {
        ownPropertyKeys = scriptContext->GetLibrary()->CreateArray(0);
    }

    JavascriptArray* ownPropsArray = JavascriptArray::FromVar(ownPropertyKeys);

    RecyclableObject* resultObj = scriptContext->GetLibrary()->CreateObject(true, static_cast<Js::PropertyIndex>(ownPropsArray->GetLength()));

    PropertyDescriptor propDesc;
    Var propKey = nullptr;

    for (uint i = 0; i < ownPropsArray->GetLength(); i++)
    {
        BOOL getPropResult = ownPropsArray->DirectGetItemAt(i, &propKey);
        Assert(getPropResult);

        if (!getPropResult)
        {
            continue;
        }

        const PropertyRecord* propertyRecord;
        JavascriptConversion::ToPropertyKey(propKey, scriptContext, &propertyRecord);

        Var newDescriptor = JavascriptObject::GetOwnPropertyDescriptorHelper(obj, propKey, scriptContext);
        resultObj->SetProperty(propertyRecord->GetPropertyId(), newDescriptor, PropertyOperation_None, nullptr);
    }

    return resultObj;
}

Var JavascriptObject::EntryGetPrototypeOf(RecyclableObject* function, CallInfo callInfo, ...)
{
    PROBE_STACK(function->","```cpp
Var JavascriptObject::EntryGetOwnPropertyDescriptors(RecyclableObject* function, CallInfo callInfo, ...)
{
    PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);

    ARGUMENTS(args, callInfo);
    ScriptContext* scriptContext = function->GetScriptContext();

    Assert(!(callInfo.Flags & CallFlags_New));

    RecyclableObject* obj = nullptr;

    if (args.Info.Count < 2)
    {
        obj = RecyclableObject::FromVar(
            JavascriptOperators::ToObject(
                scriptContext->GetLibrary()->GetUndefined(), scriptContext));
    }
    else
    {
        obj = RecyclableObject::FromVar(
            JavascriptOperators::ToObject(args[1], scriptContext));
    }

    if (obj->GetTypeId() == TypeIds_HostDispatch)
    {
        Var result;
        if (obj->InvokeBuiltInOperationRemotely(EntryGetOwnPropertyDescriptors, args, &result))
        {
            return result;
        }
    }

    Var ownPropertyKeys = JavascriptOperators::GetOwnPropertyKeys(obj, scriptContext);
    Assert(JavascriptArray::Is(ownPropertyKeys));

    if (!JavascriptArray::Is(ownPropertyKeys))
    {
        ownPropertyKeys = scriptContext->GetLibrary()->CreateArray(0);
    }

    JavascriptArray* ownPropsArray = JavascriptArray::FromVar(ownPropertyKeys);

    RecyclableObject* resultObj = scriptContext->GetLibrary()->CreateObject(
        true, static_cast<Js::PropertyIndex>(ownPropsArray->GetLength()));

    PropertyDescriptor propDesc;
    Var propKey = nullptr;

    for (uint i = 0; i < ownPropsArray->GetLength(); ++i)
    {
        BOOL getPropResult = ownPropsArray->DirectGetItemAt(i, &propKey);
        Assert(getPropResult);

        if (!getPropResult)
        {
            continue;
        }

        const PropertyRecord* propertyRecord;
        JavascriptConversion::ToPropertyKey(propKey, scriptContext, &propertyRecord);

        Var newDescriptor = JavascriptObject::GetOwnPropertyDescriptorHelper(obj, propKey, scriptContext);
        resultObj->SetProperty(propertyRecord->GetPropertyId(), newDescriptor, PropertyOperation_None, nullptr);
    }

    return resultObj;
}
```",1
"void onFailure(const std::exception& ex) override {
    sendErrorMessage(requestMessage, ex);
}","```cpp
void onFailure(std::exception_ptr ex) override {
    sendErrorMessage(requestMessage, ex);
}
```",0
"```cpp
#include <string>

static const std::string METAFOLDER_NAME = /* assign appropriate value */;
static const std::string PATH_SEPARATOR = /* assign appropriate value */;

static const std::string AUXILIARYFOLDER_NAME = METAFOLDER_NAME + PATH_SEPARATOR + "".aux"";
static const std::string BOOTSTRAP_INDEX_ROOT_FOLDER_PATH = AUXILIARYFOLDER_NAME + PATH_SEPARATOR + "".bootstrap"";
static const std::string HEARTBEAT_FOLDER_NAME = METAFOLDER_NAME + PATH_SEPARATOR + "".heartbeat"";
static const std::string COLUMN_STATISTICS_INDEX_NAME = "".colstatsindex"";
static const std::string BOOTSTRAP_INDEX_BY_PARTITION_FOLDER_PATH = BOOTSTRAP_INDEX_ROOT_FOLDER_PATH + PATH_SEPARATOR + "".partitions"";
static const std::string BOOTSTRAP_INDEX_BY_FILE_ID_FOLDER_PATH = BOOTSTRAP_INDEX_ROOT_FOLDER_PATH + PATH_SEPARATOR;
```","static const std::string AUXILIARYFOLDER_NAME = METAFOLDER_NAME + Path::SEPARATOR + "".aux"";
static const std::string BOOTSTRAP_INDEX_ROOT_FOLDER_PATH = AUXILIARYFOLDER_NAME + Path::SEPARATOR + "".bootstrap"";
static const std::string HEARTBEAT_FOLDER_NAME = METAFOLDER_NAME + Path::SEPARATOR + "".heartbeat"";
static const std::string COLUMN_STATISTICS_INDEX_NAME = "".colstatsindex"";
static const std::string BOOTSTRAP_INDEX_BY_PARTITION_FOLDER_PATH = BOOTSTRAP_INDEX_ROOT_FOLDER_PATH + Path::SEPARATOR + "".partitions"";
static const std::string BOOTSTRAP_INDEX_BY_FILE_ID_FOLDER_PATH = BOOTSTRAP_INDEX_ROOT_FOLDER_PATH + Path::SEPARATOR;",0
"std::string getName() const {
    return name;
}

private:
bool isEqualityAssertBehavior() const {
    return getBoolean(equalityAssertBehavior);
}","class Drools : public RulesEngine
{
public:
    std::string getName()
    {
        return name;
    }

private:
    bool isEqualityAssertBehavior()
    {
        return getBoolean(equalityAssertBehavior);
    }
};",1
"```cpp
std::string theCommand = vmProperties.getProperty(SUN_JAVA_COMMAND, """");
std::vector<std::string> parts;
{
    std::istringstream iss(theCommand);
    std::string token;
    if (iss >> token) {
        parts.push_back(token);
        std::string remainder;
        std::getline(iss, remainder);
        if (!remainder.empty() && remainder[0] == ' ') remainder.erase(0,1);
        if (!remainder.empty())
            parts.push_back(remainder);
    }
}

if (noPackageName) {
    std::string commandString = parts[0];
    int finalSeparatorPosition = -1;
    auto cmdLower = commandString;
    std::transform(cmdLower.begin(), cmdLower.end(), cmdLower.begin(), ::tolower);
    if (cmdLower.size() >= 4 && cmdLower.substr(cmdLower.size()-4) == "".jar"") {
        // The application was launched via '-jar'
#ifdef _WIN32
        char pathSep = '\\';
#else
        char pathSep = '/';
#endif
        finalSeparatorPosition = commandString.find_last_of(pathSep);
    } else {
        // The application was launched using a class name
        finalSeparatorPosition = commandString.find_last_of('.');
    }
    parts[0] = commandString.substr(finalSeparatorPosition + 1);
}

if (printApplicationArguments) {
    for (const auto& p : parts) {
        // Use p
    }
}
```","```cpp
std::string theCommand = vmProperties[SUN_JAVA_COMMAND];
std::vector<std::string> parts;
std::istringstream iss(theCommand);
std::string first, rest;
if (iss >> first) {
    std::getline(iss, rest);
    if (!rest.empty() && rest[0] == ' ') rest = rest.substr(1);
}
parts.push_back(first);
if (!rest.empty()) parts.push_back(rest);

if (noPackageName) {
    std::string commandString = parts[0];
    size_t finalSeparatorPosition = std::string::npos;
    std::string lowerCommandString = commandString;
    std::transform(lowerCommandString.begin(), lowerCommandString.end(), lowerCommandString.begin(), ::tolower);
    if (lowerCommandString.size() >= 4 && lowerCommandString.compare(lowerCommandString.size() - 4, 4, "".jar"") == 0) {
        // Application launched via '-jar': get file name, no directory path
        finalSeparatorPosition = commandString.find_last_of(std::filesystem::path::preferred_separator);
    } else {
        // Application launched using class name
        finalSeparatorPosition = commandString.find_last_of('.');
    }
    if (finalSeparatorPosition == std::string::npos)
        parts[0] = commandString;
    else
        parts[0] = commandString.substr(finalSeparatorPosition + 1);
}

if (printApplicationArguments) {
    for (const auto& p : parts) {
        // ...
    }
}
```",1
"return new XmlConfigurationDocumentLoader();
}

private:
XmlApplicationParser* createApplicationParser() {
    ExtensionManager* extensionManager = muleContext->getExtensionManager();
    DslResolvingContext* context =
        extensionManager != nullptr ? DslResolvingContext::getDefault(extensionManager->getExtensions()) : nullptr;
    return new XmlApplicationParser(new XmlApplicationServiceRegistry(serviceRegistry, context));
}

void determineIfOnlyNewParsingMechanismCanBeUsed() {
    if (applicationModel->hasSpringConfig()) {
        useNewParsingMechanism = false;
    }
}","XmlApplicationParser* createApplicationParser() {
    ExtensionManager* extensionManager = muleContext->getExtensionManager();
    DslResolvingContext* context = extensionManager != nullptr
        ? DslResolvingContext::getDefault(extensionManager->getExtensions())
        : nullptr;
    return new XmlApplicationParser(new XmlApplicationServiceRegistry(serviceRegistry, context));
}",1
"HoodieTableType getTableType() {
    return HoodieTableType::valueOf(getStringOrDefault(HOODIE_TABLE_TYPE_PROP));
}

Option<TimelineLayoutVersion> getTimelineLayoutVersion() {
    return contains(HOODIE_TIMELINE_LAYOUT_VERSION_PROP)
        ? Option<TimelineLayoutVersion>::of(TimelineLayoutVersion(getInt(HOODIE_TIMELINE_LAYOUT_VERSION_PROP)))
        : Option<TimelineLayoutVersion>::empty();
}","HoodieTableType getTableType() {
    return HoodieTableType::valueOf(getStringOrDefault(HOODIE_TABLE_TYPE_PROP));
}

Option<TimelineLayoutVersion> getTimelineLayoutVersion() {
    return contains(HOODIE_TIMELINE_LAYOUT_VERSION_PROP)
        ? Option<TimelineLayoutVersion>::of(TimelineLayoutVersion(getInt(HOODIE_TIMELINE_LAYOUT_VERSION_PROP)))
        : Option<TimelineLayoutVersion>::empty();
}",0
"#include <iterator>
#include <map>
#include <string>
#include <chrono>
#include <stdexcept>

#include <algorithm>
#include <memory>","#include <algorithm>
#include <iterator>
#include <map>
#include <string>
#include <vector>
#include <chrono>
#include <stdexcept>",0
"void overrideWith(const State& otherState) {
    overrideWith(otherState.specProperties);
}","void overrideWith(const State& otherState) {
    overrideWith(otherState.specProperties);
}",1
"#include <string>
#include <vector>

class Apple {};
class Banana {};
class Fruit {};

class HeisenbergConnectionExceptionEnricher {};

class HeisenbergException : public std::exception {};

class BarberPreferences {};","#include ""BackPressureContext.h""
#include ""HeisenbergConnectionExceptionEnricher.h""
#include ""HeisenbergException.h""
#include ""BarberPreferences.h""
#include ""Apple.h""
#include ""Banana.h""
#include ""Fruit.h""",0
"struct {
    void execute() {
        isWaitingForUserResponseToExternalEdit_ = false;
        CloseEvent::fire(TextEditingTarget::this_ptr, nullptr);
    }
}","{
    void execute() {
        isWaitingForUserResponseToExternalEdit_ = false;
        CloseEvent::fire(this, nullptr);
    }
},",0
"Timber::e(e, ""Could not dismiss mProgressDialog. The Activity must have been destroyed while the AsyncTask was running"");
AnkiDroidApp::sendExceptionReport(e, ""DeckPicker.onPostExecute"", ""Could not dismiss mProgressDialog"");

std::string syncMessage = data.message;
if (!data.success) {
    auto result = std::any_cast<std::vector<std::any>>(data.result);
    if (result.size() > 0 && result[0].type() == typeid(std::string)) {
        std::string resultType = std::any_cast<std::string>(result[0]);
        if (false) {} // Keep for syntax
        else if (resultType == ""badAuth"") {
            auto preferences = AnkiDroidApp::getSharedPrefs(getBaseContext());
            auto editor = preferences.edit();
            editor.putString(""username"", """");
            editor.putString(""hkey"", """");
            editor.apply();
            showSyncErrorDialog(SyncErrorDialog::DIALOG_USER_NOT_LOGGED_IN_SYNC);
        } else if (resultType == ""noChanges"") {
            SyncStatus::markSyncCompleted();
            showSyncLogMessage(R::string::sync_no_changes_message, """");
        } else if (resultType == ""clockOff"") {
            long long diff = std::any_cast<long long>(result[1]);
            std::string dialogMessage;
            if (diff >= 86100) {
                dialogMessage = res.getString(R::string::sync_log_clocks_unsynchronized, diff,
                                              res.getString(R::string::sync_log_clocks_unsynchronized_date));
            } else if (std::abs((diff % 3600LL) - 1800LL) >= 1500LL) {
                dialogMessage = res.getString(R::string::sync_log_clocks_unsynchronized, diff,
                                              res.getString(R::string::sync_log_clocks_unsynchronized_tz));
            } else {
                dialogMessage = res.getString(R::string::sync_log_clocks_unsynchronized, diff, """");
            }
            showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
        } else if (resultType == ""fullSync"") {
            if (getCol().isEmpty()) {
                sync(FULL_DOWNLOAD);
            } else {
                showSyncErrorDialog(SyncErrorDialog::DIALOG_SYNC_CONFLICT_RESOLUTION);
            }
        } else if (resultType == ""basicCheckFailed"") {
            std::string","std::string syncMessage = data.message;
if (!data.success) {
    auto* result = static_cast<std::vector<std::any>*>(data.result);
    if (result && std::any_cast<std::string>(&(*result)[0])) {
        std::string resultType = std::any_cast<std::string>((*result)[0]);
        if (resultType == ""badAuth"") {
            auto& preferences = AnkiDroidApp::getSharedPrefs(getBaseContext());
            preferences.setString(""username"", """");
            preferences.setString(""hkey"", """");
            preferences.save();
            showSyncErrorDialog(SyncErrorDialog::DIALOG_USER_NOT_LOGGED_IN_SYNC);
        } else if (resultType == ""noChanges"") {
            SyncStatus::markSyncCompleted();
            showSyncLogMessage(R::string::sync_no_changes_message, """");
        } else if (resultType == ""clockOff"") {
            long diff = std::any_cast<long>((*result)[1]);
            if (diff >= 86100) {
                dialogMessage = res.getString(R::string::sync_log_clocks_unsynchronized, diff,
                        res.getString(R::string::sync_log_clocks_unsynchronized_date));
            } else if (std::abs(static_cast<double>(diff % 3600) - 1800.0) >= 1500.0) {
                dialogMessage = res.getString(R::string::sync_log_clocks_unsynchronized, diff,
                        res.getString(R::string::sync_log_clocks_unsynchronized_tz));
            } else {
                dialogMessage = res.getString(R::string::sync_log_clocks_unsynchronized, diff, """");
            }
            showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
        } else if (resultType == ""fullSync"") {
            if (getCol().isEmpty()) {
                sync(FULL_DOWNLOAD);
            } else {
                showSyncErrorDialog(SyncErrorDialog::DIALOG_SYNC_CONFLICT_RESOLUTION);
            }
        } else if (resultType == ""basicCheckFailed"") {
            dialogMessage = res.getString(R::string::sync_basic_check_failed, res.getString(R::string::check_db));
            showSyncErrorMessage(joinSyncMessages(dialogMessage, syncMessage));
        } else if (resultType == ""dbError"") {
            showSyncErrorDialog(SyncErrorDialog::DIALOG_SYNC_CORRUPT_COLLECTION, syncMessage);
        } else if (resultType ==",1
"void enrichParameterFields(
    std::vector<FieldValues>& fieldsValues, 
    ParameterDeclaration& paramDeclaration,
    std::unordered_map<std::string, std::string>& parameterNames,
    const std::string& name,
    const std::vector<ParameterDeclaration>& allParameters
) {
    std::vector<FieldValueProviderModel> fieldValueProviderModels;
    std::unordered_map<std::string, ValueProviderFactoryModelProperty> valueProviderFactoryModelProperties;

    for (const auto& fieldValues : fieldsValues) {
        auto propertyBuilder = ValueProviderFactoryModelProperty::builder(fieldValues.value());

        ParameterizableTypeWrapper resolverClassWrapper(
            fieldValues.value(), 
            DefaultExtensionsTypeLoaderFactory().createTypeLoader()
        );

        auto resolverParameters = resolverClassWrapper.getParametersAnnotatedWith<Parameter>();

        for (const auto& param : resolverParameters) {
            propertyBuilder.withInjectableParameter(
                param.getName(),
                param.getType().asMetadataType(),
                param.isRequired()
            );
        }

        bool requiresConfiguration = false;
        bool requiresConnection = false;

        if (auto field = enrichWithConnection(propertyBuilder, resolverClassWrapper)) {
            requiresConnection = true;
        }
        if (auto field = enrichWithConfiguration(propertyBuilder, resolverClassWrapper)) {
            requiresConfiguration = true;
        }

        int partOrder = 1;
        for (const auto& targetPath : fieldValues.targetPaths()) {
            auto valueProviderFactoryModelProperty = propertyBuilder.build();
            valueProviderFactoryModelProperties[targetPath] = valueProviderFactoryModelProperty;
            fieldValueProviderModels.emplace_back(
                getActingParametersModel(resolverParameters, parameterNames, allParameters, {}),
                requiresConfiguration,
                requiresConnection,
                fieldValues.open(),
                partOrder,
                name,
                getValueProviderId(fieldValues.value()),
                targetPath
            );
            ++partOrder;
        }
        paramDeclaration.setFieldValueProviderModels(fieldValueProviderModels);
        paramDeclaration.addModelProperty(
            FieldsValueProviderFactoryModelProperty(valueProviderFactoryModelProperties)
        );
    }
}","```cpp
#include <vector>
#include <map>
#include <string>
#include <list>
#include <memory>

class FieldValues {
public:
    std::string value() const;
    std::vector<std::string> targetPaths() const;
    bool open() const;
};

class ParameterDeclaration {
public:
    void setFieldValueProviderModels(const std::list<class FieldValueProviderModel>& models);
    void addModelProperty(const class FieldsValueProviderFactoryModelProperty& property);
};

class ParameterizableTypeWrapper {
public:
    ParameterizableTypeWrapper(const std::string& value, const class DefaultExtensionsTypeLoaderFactory& loader);
    std::vector<class ExtensionParameter> getParametersAnnotatedWith(const std::type_info& annotation) const;
};

class DefaultExtensionsTypeLoaderFactory {
public:
    class TypeLoader createTypeLoader() const;
};

class FieldValueProviderModel {
public:
    FieldValueProviderModel(const std::vector<class ActingParameterModel>& actingParams, bool requiresConfiguration, bool requiresConnection, bool open, int partOrder, const std::string& name, const std::string& valueProviderId, const std::string& targetPath);
};

class ValueProviderFactoryModelProperty {
    // ...
};

class ValueProviderFactoryModelPropertyBuilder {
public:
    static ValueProviderFactoryModelPropertyBuilder builder(const std::string& value);
    ValueProviderFactoryModelPropertyBuilder& withInjectableParameter(const std::string& name, const class MetadataType& type, bool required);
    ValueProviderFactoryModelProperty build();
};

class ReferenceBool {
    bool value;
public:
    ReferenceBool(bool v) : value(v) {}
    void set(bool v) { value = v; }
    bool get() const { return value; }
};

class FieldsValueProviderFactoryModelProperty {
public:
    FieldsValueProviderFactoryModelProperty(const std::map<std::string, ValueProviderFactoryModelProperty>& properties);
};

std::string getValueProviderId(const std::string& value);
std::vector<class ActingParameterModel> getActingParametersModel(
    const std::vector<class ExtensionParameter>& resolverParameters,
    const std::map<std::string, std::string>& parameterNames,
    const std::vector<ParameterDeclaration>& allParameters,
    const std::map<std::string, std::string>& emptyMap
);

std::optional<std::string> enrichWithConnection(ValueProviderFactoryModelPropertyBuilder& builder, ParameterizableTypeWrapper& resolverClassWrapper);
std::optional<std::string> enrichWith",1
"#include ""MessageSource.h""
#include ""PollSkipAdvice.h""
#include ""SimplePollSkipStrategy.h""
#include ""OnlyOnceTrigger.h""
#include ""TestUtils.h""
#include ""CompoundTrigger.h""
#include ""DynamicPeriodicTrigger.h""","#include ""spring/integration/config/ExpressionControlBusFactoryBean.h""
#include ""spring/integration/core/MessageSource.h""
#include ""spring/integration/scheduling/PollSkipAdvice.h""
#include ""spring/integration/scheduling/SimplePollSkipStrategy.h""
#include ""spring/integration/test/util/OnlyOnceTrigger.h""
#include ""spring/integration/test/util/TestUtils.h""
#include ""spring/integration/util/CompoundTrigger.h""
#include ""spring/integration/util/DynamicPeriodicTrigger.h""",0
"return listening;
}

void sleepBeforeRecoveryAttempt() {
    if (this->recoveryInterval > 0) {
        try {
            std::this_thread::sleep_for(std::chrono::milliseconds(this->recoveryInterval));
        } catch (...) {
            logger.debug(""Thread interrupted while sleeping the recovery interval"");
        }
    }
}","private:
    void sleepBeforeRecoveryAttempt() {
        if (this->recoveryInterval > 0) {
            try {
                std::this_thread::sleep_for(std::chrono::milliseconds(this->recoveryInterval));
            } catch (...) {
                logger.debug(""Thread interrupted while sleeping the recovery interval"");
            }
        }
    }",0
"}
else
{
    copyInputStreamToFile(zip.getInputStream(entry), destFile);
    chmodRwx(destFile);
}
}","```cpp
copyInputStreamToFile(zip.getInputStream(entry), destFile);
chmodRwx(destFile);
```",1
"try {
  // ...
} catch (const IOException& ioe) {
  LOGGER.error(""Failed to close the "" + std::string(typeid(GobblinYarnAppLauncher).name()), ioe);
} catch (const TimeoutException& te) {
  LOGGER.error(""Timeout in stopping the service manager"", te);
} finally { // C++ does not have finally; see below 
  if (this->emailNotificationOnShutdown) {
    sendEmailOnShutdown(std::make_optional(applicationReport));
  }
}

// ---

void handleGetApplicationReportFailureEvent(const GetApplicationReportFailureEvent& /*getApplicationReportFailureEvent*/) {
  int numConsecutiveFailures = this->getApplicationReportFailureCount.fetch_add(1) + 1;
  if (numConsecutiveFailures > this->maxGetApplicationReportFailures) {
    LOGGER.warn(
      ""Number of consecutive failures to get the ApplicationReport "" +
      std::to_string(numConsecutiveFailures) +
      "" exceeds the threshold "" +
      std::to_string(this->maxGetApplicationReportFailures)
    );

    try {
      stop();
    } catch (const IOException& ioe) {
      LOGGER.error(""Failed to close the "" + std::string(typeid(GobblinYarnAppLauncher).name()), ioe);
    } catch (const TimeoutException& te) {
      LOGGER.error(""Timeout in stopping the service manager"", te);
    }
    if (this->emailNotificationOnShutdown) {
      sendEmailOnShutdown(std::nullopt);
    }
  }
}","```cpp
void GobblinYarnAppLauncher::handleGetApplicationReportFailureEvent(const GetApplicationReportFailureEvent& /*getApplicationReportFailureEvent*/) {
    int numConsecutiveFailures = this->getApplicationReportFailureCount.fetch_add(1) + 1;
    if (numConsecutiveFailures > this->maxGetApplicationReportFailures) {
        LOGGER.warn(fmt::format(""Number of consecutive failures to get the ApplicationReport {} exceeds the threshold {}"", 
            numConsecutiveFailures, this->maxGetApplicationReportFailures));
        try {
            stop();
        } catch (const std::ios_base::failure& ioe) {
            LOGGER.error(std::string(""Failed to close the "") + typeid(GobblinYarnAppLauncher).name(), ioe);
        } catch (const TimeoutException& te) {
            LOGGER.error(""Timeout in stopping the service manager"", te);
        } 
        if (this->emailNotificationOnShutdown) {
            sendEmailOnShutdown(std::nullopt);
        }
    }
}
```",1
"void notifySubscriber(const URL& url, NotifyListener* listener, const std::vector<Instance>& instances) {
    std::vector<Instance> healthyInstances(instances.begin(), instances.end());
    if (!healthyInstances.empty()) {
        filterHealthyInstances(healthyInstances);
    }
    std::vector<URL> urls = toUrlWithEmpty(url, healthyInstances);
    NacosRegistry::notify(url, listener, urls);
}","void notifySubscriber(const URL& url, NotifyListener* listener, const std::vector<Instance>& instances) {
    std::vector<Instance> healthyInstances(instances.begin(), instances.end());
    if (!healthyInstances.empty()) {
        filterHealthyInstances(healthyInstances);
    }
    std::vector<URL> urls = toUrlWithEmpty(url, healthyInstances);
    this->notify(url, listener, urls);
}",1
"#include <map>
#include <memory>

class ObjectFieldType;
class ObjectType;
class MetadataTypeVisitor;
class ExtensionWalker;
class IllegalModelDefinitionException;
class ExtensionModel;
class ConfigurationModel;
class ConnectionProviderModel;
class OperationModel;
class ParameterModel;
class ParameterizedModel;
class ImportedTypesModelProperty;
class SubTypesModelProperty;
class SourceModel;
class IllegalParameterModelDefinitionException;
class SubTypesMappingContainer;
class ParameterGroupModelProperty;","#include <map>
#include <memory>
#include <stdexcept>

class MetadataType;
class ObjectFieldType;
class ObjectType;
class MetadataTypeVisitor;
class ExtensionWalker;
class IllegalModelDefinitionException : public std::logic_error {
public:
    using std::logic_error::logic_error;
};
class ExtensionModel;
class ConfigurationModel;
class ConnectionProviderModel;
class OperationModel;
class ParameterModel;
class ParameterizedModel;
class ImportedTypesModelProperty;
class SubTypesModelProperty;
class SourceModel;
class IllegalParameterModelDefinitionException : public std::logic_error {
public:
    using std::logic_error::logic_error;
};
class SubTypesMappingContainer;
class ParameterGroupModelProperty;

using ImmutableMap = std::map;",0
"DFSPropertiesConfiguration readConfig(FileSystem& fs, const Path& cfgPath, const std::vector<std::string>& overriddenProps) {
    DFSPropertiesConfiguration conf(fs, cfgPath);
    try {
        if (!overriddenProps.empty()) {
            LOG.info(""Adding overridden properties to file properties."");
            std::string propsString;
            for (size_t i = 0; i < overriddenProps.size(); ++i) {
                propsString += overriddenProps[i];
                if (i + 1 != overriddenProps.size()) {
                    propsString += '\n';
                }
            }
            std::istringstream iss(propsString);
            conf.addPropsFromStream(iss);
        }
    } catch (const std::ios_base::failure& ioe) {
        throw HoodieIOException(""Unexpected error adding config overrides"", ioe);
    }
    return conf;
}","DFSPropertiesConfiguration readConfig(FileSystem& fs, const Path& cfgPath, const std::vector<std::string>& overriddenProps) {
    DFSPropertiesConfiguration conf(fs, cfgPath);
    try {
        if (!overriddenProps.empty()) {
            LOG.info(""Adding overridden properties to file properties."");
            std::ostringstream oss;
            for (size_t i = 0; i < overriddenProps.size(); ++i) {
                oss << overriddenProps[i];
                if (i + 1 < overriddenProps.size()) oss << '\n';
            }
            std::istringstream iss(oss.str());
            conf.addPropsFromStream(iss);
        }
    } catch (const std::ios_base::failure& ioe) {
        throw HoodieIOException(""Unexpected error adding config overrides"", ioe);
    }
    return conf;
}",1
"const bool canDumpHeap;

const double GCThrashingPercentagePerPeriod;

std::atomic<bool> isThrashing{false};

std::atomic<bool> isRunning{false};","```cpp
class MemoryMonitor : public Runnable, public StatusDataProvider {
private:
    const bool canDumpHeap;

    // The GC thrashing threshold (0.00 - 100.00) for every period. If the time spent on garbage
    // collection in one period exceeds this threshold, that period is considered to be in GC
    // thrashing.
    const double GCThrashingPercentagePerPeriod;

    std::atomic<bool> isThrashing{false};
    std::atomic<bool> isRunning{false};
};
```",1
"if (LOG.isDebugEnabled()) {
    LOG.debug(""Converting "" + to_string(record));
}

JdbcEntryData converted = buildJdbcEntryData(
    outputSchema,
    [&](const std::string& s) { return avroRecordValueGet(record, splitAvroRecordLevel(s)); },
    JdbcEntryData::Operation::INSERT
);

if (LOG.isDebugEnabled()) {
    LOG.debug(""Converted data into "" + to_string(converted));
}

return SingleRecordIterable<JdbcEntryData>(converted);
}


///**
// * Build a JdbcEntryData from a value generating function and an operation.
// *
// * For each column in the schema, the value generating function should return either
// * 1) the value to set the column to, 2) nullptr to set the column to null, or 3) SKIP_UPDATE to leave the column unchanged.
// * @throws DataConversionException
// */

protected:
JdbcEntryData buildJdbcEntryData(
    const JdbcEntrySchema& outputSchema,
    const std::function<std::any(const std::string&)>& valueGenerator,
    JdbcEntryData::Operation operation
) {
    std::vector<JdbcEntryDatum> jdbcEntryData;
    for (const auto& entry : outputSchema) {
        const std::string& jdbcColName = entry.getColumnName();
        const JDBCType jdbcType = entry.getJdbcType();

        std::string avroColName = convertJdbcColNameToAvroColName(jdbcColName);
        std::any val = valueGenerator(avroColName);

        if (val.has_value() && val.type() == typeid(SkipUpdateType)) {
            switch (operation) {
                case JdbcEntryData::Operation::INSERT:
                    jdbcEntryData.emplace_back(jdbcColName, nullptr);
                    break;
                case JdbcEntryData::Operation::DELETE:
                case JdbcEntryData::Operation::UPDATE:
                case JdbcEntryData::Operation::UPSERT:
                    break;
            }
            continue;
        }

        if (!val.has_value()) {
            jdbcEntryData.emplace_back(jdbcColName, nullptr);
            continue;
        }

        switch (jdbcType) {
            case JDBCType::VARCHAR:
            case JDBCType::LONGNVARCHAR:
            case JDBCType::LONGVARCHAR:
            case JDBCType::NVARCHAR:
                jdbcEntryData.emplace_back(jdbcColName, std::any_cast<std::string>(val));
                continue;
            case JDBCType::INTEGER:
                //","```cpp
#include <vector>
#include <string>
#include <functional>
#include <iterator>

enum class JDBCType {
    VARCHAR,
    LONGNVARCHAR,
    LONGVARCHAR,
    NVARCHAR,
    INTEGER,
    // ... other types
};

enum class Operation {
    INSERT,
    DELETE,
    UPDATE,
    UPSERT
};

class JdbcEntryDatum {
public:
    JdbcEntryDatum(const std::string& colName, const std::any& value)
        : columnName(colName), val(value) {}
    std::string columnName;
    std::any val;
};

class JdbcEntryData {
public:
    enum class Operation { INSERT, DELETE, UPDATE, UPSERT };

    JdbcEntryData(const std::vector<JdbcEntryDatum>& data, Operation op)
        : entryData(data), operation(op) {}
    std::vector<JdbcEntryDatum> entryData;
    Operation operation;
};

class JdbcEntryMetaDatum {
public:
    const std::string& getColumnName() const;
    JDBCType getJdbcType() const;
};

class JdbcEntrySchema {
public:
    std::vector<JdbcEntryMetaDatum>::const_iterator begin() const;
    std::vector<JdbcEntryMetaDatum>::const_iterator end() const;
};

class DataConversionException : public std::exception {
public:
    explicit DataConversionException(const std::string& msg) : message(msg) {}
    const char* what() const noexcept override { return message.c_str(); }
private:
    std::string message;
};

struct SKIP_UPDATE_t {};
constexpr SKIP_UPDATE_t SKIP_UPDATE{};

template<typename T>
class SingleRecordIterable {
public:
    explicit SingleRecordIterable(const T& record) : rec(record) {}
    const T& get() const { return rec; }
private:
    T rec;
};

JdbcEntryData buildJdbcEntryData(
    const JdbcEntrySchema& outputSchema,
    const std::function<std::any(const std::string&)>& valueGenerator,
    Operation operation)
{
    std::vector<JdbcEntryDatum> jdbcEntryData;
    for (const auto& entry : outputSchema) {
        const std::string& jdbcColName = entry.getColumnName();
        JDBCType jdbcType = entry.getJdbcType();

        std::string avroColName = convertJdbcColNameToAvroColName(jdbcColName);
        std::any val = valueGenerator(avroColName);

        if (val.type() == typeid(SKIP_UPDATE_t)) {",1
"if (!returnsVoid) {
    return from(publisher)
        .concatMap([this](auto request) {
            return just(request)
                .map([this](auto event) { return createEventWithParameters(event); })
                .transform([this](auto s) { return Base::apply(s); })
                .map([this](auto result) { return createNewEventFromJustMessage(request, result); });
        });
} else {
    return publisher;
}","if (!returnsVoid) {
    return from(publisher)
        .concatMap([this](auto request) {
            return just(request)
                .map([this](auto event) { return createEventWithParameters(event); })
                .transform([this](auto s) { return ExplicitMessage::apply(s); })
                .map([this, &request](auto result) { return createNewEventFromJustMessage(request, result); });
        });
} else {
    return publisher;
}",1
"std::optional<Schema> schema;
std::optional<GenericDatumReader<Record>> reader;

KafkaAvroExtractor(WorkUnitState& state) : Extractor(state) {
    this->schema = getExtractorSchema();
    if (this->schema.has_value()) {
        this->reader = std::make_optional<GenericDatumReader<Record>>(this->schema.value());
    } else {
        LOG.error(""Cannot find latest schema for topic {}. This topic will be skipped"", this->topicName);
        this->reader = std::nullopt;
    }
}

GenericRecord readRecordImpl(GenericRecord reuse) override {
    if (!this->schema.has_value()) {
        // ... (continued logic)
    }
    // ... (rest of function)
}","```cpp
class KafkaAvroExtractor : public KafkaExtractor<Schema, GenericRecord> {
private:
    std::optional<Schema> schema;
    std::optional<GenericDatumReader<Record>> reader;

public:
    KafkaAvroExtractor(const WorkUnitState& state) 
        : KafkaExtractor<Schema, GenericRecord>(state) {
        schema = getExtractorSchema();
        if (schema.has_value()) {
            reader.emplace(schema.value());
        } else {
            LOG::error(""Cannot find latest schema for topic {}. This topic will be skipped"", this->topicName);
            reader.reset();
        }
    }

    GenericRecord readRecordImpl(GenericRecord reuse) override {
        if (!schema.has_value()) {
            // (original method is incomplete, so body is left open)
        }
        // ...
    }
};
```",0
"assert(result1);
std::atomic<bool> sendInterrupted(false);
std::latch latch(1);
std::jthread t([&] {
    channel.send(GenericMessage<std::string>(""test-2""), 10000);
    sendInterrupted.store(true);
    latch.count_down();
});
assert(!sendInterrupted.load());
t.request_stop();
latch.wait();
assert(sendInterrupted.load());","```cpp
#include <gtest/gtest.h>
#include <atomic>
#include <thread>
#include <future>
#include <condition_variable>
#include <mutex>
#include <chrono>

// Assuming you have a QueueChannel class and GenericMessage similar to your Java code

TEST(QueueChannelTests, TestSendInterruption) {
    ASSERT_TRUE(result1);
    std::atomic<bool> sendInterrupted{false};
    std::mutex mtx;
    std::condition_variable cv;
    bool latch = false;

    auto task = [&]() {
        channel.send(GenericMessage<std::string>(""test-2""), 10000);
        sendInterrupted.store(true);
        {
            std::lock_guard<std::mutex> lock(mtx);
            latch = true;
        }
        cv.notify_one();
    };

    std::thread worker(task);
    ASSERT_FALSE(sendInterrupted.load());
    worker.detach(); // No direct interrupt, so we'll use shutdown workaround

    {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait_for(lock, std::chrono::seconds(10), [&]{ return latch; });
    }
    ASSERT_TRUE(sendInterrupted.load());
}
```",0
"#include ""TransactionCoordination.h""
#include ""NotificationUtils.h""
#include ""ThreadNameHelper.h""
#include ""Exceptions.h""
#include ""ReactiveFlux.h""
#include ""ReactiveMono.h""

using mule::runtime::core::transaction::isTransactionActive;
using mule::runtime::core::util::NotificationUtils::buildPathResolver;
using mule::runtime::core::util::concurrent::ThreadNameHelper::getPrefix;
using mule::runtime::core::util::rx::Exceptions::UNEXPECTED_EXCEPTION_PREDICATE;
using mule::runtime::core::util::rx::Exceptions::checkedFunction;
using mule::runtime::core::util::rx::Exceptions::rxExceptionToMuleException;
using reactor::core::publisher::Flux::from;
using reactor::core::publisher::Mono::empty;
using reactor::core::publisher::Mono::just;

#include ""MuleException.h""
#include ""LifecycleException.h""","#include ""SynchronousProcessingStrategy.h""
#include ""TransactionCoordination.h""
#include ""NotificationUtils.h""
#include ""ThreadNameHelper.h""
#include ""Exceptions.h""
#include ""Flux.h""
#include ""Mono.h""
#include ""MuleException.h""
#include ""LifecycleException.h""",0
"/**
 * @function
 *
 * @param blacklist When provided, replaces the resourceUrlBlacklist with the value
 *     provided. This must be an array or null. A snapshot of this array is used so further
 *     changes to the array are ignored.
 *
 *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items allowed in
 *     this array.
 *
 *     The typical usage for the blacklist is to block [open redirects](http://cwe.mitre.org/data/definitions/601.html)
 *     served by your domain as these would otherwise be trusted but actually return content from the redirected
 */","```cpp
void SceDelegateProvider(const std::vector<std::string>* blacklist = nullptr) {
    // ...
}
```",1
"#include <vector>
#include <optional>
#include <unordered_map>","#include <vector>
#include <optional>
#include <unordered_map>",0
"#include <atomic>
#include <string>
#include <chrono>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <set>

class HoodieActiveTimeline {
public:
    static std::atomic<std::string> lastInstantTime;

    /**
     * Returns next instant time that adds milliseconds in the COMMIT_FORMATTER format.
     * Ensures each instant time is at least 1 second apart since we create instant times at second granularity
     */
    static std::string createNewInstantTime(long milliseconds) {
        std::string expected = lastInstantTime.load();
        std::string newCommitTime;
        while (true) {
            do {
                auto now = std::chrono::system_clock::now() + std::chrono::milliseconds(milliseconds);
                std::time_t now_time = std::chrono::system_clock::to_time_t(now);
                std::tm tm_val;
#if defined(_MSC_VER)
                localtime_s(&tm_val, &now_time);
#else
                localtime_r(&now_time, &tm_val);
#endif  
                std::ostringstream oss;
                oss << std::put_time(&tm_val, ""%Y%m%d%H%M%S"");
                newCommitTime = oss.str();
            } while (HoodieTimeline::compareTimestamps(newCommitTime, HoodieTimeline::LESSER_THAN_OR_EQUALS, expected));
            if (lastInstantTime.compare_exchange_weak(expected, newCommitTime)) {
                return newCommitTime;
            }
        }
    }

protected:
    HoodieActiveTimeline(HoodieTableMetaClient* metaClient, const std::set<std::string>& includedExtensions)
        : HoodieActiveTimeline(metaClient, includedExtensions, true) {}

    HoodieActiveTimeline(HoodieTableMetaClient* metaClient, const std::set<std::string>& includedExtensions, bool someFlag) {
        // implementation ...
    }
};

// Dummy dependencies (for illustration; actual implementation needed)
class HoodieTableMetaClient {};
class HoodieTimeline {
public:
    enum Comparator { LESSER_THAN_OR_EQUALS };
    static bool compareTimestamps(const std::string&, Comparator, const std::string&) { return false; }
};
std::atomic<std::string> HoodieActiveTimeline::lastInstantTime{""""};","```cpp
static std::atomic<std::string> lastInstantTime;

static std::string createNewInstantTime(long milliseconds) {
    return lastInstantTime.update_and_fetch([milliseconds](const std::string& oldVal) {
        std::string newCommitTime;
        do {
            auto now = std::chrono::system_clock::now() + std::chrono::milliseconds(milliseconds);
            std::time_t now_time_t = std::chrono::system_clock::to_time_t(now);
            std::tm tm_struct;
#ifdef _WIN32
            localtime_s(&tm_struct, &now_time_t);
#else
            localtime_r(&now_time_t, &tm_struct);
#endif
            char buffer[20];
            std::strftime(buffer, sizeof(buffer), COMMIT_FORMATTER, &tm_struct);
            newCommitTime = buffer;
        } while (HoodieTimeline::compareTimestamps(newCommitTime, LESSER_THAN_OR_EQUALS, oldVal));
        return newCommitTime;
    });
}

protected:
HoodieActiveTimeline(HoodieTableMetaClient* metaClient, const std::set<std::string>& includedExtensions)
    : HoodieActiveTimeline(metaClient, includedExtensions, true) {
}
```",1
"return;
    }
    // load registry
    loadConfigs<RegistryConfig>();

    auto defaultRegistries = configManager.getDefaultRegistries();
    if (!defaultRegistries.empty()) {
        for (const auto& registry : defaultRegistries) {
            if (isUsedRegistryAsConfigCenter(registry)) {
                auto configCenter = registryAsConfigCenter(registry);
                configManager.addConfigCenter(configCenter);
            }
        }
        logger.info(""use registry as config-center: "" + to_string(configManager.getConfigCenters()));
    }
} 

private:
    bool isUsedRegistryAsConfigCenter(const RegistryConfig& registryConfig) {","loadConfigs<RegistryConfig>();

std::vector<RegistryConfig> defaultRegistries = configManager.getDefaultRegistries();
if (!defaultRegistries.empty()) {
    for (const auto& registry : defaultRegistries) {
        if (isUsedRegistryAsConfigCenter(registry)) {
            ConfigCenterConfig configCenter = registryAsConfigCenter(registry);
            configManager.addConfigCenter(configCenter);
        }
    }
    logger.info(""use registry as config-center: "" + to_string(configManager.getConfigCenters()));
}",0
"poolResponse.setHypervisor(std::to_string(static_cast<int>(pool.getHypervisor())));
}

auto poolType = storagePoolDetailsDao.findDetail(pool.getId(), ""pool_type"");
if (poolType != nullptr) {
    poolResponse.setType(poolType->getValue());
}

long long allocatedSize = pool.getUsedCapacity() + pool.getReservedCapacity();
poolResponse.setDiskSizeTotal(pool.getCapacityBytes());
poolResponse.setDiskSizeAllocated(allocatedSize);","if (pool.getHypervisor() != nullptr) {
    poolResponse.setHypervisor(pool.getHypervisor()->toString());
}

auto poolType = storagePoolDetailsDao.findDetail(pool.getId(), ""pool_type"");
if (poolType != nullptr) {
    poolResponse.setType(poolType->getValue());
}
long long allocatedSize = pool.getUsedCapacity() + pool.getReservedCapacity();
poolResponse.setDiskSizeTotal(pool.getCapacityBytes());
poolResponse.setDiskSizeAllocated(allocatedSize);",1
"if ((clusterName != nullptr || clusterId != nullptr) && podId == nullptr) {
    throw InvalidParameterValueException(""Can't specify cluster without specifying the pod"");
}

if ((toLower(hypervisorType) != toLower(HypervisorType::VMware)) &&
    (username.empty() || password.empty())) {
    throw InvalidParameterValueException(""Username and Password need to be provided."");
}

if (clusterId != nullptr) {
    if (_clusterDao.findById(clusterId) == nullptr) {","if ((clusterName != nullptr || clusterId != nullptr) && podId == nullptr) {
    throw InvalidParameterValueException(""Can't specify cluster without specifying the pod"");
}
if (!(hypervisorType != nullptr && std::string(hypervisorType) == HypervisorType::VMWARE) &&
    (username == nullptr || std::string(username).empty() || password == nullptr || std::string(password).empty())) {
    throw InvalidParameterValueException(""Username and Password need to be provided."");
}

if (clusterId != nullptr) {
    if (_clusterDao->findById(clusterId) == nullptr) {",1
"return;
  }
  try {
    this->writer.flush();
  } catch (...) {
    this->writer.close();
    this->closed = true;
    throw;
  }
  this->writer.close();
  this->closed = true;
}","void AvroHdfsDataWriter::close() {
    if (closed) {
        return;
    }
    try {
        writer->flush();
    } catch (...) {
        writer->close();
        closed = true;
        throw;
    }
    writer->close();
    closed = true;
}

void AvroHdfsDataWriter::commit() {
    // Close the writer first if it has not been closed yet
    if (!closed) {
        close();
    }

    if (!fs->exists(stagingFile)) {
        throw std::ios_base::failure(""File "" + stagingFile + "" does not exist"");
    }

    LOG_INFO(""Moving data from "" + stagingFile + "" to "" + outputFile);

    if (fs->exists(outputFile)) {
        LOG_WARN(""Task output file "" + outputFile + "" already exists"");
        HadoopUtils::deletePath(fs, outputFile, false);
    }

    HadoopUtils::renamePath(fs, stagingFile, outputFile);
}

void AvroHdfsDataWriter::cleanup() {
    // Delete the staging file
    if (fs->exists(stagingFile)) {
        HadoopUtils::deletePath(fs, stagingFile, false);
    }
}",0
"throw std::runtime_error(""Failed to commit metadata table records at instant "" + instantTime);
}
);
// trigger cleaning, compaction, with suffixes based on the same instant time. This ensures that any future
// delta commits synced over will not have an instant time lesser than the last completed instant on the
// metadata table.
writeClient.clean(instantTime + ""001"");
if (writeClient.scheduleCompactionAtInstant(instantTime + ""002"", std::nullopt)) {
    writeClient.compact(instantTime + ""002"");
}
}

// Update total size of the metadata and count of base/log files","if (!writeClient.commit(instantTime, records)) {
    throw HoodieMetadataException(""Failed to commit metadata table records at instant "" + instantTime);
}
// trigger cleaning, compaction, with suffixes based on the same instant time. This ensures that any future
// delta commits synced over will not have an instant time lesser than the last completed instant on the
// metadata table.
writeClient.clean(instantTime + ""001"");
if (writeClient.scheduleCompactionAtInstant(instantTime + ""002"", Option::empty())) {
    writeClient.compact(instantTime + ""002"");
}",1
"std::string getExpression() const {
    return expression;
}

bool isMelAvailable() const {
    return melAvailable;
}","template<typename T>
class ExpressionValueResolver {
public:
    const std::string& getExpression() const {
        return expression;
    }

    bool isMelAvailable() const {
        return melAvailable;
    }

private:
    std::string expression;
    bool melAvailable;
};",0
"#include <string>

constexpr auto TRANSPORT_HEADERS_PARAM = ""TRANSPORT_HEADERS_PARAM"";
constexpr auto CALCIO_DESC = ""CALCIO_DESC"";
constexpr auto CALCIO_ID = ""CALCIO_ID"";","#include ""mule/runtime/module/extension/soap/internal/loader/SoapInvokeOperationDeclarer.h""
#include ""mule/test/soap/extension/CalcioServiceProvider.h""

using mule::metadata::api::model::BinaryType;
using mule::metadata::api::model::ObjectType;
using mule::metadata::api::model::StringType;",0
"#include ""ComponentUtils.h""
#include ""Operators.h""
#include ""PrivilegedEvent.h""
#include ""LoggerFactory.h""
#include ""Mono.h""

using ComponentUtils::getFromAnnotatedObjectOrFail;
using Operators::requestUnbounded;
using PrivilegedEvent::setCurrentEvent;
using LoggerFactory::getLogger;
using Mono::just;

#include ""AbstractComponent.h""","#include <memory>

using namespace std;",0
"#include ""rstudio/studio/client/workbench/views/output/find/FindOutputTab.h""
#include ""rstudio/studio/client/workbench/views/output/find/model/FindInFilesServerOperations.h""
#include ""rstudio/studio/client/workbench/views/output/renderrmd/RenderRmdOutputTab.h""
#include ""rstudio/studio/client/workbench/views/output/shinyappsdeploy/ShinyAppsDeployOutputTab.h""
#include ""rstudio/studio/client/workbench/views/output/sourcecpp/SourceCppOutputPane.h""
#include ""rstudio/studio/client/workbench/views/output/sourcecpp/SourceCppOutputPresenter.h""
#include ""rstudio/studio/client/workbench/views/output/sourcecpp/SourceCppOutputTab.h""","#include ""workbench/views/output/find/FindOutputPresenter.h""
#include ""workbench/views/output/find/FindOutputTab.h""
#include ""workbench/views/output/find/model/FindInFilesServerOperations.h""
#include ""workbench/views/output/renderrmd/RenderRmdOutputTab.h""
#include ""workbench/views/output/shinyappsdeploy/ShinyAppsDeployOutputTab.h""
#include ""workbench/views/output/sourcecpp/SourceCppOutputPane.h""
#include ""workbench/views/output/sourcecpp/SourceCppOutputPresenter.h""
#include ""workbench/views/output/sourcecpp/SourceCppOutputTab.h""",0
"private:
    int carryOverBytes;
    std::vector<uint8_t> carryOverByteArray;

    JulHandlerPrintStream(Handler* handler, const std::string& loggerName, Level logLevel)
        : carryOverBytes(0), carryOverByteArray() 
    {
        // super() logic here
    }","class JulHandlerPrintStreamAdapterFactory {
private:
    int carryOverBytes;
    std::vector<uint8_t> carryOverByteArray;

    JulHandlerPrintStream(Handler* handler, const std::string& loggerName, Level logLevel)
        : carryOverBytes(0), carryOverByteArray() {
        // ...
    }
};",1
"builder.append(""library(dplyr)\n"");
}

std::string selection = master_.getSelection();
std::vector<std::string> masterComponents;
std::stringstream ss(selection);
std::string item;
while (std::getline(ss, item, '-')) {
    // Remove leading/trailing spaces
    item.erase(0, item.find_first_not_of("" \t""));
    item.erase(item.find_last_not_of("" \t"") + 1);
    masterComponents.push_back(item);
}

builder.append(""sc <- spark_connect(master = \"""");
builder.append(masterComponents[0]);
builder.append(""\"""");
if (masterComponents.size() > 1) {
    builder.append("", app_name = \"""");
    builder.append(masterComponents[1]);
    builder.append(""\"""");
}

// spark version
if (master_.isLocalMasterSelected())","std::ostringstream builder;
builder << ""library(dplyr)\n"";

std::string selection = master_->getSelection();
std::vector<std::string> masterComponents;
std::istringstream iss(selection);
std::string part;
while (std::getline(iss, part, '-')) {
    // trim whitespace
    size_t start = part.find_first_not_of("" \t"");
    size_t end = part.find_last_not_of("" \t"");
    if (start != std::string::npos && end != std::string::npos)
        part = part.substr(start, end - start + 1);
    else
        part = """";
    masterComponents.push_back(part);
}

builder << ""sc <- spark_connect(master = \"""" << (masterComponents.size() > 0 ? masterComponents[0] : """") << ""\"""";
if (masterComponents.size() > 1) {
    builder << "", app_name = \"""" << masterComponents[1] << ""\"""";
}

// spark version
if (master_->isLocalMasterSelected()) {
    // ...
}",1
"if (attributes.count(attribute)) {
    ASSERT_EQ(
        issue.getMessage(),
        attribute.getter(attributes.at(attribute))
    ) << ""line "" << issue.getLine() << "" attribute mismatch for "" << attribute << "": "" << /* print attributes appropriately */;
}","if (attributes.contains(attribute)) {
    ASSERT_EQ(issue.getMessage(),
              attribute.getter(attributes.at(attribute)))
        << ""line "" << issue.getLine() << "" attribute mismatch for "" << attribute << "": "" << attributes;
}",1
"#include <memory>

class GroovyObject;

class Example {
public:
    Example() = default;
    virtual ~Example() = default;
protected:
    std::shared_ptr<GroovyObject> groovyObject;
};",#include <string>,1
"#include <memory>

class HoodieCompactor {
public:
    struct Config {};
private:
    static std::shared_ptr<spdlog::logger> LOG;
    Config cfg;
    FileSystem* fs = nullptr;
    TypedProperties* props = nullptr;
};

std::shared_ptr<spdlog::logger> HoodieCompactor::LOG = spdlog::get(""HoodieCompactor"");","#include <iostream>
#include <vector>
#include <memory>

class HoodieCompactor {
public:
    struct Config {
        // Define config members here
    };

    static std::shared_ptr<spdlog::logger> LOG;

    explicit HoodieCompactor(const Config& config)
        : cfg(config)
    {
        // Initialize fs and props if needed
    }

private:
    Config cfg;
    // FileSystem fs; // define or include appropriate file system handle
    // TypedProperties props; // define or include appropriate properties structure
};

std::shared_ptr<spdlog::logger> HoodieCompactor::LOG = spdlog::stdout_color_mt(""HoodieCompactor"");",0
"}
 
TEST(MyTestSuite, DeleteNoParametersInputMetadata) {
    ParameterMetadataDescriptor parameters =
        getInputMetadata(""deleteMetadata"", ""DELETE FROM PLANET WHERE name = 'Mars'"");","void deleteNoParametersInputMetadata() {
    ParameterMetadataDescriptor parameters =
        getInputMetadata(""deleteMetadata"", ""DELETE FROM PLANET WHERE name = 'Mars'"");
}",1
"static constexpr const char* INITIAL_CONSISTENCY_CHECK_INTERVAL_MS_PROP = ""hoodie.consistency.check.initial_interval_ms"";
static constexpr long DEFAULT_INITIAL_CONSISTENCY_CHECK_INTERVAL_MS = 400L;

static constexpr const char* MAX_CONSISTENCY_CHECK_INTERVAL_MS_PROP = ""hoodie.consistency.check.max_interval_ms"";
static constexpr long DEFAULT_MAX_CONSISTENCY_CHECK_INTERVAL_MS = 20000L;

// maximum number of checks, for consistency of written data. Will wait upto 140 Secs
static constexpr const char* MAX_CONSISTENCY_CHECKS_PROP = ""hoodie.consistency.check.max_checks"";
static constexpr int DEFAULT_MAX_CONSISTENCY_CHECKS = 6;

// sleep time for OptimisticConsistencyGuard
static constexpr const char* OPTIMISTIC_CONSISTENCY_GUARD_SLEEP_TIME_MS_PROP = ""hoodie.optimistic.consistency.guard.sleep_time_ms"";
static constexpr long DEFAULT_OPTIMISTIC_CONSISTENCY_GUARD_SLEEP_TIME_MS_PROP = 500L;

// config to enable OptimisticConsistencyGuard in finalizeWrite instead of FailSafeConsistencyGuard
static constexpr const char* ENABLE_OPTIMISTIC_CONSISTENCY_GUARD = ""_hoodie.optimistic.consistency.guard.enable"";
static constexpr bool DEFAULT_ENABLE_OPTIMISTIC_CONSISTENCY_GUARD = true;

ConsistencyGuardConfig(const std::unordered_map<std::string, std::string>& props)
    : BaseConfig(props) {}","#include <string>
#include <cstdint>

class ConsistencyGuardConfig : public DefaultHoodieConfig {
private:
    static constexpr const char* INITIAL_CONSISTENCY_CHECK_INTERVAL_MS_PROP = ""hoodie.consistency.check.initial_interval_ms"";
    static constexpr int64_t DEFAULT_INITIAL_CONSISTENCY_CHECK_INTERVAL_MS = 400L;

    static constexpr const char* MAX_CONSISTENCY_CHECK_INTERVAL_MS_PROP = ""hoodie.consistency.check.max_interval_ms"";
    static constexpr int64_t DEFAULT_MAX_CONSISTENCY_CHECK_INTERVAL_MS = 20000L;

    static constexpr const char* MAX_CONSISTENCY_CHECKS_PROP = ""hoodie.consistency.check.max_checks"";
    static constexpr int DEFAULT_MAX_CONSISTENCY_CHECKS = 6;

    static constexpr const char* OPTIMISTIC_CONSISTENCY_GUARD_SLEEP_TIME_MS_PROP = ""hoodie.optimistic.consistency.guard.sleep_time_ms"";
    static constexpr int64_t DEFAULT_OPTIMISTIC_CONSISTENCY_GUARD_SLEEP_TIME_MS_PROP = 500L;

    static constexpr const char* ENABLE_OPTIMISTIC_CONSISTENCY_GUARD = ""_hoodie.optimistic.consistency.guard.enable"";
    static constexpr bool DEFAULT_ENABLE_OPTIMISTIC_CONSISTENCY_GUARD = true;

public:
    ConsistencyGuardConfig(const Properties& props) : DefaultHoodieConfig(props) {}
};",1
"parallelRunnerCloser = std::make_unique<Closer>();
}

std::optional<std::vector<std::shared_ptr<MetadataMerger<std::string>>>> mergersForEachBranch() {
    std::vector<std::shared_ptr<MetadataMerger<std::string>>> metadataMergers;
    bool mergersConfigured = false;

    for (int i = 0; i < numBranches; ++i) {
        if (shouldPublishMetadataForBranch(i)) {
            metadataMergers.push_back(buildPublisherForBranch(i));
            mergersConfigured = true;
        } else {
            metadataMergers.push_back(nullptr);
        }
    }

    if (mergersConfigured) {
        return metadataMergers;
    } else {
        return std::nullopt;
    }
}

std::shared_ptr<MetadataMerger<std::string>> buildPublisherForBranch(int branchId) {
    std::string keyName = ForkOperatorUtils::getPropertyNameForBranch(
        ConfigurationKeys::DATA_PUBLISH_WRITER_METADATA_MERGER_NAME_KEY, numBranches, branchId);
    std::string className = this->getState()->getProp(
        keyName, ConfigurationKeys::DATA_PUBLISH_WRITER_METADATA_MERGER_NAME_DEFAULT);

    try {
        auto merger = GobblinConstructorUtils::invokeFirstConstructor<MetadataMerger<std::string>>(
            className,
            std::vector<std::any>{ this->getState()->getProperties() },
            std::vector<std::any>{ }
        );
        if (!merger) {
            throw std::invalid_argument(className + "" does not implement the MetadataMerger interface"");
        }
        return merger;
    } catch (const ClassNotFoundException& e) {
        throw std::invalid_argument(""Specified metadata merger class "" + className + "" not found!"");
    } catch (const ReflectiveOperationException& e) {
        throw std::invalid_argument(""Error building merger class "" + className);
    }
}

void initialize() noexcept(false) {
    // Nothing needs to be done since the constructor already initializes the publisher.
}

void close() noexcept(false) {
    try {
        for (const auto& path : this->publisherOutputDirs) {
            this->state->appendToSetProp(ConfigurationKeys::PUBLISHER_DIRS, path.string());
        }
    } catch (...) {
        throw;
    }
}","#include <vector>
#include <memory>
#include <string>
#include <stdexcept>
#include <typeinfo>

class MetadataMerger {
public:
    virtual ~MetadataMerger() {}
};

class BaseDataPublisher : public SingleTaskDataPublisher {
protected:
    int numBranches;

    std::vector<std::unique_ptr<MetadataMerger>> mergersForEachBranch() {
        std::vector<std::unique_ptr<MetadataMerger>> metadataMergers;
        bool mergersConfigured = false;

        for (int i = 0; i < numBranches; ++i) {
            if (shouldPublishMetadataForBranch(i)) {
                metadataMergers.push_back(buildPublisherForBranch(i));
                mergersConfigured = true;
            } else {
                metadataMergers.push_back(nullptr);
            }
        }

        return mergersConfigured ? std::move(metadataMergers) : std::vector<std::unique_ptr<MetadataMerger>>();
    }

    std::unique_ptr<MetadataMerger> buildPublisherForBranch(int branchId) {
        std::string keyName = ForkOperatorUtils::getPropertyNameForBranch(
            ConfigurationKeys::DATA_PUBLISH_WRITER_METADATA_MERGER_NAME_KEY,
            this->numBranches, branchId);

        std::string className = this->getState().getProp(
            keyName,
            ConfigurationKeys::DATA_PUBLISH_WRITER_METADATA_MERGER_NAME_DEFAULT);

        try {
            auto merger = GobblinConstructorUtils::invokeFirstConstructor(
                className,
                this->getState().getProperties()
            );

            MetadataMerger* casted = dynamic_cast<MetadataMerger*>(merger.get());
            if (!casted) {
                throw std::invalid_argument(className + "" does not implement the MetadataMerger interface"");
            }
            return merger;
        } catch (const std::bad_cast&) {
            throw std::invalid_argument(className + "" does not implement the MetadataMerger interface"");
        } catch (const ClassNotFoundException&) {
            throw std::invalid_argument(""Specified metadata merger class "" + className + "" not found!"");
        } catch (const std::exception& e) {
            throw std::invalid_argument(""Error building merger class "" + className);
        }
    }

public:
    void initialize() override {
        // Nothing needs to be done since the constructor already initializes the publisher.
    }

    void close() override {
        try {
            for (const Path& path : this->publisherOutputDirs",1
"```cpp
void updateDataTypeWithProperty(const std::string& key, const AnyType& value)  // Assume AnyType can hold any type, like std::any
{
    if (key == MULE_ENCODING_PROPERTY)
    {
        dataType.setEncoding(getStringPropertyValue(MULE_ENCODING_PROPERTY, value));
    }
    else if (equalsIgnoreCase(key, CONTENT_TYPE_PROPERTY))
    {
        try
        {
            const std::string contentType = getStringPropertyValue(CONTENT_TYPE_PROPERTY, value);
            MimeType mimeType(contentType);
            dataType.setMimeType(mimeType.getPrimaryType() + ""/"" + mimeType.getSubType());
            std::string encoding = mimeType.getParameter(CHARSET_PARAM);
            if (!encoding.empty())
            {
                dataType.setEncoding(encoding);
            }
        }
        catch (const std::exception& e)
        {
            // Handle error as appropriate
        }
    }
}
```","void updateDataTypeWithProperty(const std::string& key, const Any& value)
{
    if (key == MULE_ENCODING_PROPERTY)
    {
        dataType.setEncoding(getStringPropertyValue(MULE_ENCODING_PROPERTY, value));
    }
    else if (equalsIgnoreCase(key, CONTENT_TYPE_PROPERTY))
    {
        try
        {
            const std::string contentType = getStringPropertyValue(CONTENT_TYPE_PROPERTY, value);
            MimeType mimeType(contentType);
            dataType.setMimeType(mimeType.getPrimaryType() + ""/"" + mimeType.getSubType());
            std::string encoding = mimeType.getParameter(CHARSET_PARAM);
            if (!StringUtils::isEmpty(encoding))
            {
                dataType.setEncoding(encoding);
            }
        }
        catch (const std::exception& e)
        {
            // handle exception as appropriate
        }
    }
}",0
"#include <string>
#include <exception>
#include <stdexcept>
#include <map>
#include <memory>
#include <system_error>
#include <iostream>
#include <sstream>

class EmailProtocol {};
class TlsContextFactory {};

class Logger {
public:
    static Logger& getLogger(const std::string&) {
        static Logger instance;
        return instance;
    }

    void info(const std::string& msg) { std::cout << ""[INFO] "" << msg << std::endl; }
    void error(const std::string& msg) { std::cerr << ""[ERROR] "" << msg << std::endl; }
};

class AuthenticationFailedException : public std::runtime_error {
public:
    explicit AuthenticationFailedException(const std::string& msg) : std::runtime_error(msg) {}
};

class MessagingException : public std::runtime_error {
public:
    explicit MessagingException(const std::string& msg) : std::runtime_error(msg) {}
};

class Folder {};
class Store {};

class ConnectException : public std::runtime_error {
public:
    explicit ConnectException(const std::string& msg) : std::runtime_error(msg) {}
};

class SocketTimeoutException : public std::runtime_error {
public:
    explicit SocketTimeoutException(const std::string& msg) : std::runtime_error(msg) {}
};

class UnknownHostException : public std::runtime_error {
public:
    explicit UnknownHostException(const std::string& msg) : std::runtime_error(msg) {}
};

using Map = std::map<std::string, std::string>;

class ConnectionValidationResult {
public:
    static ConnectionValidationResult success() {
        return ConnectionValidationResult(true, """");
    }
    static ConnectionValidationResult failure(const std::string& reason) {
        return ConnectionValidationResult(false, reason);
    }

    bool isSuccess() const { return success_; }
    std::string getReason() const { return reason_; }

private:
    ConnectionValidationResult(bool s, const std::string& r) : success_(s), reason_(r) {}
    bool success_;
    std::string reason_;
};","#include <map>
#include <string>
#include <stdexcept>
#include <system_error>
#include <exception>
#include <memory>
#include <spdlog/spdlog.h>

// Forward declarations of email classes
class Folder;
class Store;
class TlsContextFactory;
class ConnectionValidationResult;
enum class EmailProtocol;",0
"/\
 * <p>The signature of this method must satisfy the following constraints:
 *
 * <ul>
 *   <li>One of its parameters must be the {@code InputT} element.
 *   <li>One of its parameters must be the restriction.
 *   <li>One of its input parameters must be of type Backlog. Splitting the restriction
 *       should attempt to take the backlog information into account. If the backlog is known,
 *       each split should return a restriction with an approximate amount of work bounded by the
 *       backlog. In the case of an unbounded restriction, at most one of the splits can represent
 *       the unbounded portion of work. If the backlog that is specified is unknown, it is up to
 *       the SDK to choose a number of splits of approximately equally sized portions with
 *       potentially one of those splits representing the unbounded portion of work.
 *   <li>One of its parameters must be the output receiver for restrictions.
 * </ul>
 *
 * <p>Signature: {@code splitRestriction(InputT element, RestrictionT restriction, Backlog
 * backlog, OutputReceiver<RestrictionT> receiver);}
 *
 * <p>Optional: if this method is omitted, the restriction will not be split (equivalent to
 * defining the method and outputting {@code Collections::singletonList(restriction)}).
 */
// TODO: Make the InputT parameter optional.
// TODO: Make the Backlog parameter optional.
[[nodiscard]]","```cpp
template <typename InputT, typename RestrictionT, typename Backlog>
class DoFn {
public:
    virtual ~DoFn() = default;

    class OutputReceiver {
    public:
        virtual void output(const RestrictionT& restriction) = 0;
        virtual ~OutputReceiver() = default;
    };

    // Optional: override this method to implement restriction splitting.
    virtual void splitRestriction(const InputT& element,
                                  const RestrictionT& restriction,
                                  const Backlog& backlog,
                                  OutputReceiver& receiver) {
        receiver.output(restriction);
    }
};
```",1
"static int sChunk = 0;

int getChunk() {
    if (sChunk != 0) {
        return sChunk;
    }
    const int WINDOW_SIZE_KB = 2048;
    int sCursorWindowSize = WINDOW_SIZE_KB * 1024;

    auto db = mDb.getDatabase();
    DatabaseChangeDecorator* decorator = dynamic_cast<DatabaseChangeDecorator*>(db);
    if (!decorator) {
        return sChunk;
    }
    std::string db_name = typeid(*(decorator->getWrapped())).name();
    if (db_name == ""io::requery::android::database::sqlite::SQLiteDatabase"") {
        try {
            sCursorWindowSize = io::requery::android::database::CursorWindow::sCursorWindowSize;
        } catch (...) {
            Timber::w(""Unable to get window size from requery cursor."");
        }
    }
    sChunk = static_cast<int>(sCursorWindowSize * 15.0 / 16.0);
    return sChunk;
}

std::string loadColumn(const std::string& columnName) {
    int pos = 1;
    std::string buf;

    while (true) {
        try {
            std::unique_ptr<Cursor> cursor(
                mDb.getDatabase()->query(
                    ""SELECT substr("" + columnName + "", ?, ? ) FROM col"",
                    {std::to_string(pos), std::to_string(getChunk())}
                )
            );
            if (!cursor->moveToFirst()) {
                return buf;
            }
            // ...
        } catch (...) {
            // handle exceptions as needed
        }
    }
}","```cpp
static int sChunk = 0;

int getChunk() {
    if (sChunk != 0) {
        return sChunk;
    }
    const int WINDOW_SIZE_KB = 2048;
    int sCursorWindowSize = WINDOW_SIZE_KB * 1024;

    // There's no direct analog for the Android-specific reflection code in C++,
    // so we use the fallback logic used in Java.
    sChunk = static_cast<int>(sCursorWindowSize * 15.0 / 16.0);
    return sChunk;
}

std::string loadColumn(const std::string& columnName) {
    int pos = 1;
    std::string buf;

    while (true) {
        std::string query = ""SELECT substr("" + columnName + "", ?, ?) FROM col"";
        std::vector<std::string> params = {std::to_string(pos), std::to_string(getChunk())};
        auto cursor = mDb.getDatabase().query(query, params);
        if (!cursor.moveToFirst()) {
            return buf;
        }
        // Further code to process the cursor's first (and only) row...
        // For brevity, only this portion is translated as per user request.
    }
}
```",1
"```cpp
std::vector<L> getListeners() {
    std::lock_guard<std::mutex> lock(_mutex);
    std::vector<L> res(_listeners.begin(), _listeners.end());

    auto autoIter = _autoListeners.begin();
    while (autoIter != _autoListeners.end()) {
        std::shared_ptr<L> listener = autoIter->lock();
        if (listener) {
            res.push_back(*listener);
            ++autoIter;
        } else {
            _log.info(""Removing a weak listener:"" + std::to_string(reinterpret_cast<uintptr_t>(&(*autoIter))));
            autoIter = _autoListeners.erase(autoIter);
        }
    }

    return res;
}

void addListener(const L& listener) {
    std::lock_guard<std::mutex> lock(_mutex);
    _listeners.push_back(listener);
}
```","```cpp
#include <vector>
#include <memory>
#include <algorithm>

template<typename L>
class CallbacksDispatcher {
private:
    std::vector<L> _listeners;
    std::vector<std::weak_ptr<L>> _autoListeners;

    // Assuming _log is a logging facility, you may define it as appropriate
    struct Logger {
        template<typename T>
        void info(const T& message) {/* implement logging */}
    } _log;

public:
    std::vector<L> getListeners() {
        std::vector<L> res(_listeners);

        auto autoIter = _autoListeners.begin();
        while (autoIter != _autoListeners.end()) {
            if (auto listenerPtr = autoIter->lock()) {
                res.push_back(*listenerPtr);
                ++autoIter;
            } else {
                _log.info(""Removing a weak listener"");
                autoIter = _autoListeners.erase(autoIter);
            }
        }

        return res;
    }

    void addListener(const L& listener) {
        // Implementation as needed
    }
};
```",0
"```cpp
class State
{
public:
    std::vector<std::string> names;
    std::string activeColumn;

    static State createState(const std::vector<std::string>& names, const std::string& activeColumn) {
        State state;
        state.names = names;
        state.activeColumn = activeColumn;
        return state;
    }
};
```","class State {
public:
    std::vector<std::string> names;
    std::string activeColumn;

    static State createState(const std::vector<std::string>& names, const std::string& activeColumn) {
        State state;
        state.names = names;
        state.activeColumn = activeColumn;
        return state;
    }
};",0
"#include ""FlowConstructAware.h""
#include ""MuleContextAware.h""
#include ""WorkManager.h""
#include ""Debuggable.h""
#include ""FieldDebugInfo.h""
#include ""FieldDebugInfoFactory.h""
#include ""Initialisable.h""
#include ""InitialisationException.h""
#include ""LifecycleUtils.h""","#include ""FlowConstruct.h""
#include ""FlowConstructAware.h""
#include ""MuleContextAware.h""
#include ""WorkManager.h""
#include ""Debuggable.h""
#include ""FieldDebugInfo.h""
#include ""FieldDebugInfoFactory.h""
#include ""Initialisable.h""
#include ""InitialisationException.h""
#include ""LifecycleUtils.h""",0
"```
URL setUsername(const std::string& username) {
    if (frozen) {
        return URL(protocol, username, password, host, port, path, getParameters());
    }
    this->username = username;
    return *this;
}

std::string getPassword() {
```","```cpp
class URL {
public:
    URL setUsername(const std::string& username) {
        if (frozen) {
            return URL(protocol, username, password, host, port, path, getParameters());
        }
        this->username = username;
        return *this;
    }

    std::string getPassword() {
        // function body
    }

private:
    bool frozen;
    std::string protocol;
    std::string username;
    std::string password;
    std::string host;
    int port;
    std::string path;
    // Assume getParameters() returns appropriate type
    // Other members and methods...
};
```",0
"#include <vector>
#include <map>
#include <string>
#include <cmath>
#include <memory>
#include <iterator>
#include <sstream>
#include <iomanip>
#include <stdexcept>

std::vector<uint8_t> serializeRecords(const std::vector<std::shared_ptr<IndexedRecord>>& records) {
    HFileContextBuilder contextBuilder;
    contextBuilder.withBlockSize(DEFAULT_BLOCK_SIZE)
                  /* TODO fetch value from the config */
                  .withCompression(DEFAULT_COMPRESSION_ALGO);
    auto context = contextBuilder.build();

    Configuration conf;
    CacheConfig cacheConfig(conf);
    ByteArrayOutputStream baos;
    FSDataOutputStream ostream(&baos, nullptr);

    bool useIntegerKey = getRecordKey(*records[0]).empty();
    int keyWidth = 0;
    if (useIntegerKey) {
        keyWidth = static_cast<int>(std::ceil(std::log(records.size()))) + 1;
    }

    std::map<std::string, std::vector<uint8_t>> sortedRecordsMap;
    int id = 0;
    for (const auto& record_ptr : records) {
        const auto& record = *record_ptr;
        std::string recordKey;

        if (useIntegerKey) {
            std::ostringstream ss;
            ss << std::setw(keyWidth) << std::setfill(' ') << id++;
            recordKey = ss.str();
        } else {
            recordKey = getRecordKey(record);
        }

        auto recordBytes = HoodieAvroUtils::indexedRecordToBytes(record);

        if (sortedRecordsMap.count(recordKey) > 0) {
            throw std::runtime_error(""Writing multiple records with same key not supported for "" + std::string(typeid(*this).name()));
        }
        sortedRecordsMap.emplace(recordKey, std::move(recordBytes));
    }

    auto writer = HFile::getWriterFactory(conf, cacheConfig)
                    .withOutputStream(ostream)
                    .withFileContext(context)
                    .withComparator(HoodieHBaseKVComparator())
                    .create();

    // Write the records
    for (const auto& [recordKey, recordBytes] : sortedRecordsMap) {
        try {
            //...
        } catch (...) {
            //...
        }
    }

    // ... finish and return
    return baos.toByteVector();
}","```cpp
#include <vector>
#include <string>
#include <map>
#include <iterator>
#include <cmath>
#include <sstream>
#include <iomanip>
#include <memory>

using namespace std;

vector<uint8_t> serializeRecords(const vector<IndexedRecord>& records) {
    HFileContext context = HFileContextBuilder()
        .withBlockSize(DEFAULT_BLOCK_SIZE)
        .withCompression(DEFAULT_COMPRESSION_ALGO)
        .build();
    Configuration conf;
    CacheConfig cacheConfig(conf);
    ostringstream baos;
    FSDataOutputStream ostream(baos);

    bool useIntegerKey = (getRecordKey(records[0]) == """");
    int keyWidth = 0;
    if (useIntegerKey) {
        keyWidth = static_cast<int>(ceil(log(records.size()))) + 1;
    }

    map<string, vector<uint8_t>> sortedRecordsMap;
    int id = 0;
    for (const auto& record : records) {
        string recordKey;
        if (useIntegerKey) {
            ostringstream oss;
            oss << setw(keyWidth) << setfill(' ') << id++;
            recordKey = oss.str();
        } else {
            recordKey = getRecordKey(record);
        }
        vector<uint8_t> recordBytes = HoodieAvroUtils::indexedRecordToBytes(record);
        if (sortedRecordsMap.count(recordKey) > 0) {
            throw runtime_error(""Writing multiple records with same key not supported for "" + string(typeid(*this).name()));
        }
        sortedRecordsMap[recordKey] = recordBytes;
    }

    unique_ptr<HFile::Writer> writer(
        HFile::getWriterFactory(conf, cacheConfig)
            .withOutputStream(ostream)
            .withFileContext(context)
            .withComparator(HoodieHBaseKVComparator())
            .create()
    );

    for (const auto& kv : sortedRecordsMap) {
        const string& recordKey = kv.first;
        const vector<uint8_t>& recordBytes = kv.second;
        try {
            // Continue here with writing logic
        } catch (...) {
            // handle
        }
    }

    // Return baos as vector<uint8_t>
    string str = baos.str();
    return vector<uint8_t>(str.begin(), str.end());
}
```",1
"std::string tempFilePath = remoteFilePath + this->temporaryFileSuffix;

if (this->autoCreateDirectory) {
    session.mkdir(remoteDirectory);
}

try {","```cpp
std::string tempFilePath = remoteFilePath + this->temporaryFileSuffix;

if (this->autoCreateDirectory) {
    session.mkdir(remoteDirectory);
}

try {
```",0
"for (auto symbol : site.getSymbol().members().lookup(name)) {
    if (symbol->kind == JavaSymbol::MTH) {
        JavaSymbol* best = selectBest(env, callSite, argTypes, typeParams, symbol, bestSoFar.symbol, autoboxing);
        if (best == symbol) {
            bestSoFar = Resolution::resolution(best);
            if (!isConstructor(symbol)) {
                bestSoFar.type = typeSubstitutionSolver.getReturnType(static_cast<JavaSymbol::MethodJavaSymbol*>(best), site, typeParams, argTypes);
            }
        }
    }
}

if (superclass != nullptr) {
    auto method = findMethod(env, callSite, superclass, name, argTypes, typeParams);
    if (!isConstructor(method.symbol)) {
        method.type = typeSubstitutionSolver.applySiteSubstitution(
            typeSubstitutionSolver.applySiteSubstitution(method.type, superclass),
            site
        );
    }
    JavaSymbol* best = selectBest(env, callSite, argTypes, typeParams, method.symbol, bestSoFar.symbol, autoboxing);
    if (best == method.symbol) {
        bestSoFar = method;
    }
}

for (auto interfaceType : site.getSymbol().getInterfaces()) {
    auto method = findMethod(env, callSite, interfaceType, name, argTypes, typeParams);
    if (!isConstructor(method.symbol)) {
        method.type = typeSubstitutionSolver.applySiteSubstitution(
            typeSubstitutionSolver.applySiteSubstitution(method.type, interfaceType),
            site
        );
    }
    JavaSymbol* best = selectBest(env, callSite, argTypes, typeParams, method.symbol, bestSoFar.symbol, autoboxing);
    if (best == method.symbol) {
        bestSoFar = method;
    }
}","for (const JavaSymbol& symbol : site.getSymbol()->members().lookup(name)) {
    if (symbol.kind == JavaSymbol::MTH) {
        JavaSymbol* best = selectBest(env, callSite, argTypes, typeParams, &symbol, bestSoFar.symbol, autoboxing);
        if (best == &symbol) {
            bestSoFar = Resolution::resolution(*best);
            if (!isConstructor(symbol)) {
                bestSoFar.type = typeSubstitutionSolver.getReturnType(
                    static_cast<const JavaSymbol::MethodJavaSymbol*>(best), site, typeParams, argTypes);
            }
        }
    }
}
if (superclass != nullptr) {
    Resolution method = findMethod(env, callSite, superclass, name, argTypes, typeParams);
    if (!isConstructor(method.symbol)) {
        method.type = typeSubstitutionSolver.applySiteSubstitution(
            typeSubstitutionSolver.applySiteSubstitution(method.type, superclass), site);
    }
    JavaSymbol* best = selectBest(env, callSite, argTypes, typeParams, method.symbol, bestSoFar.symbol, autoboxing);
    if (best == method.symbol) {
        bestSoFar = method;
    }
}
for (const JavaType& interfaceType : site.getSymbol()->getInterfaces()) {
    Resolution method = findMethod(env, callSite, interfaceType, name, argTypes, typeParams);
    if (!isConstructor(method.symbol)) {
        method.type = typeSubstitutionSolver.applySiteSubstitution(
            typeSubstitutionSolver.applySiteSubstitution(method.type, interfaceType), site);
    }
    JavaSymbol* best = selectBest(env, callSite, argTypes, typeParams, method.symbol, bestSoFar.symbol, autoboxing);
    if (best == method.symbol) {
        bestSoFar = method;
    }
}",1
"} else if (!(safeFsMkdir(fs, trashLocation.parent_path(), ALL_PERM) &&
             safeFsMkdir(fs, trashLocation, PERM) &&
             safeFsMkdir(fs, trashLocation / TRASH_IDENTIFIER_FILE))) {
    throw std::ios_base::failure(""Failed to create trash directory at "" + trashLocation.string());
}","if (!(safeFsMkdir(fs, trashLocation.parent_path(), ALL_PERM) && safeFsMkdir(fs, trashLocation, PERM)
    && safeFsMkdir(fs, trashLocation / TRASH_IDENTIFIER_FILE))) {
    throw std::ios_base::failure(""Failed to create trash directory at "" + trashLocation.string());
}",1
"auto headers = message.getHeaders();
return getMessageBuilderFactory()
    .fromMessage(message)
    .setHeader(MessageHeaders::ERROR_CHANNEL, headers.get(GATHER_RESULT_CHANNEL))
    .build();","MessageHeaders headers = message.getHeaders();
return getMessageBuilderFactory()
    .fromMessage(message)
    .setHeader(MessageHeaders::ERROR_CHANNEL, headers.get(GATHER_RESULT_CHANNEL))
    .build();",1
"class TestFutureCallback : public FutureCallback<HttpResponse> {
private:
    int statusCode = -1;
    std::string reasonPhrase;

public:
    void cancelled() override {
    }

    void completed(const HttpResponse& response) override {
        statusCode = response.getStatusLine().getStatusCode();
        reasonPhrase = response.getStatusLine().getReasonPhrase();
    }

    void failed(const std::exception& ex) override {
    }

    int getStatusCode() const {
        return statusCode;
    }

    std::string getReasonPhrase() const {
        return reasonPhrase;
    }
};","class TestFutureCallback {
private:
    int statusCode = -1;
    std::string reasonPhrase;

public:
    virtual void cancelled() {
    }

    virtual void completed(const HttpResponse& response) {
        statusCode = response.getStatusLine().getStatusCode();
        reasonPhrase = response.getStatusLine().getReasonPhrase();
    }

    virtual void failed(const std::exception& ex) {
    }

    int getStatusCode() const {
        return statusCode;
    }

    const std::string& getReasonPhrase() const {
        return reasonPhrase;
    }
};",0
"ValidatesRunner,
UsesStatefulParDo,
UsesTimersInParDo,
UsesTestStream,
UsesTestStreamWithOutputTimestamp
void testOutputTimestamp() {","#include <type_traits>
#include <tuple>

class ValidatesRunner {};
class UsesStatefulParDo {};
class UsesTimersInParDo {};
class UsesTestStream {};
class UsesTestStreamWithOutputTimestamp {};

using TestTypes = std::tuple<
    ValidatesRunner,
    UsesStatefulParDo,
    UsesTimersInParDo,
    UsesTestStream,
    UsesTestStreamWithOutputTimestamp
>;

void testOutputTimestamp() {
}",1
"```cpp
BitList<Invoker<T>> resultInvokers = availableInvokers.clone();

resultInvokers = headStateRouter.route(resultInvokers, url, invocation, false, nullptr);
if (resultInvokers.isEmpty() && (shouldFailFast || routers.empty())) {
    printRouterSnapshot(url, availableInvokers, invocation);
    return BitList<Invoker<T>>::emptyList();
}

if (routers.empty()) {
    return resultInvokers;
}
```","```cpp
BitList<Invoker<T>> resultInvokers = availableInvokers.clone();

resultInvokers = headStateRouter.route(resultInvokers, url, invocation, false, nullptr);
if (resultInvokers.isEmpty() && (shouldFailFast || routers.empty())) {
    printRouterSnapshot(url, availableInvokers, invocation);
    return BitList<Invoker<T>>::emptyList();
}

if (routers.empty()) {
    return resultInvokers;
}
```",0
"return;
}

SystemVmTemplateRegistration::parseMetadataFile();
CloudStackVersion currentVersion = CloudStackVersion::parse(currentVersionValue);
SystemVmTemplateRegistration::CS_MAJOR_VERSION = std::to_string(currentVersion.getMajorRelease()) + ""."" + std::to_string(currentVersion.getMinorRelease());
SystemVmTemplateRegistration::CS_TINY_VERSION = std::to_string(currentVersion.getPatchRelease());
s_logger.info(""DB version = "" + dbVersion + "" Code Version = "" + currentVersion);

if (dbVersion.compare(currentVersion) > 0) {","SystemVmTemplateRegistration::parseMetadataFile();
CloudStackVersion currentVersion = CloudStackVersion::parse(currentVersionValue);
SystemVmTemplateRegistration::CS_MAJOR_VERSION = std::to_string(currentVersion.getMajorRelease()) + ""."" + std::to_string(currentVersion.getMinorRelease());
SystemVmTemplateRegistration::CS_TINY_VERSION = std::to_string(currentVersion.getPatchRelease());
s_logger.info(""DB version = "" + dbVersion + "" Code Version = "" + currentVersion);

if (dbVersion.compareTo(currentVersion) > 0) {",1
"auto sc = _hostDao.createSearchCriteria();
sc.addAnd(""status"", SearchCriteria::Op::EQ, Status::Up.toString());
sc.addAnd(""resourceState"", SearchCriteria::Op::NIN, {ResourceState::Maintenance, ResourceState::PrepareForMaintenance, ResourceState::ErrorInMaintenance});
sc.addAnd(""type"", SearchCriteria::Op::EQ, Host::Type::Routing.toString());

std::unordered_map<long, HostStats*> hostStats;
std::unordered_map<void*, void*> metrics;
auto hosts = _hostDao.search(sc, nullptr);

for (auto& host : hosts) {
    auto* hostStatsEntry = dynamic_cast<HostStatsEntry*>(_resourceMgr.getHostStatistics(host.getId()));
    if (hostStatsEntry != nullptr) {
        hostStatsEntry->setHostVo(host);
        metrics[reinterpret_cast<void*>(hostStatsEntry->getHostId())] = static_cast<void*>(hostStatsEntry);
        _hostStats[host.getId()] = hostStatsEntry;
    } else {
        s_logger.warn(""Received invalid host stats for host: "" + std::to_string(host.getId()));
    }
}

if (externalStatsType == ExternalStatsProtocol::INFLUXDB) {
    sendMetricsToInfluxdb(metrics);
}

updateGpuEnabledHostsDetails(hosts);

} catch (const std::exception& t) {
    s_logger.error(""Error trying to retrieve host stats"", t);
}

void updateGpuEnabledHostsDetails(const std::vector<HostVO>& hosts) {
    std::vector<HostVO> gpuEnabledHosts;
    if (hostIds != nullptr) {
        for (const auto& host : hosts) {
            if (hostIds->contains(host.getId())) {
                gpuEnabledHosts.push_back(host);
            }
        }
    } else {
        gpuEnabledHosts = hosts;
    }
    for (const auto& host : gpuEnabledHosts) {
        auto groupDetails = _resourceMgr.getGPUStatistics(host);
        if (groupDetails != nullptr) {
            _resourceMgr.updateGPUDetails(host.getId(), groupDetails);
        }
    }
    hostIds = _hostGpuGroupsDao.listHostIds();
}

protected:
Point creteInfluxDbPoint(void* metricsObject) override {
    return createInfluxDbPointForHostMetrics(metricsObject);
}

class VmStatsCollector : public AbstractStatsCollector {
protected:
    void runInContext() override {
        try {
            // ...
        }
    }","```cpp
void StatsCollector::runInContext() {
    try {
        auto sc = _hostDao.createSearchCriteria();
        sc.addAnd(""status"", SearchCriteria::Op::EQ, Status::Up.toString());
        sc.addAnd(""resourceState"", SearchCriteria::Op::NIN, {ResourceState::Maintenance.toString(), ResourceState::PrepareForMaintenance.toString(), ResourceState::ErrorInMaintenance.toString()});
        sc.addAnd(""type"", SearchCriteria::Op::EQ, Host::Type::Routing.toString());

        std::unordered_map<long long, std::shared_ptr<HostStats>> hostStats;
        std::unordered_map<std::any, std::any> metrics;
        auto hosts = _hostDao.search(sc, nullptr);

        for (const auto& host : hosts) {
            auto hostStatsEntry = std::dynamic_pointer_cast<HostStatsEntry>(_resourceMgr.getHostStatistics(host->getId()));
            if (hostStatsEntry) {
                hostStatsEntry->setHostVo(host);
                metrics[hostStatsEntry->getHostId()] = hostStatsEntry;
                _hostStats[host->getId()] = hostStatsEntry;
            } else {
                s_logger.warn(""Received invalid host stats for host: "" + std::to_string(host->getId()));
            }
        }

        if (externalStatsType == ExternalStatsProtocol::INFLUXDB) {
            sendMetricsToInfluxdb(metrics);
        }

        updateGpuEnabledHostsDetails(hosts);
    } catch (const std::exception& t) {
        s_logger.error(""Error trying to retrieve host stats"", t);
    } catch (...) {
        s_logger.error(""Error trying to retrieve host stats"");
    }
}

void StatsCollector::updateGpuEnabledHostsDetails(const std::vector<std::shared_ptr<HostVO>>& hosts) {
    std::vector<std::shared_ptr<HostVO>> gpuEnabledHosts;
    if (hostIds) {
        for (const auto& host : hosts) {
            if (hostIds->count(host->getId()) > 0) {
                gpuEnabledHosts.push_back(host);
            }
        }
    } else {
        gpuEnabledHosts = hosts;
    }
    for (const auto& host : gpuEnabledHosts) {
        auto groupDetails = _resourceMgr.getGPUStatistics(host);
        if (groupDetails) {
            _resourceMgr.updateGPUDetails(host->getId(), *groupDetails);
        }
    }
    host",1
"#include <set>
#include <memory>
#include <map>

class MetadataKey {};
class MetadataContext {};
class TypeKeysResolver {
public:
    virtual std::set<MetadataKey> getKeys(MetadataContext& context) = 0;
    virtual ~TypeKeysResolver() = default;
};
class PartialTypeKeysResolver : public TypeKeysResolver {
public:
    virtual MetadataKey resolveChilds(MetadataContext& context, const void* partialKey) = 0;
};
class ReflectionCache {};
class ParameterModel {};

std::set<MetadataKey> singleton(const MetadataKey& key) {
    return { key };
}

std::set<MetadataKey> getMetadataKeys(
    MetadataContext& context,
    TypeKeysResolver* keyResolver,
    const void* partialKey,
    ReflectionCache& reflectionCache,
    std::map<int, ParameterModel>& partsByOrder)
{
    if (auto ptr = dynamic_cast<PartialTypeKeysResolver*>(keyResolver)) {
        if (hasInitialLevel(partialKey, partsByOrder, reflectionCache)) {
            return singleton(ptr->resolveChilds(context, partialKey));
        }
    }
    return keyResolver->getKeys(context);
}

bool hasInitialLevel(
    const void* keyValue,
    std::map<int, ParameterModel>& partsByOrder,
    ReflectionCache& reflectionCache)
{
    if (keyValue == nullptr) {
        return false;
    }","#include <set>
#include <memory>
#include <map>

class MetadataKey {};
class MetadataContext {};
class TypeKeysResolver {
public:
    virtual std::set<MetadataKey> getKeys(const MetadataContext& context) = 0;
    virtual ~TypeKeysResolver() = default;
};
class PartialTypeKeysResolver : public TypeKeysResolver {
public:
    virtual MetadataKey resolveChilds(const MetadataContext& context, const std::shared_ptr<void>& partialKey) = 0;
};
class ReflectionCache {};
class ParameterModel {};

std::set<MetadataKey> singleton(const MetadataKey& key) {
    return {key};
}

std::set<MetadataKey> getMetadataKeys(
    const MetadataContext& context,
    std::shared_ptr<TypeKeysResolver> keyResolver,
    std::shared_ptr<void> partialKey,
    const ReflectionCache& reflectionCache,
    const std::map<int, std::shared_ptr<ParameterModel>>& partsByOrder
) {
    if (auto partialTypeKeysResolver = std::dynamic_pointer_cast<PartialTypeKeysResolver>(keyResolver)) {
        if (hasInitialLevel(partialKey, partsByOrder, reflectionCache)) {
            return singleton(partialTypeKeysResolver->resolveChilds(context, partialKey));
        }
    }
    return keyResolver->getKeys(context);
}

bool hasInitialLevel(
    const std::shared_ptr<void>& keyValue,
    const std::map<int, std::shared_ptr<ParameterModel>>& partsByOrder,
    const ReflectionCache& reflectionCache
) {
    if (!keyValue) {
        return false;
    }
    // The rest of the implementation should follow here.
    return true;
}",0
"for (const auto& prop : pt.properties) {
    std::string paramName = csharpIdentifier(prop.Name);
    std::string fieldName = pt.mod.propertyName(prop);
    if (fieldName == paramName) {
        // Avoid a no-op in case of field and property name collision.
        fieldName = ""this->"" + fieldName;
    }
    fmt.Fprintf(w, ""%s        %s = %s;\n"", indent.c_str(), fieldName.c_str(), paramName.c_str());
}
fmt.Fprintf(w, ""%s    }\n"", indent.c_str());","```cpp
for (const auto& prop : pt.properties) {
    std::string paramName = csharpIdentifier(prop.Name);
    std::string fieldName = pt.mod.propertyName(prop);
    if (fieldName == paramName) {
        // Avoid a no-op in case of field and property name collision.
        fieldName = ""this->"" + fieldName;
    }
    fprintf(w, ""%s        %s = %s;\n"", indent, fieldName.c_str(), paramName.c_str());
}
fprintf(w, ""%s    }\n"", indent);
```",1
"auto propagatorsBuilder = DefaultContextPropagators::builder();

std::vector<std::string> propagatorIds;
for (const auto& propagator : propagators) {
    std::string id = propagator;
    std::transform(id.begin(), id.end(), id.begin(), ::tolower);
    id.erase(id.begin(), std::find_if(id.begin(), id.end(), [](unsigned char ch) { return !std::isspace(ch); }));
    id.erase(std::find_if(id.rbegin(), id.rend(), [](unsigned char ch) { return !std::isspace(ch); }).base(), id.end());
    propagatorIds.push_back(id);
}

auto removePropagator = [&](const std::string& id) -> bool {
    auto it = std::find(propagatorIds.begin(), propagatorIds.end(), id);
    if (it != propagatorIds.end()) {
        propagatorIds.erase(it);
        return true;
    }
    return false;
};

if (removePropagator(JAEGER)) {
    propagatorsBuilder.addTextMapPropagator(JaegerPropagator::getInstance());
    log.info(""Added "" + std::to_string(reinterpret_cast<std::uintptr_t>(JaegerPropagator::getInstance())) + "" propagator"");
}
if (removePropagator(BAGGAGE)) {
    propagatorsBuilder.addTextMapPropagator(W3CBaggagePropagator::getInstance());
    log.info(""Added "" + std::to_string(reinterpret_cast<std::uintptr_t>(W3CBaggagePropagator::getInstance())) + "" propagator"");
}

for (const auto& propagatorId : propagatorIds) {
    auto it = TEXTMAP_PROPAGATORS.find(propagatorId);
    if (it != TEXTMAP_PROPAGATORS.end() && it->second != nullptr) {
        textPropagators.push_back(it->second);
        log.info(""Added "" + std::to_string(reinterpret_cast<std::uintptr_t>(it->second)) + "" propagator"");
    }
}","```cpp
DefaultContextPropagators::Builder propagatorsBuilder;

std::vector<TextMapPropagator*> textPropagators;
textPropagators.reserve(propagators.size());

std::vector<std::string> propagatorIds;
for (const auto& propagator : propagators) {
    std::string id = propagator;
    id.erase(0, id.find_first_not_of("" \t\n\r\f\v""));
    id.erase(id.find_last_not_of("" \t\n\r\f\v"") + 1);
    std::transform(id.begin(), id.end(), id.begin(), ::tolower);
    propagatorIds.push_back(id);
}

auto remove_and_handle = [&](const std::string& key, auto* instance, const std::string& instanceName) {
    auto it = std::find(propagatorIds.begin(), propagatorIds.end(), key);
    if (it != propagatorIds.end()) {
        propagatorIds.erase(it);
        propagatorsBuilder.addTextMapPropagator(instance);
        log.info(""Added "" + instanceName + "" propagator"");
    }
};

remove_and_handle(JAEGER, JaegerPropagator::getInstance(), ""JaegerPropagator"");
remove_and_handle(BAGGAGE, W3CBaggagePropagator::getInstance(), ""W3CBaggagePropagator"");

for (const auto& propagatorId : propagatorIds) {
    auto it = TEXTMAP_PROPAGATORS.find(propagatorId);
    TextMapPropagator* textPropagator = (it != TEXTMAP_PROPAGATORS.end()) ? it->second : nullptr;
    if (textPropagator != nullptr) {
        textPropagators.push_back(textPropagator);
        log.info(""Added "" + propagatorId + "" propagator"");
    }
}
```",0
"return pnode->nop == knopName && pnode->sxPid.PropertyIdFromNameNode() == Js::PropertyIds::Array;
}

#define STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode) \
    if ((isTopLevel)) \
    { \
        byteCodeGenerator->StartStatement(pnode); \
    }

#define ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode) \
    if ((isTopLevel)) \
    { \
        byteCodeGenerator->EndStatement(pnode); \
    }

bool MayHaveSideEffectOnNode(ParseNode* pnode, ParseNode* pnodeSE)
{
    // Try to determine whether pnodeSE may kill the named var represented by pnode.","inline bool CallTargetIsArray(ParseNode* pnode)
{
    return pnode->nop == knopName && pnode->sxPid.PropertyIdFromNameNode() == Js::PropertyIds::Array;
}

#define STARTSTATEMENET_IFTOPLEVEL(isTopLevel, pnode) \
if ((isTopLevel)) \
{ \
    byteCodeGenerator->StartStatement(pnode); \
}

#define ENDSTATEMENET_IFTOPLEVEL(isTopLevel, pnode) \
if ((isTopLevel)) \
{ \
    byteCodeGenerator->EndStatement(pnode); \
}

bool MayHaveSideEffectOnNode(ParseNode* pnode, ParseNode* pnodeSE)
{
    // Try to determine whether pnodeSE may kill the named var represented by pnode.
}",1
"scope.close();

if (throwable != nullptr) {
    MESSAGE_TRACER.endExceptionally(span, throwable);
} else {
    MESSAGE_TRACER.end(span);
}","MESSAGE_TRACER.endExceptionally(span, throwable);
} else {
    MESSAGE_TRACER.end(span);
}",0
"void dispose() {
    disposeIfNeeded(delegate, LOGGER);
}

bool isAsync() override {
    return false;
}","class AsynchronousRetryTemplate : public AbstractComponent {
public:
    void dispose() override {
        disposeIfNeeded(delegate, LOGGER);
    }

    bool isAsync() override {
        return false;
    }
};",1
"protected:
    virtual void onMethodReferenceFound(const MethodReferenceTree& methodReferenceTree) {
        // Do nothing by default
    }

private:
    std::vector<MethodMatcher> matchers() {
        if (matchers_.empty()) {
            matchers_ = getMethodInvocationMatchers();
        }
        return matchers_;
    }
    std::vector<MethodMatcher> matchers_;","protected:
  virtual void onMethodReferenceFound(const MethodReferenceTree& methodReferenceTree) {
    // Do nothing by default
  }

private:
  std::vector<MethodMatcher> matchers() {
    if (!matchers_) {
      matchers_ = getMethodInvocationMatchers();
    }
    return *matchers_;
  }

  std::optional<std::vector<MethodMatcher>> matchers_;",1
"EXPECT_CALL(certService._entityMgr, findById(testing::Eq(typeid(LoadBalancerVO)), testing::_))
    .WillOnce(testing::Return(new LoadBalancerVO()));

auto deleteCmd = std::make_unique<DeleteSslCertCmdExtn>();
const std::type_info& klazz = typeid(*deleteCmd);

auto certField = deleteCmd->getField(""id"");
certField->setAccessible(true);
certField->set(deleteCmd.get(), certId);

try {
    certService.deleteSslCert(*deleteCmd);
    FAIL() << ""Delete with a cert id bound to a lb should fail"";
} catch (const std::exception& e) {
    ASSERT_TRUE(std::string(e.what()).find(""Certificate in use by a loadbalancer"") != std::string::npos);
}","```cpp
EXPECT_CALL(certService._entityMgr, findById(::testing::Eq(typeid(LoadBalancerVO)), ::testing::_))
    .WillOnce(::testing::Return(new LoadBalancerVO()));

const DeleteSslCertCmdExtn deleteCmd;
const std::type_info& klazz = typeid(*static_cast<const DeleteSslCertCmd*>(&deleteCmd));
auto certField = deleteCmd.getIdMemberPointer(); // Assume this method gives pointer to member id
deleteCmd.*certField = certId;

try {
    certService.deleteSslCert(deleteCmd);
    FAIL() << ""Delete with a cert id bound to a lb should fail"";
} catch (const std::exception& e) {
    ASSERT_TRUE(std::string(e.what()).find(""Certificate in use by a loadbalancer"") != std::string::npos);
}
```",1
"CxfConfiguration* config = new CxfConfiguration();
config->setMuleContext(muleContext);
config->initialise();

WebServiceMessageProcessorBuilder* builder = new WebServiceMessageProcessorBuilder();
builder->setConfiguration(config);
builder->setServiceClass(typeid(Echo));
builder->setMuleContext(muleContext);

CxfInboundMessageProcessor* processor = builder->build();
processor->start();
return processor;","CxfConfiguration config;
config.setMuleContext(muleContext);
config.initialise();

WebServiceMessageProcessorBuilder builder;
builder.setConfiguration(config);
builder.setServiceClass(Echo);
builder.setMuleContext(muleContext);

CxfInboundMessageProcessor* processor = builder.build();
processor->start();
return processor;",0
"executeQueries(cleanupCommands);
}

void executeQueries(const std::string& queries) {
    if (queries.empty() || std::all_of(queries.begin(), queries.end(), isspace)) {
        return;
    }
    try {
        this->hiveJdbcConnector.executeStatements(queries);
    } catch (const std::exception& e) {
        throw std::runtime_error(e.what());
    }
}","void HiveConvertPublisher::publish() {
    // ... existing code ...
    // Execute cleanup staging table commands
    executeQueries(cleanupCommands);
}

void HiveConvertPublisher::executeQueries(const std::string& queries) {
    if (queries.empty() || std::all_of(queries.begin(), queries.end(), isspace)) {
        return;
    }
    try {
        this->hiveJdbcConnector.executeStatements(queries);
    } catch (const std::exception& e) {
        throw std::runtime_error(e.what());
    }
}",0
"return 0;
}

auto clazz1 = o1;
auto clazz2 = o2;

OrderInfo a1 = parseOrder(clazz1);
OrderInfo a2 = parseOrder(clazz2);","OrderInfo a1 = parseOrder(clazz1);
OrderInfo a2 = parseOrder(clazz2);",1
"if (typeid(*propagator).name() == std::string(""NoopTextMapPropagator"")) {
    OpenTelemetry::setGlobalPropagators(
        ContextPropagators::create(W3CTraceContextPropagator::getInstance()));
}
OpenTelemetrySdk::getGlobalTracerManagement().addSpanProcessor(TEST_WRITER);
TEST_TRACER = OpenTelemetry::getGlobalTracer(""io.opentelemetry.auto"");","if (typeid(OpenTelemetry::GetGlobalPropagators().GetTextMapPropagator()).name() == std::string(""NoopTextMapPropagator"")) {
    OpenTelemetry::SetGlobalPropagators(
        ContextPropagators::Create(W3CTraceContextPropagator::GetInstance()));
}
OpenTelemetrySdk::GetGlobalTracerManagement().AddSpanProcessor(TEST_WRITER);
TEST_TRACER = OpenTelemetry::GetGlobalTracer(""io.opentelemetry.auto"");",0
"#include <cassert>
#include <stdexcept>

void usesParentOnlyLookupAndFails() {
    ClassLoader* parent = mock<ClassLoader>();
    assert(EXPECTED_PARENT_MESSAGE == invokeTestClassMethod(ext));
}","#include <gtest/gtest.h>
#include <stdexcept>

TEST(FineGrainedControlClassLoaderTestCase, usesParentOnlyLookupAndFails)
{
    auto parent = ::testing::NiceMock<::testing::MockFunction<void()>>();
    // The equivalent logic using mocks and simulating ClassNotFoundException should be implemented here.
    // throw std::runtime_error(""ClassNotFoundException"");
}",0
"std::string sanityCheckInterval = configs[""usage.sanity.check.interval""];
std::string quotaEnable = configs[""quota.enable.service""];
_runQuota = (quotaEnable.empty() ? false : (quotaEnable == ""true""));
usageSnapshotSelection = (configs[""usage.snapshot.virtualsize.select""] == ""true"");
if (!sanityCheckInterval.empty()) {
    _sanityCheckInterval = std::stoi(sanityCheckInterval);
}","std::string sanityCheckInterval = configs[""usage.sanity.check.interval""];
std::string quotaEnable = configs[""quota.enable.service""];
_runQuota = (quotaEnable.empty() ? false : (quotaEnable == ""true""));
usageSnapshotSelection = (configs[""usage.snapshot.virtualsize.select""] == ""true"");
if (!sanityCheckInterval.empty()) {
    _sanityCheckInterval = std::stoi(sanityCheckInterval);
}",1
"constexpr int GCS_UPLOAD_BUFFER_SIZE_BYTES_DEFAULT = 1024 * 1024;

constexpr const char* PIPELINE_FILE_NAME = ""pipeline.pb"";
constexpr const char* DATAFLOW_GRAPH_FILE_NAME = ""dataflow_graph.json"";

static ObjectMapper MAPPER;","static constexpr int GCS_UPLOAD_BUFFER_SIZE_BYTES_DEFAULT = 1024 * 1024;

static constexpr const char* PIPELINE_FILE_NAME = ""pipeline.pb"";
static constexpr const char* DATAFLOW_GRAPH_FILE_NAME = ""dataflow_graph.json"";

static ObjectMapper MAPPER;",1
"```cpp
#include <set>
#include <string>
#include <vector>
#include <algorithm>
#include <iterator>

class NacosServiceName {
public:
    NacosServiceName(const std::string& name);
    bool isCompatible(const NacosServiceName& other) const;
    std::string toString() const;
};

class MyClass {
public:
    std::set<std::string> filterServiceNames(const NacosServiceName& serviceName) {
        std::set<std::string> serviceNames;
        execute([&](auto& namingService) {
            auto services = namingService.getServicesOfServer(
                1, std::numeric_limits<int>::max(),
                getUrl().getParameter(GROUP_KEY, Constants::DEFAULT_GROUP)
            ).getData();

            std::vector<std::string> filtered;
            std::copy_if(services.begin(), services.end(), std::back_inserter(filtered), [&](const std::string& s) {
                return isConformRules(s);
            });

            for (const std::string& s : filtered) {
                NacosServiceName ns{s};
                if (serviceName.isCompatible(ns)) {
                    serviceNames.insert(ns.toString());
                }
            }
        });
        return serviceNames;
    }

    /**
     * Verify whether it is a dubbo service
     *
     * @param serviceName
     * @return
     * @since 2.7.11
     */
    bool isConformRules(const std::string& serviceName) const {
        constexpr char NAME_SEPARATOR = ':'; // adjust as needed
        int count = 1;
        for (char ch : serviceName) {
            if (ch == NAME_SEPARATOR) ++count;
        }
        return count == 4;
    }

    // Definitions/stubs for demonstration, to be replaced or provided as needed:
    template <typename F>
    void execute(F f);

    struct URL {
        std::string getParameter(const std::string& key, const std::string& def) const;
    };

    URL getUrl() const;

    static const std::string GROUP_KEY;
    struct Constants {
        static const std::string DEFAULT_GROUP;
    };
};
```","```cpp
#include <set>
#include <list>
#include <string>
#include <algorithm>
#include <iterator>

class NacosRegistry : public FailbackRegistry {
private:
    std::set<std::string> filterServiceNames(const NacosServiceName& serviceName) {
        std::set<std::string> serviceNames;

        execute([&](auto& namingService) {
            auto group = getUrl().getParameter(GROUP_KEY, Constants::DEFAULT_GROUP);
            auto data = namingService.getServicesOfServer(1, std::numeric_limits<int>::max(), group).getData();
            std::list<std::string> filteredNames;

            for (const auto& sn : data) {
                if (isConformRules(sn)) {
                    NacosServiceName nsn(sn);
                    if (serviceName.isCompatible(nsn)) {
                        filteredNames.push_back(nsn.toString());
                    }
                }
            }
            serviceNames.insert(filteredNames.begin(), filteredNames.end());
        });

        return serviceNames;
    }

public:
    bool isConformRules(const std::string& serviceName) {
        size_t count = 0;
        size_t start = 0;
        while (true) {
            size_t pos = serviceName.find(NAME_SEPARATOR, start);
            ++count;
            if (pos == std::string::npos) break;
            start = pos + std::string(NAME_SEPARATOR).length();
        }
        return count == 4;
    }
};
```",1
"protected:
  class XxeSymbolicValue : public SymbolicValue {
  protected:
    const Tree* init;
    bool isField;
  private:
    std::function<bool(const ConstraintsByDomain&)> conditionForSecured;
  public:
    XxeSymbolicValue(const Tree* init, std::function<bool(const ConstraintsByDomain&)> conditionForSecured)
      : init(init), isField(false), conditionForSecured(conditionForSecured) {}
  };","enum CustomEntityResolver {
    CUSTOM_ENTITY_RESOLVER
};

class XxeSymbolicValue : public SymbolicValue {
protected:
    const Tree* init;
    bool isField;
public:
    XxeSymbolicValue(const Tree* init, std::function<bool(const ConstraintsByDomain&)> conditionForSecured)
        : init(init), conditionForSecured(conditionForSecured), isField(false) {}

private:
    std::function<bool(const ConstraintsByDomain&)> conditionForSecured;
};",0
"#include <gtest/gtest.h>

using ::testing::NotNull;
using ::testing::IsNull;","#include <gtest/gtest.h>

using ::testing::Eq;
using ::testing::Ne;
using ::testing::NotNull;
using ::testing::IsNull;",0
"return;
  }
  try {
    this->writer.flush();
  } catch (...) {
    this->writer.close();
    this->closed = true;
    throw;
  }
  this->writer.close();
  this->closed = true;
}","void close() override {
    try {
        writer->flush();
    } catch (...) {
        writer->close();
        closed = true;
        throw;
    }
    writer->close();
    closed = true;
}

void commit() override {
    if (!closed) {
        close();
    }

    if (!fs->exists(stagingFile)) {
        throw std::ios_base::failure(""File "" + stagingFile + "" does not exist"");
    }

    LOG_INFO(""Moving data from "" + stagingFile + "" to "" + outputFile);
    if (fs->exists(outputFile)) {
        LOG_WARN(""Task output file "" + outputFile + "" already exists"");
        HadoopUtils::deletePath(fs, outputFile, false);
    }

    HadoopUtils::renamePath(fs, stagingFile, outputFile);
}

void cleanup() override {
    if (fs->exists(stagingFile)) {
        HadoopUtils::deletePath(fs, stagingFile, false);
    }
}",0
"<tr>
<td>std::string</td>
<td>TAG_CONTENT</td>
<td>DataColumns::DATA1</td>
<td>read-write</td>
<td>Tags, separated by spaces</td>
</tr>","@@ -553,7 +553,7 @@
          * <tr>
          * <td>std::string</td>
          * <td>{TAG_CONTENT}</td>
-         * <td>{FlashCardsContract::DataColumns::DATA1}</td>
+         * <td>{DataColumns::DATA1}</td>
          * <td>read-write</td>
          * <td>Tags, separated by spaces</td>
          * </tr>",0
"#include <vector>
#include <memory>

void testExplicitMethodMatchSetArrayPass() {
    ReflectionEntryPointResolver resolver;
    auto event = Event::builder(DefaultEventContext::create(flowConstruct, fromSingleComponent(TEST_CONNECTOR)))
        .message(of(std::vector<std::shared_ptr<Fruit>>{std::make_shared<Apple>(), std::make_shared<Orange>()}))
        .build();
    MuleEventContext eventContext;
}","```cpp
void testExplicitMethodMatchSetArrayPass() {
    ReflectionEntryPointResolver resolver;
    auto event = Event::builder(DefaultEventContext::create(flowConstruct, fromSingleComponent(TEST_CONNECTOR)))
        .message(of(std::vector<Fruit*>{ new Apple(), new Orange() }))
        .build();
    MuleEventContext eventContext;
}
```",0
"#include <vector>
#include <memory>
#include <stdexcept>

std::vector<Spec> getSpecs() {
    std::vector<Spec> specs;
    auto connection = this->dataSource->getConnection();
    std::string query = 
        (this->readFromOldTable 
            ? (std::string)std::format(GET_ALL_STATEMENT, this->tableName)
            : (std::string)std::format(GET_ALL_STATEMENT, this->tableNameV2));
    auto statement = connection->prepareStatement(query);
    auto rs = statement->executeQuery();
    while (rs->next()) {
        try {
            if (this->readFromOldTable) {
                std::string str = rs->getString(2);
                specs.push_back(this->specSerDe->deserialize(
                    std::vector<uint8_t>(str.begin(), str.end())
                ));
            } else {
                auto blob = rs->getBlob(2);
                auto bytes = ByteStreams::toByteArray(blob->getBinaryStream());
                specs.push_back(this->specSerDe->deserialize(bytes));
            }
        } catch (const std::exception& e) {
            log_error(""Failed to deserialize spec"", e);
        }
    }
    return specs;
}","std::vector<Spec> getSpecs() {
    std::vector<Spec> specs;
    std::string query = this->readFromOldTable
        ? (boost::format(GET_ALL_STATEMENT) % this->tableName).str()
        : (boost::format(GET_ALL_STATEMENT) % this->tableNameV2).str();

    std::unique_ptr<sql::Connection> connection(this->dataSource->getConnection());
    std::unique_ptr<sql::PreparedStatement> statement(connection->prepareStatement(query));
    std::unique_ptr<sql::ResultSet> rs(statement->executeQuery());

    while (rs->next()) {
        try {
            if (this->readFromOldTable) {
                std::string str = rs->getString(2);
                specs.push_back(this->specSerDe.deserialize(
                    std::vector<uint8_t>(str.begin(), str.end())
                ));
            } else {
                std::istream *stream = rs->getBlob(2);
                std::vector<uint8_t> bytes((std::istreambuf_iterator<char>(*stream)),
                                            std::istreambuf_iterator<char>());
                specs.push_back(this->specSerDe.deserialize(bytes));
            }
        } catch (const sql::SQLException& e) {
            log.error(""Failed to deserialize spec: %s"", e.what());
        } catch (const SpecSerDeException& e) {
            log.error(""Failed to deserialize spec: %s"", e.what());
        }
    }
    return specs;
}",0
"class LineCommentParsingState : public ParsingState {
public:
    LineCommentParsingState(const std::string& start)
        : ParsingState(start, ""\n"", REMOVE_DASH_LINECOMMENT) {}
};","class QueryParser {
private:
    class ParsingState {
    public:
        ParsingState(const std::string& start, const std::string& end, int flag) {}
    };
    static constexpr int REMOVE_DASH_LINECOMMENT = 1; // Presumed value for flag
    class LineCommentParsingState : public ParsingState {
    public:
        LineCommentParsingState(const std::string& start)
            : ParsingState(start, ""\n"", REMOVE_DASH_LINECOMMENT) {}
    };
};",0
"#include <gmock/gmock.h>
#include <gtest/gtest.h>
#include <vector>

using ::testing::NiceMock;

NiceMock<AccountManager> _accountMgr;
NiceMock<NetworkOrchestrationService> _networkMgr;
NiceMock<NetworkModel> _networkModel;
NiceMock<DomainManager> _domainMgr;
NiceMock<VpcManager> _vpcMgr;
NiceMock<IpAddressManager> _ipAddrMgr;
NiceMock<FirewallRulesDao> _firewallDao;

FirewallManagerImpl _firewallMgr;

class FirewallManagerTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Initialization if needed
    }
};

TEST_F(FirewallManagerTest, DISABLED_testApplyRules) {
    std::vector<FirewallRuleVO> ruleList;
}","#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <vector>

using namespace testing;

class AccountManagerMock : public AccountManager {
    // Mock methods if needed
};

class NetworkOrchestrationServiceMock : public NetworkOrchestrationService {
    // Mock methods if needed
};

class NetworkModelMock : public NetworkModel {
    // Mock methods if needed
};

class DomainManagerMock : public DomainManager {
    // Mock methods if needed
};

class VpcManagerMock : public VpcManager {
    // Mock methods if needed
};

class IpAddressManagerMock : public IpAddressManager {
    // Mock methods if needed
};

class FirewallRulesDaoMock : public FirewallRulesDao {
    // Mock methods if needed
};

class FirewallManagerTest : public ::testing::Test {
protected:
    AccountManagerMock _accountMgr;
    NetworkOrchestrationServiceMock _networkMgr;
    NetworkModelMock _networkModel;
    DomainManagerMock _domainMgr;
    VpcManagerMock _vpcMgr;
    IpAddressManagerMock _ipAddrMgr;
    FirewallRulesDaoMock _firewallDao;

    FirewallManagerImpl _firewallMgr;

    void SetUp() override {
        // Set up mocks if necessary
    }
};

TEST_F(FirewallManagerTest, DISABLED_testApplyRules) {
    std::vector<FirewallRuleVO> ruleList;
    // Test implementation here
}",1
"}
private:
void addColumnControls(Toolbar& toolbar)
{
    colsLabel_ = new ToolbarLabel(constants_.colsLabel());
    colsLabel_->addStyleName(ThemeStyles::INSTANCE.toolbarInfoLabel());
    colsLabel_->setVisible(false);
    toolbar.addLeftWidget(colsLabel_);
}","colsLabel_ = new ToolbarLabel(constants_->colsLabel());
colsLabel_->addStyleName(ThemeStyles::INSTANCE->toolbarInfoLabel());
colsLabel_->setVisible(false);
toolbar->addLeftWidget(colsLabel_);",0
"#include <string>
#include <typeinfo>

namespace io {
namespace opentelemetry {
namespace javaagent {
namespace instrumentation {
namespace springwebmvc {

}
}
}
}
}

#include ""io/opentelemetry/context/Context.h""
#include ""io/opentelemetry/instrumentation/api/tracer/BaseTracer.h""
#include ""io/opentelemetry/trace/Span.h""
#include <typeinfo>","#include <string>
#include <typeinfo>
#include <typeindex>
#include <cstddef>
#include ""opentelemetry/context/context.h""
#include ""opentelemetry/instrumentation/api/tracer/BaseTracer.h""
#include ""opentelemetry/trace/span.h""
#include <typeinfo>",0
"std::optional<std::chrono::system_clock::time_point> timestamp,
T contextData
{
    AttributesBuilder attributes;

    if (message != nullptr) {
        if (auto mapMsg = dynamic_cast<MapMessage*>(message)) {
            builder.setBody(mapMsg->getFormat());
            captureMapMessageAttributes(attributes, *mapMsg);
        } else {
            builder.setBody(message->getFormattedMessage());
        }
    }

    if (level != nullptr) {","AttributesBuilder attributes;

if (message != nullptr) {
    if (auto mapMsg = dynamic_cast<MapMessage*>(message)) {
        builder.setBody(mapMsg->getFormat());
        captureMapMessageAttributes(attributes, mapMsg);
    } else {
        builder.setBody(message->getFormattedMessage());
    }
}",1
"class MessageGroupStoreReaper : public Runnable, public DisposableBean, public InitializingBean, public ManageableSmartLifecycle {
private:
    static Log logger;
};

Log MessageGroupStoreReaper::logger = LogFactory::getLog(""MessageGroupStoreReaper"");","#include <atomic>
#include <thread>
#include <memory>

class Runnable {
public:
    virtual void run() = 0;
    virtual ~Runnable() = default;
};

class DisposableBean {
public:
    virtual void destroy() = 0;
    virtual ~DisposableBean() = default;
};

class InitializingBean {
public:
    virtual void afterPropertiesSet() = 0;
    virtual ~InitializingBean() = default;
};

class ManageableSmartLifecycle {
public:
    virtual void start() = 0;
    virtual void stop() = 0;
    virtual bool isRunning() const = 0;
    virtual ~ManageableSmartLifecycle() = default;
};

class Logger {
public:
    static Logger& getLogger(const char* /*className*/) {
        static Logger instance;
        return instance;
    }
    void info(const std::string& msg) {}
    void warn(const std::string& msg) {}
    void error(const std::string& msg) {}
};

class MessageGroupStoreReaper : public Runnable, public DisposableBean, public InitializingBean, public ManageableSmartLifecycle {
private:
    static Logger& logger;

public:
    MessageGroupStoreReaper() = default;

    void run() override {
        // Implementation here
    }
    void destroy() override {
        // Implementation here
    }
    void afterPropertiesSet() override {
        // Implementation here
    }
    void start() override {
        // Implementation here
    }
    void stop() override {
        // Implementation here
    }
    bool isRunning() const override {
        // Implementation here
        return false;
    }
};

Logger& MessageGroupStoreReaper::logger = Logger::getLogger(""MessageGroupStoreReaper"");",1
"private:
    const DBEventDefinitionService& eventDefinitionService;
    const DBNotificationGracePeriodService& notificationGracePeriodService;
    const std::map<std::string, std::shared_ptr<EventNotification::Factory>>& eventNotificationFactories;
    const EventsConfiguration& eventsConfiguration;

public:
    EventNotificationExecutionJob(const JobDefinitionDto& jobDefinition,
                                  std::shared_ptr<DBNotificationService> dbNotificationService,
                                  const DBEventDefinitionService& eventDefinitionService,
                                  const DBNotificationGracePeriodService& notificationGracePeriodService,
                                  const std::map<std::string, std::shared_ptr<EventNotification::Factory>>& eventNotificationFactories,
                                  const EventsConfigurationProvider& configurationProvider)
        : eventDefinitionService(eventDefinitionService),
          notificationGracePeriodService(notificationGracePeriodService),
          eventNotificationFactories(eventNotificationFactories),
          eventsConfiguration(configurationProvider.get())
    {
        jobConfig = std::static_pointer_cast<Config>(jobDefinition.config());
        notificationService = dbNotificationService;
    }","```cpp
class EventNotificationExecutionJob : public Job {
private:
    DBEventDefinitionService& eventDefinitionService;
    DBNotificationGracePeriodService& notificationGracePeriodService;
    std::map<std::string, std::shared_ptr<EventNotification::Factory>> eventNotificationFactories;
    EventsConfiguration eventsConfiguration;
    Config jobConfig;
    DBNotificationService& notificationService;

public:
    EventNotificationExecutionJob(
        const JobDefinitionDto& jobDefinition,
        DBNotificationService& dbNotificationService,
        DBEventDefinitionService& eventDefinitionService,
        DBNotificationGracePeriodService& notificationGracePeriodService,
        const std::map<std::string, std::shared_ptr<EventNotification::Factory>>& eventNotificationFactories,
        EventsConfigurationProvider& configurationProvider
    )
        : jobConfig(static_cast<const Config&>(*jobDefinition.config())),
          notificationService(dbNotificationService),
          eventDefinitionService(eventDefinitionService),
          notificationGracePeriodService(notificationGracePeriodService),
          eventNotificationFactories(eventNotificationFactories),
          eventsConfiguration(configurationProvider.get())
    {
    }

    void execute() override {
        // ...
    }
};
```",1
"void checkAccess(const std::type_info& targetClass, const std::string& name, int memberModifiers, MethodHandle* handle) {
    checkClassAccess(targetClass);

#if SIDE_CAR_19_SE
    if (handle != nullptr) {
        MethodType type = handle->type();
        Module accessModule = accessClass.getModule();

        try {
            checkClassModuleVisibility(accessMode, accessModule, type.returnType());
            for (const std::type_info* c : type.arguments()) {
                checkClassModuleVisibility(accessMode, accessModule, *c);
            }
        } catch (const IllegalAccessException& exc) {
            IllegalAccessError err(exc.what());
            err.initCause(exc);
            throw err;
        }
    }
#endif
    if ((memberModifiers & Modifier::PUBLIC) != 0) {
        // checkClassAccess already determined that we have more than ""no access"" (public access)
        return;
    }
}","```cpp
private:
    void checkAccess(const std::type_info& targetClass, const std::string& name, int memberModifiers, MethodHandle* handle) {
        checkClassAccess(targetClass);

#if defined(SIDECAR19_SE)
        if (handle != nullptr) {
            MethodType type = handle->type();
            Module* accessModule = accessClass->getModule();

            try {
                checkClassModuleVisibility(accessMode, accessModule, type.returnType);
                for (const std::type_info* c : type.arguments) {
                    checkClassModuleVisibility(accessMode, accessModule, c);
                }
            } catch (const IllegalAccessException& exc) {
                IllegalAccessError err(exc.what());
                err.initCause(exc);
                throw err;
            }
        }
#endif
        if (Modifier::isPublic(memberModifiers)) {
            // checkClassAccess already determined that we have more than ""no access"" (public access)
            return;
        }
    }
```",1
"ContextAwareHistogram* contextAwareHistogram(const std::string& name, ContextAwareMetricFactory<ContextAwareHistogram>* factory, const std::vector<std::any>& args) {
    return this->innerMetricContext.getOrCreate(name, factory, args);
}","ContextAwareHistogram* contextAwareHistogram(const std::string& name,
    ContextAwareMetricFactory<ContextAwareHistogram>* factory, auto&&... args) {
    return this->innerMetricContext.getOrCreate(name, factory, std::forward<decltype(args)>(args)...);
}",0
"#include ""ConnectorMessageNotification.h""
#include ""TransactionalErrorHandlingExecutionTemplate.h""
#include ""MuleException.h""
#include ""DefaultMuleException.h""
#include ""Event.h""

using org::mule::runtime::core::context::notification::ConnectorMessageNotification::MESSAGE_ERROR_RESPONSE;
using org::mule::runtime::core::context::notification::ConnectorMessageNotification::MESSAGE_RESPONSE;
using org::mule::runtime::core::execution::TransactionalErrorHandlingExecutionTemplate::createMainExecutionTemplate;

using org::mule::runtime::api::exception::MuleException;
using org::mule::runtime::core::api::DefaultMuleException;
using org::mule::runtime::core::api::Event;","#include ""org/mule/runtime/core/context/notification/ConnectorMessageNotification.h""
#include ""org/mule/runtime/core/execution/TransactionalErrorHandlingExecutionTemplate.h""
#include ""org/mule/runtime/api/exception/MuleException.h""
#include ""org/mule/runtime/core/api/DefaultMuleException.h""
#include ""org/mule/runtime/core/api/Event.h""

using namespace org::mule::runtime::core::context::notification;
using namespace org::mule::runtime::core::execution;
using namespace org::mule::runtime::api::exception;
using namespace org::mule::runtime::core::api;

const auto MESSAGE_ERROR_RESPONSE = ConnectorMessageNotification::MESSAGE_ERROR_RESPONSE;
const auto MESSAGE_RESPONSE = ConnectorMessageNotification::MESSAGE_RESPONSE;
using createMainExecutionTemplateFunc = decltype(TransactionalErrorHandlingExecutionTemplate::createMainExecutionTemplate);",0
"#include <string>

class AttributeKey {
public:
    explicit AttributeKey(const std::string& name) : name_(name) {}
    const std::string& name() const { return name_; }
    static AttributeKey stringKey(const std::string& name) { return AttributeKey(name); }
private:
    std::string name_;
};

class Attributes {
public:
    Attributes(const AttributeKey& key, const std::string& value) {
        entries_.emplace(key.name(), value);
    }
    static Attributes of(const AttributeKey& key, const std::string& value) {
        return Attributes(key, value);
    }
private:
    std::map<std::string, std::string> entries_;
};

class SystemMetrics {
public:
    static const AttributeKey DEVICE_KEY;
    static const AttributeKey DIRECTION_KEY;
    static const AttributeKey STATE_KEY;

    static const Attributes ATTRIBUTES_USED;
    static const Attributes ATTRIBUTES_FREE;

private:
    SystemMetrics() = delete;
};

const AttributeKey SystemMetrics::DEVICE_KEY = AttributeKey::stringKey(""device"");
const AttributeKey SystemMetrics::DIRECTION_KEY = AttributeKey::stringKey(""direction"");
const AttributeKey SystemMetrics::STATE_KEY = AttributeKey::stringKey(""state"");
const Attributes SystemMetrics::ATTRIBUTES_USED = Attributes::of(SystemMetrics::STATE_KEY, ""used"");
const Attributes SystemMetrics::ATTRIBUTES_FREE = Attributes::of(SystemMetrics::STATE_KEY, ""free"");","#include <string>

class AttributeKey {
public:
    explicit AttributeKey(const std::string& key) : key_(key) {}
    static AttributeKey stringKey(const std::string& key) { return AttributeKey(key); }
    bool operator==(const AttributeKey& other) const { return key_ == other.key_; }
    std::string key() const { return key_; }
private:
    std::string key_;
};

class Attributes {
public:
    Attributes(const AttributeKey& key, const std::string& value) {
        attributes_.emplace_back(key, value);
    }
    static Attributes of(const AttributeKey& key, const std::string& value) {
        return Attributes(key, value);
    }
private:
    std::vector<std::pair<AttributeKey, std::string>> attributes_;
};

class SystemMetrics {
public:
    static const AttributeKey DEVICE_KEY;
    static const AttributeKey DIRECTION_KEY;
    static const AttributeKey STATE_KEY;
    static const Attributes ATTRIBUTES_USED;
    static const Attributes ATTRIBUTES_FREE;

private:
    SystemMetrics() = default;
};

const AttributeKey SystemMetrics::DEVICE_KEY = AttributeKey::stringKey(""device"");
const AttributeKey SystemMetrics::DIRECTION_KEY = AttributeKey::stringKey(""direction"");
const AttributeKey SystemMetrics::STATE_KEY = AttributeKey::stringKey(""state"");
const Attributes SystemMetrics::ATTRIBUTES_USED = Attributes::of(SystemMetrics::STATE_KEY, ""used"");
const Attributes SystemMetrics::ATTRIBUTES_FREE = Attributes::of(SystemMetrics::STATE_KEY, ""free"");",0
"private:
void injectValueProviderFields(ValueProvider& resolver) {
    std::vector<std::string> missingParameters;
    for (const auto& injectableParam : factoryModelProperty.getInjectableParameters()) {
        void* parameterValue = nullptr;
        std::string parameterName = injectableParam.getParameterName();
        try {
            parameterValue = parameterValueResolver.getParameterValue(parameterName);
        } catch (const ValueResolvingException&) {
            // no op
        }

        if (parameterValue != nullptr) {
            injectValueIntoField(resolver, parameterValue, parameterName);
        } else if (injectableParam.isRequired()) {
            missingParameters.push_back(parameterName);
        }
    }

    if (!missingParameters.empty()) {
        throw ValueResolvingException(
            ""Unable to retrieve values. There are missing required parameters for the resolution: ""
            + toString(missingParameters),
            MISSING_REQUIRED_PARAMETERS
        );
    }
}

static void injectValueIntoField(ValueProvider& fieldContainer, void* valueToInject, const std::string& requiredParamName);","void injectValueProviderFields(ValueProvider& resolver) {
    std::vector<std::string> missingParameters;
    for (const auto& injectableParam : factoryModelProperty.getInjectableParameters()) {
        std::any parameterValue;
        std::string parameterName = injectableParam.getParameterName();
        try {
            parameterValue = parameterValueResolver.getParameterValue(parameterName);
        } catch (const ValueResolvingException&) {
            // no op
        }

        if (parameterValue.has_value()) {
            injectValueIntoField(resolver, parameterValue, parameterName);
        } else if (injectableParam.isRequired()) {
            missingParameters.push_back(parameterName);
        }
    }

    if (!missingParameters.empty()) {
        throw ValueResolvingException(
            ""Unable to retrieve values. There are missing required parameters for the resolution: ""
            + ::join(missingParameters, "", ""),
            MISSING_REQUIRED_PARAMETERS
        );
    }
}

static void injectValueIntoField(ValueProvider& fieldContainer, const std::any& valueToInject, const std::string& requiredParamName);",1
"```cpp
void doApplicationPolicyExecutionTest(PolicyPointcut pointcut, int expectedPolicyInvocations) {
    PolicyFileBuilder policyFileBuilder(
        FOO_POLICY_NAME, ""fooPolicy.xml"", {{""policy.name"", FOO_POLICY_NAME}}
    );
    policyManager.registerPolicyTemplate(policyFileBuilder.getArtifactFile());

    ApplicationFileBuilder applicationFileBuilder = createExtensionApplicationWithServices();
    addPackedAppFromBuilder(applicationFileBuilder);

    policyManager.addPolicy(
        applicationFileBuilder.getId(),
        policyFileBuilder.getId(),
        PolicyParametrization(TEST_POLICY_ID, pointcut, HashedMap())
    );
    startDeployment();

    assertApplicationDeploymentSuccess(applicationDeploymentListener, applicationFileBuilder.getId());

    executeApplicationFlow(""main"");
    assertThat(invocationCount, equalTo(expectedPolicyInvocations));
}

void removesApplicationPolicy() {
    policyManager.registerPolicyTemplate(policyFileBuilder.getArtifactFile());

    ApplicationFileBuilder applicationFileBuilder = createExtensionApplicationWithServices();
    addPackedAppFromBuilder(applicationFileBuilder);

    policyManager.addPolicy(
        applicationFileBuilder.getId(),
        policyFileBuilder.getId(),
        PolicyParametrization(
            TEST_POLICY_ID,
            [](auto parameters) { return true; },
            HashedMap()
        )
    );

    startDeployment();

    assertApplicationDeploymentSuccess(applicationDeploymentListener, applicationFileBuilder.getId());

    executeApplicationFlow(""main"");
    assertThat(invocationCount, equalTo(1));

    policyManager.removePolicy(applicationFileBuilder.getId(), TEST_POLICY_ID);

    executeApplicationFlow(""main"");
    assertThat(""Policy is still applied on the application"", invocationCount, equalTo(1));
}

ApplicationFileBuilder createExtensionApplicationWithServices() {
    ServiceFileBuilder echoService(
        ""echoService""
    );
    echoService.configuredWith(SERVICE_PROVIDER_CLASS_NAME, ""org.mule.echo.EchoServiceProvider"")
               .usingLibrary(defaulServiceEchoJarFile.getAbsolutePath());
    // ...
    return ApplicationFileBuilder(/*...*/);
}
```","```cpp
void doApplicationPolicyExecutionTest(PolicyPointcut pointcut, int expectedPolicyInvocations) {
    policyManager.registerPolicyTemplate(policyFileBuilder.getArtifactFile());

    ApplicationFileBuilder applicationFileBuilder = createExtensionApplicationWithServices();
    addPackedAppFromBuilder(applicationFileBuilder);

    policyManager.addPolicy(applicationFileBuilder.getId(), policyFileBuilder.getId(),
                            PolicyParametrization(TEST_POLICY_ID, pointcut, HashedMap()));
    startDeployment();

    assertApplicationDeploymentSuccess(applicationDeploymentListener, applicationFileBuilder.getId());

    executeApplicationFlow(""main"");
    assertThat(invocationCount, equalTo(expectedPolicyInvocations));
}

void removesApplicationPolicy() {
    policyManager.registerPolicyTemplate(policyFileBuilder.getArtifactFile());

    ApplicationFileBuilder applicationFileBuilder = createExtensionApplicationWithServices();
    addPackedAppFromBuilder(applicationFileBuilder);

    policyManager.addPolicy(
        applicationFileBuilder.getId(),
        policyFileBuilder.getId(),
        PolicyParametrization(TEST_POLICY_ID,
            [](const auto& parameters) { return true; },
            HashedMap()
        )
    );

    startDeployment();

    assertApplicationDeploymentSuccess(applicationDeploymentListener, applicationFileBuilder.getId());

    executeApplicationFlow(""main"");
    assertThat(invocationCount, equalTo(1));

    policyManager.removePolicy(applicationFileBuilder.getId(), TEST_POLICY_ID);

    executeApplicationFlow(""main"");
    assertThat(""Policy is still applied on the application"", invocationCount, equalTo(1));
}

ApplicationFileBuilder createExtensionApplicationWithServices() {
    ServiceFileBuilder echoService(
        ""echoService""
    );
    echoService.configuredWith(SERVICE_PROVIDER_CLASS_NAME, ""org.mule.echo.EchoServiceProvider"")
               .usingLibrary(defaulServiceEchoJarFile.getAbsolutePath());
    // Additional implementation as needed...
    return ApplicationFileBuilder(); // Placeholder, actual logic omitted for brevity
}
```",1
